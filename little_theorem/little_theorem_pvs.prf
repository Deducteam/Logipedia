(little_theorem_pvs
 (factorial_TCC1 0
  (factorial_TCC1-1 nil 3734443831 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil (factorial subtype "(number_fields.-)(little_theorem_pvs.n, 1)" "nat")))
 (factorial_TCC2 0
  (factorial_TCC2-1 nil 3734443831 ("" (termination-tcc) nil nil) nil
   nil
   (factorial termination
    "little_theorem_pvs.factorial((number_fields.-)(little_theorem_pvs.n, 1))" "nil")))
 (mod_aux_TCC1 0
  (mod_aux_TCC1-1 nil 3734443831 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (mod_aux subtype
    "(number_fields.-)(little_theorem_pvs.m, ((number_fields.+)(little_theorem_pvs.n, 1)))"
    "nat")))
 (mod_aux_TCC2 0
  (mod_aux_TCC2-1 nil 3734443831 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil (mod_aux subtype "(number_fields.-)(little_theorem_pvs.p, 1)" "nat")))
 (mod_aux_TCC3 0
  (mod_aux_TCC3-1 nil 3734443831 ("" (termination-tcc) nil nil) nil nil
   (mod_aux termination
    "little_theorem_pvs.mod_aux((number_fields.-)(little_theorem_pvs.p, 1))" "nil")))
 (gcd_aux_TCC1 0
  (gcd_aux_TCC1-1 nil 3734443831 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (mod const-decl "nat" little_theorem_pvs nil)
    (dividesb const-decl "bool" little_theorem_pvs nil))
   nil (gcd_aux subtype "(number_fields.-)(little_theorem_pvs.p, 1)" "nat")))
 (gcd_aux_TCC2 0
  (gcd_aux_TCC2-1 nil 3734443831 ("" (termination-tcc) nil nil)
   ((match_nat_type const-decl "return" little_theorem_pvs nil)
    (mod const-decl "nat" little_theorem_pvs nil)
    (dividesb const-decl "bool" little_theorem_pvs nil))
   nil
   (gcd_aux termination
    "little_theorem_pvs.gcd_aux((number_fields.-)(little_theorem_pvs.p, 1))" "nil")))
 (IMP_little_theorem_sttfa_TCC1 0
  (IMP_little_theorem_sttfa_TCC1-1 nil 3734443831 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (IMP_little_theorem_sttfa subtype "(number_fields.-)(little_theorem_pvs.n, little_theorem_pvs.m)"
    "nat")))
 (IMP_little_theorem_sttfa_falsity_TCC1 0
  (IMP_little_theorem_sttfa_falsity_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "falsity: AXIOM (FORALL (t: booleans.bool): (booleans.=>(little_theorem_sttfa.sttfa_False, t)))")))
 (IMP_little_theorem_sttfa_nmk_TCC1 0
  (IMP_little_theorem_sttfa_nmk_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "nmk: AXIOM (FORALL (A: booleans.bool): (booleans.=>((booleans.=>(A, little_theorem_sttfa.sttfa_False)), little_theorem_sttfa.sttfa_Not(A))))")))
 (IMP_little_theorem_sttfa_Not_ind_TCC1 0
  (IMP_little_theorem_sttfa_Not_ind_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "Not_ind: AXIOM (FORALL (A: booleans.bool): FORALL (Q: booleans.bool): (booleans.=>((booleans.=>((booleans.=>(A, little_theorem_sttfa.sttfa_False)), Q)), (booleans.=>(little_theorem_sttfa.sttfa_Not(A), Q)))))")))
 (IMP_little_theorem_sttfa_conj_TCC1 0
  (IMP_little_theorem_sttfa_conj_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "conj: AXIOM (FORALL (A: booleans.bool): FORALL (B: booleans.bool): (booleans.=>(A, (booleans.=>(B, little_theorem_sttfa.sttfa_And(A)(B))))))")))
 (IMP_little_theorem_sttfa_match_And_prop_TCC1 0
  (IMP_little_theorem_sttfa_match_And_prop_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "match_And_prop: AXIOM (FORALL (A: booleans.bool): FORALL (B: booleans.bool): FORALL (return: booleans.bool): (booleans.=>((booleans.=>(A, (booleans.=>(B, return)))), (booleans.=>(little_theorem_sttfa.sttfa_And(A)(B), return)))))")))
 (IMP_little_theorem_sttfa_or_intror_TCC1 0
  (IMP_little_theorem_sttfa_or_intror_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "or_intror: AXIOM (FORALL (A: booleans.bool): FORALL (B: booleans.bool): (booleans.=>(B, little_theorem_sttfa.sttfa_Or(A)(B))))")))
 (IMP_little_theorem_sttfa_match_Or_prop_TCC1 0
  (IMP_little_theorem_sttfa_match_Or_prop_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "match_Or_prop: AXIOM (FORALL (A: booleans.bool): FORALL (B: booleans.bool): FORALL (return: booleans.bool): (booleans.=>((booleans.=>(A, return)), (booleans.=>((booleans.=>(B, return)), (booleans.=>(little_theorem_sttfa.sttfa_Or(A)(B), return)))))))")))
 (IMP_little_theorem_sttfa_ex_intro_TCC1 0
  (IMP_little_theorem_sttfa_ex_intro_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) (nil) nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "ex_intro[A: TYPE+]: AXIOM (FORALL (P: [little_theorem_sttfa.A -> booleans.bool]): FORALL (x: little_theorem_sttfa.A): (booleans.=>(P(x), little_theorem_sttfa.sttfa_ex[little_theorem_sttfa.A](P))))")))
 (IMP_little_theorem_sttfa_match_ex_prop_TCC1 0
  (IMP_little_theorem_sttfa_match_ex_prop_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) (nil) nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "match_ex_prop[A: TYPE+]: AXIOM (FORALL (P: [little_theorem_sttfa.A -> booleans.bool]): FORALL (return: booleans.bool): (booleans.=>(FORALL (x: little_theorem_sttfa.A): (booleans.=>(P(x), return)), (booleans.=>(little_theorem_sttfa.sttfa_ex[little_theorem_sttfa.A](P), return)))))")))
 (IMP_little_theorem_sttfa_refl_equal_TCC1 0
  (IMP_little_theorem_sttfa_refl_equal_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "refl_equal[A: TYPE+]: AXIOM (FORALL (x: little_theorem_sttfa.A): little_theorem_sttfa.equal[little_theorem_sttfa.A](x)(x))")))
 (IMP_little_theorem_sttfa_equal_leibniz_TCC1 0
  (IMP_little_theorem_sttfa_equal_leibniz_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "equal_leibniz[A: TYPE+]: AXIOM (FORALL (x: little_theorem_sttfa.A): FORALL (y: little_theorem_sttfa.A): (booleans.=>(little_theorem_sttfa.equal[little_theorem_sttfa.A](x)(y), FORALL (P: [little_theorem_sttfa.A -> booleans.bool]): (booleans.=>(P(x), P(y))))))")))
 (IMP_little_theorem_sttfa_refl_TCC1 0
  (IMP_little_theorem_sttfa_refl_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "refl[A: TYPE+]: AXIOM (FORALL (x: little_theorem_sttfa.A): little_theorem_sttfa.eq[little_theorem_sttfa.A](x)(x))")))
 (IMP_little_theorem_sttfa_eq_ind_TCC1 0
  (IMP_little_theorem_sttfa_eq_ind_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "eq_ind[A: TYPE+]: AXIOM (FORALL (x: little_theorem_sttfa.A): FORALL (P: [little_theorem_sttfa.A -> booleans.bool]): (booleans.=>(P(x), FORALL (y: little_theorem_sttfa.A): (booleans.=>(little_theorem_sttfa.eq[little_theorem_sttfa.A](x)(y), P(y))))))")))
 (IMP_little_theorem_sttfa_match_bool_prop_TCC1 0
  (IMP_little_theorem_sttfa_match_bool_prop_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "match_bool_prop: AXIOM (FORALL (return: [little_theorem_sttfa.sttfa_bool -> booleans.bool]): (booleans.=>(return(little_theorem_sttfa.sttfa_true), (booleans.=>(return(little_theorem_sttfa.sttfa_false), FORALL (z: little_theorem_sttfa.sttfa_bool): return(little_theorem_sttfa.z))))))")))
 (IMP_little_theorem_sttfa_axiom_match_bool_type_true_TCC1 0
  (IMP_little_theorem_sttfa_axiom_match_bool_type_true_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_match_bool_type_true[return: TYPE+]: AXIOM (FORALL (case_true: little_theorem_sttfa.return): FORALL (case_false: little_theorem_sttfa.return): little_theorem_sttfa.equal[return](little_theorem_sttfa.match_bool_type[return](case_true)(case_false)(little_theorem_sttfa.sttfa_true))(case_true))")))
 (IMP_little_theorem_sttfa_axiom_match_bool_type_false_TCC1 0
  (IMP_little_theorem_sttfa_axiom_match_bool_type_false_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_match_bool_type_false[return: TYPE+]: AXIOM (FORALL (case_true: little_theorem_sttfa.return): FORALL (case_false: little_theorem_sttfa.return): little_theorem_sttfa.equal[return](little_theorem_sttfa.match_bool_type[return](case_true)(case_false)(little_theorem_sttfa.sttfa_false))(case_false))")))
 (IMP_little_theorem_sttfa_match_nat_prop_TCC1 0
  (IMP_little_theorem_sttfa_match_nat_prop_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "match_nat_prop: AXIOM (FORALL (return: [little_theorem_sttfa.sttfa_nat -> booleans.bool]): (booleans.=>(return(little_theorem_sttfa.sttfa_O), (booleans.=>(FORALL (n: little_theorem_sttfa.sttfa_nat): return(little_theorem_sttfa.sttfa_S(little_theorem_sttfa.n)), FORALL (z: little_theorem_sttfa.sttfa_nat): return(little_theorem_sttfa.z))))))")))
 (IMP_little_theorem_sttfa_axiom_match_nat_type_O_TCC1 0
  (IMP_little_theorem_sttfa_axiom_match_nat_type_O_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil)
   ((match_nat_type const-decl "return" little_theorem_pvs nil)) nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_match_nat_type_O[return_type: TYPE+]: AXIOM (FORALL (case_O: little_theorem_sttfa.return_type): FORALL (case_S: [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.return_type]): little_theorem_sttfa.equal[little_theorem_sttfa.return_type](little_theorem_sttfa.match_nat_type[little_theorem_sttfa.return_type](case_O)(case_S)(little_theorem_sttfa.sttfa_O))(case_O))")))
 (IMP_little_theorem_sttfa_axiom_match_nat_type_S_TCC1 0
  (IMP_little_theorem_sttfa_axiom_match_nat_type_S_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil)
   ((match_nat_type const-decl "return" little_theorem_pvs nil)) nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_match_nat_type_S[return_type: TYPE+]: AXIOM (FORALL (case_O: little_theorem_sttfa.return_type): FORALL (case_S: [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.return_type]): FORALL (n: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.equal[little_theorem_sttfa.return_type](little_theorem_sttfa.match_nat_type[little_theorem_sttfa.return_type](case_O)(case_S)(little_theorem_sttfa.sttfa_S(little_theorem_sttfa.n)))(case_S(little_theorem_sttfa.n)))")))
 (IMP_little_theorem_sttfa_axiom_filter_nat_type_O_TCC1 0
  (IMP_little_theorem_sttfa_axiom_filter_nat_type_O_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_filter_nat_type_O[return_type: TYPE+]: AXIOM (FORALL (return: [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.return_type]): little_theorem_sttfa.equal[little_theorem_sttfa.return_type](little_theorem_sttfa.filter_nat_type[little_theorem_sttfa.return_type](return)(little_theorem_sttfa.sttfa_O))(return(little_theorem_sttfa.sttfa_O)))")))
 (IMP_little_theorem_sttfa_axiom_filter_nat_type_S_TCC1 0
  (IMP_little_theorem_sttfa_axiom_filter_nat_type_S_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_filter_nat_type_S[return_type: TYPE+]: AXIOM (FORALL (return: [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.return_type]): FORALL (n: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.equal[little_theorem_sttfa.return_type](little_theorem_sttfa.filter_nat_type[little_theorem_sttfa.return_type](return)(little_theorem_sttfa.sttfa_S(little_theorem_sttfa.n)))(return(little_theorem_sttfa.sttfa_S(little_theorem_sttfa.n))))")))
 (IMP_little_theorem_sttfa_nat_ind_TCC1 0
  (IMP_little_theorem_sttfa_nat_ind_TCC1-1 nil 3734443831
   ("" (skeep) (("" (induct-and-simplify "x") nil nil)) nil)
   ((nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "nat_ind: AXIOM (FORALL (Q: [little_theorem_sttfa.sttfa_nat -> booleans.bool]): (booleans.=>(Q(little_theorem_sttfa.sttfa_O), (booleans.=>(FORALL (x: little_theorem_sttfa.sttfa_nat): (booleans.=>(Q(little_theorem_sttfa.x), Q(little_theorem_sttfa.sttfa_S(little_theorem_sttfa.x)))), FORALL (x: little_theorem_sttfa.sttfa_nat): Q(little_theorem_sttfa.x))))))")))
 (IMP_little_theorem_sttfa_le_n_TCC1 0
  (IMP_little_theorem_sttfa_le_n_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "le_n: AXIOM (FORALL (n: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.le(little_theorem_sttfa.n)(little_theorem_sttfa.n))")))
 (IMP_little_theorem_sttfa_le_S_TCC1 0
  (IMP_little_theorem_sttfa_le_S_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "le_S: AXIOM (FORALL (n: little_theorem_sttfa.sttfa_nat): (FORALL (m: little_theorem_sttfa.sttfa_nat): (booleans.=>(little_theorem_sttfa.le(little_theorem_sttfa.n)(little_theorem_sttfa.m), little_theorem_sttfa.le(little_theorem_sttfa.n)(little_theorem_sttfa.sttfa_S(little_theorem_sttfa.m))))))")))
 (IMP_little_theorem_sttfa_match_le_prop_TCC1 0
  (IMP_little_theorem_sttfa_match_le_prop_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "match_le_prop: AXIOM (FORALL (n: little_theorem_sttfa.sttfa_nat): (FORALL (return: [little_theorem_sttfa.sttfa_nat -> booleans.bool]): (booleans.=>(return(little_theorem_sttfa.n), (booleans.=>(FORALL (m: little_theorem_sttfa.sttfa_nat): return(little_theorem_sttfa.sttfa_S(little_theorem_sttfa.m)), FORALL (m: little_theorem_sttfa.sttfa_nat): (booleans.=>(little_theorem_sttfa.le(little_theorem_sttfa.n)(little_theorem_sttfa.m), return(little_theorem_sttfa.m)))))))))")))
 (IMP_little_theorem_sttfa_le_ind_TCC1 0
  (IMP_little_theorem_sttfa_le_ind_TCC1-1 nil 3734443831
   ("" (skeep)
    (("" (skeep) (("" (induct-and-simplify "m") nil nil)) nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "le_ind: AXIOM (FORALL (n: little_theorem_sttfa.sttfa_nat): (FORALL (Q: [little_theorem_sttfa.sttfa_nat -> booleans.bool]): (booleans.=>(Q(little_theorem_sttfa.n), (booleans.=>(FORALL (m: little_theorem_sttfa.sttfa_nat): (booleans.=>(little_theorem_sttfa.le(little_theorem_sttfa.n)(little_theorem_sttfa.m), (booleans.=>(Q(little_theorem_sttfa.m), Q(little_theorem_sttfa.sttfa_S(little_theorem_sttfa.m)))))), FORALL (m: little_theorem_sttfa.sttfa_nat): (booleans.=>(little_theorem_sttfa.le(little_theorem_sttfa.n)(little_theorem_sttfa.m), Q(little_theorem_sttfa.m)))))))))")))
 (IMP_little_theorem_sttfa_axiom_plus_TCC1 0
  (IMP_little_theorem_sttfa_axiom_plus_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_plus: AXIOM (FORALL (n: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.equal[[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]](little_theorem_sttfa.plus(little_theorem_sttfa.n))(little_theorem_sttfa.filter_nat_type[[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]](little_theorem_sttfa.plus_body)(little_theorem_sttfa.n)))")))
 (IMP_little_theorem_sttfa_axiom_plus_body_O_TCC1 0
  (IMP_little_theorem_sttfa_axiom_plus_body_O_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_plus_body_O: AXIOM little_theorem_sttfa.equal[[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]](little_theorem_sttfa.plus_body(little_theorem_sttfa.sttfa_O))((LAMBDA (m: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.m))")))
 (IMP_little_theorem_sttfa_axiom_plus_body_S_TCC1 0
  (IMP_little_theorem_sttfa_axiom_plus_body_S_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_plus_body_S: AXIOM (FORALL (n: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.equal[[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]](little_theorem_sttfa.plus_body(little_theorem_sttfa.sttfa_S(little_theorem_sttfa.n)))((LAMBDA (m: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.sttfa_S(little_theorem_sttfa.plus(little_theorem_sttfa.n)(little_theorem_sttfa.m)))))")))
 (IMP_little_theorem_sttfa_axiom_times_TCC1 0
  (IMP_little_theorem_sttfa_axiom_times_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_times: AXIOM (FORALL (n: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.equal[[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]](little_theorem_sttfa.times(little_theorem_sttfa.n))(little_theorem_sttfa.filter_nat_type[[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]](little_theorem_sttfa.times_body)(little_theorem_sttfa.n)))")))
 (IMP_little_theorem_sttfa_axiom_times_body_O_TCC1 0
  (IMP_little_theorem_sttfa_axiom_times_body_O_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil)
   ((mult_divides1 application-judgement "(divides(n))" divides nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_times_body_O: AXIOM little_theorem_sttfa.equal[[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]](little_theorem_sttfa.times_body(little_theorem_sttfa.sttfa_O))((LAMBDA (m: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.sttfa_O))")))
 (IMP_little_theorem_sttfa_axiom_times_body_S_TCC1 0
  (IMP_little_theorem_sttfa_axiom_times_body_S_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil)
   ((mult_divides1 application-judgement "(divides(n))" divides nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_times_body_S: AXIOM (FORALL (n: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.equal[[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]](little_theorem_sttfa.times_body(little_theorem_sttfa.sttfa_S(little_theorem_sttfa.n)))((LAMBDA (m: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.plus(little_theorem_sttfa.m)(little_theorem_sttfa.times(little_theorem_sttfa.n)(little_theorem_sttfa.m)))))")))
 (IMP_little_theorem_sttfa_axiom_minus_TCC1 0
  (IMP_little_theorem_sttfa_axiom_minus_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_minus: AXIOM (FORALL (n: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.equal[[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]](little_theorem_sttfa.minus(little_theorem_sttfa.n))(little_theorem_sttfa.filter_nat_type[[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]](little_theorem_sttfa.minus_body)(little_theorem_sttfa.n)))")))
 (IMP_little_theorem_sttfa_axiom_minus_body_O_TCC1 0
  (IMP_little_theorem_sttfa_axiom_minus_body_O_TCC1-1 nil 3734443831
   ("" (decompose-equality) (("" (grind) nil nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_minus_body_O: AXIOM little_theorem_sttfa.equal[[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]](little_theorem_sttfa.minus_body(little_theorem_sttfa.sttfa_O))((LAMBDA (m: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.sttfa_O))")))
 (IMP_little_theorem_sttfa_axiom_minus_body_S_TCC1 0
  (IMP_little_theorem_sttfa_axiom_minus_body_S_TCC1-1 nil 3734443831
   ("" (skeep)
    (("" (decompose-equality)
      (("1" (grind) nil nil)
       ("2" (hide 2) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil) nil
    (< const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (match_nat_type const-decl "return" little_theorem_pvs nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_minus_body_S: AXIOM (FORALL (n: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.equal[[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]](little_theorem_sttfa.minus_body(little_theorem_sttfa.sttfa_S(little_theorem_sttfa.n)))((LAMBDA (m: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.match_nat_type[little_theorem_sttfa.sttfa_nat](little_theorem_sttfa.sttfa_S(little_theorem_sttfa.n))((LAMBDA (q: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.minus(little_theorem_sttfa.n)(little_theorem_sttfa.q)))(little_theorem_sttfa.m))))")))
 (IMP_little_theorem_sttfa_axiom_eqb_TCC1 0
  (IMP_little_theorem_sttfa_axiom_eqb_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_eqb: AXIOM (FORALL (n: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.equal[[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_bool]](little_theorem_sttfa.eqb(little_theorem_sttfa.n))(little_theorem_sttfa.filter_nat_type[[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_bool]](little_theorem_sttfa.eqb_body)(little_theorem_sttfa.n)))")))
 (IMP_little_theorem_sttfa_axiom_eqb_body_O_TCC1 0
  (IMP_little_theorem_sttfa_axiom_eqb_body_O_TCC1-1 nil 3734443831
   ("" (decompose-equality) (("" (grind) nil nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (FALSE const-decl "bool" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (match_nat_type const-decl "return" little_theorem_pvs nil)
    (= const-decl "[T, T -> boolean]" equalities nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_eqb_body_O: AXIOM little_theorem_sttfa.equal[[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_bool]](little_theorem_sttfa.eqb_body(little_theorem_sttfa.sttfa_O))((LAMBDA (m: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.match_nat_type[little_theorem_sttfa.sttfa_bool](little_theorem_sttfa.sttfa_true)((LAMBDA (q: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.sttfa_false))(little_theorem_sttfa.m)))")))
 (IMP_little_theorem_sttfa_axiom_eqb_body_S_TCC1 0
  (IMP_little_theorem_sttfa_axiom_eqb_body_S_TCC1-1 nil 3734443831
   ("" (skeep) (("" (decompose-equality) (("" (grind) nil nil)) nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (match_nat_type const-decl "return" little_theorem_pvs nil)
    (FALSE const-decl "bool" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_eqb_body_S: AXIOM (FORALL (n: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.equal[[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_bool]](little_theorem_sttfa.eqb_body(little_theorem_sttfa.sttfa_S(little_theorem_sttfa.n)))((LAMBDA (m: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.match_nat_type[little_theorem_sttfa.sttfa_bool](little_theorem_sttfa.sttfa_false)((LAMBDA (q: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.eqb(little_theorem_sttfa.n)(little_theorem_sttfa.q)))(little_theorem_sttfa.m))))")))
 (IMP_little_theorem_sttfa_axiom_leb_TCC1 0
  (IMP_little_theorem_sttfa_axiom_leb_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_leb: AXIOM (FORALL (n: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.equal[[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_bool]](little_theorem_sttfa.leb(little_theorem_sttfa.n))(little_theorem_sttfa.filter_nat_type[[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_bool]](little_theorem_sttfa.leb_body)(little_theorem_sttfa.n)))")))
 (IMP_little_theorem_sttfa_axiom_leb_body_O_TCC1 0
  (IMP_little_theorem_sttfa_axiom_leb_body_O_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_leb_body_O: AXIOM little_theorem_sttfa.equal[[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_bool]](little_theorem_sttfa.leb_body(little_theorem_sttfa.sttfa_O))((LAMBDA (m: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.sttfa_true))")))
 (IMP_little_theorem_sttfa_axiom_leb_body_S_TCC1 0
  (IMP_little_theorem_sttfa_axiom_leb_body_S_TCC1-1 nil 3734443831
   ("" (skeep) (("" (decompose-equality) (("" (grind) nil nil)) nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (match_nat_type const-decl "return" little_theorem_pvs nil)
    (FALSE const-decl "bool" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_leb_body_S: AXIOM (FORALL (n: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.equal[[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_bool]](little_theorem_sttfa.leb_body(little_theorem_sttfa.sttfa_S(little_theorem_sttfa.n)))((LAMBDA (m: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.match_nat_type[little_theorem_sttfa.sttfa_bool](little_theorem_sttfa.sttfa_false)((LAMBDA (q: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.leb(little_theorem_sttfa.n)(little_theorem_sttfa.q)))(little_theorem_sttfa.m))))")))
 (IMP_little_theorem_sttfa_axiom_fact_TCC1 0
  (IMP_little_theorem_sttfa_axiom_fact_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_fact: AXIOM (FORALL (n: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.equal[little_theorem_sttfa.sttfa_nat](little_theorem_sttfa.sttfa_fact(little_theorem_sttfa.n))(little_theorem_sttfa.filter_nat_type[little_theorem_sttfa.sttfa_nat](little_theorem_sttfa.fact_body)(little_theorem_sttfa.n)))")))
 (IMP_little_theorem_sttfa_axiom_fact_body_O_TCC1 0
  (IMP_little_theorem_sttfa_axiom_fact_body_O_TCC1-1 nil 3734443831
   ("" (grind) nil nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (factorial def-decl "nat" little_theorem_pvs nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_fact_body_O: AXIOM little_theorem_sttfa.equal[little_theorem_sttfa.sttfa_nat](little_theorem_sttfa.fact_body(little_theorem_sttfa.sttfa_O))(little_theorem_sttfa.sttfa_S(little_theorem_sttfa.sttfa_O))")))
 (IMP_little_theorem_sttfa_axiom_fact_body_S_TCC1 0
  (IMP_little_theorem_sttfa_axiom_fact_body_S_TCC1-1 nil 3734443831
   ("" (grind) nil nil)
   ((mult_divides1 application-judgement "(divides(n))" divides nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (factorial def-decl "nat" little_theorem_pvs nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_fact_body_S: AXIOM (FORALL (n: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.equal[little_theorem_sttfa.sttfa_nat](little_theorem_sttfa.fact_body(little_theorem_sttfa.sttfa_S(little_theorem_sttfa.n)))(little_theorem_sttfa.times(little_theorem_sttfa.sttfa_fact(little_theorem_sttfa.n))(little_theorem_sttfa.sttfa_S(little_theorem_sttfa.n))))")))
 (IMP_little_theorem_sttfa_axiom_exp_TCC1 0
  (IMP_little_theorem_sttfa_axiom_exp_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_exp: AXIOM (FORALL (n: little_theorem_sttfa.sttfa_nat): (FORALL (m: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.equal[little_theorem_sttfa.sttfa_nat](little_theorem_sttfa.sttfa_exp(little_theorem_sttfa.n)(little_theorem_sttfa.m))(little_theorem_sttfa.filter_nat_type[little_theorem_sttfa.sttfa_nat](little_theorem_sttfa.exp_body(little_theorem_sttfa.n))(little_theorem_sttfa.m))))")))
 (IMP_little_theorem_sttfa_axiom_exp_body_O_TCC1 0
  (IMP_little_theorem_sttfa_axiom_exp_body_O_TCC1-1 nil 3734443831
   ("" (grind) nil nil) ((sttfa_exp def-decl "nat" little_theorem_pvs nil)) nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_exp_body_O: AXIOM (FORALL (n: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.equal[little_theorem_sttfa.sttfa_nat](little_theorem_sttfa.exp_body(little_theorem_sttfa.n)(little_theorem_sttfa.sttfa_O))(little_theorem_sttfa.sttfa_S(little_theorem_sttfa.sttfa_O)))")))
 (IMP_little_theorem_sttfa_axiom_exp_body_S_TCC1 0
  (IMP_little_theorem_sttfa_axiom_exp_body_S_TCC1-1 nil 3734443831
   ("" (grind) nil nil) ((sttfa_exp def-decl "nat" little_theorem_pvs nil)) nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_exp_body_S: AXIOM (FORALL (n: little_theorem_sttfa.sttfa_nat): (FORALL (m: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.equal[little_theorem_sttfa.sttfa_nat](little_theorem_sttfa.exp_body(little_theorem_sttfa.n)(little_theorem_sttfa.sttfa_S(little_theorem_sttfa.m)))(little_theorem_sttfa.times(little_theorem_sttfa.sttfa_exp(little_theorem_sttfa.n)(little_theorem_sttfa.m))(little_theorem_sttfa.n))))")))
 (IMP_little_theorem_sttfa_axiom_mod_aux_TCC1 0
  (IMP_little_theorem_sttfa_axiom_mod_aux_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_mod_aux: AXIOM (FORALL (p: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.equal[[little_theorem_sttfa.sttfa_nat -> [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]]](little_theorem_sttfa.mod_aux(little_theorem_sttfa.p))(little_theorem_sttfa.filter_nat_type[[little_theorem_sttfa.sttfa_nat -> [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]]](little_theorem_sttfa.mod_aux_body)(little_theorem_sttfa.p)))")))
 (IMP_little_theorem_sttfa_axiom_mod_aux_body_O_TCC1 0
  (IMP_little_theorem_sttfa_axiom_mod_aux_body_O_TCC1-1 nil 3734443831
   ("" (decompose-equality)
    (("" (decompose-equality) (("" (grind) nil nil)) nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (mod_aux def-decl "nat" little_theorem_pvs nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_mod_aux_body_O: AXIOM little_theorem_sttfa.equal[[little_theorem_sttfa.sttfa_nat -> [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]]](little_theorem_sttfa.mod_aux_body(little_theorem_sttfa.sttfa_O))((LAMBDA (m: little_theorem_sttfa.sttfa_nat): (LAMBDA (n: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.m)))")))
 (IMP_little_theorem_sttfa_axiom_mod_aux_body_S_TCC1 0
  (IMP_little_theorem_sttfa_axiom_mod_aux_body_S_TCC1-1 nil 3734443831
   ("" (skeep)
    (("" (decompose-equality)
      (("1" (decompose-equality)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
       ("2" (hide 2) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (mod_aux def-decl "nat" little_theorem_pvs nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_mod_aux_body_S: AXIOM (FORALL (p: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.equal[[little_theorem_sttfa.sttfa_nat -> [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]]](little_theorem_sttfa.mod_aux_body(little_theorem_sttfa.sttfa_S(little_theorem_sttfa.p)))((LAMBDA (m: little_theorem_sttfa.sttfa_nat): (LAMBDA (n: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.match_bool_type[little_theorem_sttfa.sttfa_nat](little_theorem_sttfa.m)(little_theorem_sttfa.mod_aux(little_theorem_sttfa.p)(little_theorem_sttfa.minus(little_theorem_sttfa.m)(little_theorem_sttfa.sttfa_S(little_theorem_sttfa.n)))(little_theorem_sttfa.n))(little_theorem_sttfa.leb(little_theorem_sttfa.m)(little_theorem_sttfa.n))))))")))
 (IMP_little_theorem_sttfa_axiom_div_aux_TCC1 0
  (IMP_little_theorem_sttfa_axiom_div_aux_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_div_aux: AXIOM (FORALL (p: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.equal[[little_theorem_sttfa.sttfa_nat -> [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]]](little_theorem_sttfa.div_aux(little_theorem_sttfa.p))(little_theorem_sttfa.filter_nat_type[[little_theorem_sttfa.sttfa_nat -> [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]]](little_theorem_sttfa.div_aux_body)(little_theorem_sttfa.p)))")))
 (IMP_little_theorem_sttfa_axiom_div_aux_body_O_TCC1 0
  (IMP_little_theorem_sttfa_axiom_div_aux_body_O_TCC1-1 nil 3734443831
   ("" (decompose-equality)
    (("" (decompose-equality) (("" (grind) nil nil)) nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (div_aux def-decl "nat" little_theorem_pvs nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_div_aux_body_O: AXIOM little_theorem_sttfa.equal[[little_theorem_sttfa.sttfa_nat -> [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]]](little_theorem_sttfa.div_aux_body(little_theorem_sttfa.sttfa_O))((LAMBDA (m: little_theorem_sttfa.sttfa_nat): (LAMBDA (n: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.sttfa_O)))")))
 (IMP_little_theorem_sttfa_axiom_div_aux_body_S_TCC1 0
  (IMP_little_theorem_sttfa_axiom_div_aux_body_S_TCC1-1 nil 3734443831
   ("" (skeep)
    (("" (decompose-equality)
      (("1" (decompose-equality)
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
       ("2" (hide 2) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (div_aux def-decl "nat" little_theorem_pvs nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_div_aux_body_S: AXIOM (FORALL (p: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.equal[[little_theorem_sttfa.sttfa_nat -> [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]]](little_theorem_sttfa.div_aux_body(little_theorem_sttfa.sttfa_S(little_theorem_sttfa.p)))((LAMBDA (m: little_theorem_sttfa.sttfa_nat): (LAMBDA (n: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.match_bool_type[little_theorem_sttfa.sttfa_nat](little_theorem_sttfa.sttfa_O)(little_theorem_sttfa.sttfa_S(little_theorem_sttfa.div_aux(little_theorem_sttfa.p)(little_theorem_sttfa.minus(little_theorem_sttfa.m)(little_theorem_sttfa.sttfa_S(little_theorem_sttfa.n)))(little_theorem_sttfa.n)))(little_theorem_sttfa.leb(little_theorem_sttfa.m)(little_theorem_sttfa.n))))))")))
 (IMP_little_theorem_sttfa_div_mod_spec_intro_TCC1 0
  (IMP_little_theorem_sttfa_div_mod_spec_intro_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (ACop const-decl "bool" little_theorem_pvs nil) nil
    (Aop const-decl "bool" little_theorem_pvs nil) nil nil
    (bigop def-decl "H" little_theorem_pvs nil) nil
    (invert_permut def-decl "nat" little_theorem_pvs nil)
    (gcd_aux def-decl "nat" little_theorem_pvs nil)
    (sttfa_divides const-decl "bool" little_theorem_pvs nil)
    (div_mod_spec const-decl "bool" little_theorem_pvs nil)
    (div_aux def-decl "nat" little_theorem_pvs nil)
    (mod_aux def-decl "nat" little_theorem_pvs nil)
    (sttfa_exp def-decl "nat" little_theorem_pvs nil)
    (factorial def-decl "nat" little_theorem_pvs nil)
    (match_nat_type const-decl "return" little_theorem_pvs nil) nil
    (<= const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil) nil nil
    (= const-decl "[T, T -> boolean]" equalities nil) nil nil
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (FALSE const-decl "bool" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (lt const-decl
        "[little_theorem_sttfa.sttfa_nat -> [little_theorem_sttfa.sttfa_nat -> bool]]"
        little_theorem_sttfa nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "div_mod_spec_intro: AXIOM (FORALL (n: little_theorem_sttfa.sttfa_nat): (FORALL (m: little_theorem_sttfa.sttfa_nat): (FORALL (q: little_theorem_sttfa.sttfa_nat): (FORALL (r: little_theorem_sttfa.sttfa_nat): (booleans.=>(little_theorem_sttfa.lt(little_theorem_sttfa.r)(little_theorem_sttfa.m), (booleans.=>(little_theorem_sttfa.eq[little_theorem_sttfa.sttfa_nat](little_theorem_sttfa.n)(little_theorem_sttfa.plus(little_theorem_sttfa.times(little_theorem_sttfa.q)(little_theorem_sttfa.m))(little_theorem_sttfa.r)), little_theorem_sttfa.div_mod_spec(little_theorem_sttfa.n)(little_theorem_sttfa.m)(little_theorem_sttfa.q)(little_theorem_sttfa.r)))))))))")))
 (IMP_little_theorem_sttfa_match_div_mod_spec_prop_TCC1 0
  (IMP_little_theorem_sttfa_match_div_mod_spec_prop_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (ACop const-decl "bool" little_theorem_pvs nil) nil
    (Aop const-decl "bool" little_theorem_pvs nil) nil nil
    (bigop def-decl "H" little_theorem_pvs nil) nil
    (invert_permut def-decl "nat" little_theorem_pvs nil)
    (gcd_aux def-decl "nat" little_theorem_pvs nil)
    (sttfa_divides const-decl "bool" little_theorem_pvs nil)
    (div_mod_spec const-decl "bool" little_theorem_pvs nil)
    (div_aux def-decl "nat" little_theorem_pvs nil)
    (mod_aux def-decl "nat" little_theorem_pvs nil)
    (sttfa_exp def-decl "nat" little_theorem_pvs nil)
    (factorial def-decl "nat" little_theorem_pvs nil)
    (match_nat_type const-decl "return" little_theorem_pvs nil) nil
    (<= const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil) nil nil
    (= const-decl "[T, T -> boolean]" equalities nil) nil nil
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (FALSE const-decl "bool" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (lt const-decl
        "[little_theorem_sttfa.sttfa_nat -> [little_theorem_sttfa.sttfa_nat -> bool]]"
        little_theorem_sttfa nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "match_div_mod_spec_prop: AXIOM (FORALL (n: little_theorem_sttfa.sttfa_nat): (FORALL (m: little_theorem_sttfa.sttfa_nat): (FORALL (q: little_theorem_sttfa.sttfa_nat): (FORALL (r: little_theorem_sttfa.sttfa_nat): (FORALL (return: booleans.bool): (booleans.=>((booleans.=>(little_theorem_sttfa.lt(little_theorem_sttfa.r)(little_theorem_sttfa.m), (booleans.=>(little_theorem_sttfa.eq[little_theorem_sttfa.sttfa_nat](little_theorem_sttfa.n)(little_theorem_sttfa.plus(little_theorem_sttfa.times(little_theorem_sttfa.q)(little_theorem_sttfa.m))(little_theorem_sttfa.r)), return)))), (booleans.=>(little_theorem_sttfa.div_mod_spec(little_theorem_sttfa.n)(little_theorem_sttfa.m)(little_theorem_sttfa.q)(little_theorem_sttfa.r), return)))))))))")))
 (IMP_little_theorem_sttfa_quotient_TCC1 0
  (IMP_little_theorem_sttfa_quotient_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (sttfa_divides const-decl "bool" little_theorem_pvs nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "quotient: AXIOM (FORALL (n: little_theorem_sttfa.sttfa_nat): (FORALL (m: little_theorem_sttfa.sttfa_nat): (FORALL (q: little_theorem_sttfa.sttfa_nat): (booleans.=>(little_theorem_sttfa.eq[little_theorem_sttfa.sttfa_nat](little_theorem_sttfa.m)(little_theorem_sttfa.times(little_theorem_sttfa.n)(little_theorem_sttfa.q)), little_theorem_sttfa.sttfa_divides(little_theorem_sttfa.n)(little_theorem_sttfa.m))))))")))
 (IMP_little_theorem_sttfa_match_divides_prop_TCC1 0
  (IMP_little_theorem_sttfa_match_divides_prop_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (sttfa_divides const-decl "bool" little_theorem_pvs nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "match_divides_prop: AXIOM (FORALL (n: little_theorem_sttfa.sttfa_nat): (FORALL (m: little_theorem_sttfa.sttfa_nat): (FORALL (return_type: booleans.bool): (booleans.=>(FORALL (q: little_theorem_sttfa.sttfa_nat): (booleans.=>(little_theorem_sttfa.eq[little_theorem_sttfa.sttfa_nat](little_theorem_sttfa.m)(little_theorem_sttfa.times(little_theorem_sttfa.n)(little_theorem_sttfa.q)), return_type)), (booleans.=>(little_theorem_sttfa.sttfa_divides(little_theorem_sttfa.n)(little_theorem_sttfa.m), return_type)))))))")))
 (IMP_little_theorem_sttfa_axiom_gcd_aux_TCC1 0
  (IMP_little_theorem_sttfa_axiom_gcd_aux_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_gcd_aux: AXIOM (FORALL (p: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.equal[[little_theorem_sttfa.sttfa_nat -> [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]]](little_theorem_sttfa.gcd_aux(little_theorem_sttfa.p))(little_theorem_sttfa.filter_nat_type[[little_theorem_sttfa.sttfa_nat -> [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]]](little_theorem_sttfa.gcd_aux_body)(little_theorem_sttfa.p)))")))
 (IMP_little_theorem_sttfa_axiom_gcd_aux_body_O_TCC1 0
  (IMP_little_theorem_sttfa_axiom_gcd_aux_body_O_TCC1-1 nil 3734443831
   ("" (decompose-equality)
    (("" (decompose-equality) (("" (grind) nil nil)) nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (gcd_aux def-decl "nat" little_theorem_pvs nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_gcd_aux_body_O: AXIOM little_theorem_sttfa.equal[[little_theorem_sttfa.sttfa_nat -> [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]]](little_theorem_sttfa.gcd_aux_body(little_theorem_sttfa.sttfa_O))((LAMBDA (m: little_theorem_sttfa.sttfa_nat): (LAMBDA (n: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.m)))")))
 (IMP_little_theorem_sttfa_axiom_gcd_aux_body_S_TCC1 0
  (IMP_little_theorem_sttfa_axiom_gcd_aux_body_S_TCC1-1 nil 3734443831
   ("" (skeep)
    (("" (decompose-equality)
      (("" (decompose-equality) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (gcd_aux def-decl "nat" little_theorem_pvs nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (TRUE const-decl "bool" booleans nil)
    (FALSE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil) nil nil
    (= const-decl "[T, T -> boolean]" equalities nil) nil nil nil
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil) nil
    (match_nat_type const-decl "return" little_theorem_pvs nil)
    (factorial def-decl "nat" little_theorem_pvs nil)
    (sttfa_exp def-decl "nat" little_theorem_pvs nil)
    (mod_aux def-decl "nat" little_theorem_pvs nil)
    (div_aux def-decl "nat" little_theorem_pvs nil)
    (div_mod_spec const-decl "bool" little_theorem_pvs nil)
    (sttfa_divides const-decl "bool" little_theorem_pvs nil)
    (invert_permut def-decl "nat" little_theorem_pvs nil) nil
    (bigop def-decl "H" little_theorem_pvs nil) nil nil
    (Aop const-decl "bool" little_theorem_pvs nil) nil
    (ACop const-decl "bool" little_theorem_pvs nil)
    (dividesb const-decl
     "[little_theorem_sttfa.sttfa_nat -> [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_bool]]"
     little_theorem_sttfa nil)
    (mod const-decl
         "[little_theorem_sttfa.sttfa_nat -> [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]]"
         little_theorem_sttfa nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (dividesb const-decl "bool" little_theorem_pvs nil)
    (mod const-decl "nat" little_theorem_pvs nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_gcd_aux_body_S: AXIOM (FORALL (p: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.equal[[little_theorem_sttfa.sttfa_nat -> [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]]](little_theorem_sttfa.gcd_aux_body(little_theorem_sttfa.sttfa_S(little_theorem_sttfa.p)))((LAMBDA (m: little_theorem_sttfa.sttfa_nat): (LAMBDA (n: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.match_bool_type[little_theorem_sttfa.sttfa_nat](little_theorem_sttfa.n)(little_theorem_sttfa.gcd_aux(little_theorem_sttfa.p)(little_theorem_sttfa.n)(little_theorem_sttfa.mod(little_theorem_sttfa.m)(little_theorem_sttfa.n)))(little_theorem_sttfa.dividesb(little_theorem_sttfa.n)(little_theorem_sttfa.m))))))")))
 (IMP_little_theorem_sttfa_axiom_invert_permut_TCC1 0
  (IMP_little_theorem_sttfa_axiom_invert_permut_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_invert_permut: AXIOM (FORALL (n: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.equal[[[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat] -> [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]]](little_theorem_sttfa.invert_permut(little_theorem_sttfa.n))(little_theorem_sttfa.filter_nat_type[[[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat] -> [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]]](little_theorem_sttfa.invert_permut_body)(little_theorem_sttfa.n)))")))
 (IMP_little_theorem_sttfa_axiom_invert_permut_body_O_TCC1 0
  (IMP_little_theorem_sttfa_axiom_invert_permut_body_O_TCC1-1 nil 3734443831
   ("" (decompose-equality)
    (("" (decompose-equality) (("" (grind) nil nil)) nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (invert_permut def-decl "nat" little_theorem_pvs nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_invert_permut_body_O: AXIOM little_theorem_sttfa.equal[[[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat] -> [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]]](little_theorem_sttfa.invert_permut_body(little_theorem_sttfa.sttfa_O))((LAMBDA (f: [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]): (LAMBDA (m: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.match_bool_type[little_theorem_sttfa.sttfa_nat](little_theorem_sttfa.sttfa_O)(little_theorem_sttfa.sttfa_O)(little_theorem_sttfa.eqb(little_theorem_sttfa.m)(little_theorem_sttfa.f(little_theorem_sttfa.sttfa_O))))))")))
 (IMP_little_theorem_sttfa_axiom_invert_permut_body_S_TCC1 0
  (IMP_little_theorem_sttfa_axiom_invert_permut_body_S_TCC1-1 nil 3734443831
   ("" (skeep)
    (("" (decompose-equality)
      (("" (decompose-equality) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (invert_permut def-decl "nat" little_theorem_pvs nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_invert_permut_body_S: AXIOM (FORALL (n: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.equal[[[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat] -> [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]]](little_theorem_sttfa.invert_permut_body(little_theorem_sttfa.sttfa_S(little_theorem_sttfa.n)))((LAMBDA (f: [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_nat]): (LAMBDA (m: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.match_bool_type[little_theorem_sttfa.sttfa_nat](little_theorem_sttfa.sttfa_S(little_theorem_sttfa.n))(little_theorem_sttfa.invert_permut(little_theorem_sttfa.n)(little_theorem_sttfa.f)(little_theorem_sttfa.m))(little_theorem_sttfa.eqb(little_theorem_sttfa.m)(little_theorem_sttfa.f(little_theorem_sttfa.sttfa_S(little_theorem_sttfa.n))))))))")))
 (IMP_little_theorem_sttfa_axiom_bigop_S_TCC1 0
  (IMP_little_theorem_sttfa_axiom_bigop_S_TCC1-1 nil 3734443831
   ("" (mapped-axiom-tcc) nil nil) nil nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_bigop_S[H: TYPE+]: AXIOM (FORALL (n: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.equal[[[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_bool] -> [little_theorem_sttfa.H -> [[little_theorem_sttfa.H -> [little_theorem_sttfa.H -> little_theorem_sttfa.H]] -> [[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.H] -> little_theorem_sttfa.H]]]]](little_theorem_sttfa.bigop[little_theorem_sttfa.H](little_theorem_sttfa.sttfa_S(little_theorem_sttfa.n)))(little_theorem_sttfa.bigop_body[little_theorem_sttfa.H](little_theorem_sttfa.sttfa_S(little_theorem_sttfa.n))))")))
 (IMP_little_theorem_sttfa_axiom_bigop_body_O_TCC1 0
  (IMP_little_theorem_sttfa_axiom_bigop_body_O_TCC1-1 nil 3734443831
   ("" (decompose-equality)
    (("" (decompose-equality)
      (("" (decompose-equality)
        (("" (decompose-equality) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil) nil
    (bigop def-decl "H" little_theorem_pvs nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_bigop_body_O[H: TYPE+]: AXIOM little_theorem_sttfa.equal[[[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_bool] -> [little_theorem_sttfa.H -> [[little_theorem_sttfa.H -> [little_theorem_sttfa.H -> little_theorem_sttfa.H]] -> [[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.H] -> little_theorem_sttfa.H]]]]](little_theorem_sttfa.bigop_body[little_theorem_sttfa.H](little_theorem_sttfa.sttfa_O))((LAMBDA (p: [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_bool]): (LAMBDA (nil: little_theorem_sttfa.H): LAMBDA (op: [little_theorem_sttfa.H -> [little_theorem_sttfa.H -> little_theorem_sttfa.H]]): LAMBDA (f: [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.H]): nil)))")))
 (IMP_little_theorem_sttfa_axiom_bigop_body_S_TCC1 0
  (IMP_little_theorem_sttfa_axiom_bigop_body_S_TCC1-1 nil 3734443831
   ("" (skeep)
    (("" (decompose-equality)
      (("" (decompose-equality)
        (("" (decompose-equality)
          (("" (decompose-equality) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (bigop def-decl "H" little_theorem_pvs nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil) nil
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "axiom_bigop_body_S[H: TYPE+]: AXIOM (FORALL (n: little_theorem_sttfa.sttfa_nat): little_theorem_sttfa.equal[[[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_bool] -> [little_theorem_sttfa.H -> [[little_theorem_sttfa.H -> [little_theorem_sttfa.H -> little_theorem_sttfa.H]] -> [[little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.H] -> little_theorem_sttfa.H]]]]](little_theorem_sttfa.bigop_body[little_theorem_sttfa.H](little_theorem_sttfa.sttfa_S(little_theorem_sttfa.n)))((LAMBDA (p: [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.sttfa_bool]): (LAMBDA (nil: little_theorem_sttfa.H): LAMBDA (op: [little_theorem_sttfa.H -> [little_theorem_sttfa.H -> little_theorem_sttfa.H]]): LAMBDA (f: [little_theorem_sttfa.sttfa_nat -> little_theorem_sttfa.H]): little_theorem_sttfa.match_bool_type[little_theorem_sttfa.H](op(f(little_theorem_sttfa.n))(little_theorem_sttfa.bigop[little_theorem_sttfa.H](little_theorem_sttfa.n)(little_theorem_sttfa.p)(nil)(op)(f)))(little_theorem_sttfa.bigop[little_theorem_sttfa.H](little_theorem_sttfa.n)(little_theorem_sttfa.p)(nil)(op)(f))(little_theorem_sttfa.p(little_theorem_sttfa.n))))))")))
 (IMP_little_theorem_sttfa_mk_Aop_TCC1 0
  (IMP_little_theorem_sttfa_mk_Aop_TCC1-1 nil 3734443831
   ("" (grind) (("" (inst 1 "op!1") (("" (grind) nil nil)) nil)) nil)
   (nil (Aop const-decl "bool" little_theorem_pvs nil)) nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "mk_Aop[A: TYPE+]: AXIOM (FORALL (nil: little_theorem_sttfa.A): FORALL (op: [little_theorem_sttfa.A -> [little_theorem_sttfa.A -> little_theorem_sttfa.A]]): (booleans.=>(FORALL (a: little_theorem_sttfa.A): little_theorem_sttfa.eq[little_theorem_sttfa.A](op(nil)(a))(a), (booleans.=>(FORALL (a: little_theorem_sttfa.A): little_theorem_sttfa.eq[little_theorem_sttfa.A](op(a)(nil))(a), (booleans.=>(FORALL (a: little_theorem_sttfa.A): FORALL (b: little_theorem_sttfa.A): FORALL (c: little_theorem_sttfa.A): little_theorem_sttfa.eq[little_theorem_sttfa.A](op(a)(op(b)(c)))(op(op(a)(b))(c)), little_theorem_sttfa.Aop[little_theorem_sttfa.A](nil))))))))")))
 (IMP_little_theorem_sttfa_mk_ACop_TCC1 0
  (IMP_little_theorem_sttfa_mk_ACop_TCC1-1 nil 3734443831
   ("" (grind) (("" (inst 1 "op!1") (("" (grind) nil nil)) nil)) nil)
   (nil (ACop const-decl "bool" little_theorem_pvs nil)) nil
   (IMP_little_theorem_sttfa mapped-axiom
    "little_theorem_sttfa{{ sttfa_True := TRUE, sttfa_False := FALSE, sttfa_And := LAMBDA (a: bool): LAMBDA (b: bool): a AND b, sttfa_Or := LAMBDA (a: bool): LAMBDA (b: bool): a OR b, sttfa_Not := LAMBDA (a: bool): NOT a, sttfa_ex[A: TYPE+] := LAMBDA (f: [A -> bool]): EXISTS (y: A): f(y), equal[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, eq[A: TYPE+] := LAMBDA (x: A): LAMBDA (y: A): x = y, sttfa_bool := bool, sttfa_true := TRUE, sttfa_false := FALSE, match_bool_type[return: TYPE+] := LAMBDA (x: return): LAMBDA (y: return): LAMBDA (b: bool): IF b THEN x ELSE y ENDIF, sttfa_nat := nat, sttfa_O := 0, sttfa_S := LAMBDA (n: nat): n + 1, filter_nat_type[return: TYPE+] := LAMBDA (f: [nat -> return]): LAMBDA (n: nat): f(n), plus := LAMBDA (n: nat): LAMBDA (m: nat): n + m, plus_body := LAMBDA (n: nat): LAMBDA (m: nat): n + m, times := LAMBDA (n: nat): LAMBDA (m: nat): n * m, times_body := LAMBDA (n: nat): LAMBDA (m: nat): n * m, minus := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, minus_body := LAMBDA (n: nat): LAMBDA (m: nat): IF n < m THEN 0 ELSE n - m ENDIF, eqb := LAMBDA (n: nat): LAMBDA (m: nat): n = m, eqb_body := LAMBDA (n: nat): LAMBDA (m: nat): n = m, leb := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, leb_body := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, le := LAMBDA (n: nat): LAMBDA (m: nat): n <= m, match_nat_type[return: TYPE+] := match_nat_type[return], sttfa_fact := factorial, fact_body := factorial, sttfa_exp := sttfa_exp, exp_body := sttfa_exp, mod_aux := mod_aux, mod_aux_body := mod_aux, div_aux := div_aux, div_aux_body := div_aux, div_mod_spec := div_mod_spec, sttfa_divides := sttfa_divides, gcd_aux := gcd_aux, gcd_aux_body := gcd_aux, invert_permut := invert_permut, invert_permut_body := invert_permut, bigop[H: TYPE+] := bigop[H], bigop_body[H: TYPE+] := bigop[H], Aop[A: TYPE+] := Aop[A], ACop[A: TYPE+] := ACop[A] }}.little_theorem_sttfa"
    "mk_ACop[A: TYPE+]: AXIOM (FORALL (nil: little_theorem_sttfa.A): FORALL (op: [little_theorem_sttfa.A -> [little_theorem_sttfa.A -> little_theorem_sttfa.A]]): (booleans.=>(FORALL (a: little_theorem_sttfa.A): little_theorem_sttfa.eq[little_theorem_sttfa.A](op(nil)(a))(a), (booleans.=>(FORALL (a: little_theorem_sttfa.A): little_theorem_sttfa.eq[little_theorem_sttfa.A](op(a)(nil))(a), (booleans.=>(FORALL (a: little_theorem_sttfa.A): FORALL (b: little_theorem_sttfa.A): FORALL (c: little_theorem_sttfa.A): little_theorem_sttfa.eq[little_theorem_sttfa.A](op(a)(op(b)(c)))(op(op(a)(b))(c)), (booleans.=>(FORALL (a: little_theorem_sttfa.A): FORALL (b: little_theorem_sttfa.A): little_theorem_sttfa.eq[little_theorem_sttfa.A](op(a)(b))(op(b)(a)), little_theorem_sttfa.ACop[little_theorem_sttfa.A](nil))))))))))")))
 (foo 0
  (foo-1 nil 3734445180
   ("" (lemma "congruent_exp_pred_SO")
    (("" (beta) (("" (postpone) nil nil)) nil)) nil)
   nil shostak)))

