Require Import bool.
Require Import connectives.
Require Import leibniz.
Require Import logic.
Require Import nat.
Require Import relations.
Definition injn : (((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> Prop := fun (f:((nat.nat) ) -> (nat.nat) ) => fun (n:(nat.nat) ) => forall (i:(nat.nat) ), forall (j:(nat.nat) ), ((((nat.le) ) (i)) (n)) -> ((((nat.le) ) (j)) (n)) -> ((((logic.eq) ((nat.nat) )) ((f) (i))) ((f) (j))) -> (((logic.eq) ((nat.nat) )) (i)) (j).
Definition injn_Sn_n : forall (f:((nat.nat) ) -> (nat.nat) ), forall (n:(nat.nat) ), ((((injn) ) (f)) (((nat.S) ) (n))) -> (((injn) ) (f)) (n) := fun (f:((nat.nat) ) -> (nat.nat) ) => fun (n:(nat.nat) ) => fun (H:(((injn) ) (f)) (((nat.S) ) (n))) => (fun (i:(nat.nat) ) => fun (j:(nat.nat) ) => fun (lei:(((nat.le) ) (i)) (n)) => (fun (lej:(((nat.le) ) (j)) (n)) => (fun (eqf:(((logic.eq) ((nat.nat) )) ((f) (i))) ((f) (j))) => ((((((H) (i)) (j)) ((((nat.le_S) (i)) (n)) (lei))) ((((nat.le_S) (j)) (n)) (lej))) (((((((logic.rewrite_l) ((nat.nat) )) ((f) (i))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((f) (i))) (__))) (((logic.refl) ((nat.nat) )) ((f) (i)))) ((f) (j))) (eqf)))))).
Definition permut : (((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> Prop := fun (f:((nat.nat) ) -> (nat.nat) ) => fun (m:(nat.nat) ) => (((connectives.And) ) (forall (i:(nat.nat) ), ((((nat.le) ) (i)) (m)) -> (((nat.le) ) ((f) (i))) (m))) ((((injn) ) (f)) (m)).
Definition transpose : ((nat.nat) ) -> ((nat.nat) ) -> ((nat.nat) ) -> (nat.nat)  := fun (i:(nat.nat) ) => fun (j:(nat.nat) ) => fun (n:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) ((((nat.eqb) ) (n)) (i)).
Definition transpose_i_j_i : forall (i:(nat.nat) ), forall (j:(nat.nat) ), (((logic.eq) ((nat.nat) )) (((((transpose) ) (i)) (j)) (i))) (j) := fun (i:(nat.nat) ) => fun (j:(nat.nat) ) => ((((((logic.eq_ind_r) ((bool.bool) )) ((bool.true) )) (fun (x:(bool.bool) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (i)) ((((nat.eqb) ) (i)) (j)))) (x))) (j))) ((((((bool.eq_match_bool_type_true) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (i)) ((((nat.eqb) ) (i)) (j)))) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (i)) ((((nat.eqb) ) (i)) (j)))) ((bool.true) ))) (y))) (((logic.refl) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (i)) ((((nat.eqb) ) (i)) (j)))) ((bool.true) ))))) ((((nat.eqb) ) (i)) (i))) ((nat.eqb_n_n) (i)).
Definition transpose_i_j_j : forall (i:(nat.nat) ), forall (j:(nat.nat) ), (((logic.eq) ((nat.nat) )) (((((transpose) ) (i)) (j)) (j))) (i) := fun (i:(nat.nat) ) => fun (j:(nat.nat) ) => ((((((connectives.match_Or_prop) ((((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (j)) (i))) ((bool.true) ))) ((((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (j)) (i))) ((bool.false) ))) ((((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (j)) ((((nat.eqb) ) (j)) (j)))) ((((nat.eqb) ) (j)) (i)))) (i))) (fun (Hc:(((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (j)) (i))) ((bool.true) )) => (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.true) )) (fun (x:(bool.bool) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (j)) ((((nat.eqb) ) (j)) (j)))) (x))) (i))) ((((((bool.sym_eq_match_bool_type_true) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (j)) ((((nat.eqb) ) (j)) (j)))) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (y)) (i))) (((((((logic.eq_ind_r) ((nat.nat) )) (i)) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (x)) (i))) (((logic.refl) ((nat.nat) )) (i))) (j)) ((((nat.eqb_true_to_eq) (j)) (i)) (Hc))))) ((((nat.eqb) ) (j)) (i))) (Hc)))) (fun (Hc:(((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (j)) (i))) ((bool.false) )) => (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.false) )) (fun (x:(bool.bool) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (j)) ((((nat.eqb) ) (j)) (j)))) (x))) (i))) (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.true) )) (fun (x:(bool.bool) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (j)) (x))) ((bool.false) ))) (i))) ((((((bool.sym_eq_match_bool_type_false) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (j)) ((bool.true) ))) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (y)) (i))) ((((((bool.eq_match_bool_type_true) ((nat.nat) )) (i)) (j)) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (i)) (j)) ((bool.true) ))) (y))) ((((((bool.eq_match_bool_type_false) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (j)) ((bool.true) ))) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (i)) (j)) ((bool.true) ))) (y))) ((((((bool.eq_match_bool_type_false) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (j)) ((bool.true) ))) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (y)) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (j)) ((bool.true) ))) ((bool.false) )))) (((logic.refl) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (j)) ((bool.true) ))) ((bool.false) )))))))) ((((nat.eqb) ) (j)) (j))) ((nat.eqb_n_n) (j)))) ((((nat.eqb) ) (j)) (i))) (Hc)))) ((bool.true_or_false) ((((nat.eqb) ) (j)) (i))).
Definition transpose_i_j_j_i : forall (i:(nat.nat) ), forall (j:(nat.nat) ), forall (n:(nat.nat) ), (((logic.eq) ((nat.nat) )) (((((transpose) ) (i)) (j)) (n))) (((((transpose) ) (j)) (i)) (n)) := fun (i:(nat.nat) ) => fun (j:(nat.nat) ) => fun (n:(nat.nat) ) => ((((((connectives.match_Or_prop) ((((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (n)) (i))) ((bool.true) ))) ((((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (n)) (i))) ((bool.false) ))) ((((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) ((((nat.eqb) ) (n)) (i)))) (((((bool.match_bool_type) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (j)) (n)) ((((nat.eqb) ) (n)) (i)))) ((((nat.eqb) ) (n)) (j))))) (fun (Hni:(((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (n)) (i))) ((bool.true) )) => (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.true) )) (fun (x:(bool.bool) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) (x))) (((((bool.match_bool_type) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (j)) (n)) (x))) ((((nat.eqb) ) (n)) (j))))) (((((((connectives.match_Or_prop) ((((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (n)) (j))) ((bool.true) ))) ((((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (n)) (j))) ((bool.false) ))) ((((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) ((bool.true) ))) (((((bool.match_bool_type) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (j)) (n)) ((bool.true) ))) ((((nat.eqb) ) (n)) (j))))) (fun (Hnj:(((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (n)) (j))) ((bool.true) )) => (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.true) )) (fun (x:(bool.bool) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) (x))) ((bool.true) ))) (((((bool.match_bool_type) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (j)) (n)) ((bool.true) ))) (x)))) ((((((bool.sym_eq_match_bool_type_true) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((bool.true) ))) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (y)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (j)) (n)) ((bool.true) ))) ((bool.true) )))) ((((((bool.sym_eq_match_bool_type_true) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (j)) (n)) ((bool.true) ))) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (j)) (y))) (((((((logic.eq_ind) ((nat.nat) )) (n)) (fun (x_1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (j)) (x_1))) (((((((logic.eq_ind) ((nat.nat) )) (n)) (fun (x_1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (x_1)) (n))) (((logic.refl) ((nat.nat) )) (n))) (j)) ((((nat.eqb_true_to_eq) (n)) (j)) (Hnj)))) (i)) ((((nat.eqb_true_to_eq) (n)) (i)) (Hni)))))) ((((nat.eqb) ) (n)) (j))) (Hnj)))) (fun (Hnj:(((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (n)) (j))) ((bool.false) )) => (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.false) )) (fun (x:(bool.bool) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) (x))) ((bool.true) ))) (((((bool.match_bool_type) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (j)) (n)) ((bool.true) ))) (x)))) ((((((bool.sym_eq_match_bool_type_false) ((nat.nat) )) (i)) (n)) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (y)) ((bool.true) ))) (((((bool.match_bool_type) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (j)) (n)) ((bool.true) ))) ((bool.false) )))) ((((((bool.sym_eq_match_bool_type_false) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (j)) (n)) ((bool.true) ))) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (n)) ((bool.true) ))) (y))) ((((((bool.sym_eq_match_bool_type_true) ((nat.nat) )) (j)) (n)) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (n)) ((bool.true) ))) (y))) ((((((bool.sym_eq_match_bool_type_true) ((nat.nat) )) (j)) (n)) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (y)) (j))) (((logic.refl) ((nat.nat) )) (j))))))) ((((nat.eqb) ) (n)) (j))) (Hnj)))) ((bool.true_or_false) ((((nat.eqb) ) (n)) (j))))) ((((nat.eqb) ) (n)) (i))) (Hni)))) (fun (Hni:(((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (n)) (i))) ((bool.false) )) => (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.false) )) (fun (x:(bool.bool) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) (x))) (((((bool.match_bool_type) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (j)) (n)) (x))) ((((nat.eqb) ) (n)) (j))))) (((((((connectives.match_Or_prop) ((((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (n)) (j))) ((bool.true) ))) ((((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (n)) (j))) ((bool.false) ))) ((((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) ((bool.false) ))) (((((bool.match_bool_type) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (j)) (n)) ((bool.false) ))) ((((nat.eqb) ) (n)) (j))))) (fun (Hnj:(((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (n)) (j))) ((bool.true) )) => (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.true) )) (fun (x:(bool.bool) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) (x))) ((bool.false) ))) (((((bool.match_bool_type) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (j)) (n)) ((bool.false) ))) (x)))) ((((((bool.sym_eq_match_bool_type_false) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((bool.true) ))) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (y)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (j)) (n)) ((bool.false) ))) ((bool.true) )))) ((((((bool.sym_eq_match_bool_type_false) ((nat.nat) )) (j)) (n)) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((bool.true) ))) (((((bool.match_bool_type) ((nat.nat) )) (i)) (y)) ((bool.true) )))) ((((((bool.sym_eq_match_bool_type_true) ((nat.nat) )) (i)) (n)) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((bool.true) ))) (y))) ((((((bool.sym_eq_match_bool_type_true) ((nat.nat) )) (i)) (n)) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (y)) (i))) (((logic.refl) ((nat.nat) )) (i))))))) ((((nat.eqb) ) (n)) (j))) (Hnj)))) (fun (Hnj:(((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (n)) (j))) ((bool.false) )) => (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.false) )) (fun (x:(bool.bool) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) (x))) ((bool.false) ))) (((((bool.match_bool_type) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (j)) (n)) ((bool.false) ))) (x)))) ((((((bool.sym_eq_match_bool_type_false) ((nat.nat) )) (i)) (n)) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (y)) ((bool.false) ))) (((((bool.match_bool_type) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (j)) (n)) ((bool.false) ))) ((bool.false) )))) ((((((bool.sym_eq_match_bool_type_false) ((nat.nat) )) (j)) (n)) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (n)) ((bool.false) ))) (((((bool.match_bool_type) ((nat.nat) )) (i)) (y)) ((bool.false) )))) ((((((bool.sym_eq_match_bool_type_false) ((nat.nat) )) (j)) (n)) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (y)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((bool.false) )))) ((((((bool.sym_eq_match_bool_type_false) ((nat.nat) )) (i)) (n)) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) (y))) (((logic.refl) ((nat.nat) )) (n))))))) ((((nat.eqb) ) (n)) (j))) (Hnj)))) ((bool.true_or_false) ((((nat.eqb) ) (n)) (j))))) ((((nat.eqb) ) (n)) (i))) (Hni)))) ((bool.true_or_false) ((((nat.eqb) ) (n)) (i))).
Definition transpose_transpose : forall (i:(nat.nat) ), forall (j:(nat.nat) ), forall (n:(nat.nat) ), (((logic.eq) ((nat.nat) )) (((((transpose) ) (i)) (j)) (((((transpose) ) (i)) (j)) (n)))) (n) := fun (i:(nat.nat) ) => fun (j:(nat.nat) ) => fun (n:(nat.nat) ) => ((((((connectives.match_Or_prop) ((((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (n)) (i))) ((bool.true) ))) ((((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (n)) (i))) ((bool.false) ))) ((((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) ((((nat.eqb) ) (n)) (i)))) ((((nat.eqb) ) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) ((((nat.eqb) ) (n)) (i)))) (j)))) ((((nat.eqb) ) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) ((((nat.eqb) ) (n)) (i)))) (i)))) (n))) (fun (Hni:(((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (n)) (i))) ((bool.true) )) => (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.true) )) (fun (x:(bool.bool) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) (x))) ((((nat.eqb) ) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) (x))) (j)))) ((((nat.eqb) ) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) (x))) (i)))) (n))) ((((((bool.sym_eq_match_bool_type_true) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) ((bool.true) ))) ((((nat.eqb) ) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) ((bool.true) ))) (j)))) ((((nat.eqb) ) (y)) (i)))) (n))) ((((((bool.sym_eq_match_bool_type_true) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) ((bool.true) ))) ((((nat.eqb) ) (y)) (j)))) ((((nat.eqb) ) (j)) (i)))) (n))) ((((((bool.sym_eq_match_bool_type_true) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (y)) ((((nat.eqb) ) (j)) (j)))) ((((nat.eqb) ) (j)) (i)))) (n))) (((((((connectives.match_Or_prop) ((((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (j)) (i))) ((bool.true) ))) ((((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (j)) (i))) ((bool.false) ))) ((((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (j)) ((((nat.eqb) ) (j)) (j)))) ((((nat.eqb) ) (j)) (i)))) (n))) (fun (Hji:(((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (j)) (i))) ((bool.true) )) => (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.true) )) (fun (x:(bool.bool) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (j)) ((((nat.eqb) ) (j)) (j)))) (x))) (n))) ((((((bool.sym_eq_match_bool_type_true) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (j)) ((((nat.eqb) ) (j)) (j)))) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (y)) (n))) (((((((logic.eq_ind_r) ((nat.nat) )) (i)) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (j)) (x))) ((((nat.eqb_true_to_eq) (j)) (i)) (Hji))) (n)) ((((nat.eqb_true_to_eq) (n)) (i)) (Hni))))) ((((nat.eqb) ) (j)) (i))) (Hji)))) (fun (Hji:(((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (j)) (i))) ((bool.false) )) => (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.false) )) (fun (x:(bool.bool) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (j)) ((((nat.eqb) ) (j)) (j)))) (x))) (n))) ((((((bool.sym_eq_match_bool_type_false) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (j)) ((((nat.eqb) ) (j)) (j)))) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (y)) (n))) (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.true) )) (fun (x:(bool.bool) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (i)) (j)) (x))) (n))) ((((((bool.sym_eq_match_bool_type_true) ((nat.nat) )) (i)) (j)) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (y)) (n))) (((((logic.sym_eq) ((nat.nat) )) (n)) (i)) ((((nat.eqb_true_to_eq) (n)) (i)) (Hni))))) ((((nat.eqb) ) (j)) (j))) ((nat.eqb_n_n) (j))))) ((((nat.eqb) ) (j)) (i))) (Hji)))) ((bool.true_or_false) ((((nat.eqb) ) (j)) (i)))))))) ((((nat.eqb) ) (n)) (i))) (Hni)))) (fun (Hni:(((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (n)) (i))) ((bool.false) )) => (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.false) )) (fun (x:(bool.bool) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) (x))) ((((nat.eqb) ) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) (x))) (j)))) ((((nat.eqb) ) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) (x))) (i)))) (n))) ((((((bool.sym_eq_match_bool_type_false) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) ((bool.false) ))) ((((nat.eqb) ) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) ((bool.false) ))) (j)))) ((((nat.eqb) ) (y)) (i)))) (n))) ((((((bool.sym_eq_match_bool_type_false) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) ((bool.false) ))) ((((nat.eqb) ) (y)) (j)))) ((((nat.eqb) ) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) (i)))) (n))) ((((((bool.sym_eq_match_bool_type_false) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (y)) ((((nat.eqb) ) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) (j)))) ((((nat.eqb) ) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) (i)))) (n))) (((((((connectives.match_Or_prop) ((((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (n)) (j))) ((bool.true) ))) ((((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (n)) (j))) ((bool.false) ))) ((((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) ((((nat.eqb) ) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) (j)))) ((((nat.eqb) ) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) (i)))) (n))) (fun (Hnj:(((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (n)) (j))) ((bool.true) )) => (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.true) )) (fun (x:(bool.bool) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) (x))) ((((nat.eqb) ) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) (x))) (j)))) ((((nat.eqb) ) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) (x))) (i)))) (n))) ((((((bool.sym_eq_match_bool_type_true) ((nat.nat) )) (i)) (n)) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((bool.true) ))) ((((nat.eqb) ) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((bool.true) ))) (j)))) ((((nat.eqb) ) (y)) (i)))) (n))) ((((((bool.sym_eq_match_bool_type_true) ((nat.nat) )) (i)) (n)) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((bool.true) ))) ((((nat.eqb) ) (y)) (j)))) ((((nat.eqb) ) (i)) (i)))) (n))) ((((((bool.sym_eq_match_bool_type_true) ((nat.nat) )) (i)) (n)) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (y)) ((((nat.eqb) ) (i)) (j)))) ((((nat.eqb) ) (i)) (i)))) (n))) (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.true) )) (fun (x:(bool.bool) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (i)) ((((nat.eqb) ) (i)) (j)))) (x))) (n))) ((((((bool.sym_eq_match_bool_type_true) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (i)) ((((nat.eqb) ) (i)) (j)))) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (y)) (n))) (((((logic.sym_eq) ((nat.nat) )) (n)) (j)) ((((nat.eqb_true_to_eq) (n)) (j)) (Hnj))))) ((((nat.eqb) ) (i)) (i))) ((nat.eqb_n_n) (i))))))) ((((nat.eqb) ) (n)) (j))) (Hnj)))) (fun (Hnj:(((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (n)) (j))) ((bool.false) )) => (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.false) )) (fun (x:(bool.bool) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) (x))) ((((nat.eqb) ) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) (x))) (j)))) ((((nat.eqb) ) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) (x))) (i)))) (n))) ((((((bool.sym_eq_match_bool_type_false) ((nat.nat) )) (i)) (n)) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((bool.false) ))) ((((nat.eqb) ) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((bool.false) ))) (j)))) ((((nat.eqb) ) (y)) (i)))) (n))) ((((((bool.sym_eq_match_bool_type_false) ((nat.nat) )) (i)) (n)) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((bool.false) ))) ((((nat.eqb) ) (y)) (j)))) ((((nat.eqb) ) (n)) (i)))) (n))) ((((((bool.sym_eq_match_bool_type_false) ((nat.nat) )) (i)) (n)) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (y)) ((((nat.eqb) ) (n)) (j)))) ((((nat.eqb) ) (n)) (i)))) (n))) (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.false) )) (fun (x:(bool.bool) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((((nat.eqb) ) (n)) (j)))) (x))) (n))) (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.false) )) (fun (x:(bool.bool) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) (x))) ((bool.false) ))) (n))) ((((((bool.eq_match_bool_type_false) ((nat.nat) )) (i)) (n)) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((bool.false) ))) ((bool.false) ))) (y))) ((((((bool.eq_match_bool_type_false) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((bool.false) ))) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((bool.false) ))) ((bool.false) ))) (y))) (((logic.refl) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (n)) ((bool.false) ))) ((bool.false) )))))) ((((nat.eqb) ) (n)) (j))) (Hnj))) ((((nat.eqb) ) (n)) (i))) (Hni)))))) ((((nat.eqb) ) (n)) (j))) (Hnj)))) ((bool.true_or_false) ((((nat.eqb) ) (n)) (j)))))))) ((((nat.eqb) ) (n)) (i))) (Hni)))) ((bool.true_or_false) ((((nat.eqb) ) (n)) (i))).
Definition injective_transpose : forall (i:(nat.nat) ), forall (j:(nat.nat) ), ((relations.injective) ((nat.nat) ) ((nat.nat) )) ((((transpose) ) (i)) (j)) := fun (i:(nat.nat) ) => fun (j:(nat.nat) ) => fun (x:(nat.nat) ) => fun (y:(nat.nat) ) => fun (auto:(((logic.eq) ((nat.nat) )) (((((transpose) ) (i)) (j)) (x))) (((((transpose) ) (i)) (j)) (y))) => (((((((logic.rewrite_r) ((nat.nat) )) (y)) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__)) (y))) (((logic.refl) ((nat.nat) )) (y))) (x)) (((((((logic.rewrite_l) ((nat.nat) )) (((((transpose) ) (i)) (j)) (((((transpose) ) (i)) (j)) (x)))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__)) (y))) (((((((logic.rewrite_r) ((nat.nat) )) (((((transpose) ) (i)) (j)) (y))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((transpose) ) (i)) (j)) (__))) (y))) ((((transpose_transpose) (i)) (j)) (y))) (((((transpose) ) (i)) (j)) (x))) (auto))) (x)) ((((transpose_transpose) (i)) (j)) (x)))).
Definition permut_S_to_permut_transpose : forall (f:((nat.nat) ) -> (nat.nat) ), forall (m:(nat.nat) ), ((((permut) ) (f)) (((nat.S) ) (m))) -> (((permut) ) (fun (n:(nat.nat) ) => ((((transpose) ) ((f) (((nat.S) ) (m)))) (((nat.S) ) (m))) ((f) (n)))) (m) := fun (f:((nat.nat) ) -> (nat.nat) ) => fun (m:(nat.nat) ) => fun (_clearme:(((permut) ) (f)) (((nat.S) ) (m))) => ((((((connectives.match_And_prop) (forall (i:(nat.nat) ), ((((nat.le) ) (i)) (((nat.S) ) (m))) -> (((nat.le) ) ((f) (i))) (((nat.S) ) (m)))) ((((injn) ) (f)) (((nat.S) ) (m)))) ((((permut) ) (fun (n:(nat.nat) ) => ((((transpose) ) ((f) (((nat.S) ) (m)))) (((nat.S) ) (m))) ((f) (n)))) (m))) (fun (permf1:forall (i:(nat.nat) ), ((((nat.le) ) (i)) (((nat.S) ) (m))) -> (((nat.le) ) ((f) (i))) (((nat.S) ) (m))) => (fun (permf2:(((injn) ) (f)) (((nat.S) ) (m))) => (((((connectives.conj) (forall (x:(nat.nat) ), ((((nat.le) ) (x)) (m)) -> (((nat.le) ) (((((transpose) ) ((f) (((nat.S) ) (m)))) (((nat.S) ) (m))) ((f) (x)))) (m))) ((((injn) ) (fun (n:(nat.nat) ) => ((((transpose) ) ((f) (((nat.S) ) (m)))) (((nat.S) ) (m))) ((f) (n)))) (m))) (fun (i:(nat.nat) ) => fun (leim:(((nat.le) ) (i)) (m)) => (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.false) )) (fun (x:(bool.bool) ) => (((nat.le) ) (((((bool.match_bool_type) ((nat.nat) )) (((nat.S) ) (m))) (((((bool.match_bool_type) ((nat.nat) )) ((f) (((nat.S) ) (m)))) ((f) (i))) ((((nat.eqb) ) ((f) (i))) (((nat.S) ) (m))))) (x))) (m))) ((((((bool.sym_eq_match_bool_type_false) ((nat.nat) )) (((nat.S) ) (m))) (((((bool.match_bool_type) ((nat.nat) )) ((f) (((nat.S) ) (m)))) ((f) (i))) ((((nat.eqb) ) ((f) (i))) (((nat.S) ) (m))))) (fun (y:(nat.nat) ) => (((nat.le) ) (y)) (m))) (((((((connectives.match_Or_prop) ((((nat.lt) ) ((f) (i))) (((nat.S) ) (m)))) ((((logic.eq) ((nat.nat) )) ((f) (i))) (((nat.S) ) (m)))) ((((nat.le) ) (((((bool.match_bool_type) ((nat.nat) )) ((f) (((nat.S) ) (m)))) ((f) (i))) ((((nat.eqb) ) ((f) (i))) (((nat.S) ) (m))))) (m))) (fun (Hfi:(((nat.lt) ) ((f) (i))) (((nat.S) ) (m))) => (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.false) )) (fun (x:(bool.bool) ) => (((nat.le) ) (((((bool.match_bool_type) ((nat.nat) )) ((f) (((nat.S) ) (m)))) ((f) (i))) (x))) (m))) ((((((bool.sym_eq_match_bool_type_false) ((nat.nat) )) ((f) (((nat.S) ) (m)))) ((f) (i))) (fun (y:(nat.nat) ) => (((nat.le) ) (y)) (m))) ((((nat.le_S_S_to_le) ((f) (i))) (m)) (Hfi)))) ((((nat.eqb) ) ((f) (i))) (((nat.S) ) (m)))) ((((nat.not_eq_to_eqb_false) ((f) (i))) (((nat.S) ) (m))) ((((nat.lt_to_not_eq) ((f) (i))) (((nat.S) ) (m))) (Hfi)))))) (fun (Hfi:(((logic.eq) ((nat.nat) )) ((f) (i))) (((nat.S) ) (m))) => (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.true) )) (fun (x:(bool.bool) ) => (((nat.le) ) (((((bool.match_bool_type) ((nat.nat) )) ((f) (((nat.S) ) (m)))) ((f) (i))) (x))) (m))) ((((((bool.sym_eq_match_bool_type_true) ((nat.nat) )) ((f) (((nat.S) ) (m)))) ((f) (i))) (fun (y:(nat.nat) ) => (((nat.le) ) (y)) (m))) (((((((connectives.match_Or_prop) ((((nat.lt) ) ((f) (((nat.S) ) (m)))) (((nat.S) ) (m)))) ((((logic.eq) ((nat.nat) )) ((f) (((nat.S) ) (m)))) (((nat.S) ) (m)))) ((((nat.le) ) ((f) (((nat.S) ) (m)))) (m))) (fun (H:(((nat.lt) ) ((f) (((nat.S) ) (m)))) (((nat.S) ) (m))) => ((((nat.le_S_S_to_le) ((f) (((nat.S) ) (m)))) (m)) (H)))) (fun (H:(((logic.eq) ((nat.nat) )) ((f) (((nat.S) ) (m)))) (((nat.S) ) (m))) => (((connectives.falsity) ((((nat.le) ) ((f) (((nat.S) ) (m)))) (m))) ((((logic.absurd) ((((logic.eq) ((nat.nat) )) (i)) (((nat.S) ) (m)))) ((((((permf2) (i)) (((nat.S) ) (m))) ((((nat.le_S) (i)) (m)) (leim))) ((nat.le_n) (((nat.S) ) (m)))) (((((((logic.rewrite_l) ((nat.nat) )) ((f) (i))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((f) (i))) ((f) (__)))) (((((((logic.rewrite_r) ((nat.nat) )) ((f) (i))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((f) (i))) (__))) (((logic.refl) ((nat.nat) )) ((f) (i)))) ((f) ((f) (i)))) (((((((logic.rewrite_r) ((nat.nat) )) (((nat.S) ) (m))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((f) ((f) (i)))) (__))) (((((((logic.rewrite_r) ((nat.nat) )) (((nat.S) ) (m))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((f) (__))) (((nat.S) ) (m)))) (H)) ((f) (i))) (Hfi))) ((f) (i))) (Hfi)))) (((nat.S) ) (m))) (Hfi)))) (((((logic.not_to_not) ((((logic.eq) ((nat.nat) )) (i)) (((nat.S) ) (m)))) ((((nat.le) ) (((nat.S) ) (m))) (m))) (fun (auto:(((logic.eq) ((nat.nat) )) (i)) (((nat.S) ) (m))) => (((((logic.eq_coerc) ((((nat.le) ) (i)) (m))) ((((nat.le) ) (((nat.S) ) (m))) (m))) (leim)) (((((((logic.rewrite_l) ((nat.nat) )) (i)) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) (i)) (m))) ((((nat.le) ) (__)) (m)))) (((logic.refl) (Prop)) ((((nat.le) ) (i)) (m)))) (((nat.S) ) (m))) (auto))))) ((((nat.lt_to_not_le) (m)) (((nat.S) ) (m))) ((nat.le_n) (((nat.S) ) (m))))))))) ((((nat.le_to_or_lt_eq) ((f) (((nat.S) ) (m)))) (((nat.S) ) (m))) (((permf1) (((nat.S) ) (m))) ((nat.le_n) (((nat.S) ) (m)))))))) ((((nat.eqb) ) ((f) (i))) (((nat.S) ) (m)))) ((((nat.eq_to_eqb_true) ((f) (i))) (((nat.S) ) (m))) (Hfi))))) ((((nat.le_to_or_lt_eq) ((f) (i))) (((nat.S) ) (m))) (((permf1) (i)) ((((nat.le_S) (i)) (m)) (leim))))))) ((((nat.eqb) ) ((f) (i))) ((f) (((nat.S) ) (m))))) ((((nat.not_eq_to_eqb_false) ((f) (i))) ((f) (((nat.S) ) (m)))) (((connectives.nmk) ((((logic.eq) ((nat.nat) )) ((f) (i))) ((f) (((nat.S) ) (m))))) (fun (H:(((logic.eq) ((nat.nat) )) ((f) (i))) ((f) (((nat.S) ) (m)))) => ((((logic.absurd) ((((logic.eq) ((nat.nat) )) (i)) (((nat.S) ) (m)))) ((((((permf2) (i)) (((nat.S) ) (m))) ((((nat.le_S) (i)) (m)) (leim))) ((nat.le_n) (((nat.S) ) (m)))) (H))) ((((nat.lt_to_not_eq) (i)) (((nat.S) ) (m))) ((((nat.le_S_S) (i)) (m)) (leim)))))))))) (fun (a:(nat.nat) ) => fun (b:(nat.nat) ) => fun (leam:(((nat.le) ) (a)) (m)) => (fun (lebm:(((nat.le) ) (b)) (m)) => (fun (H:(((logic.eq) ((nat.nat) )) (((((transpose) ) ((f) (((nat.S) ) (m)))) (((nat.S) ) (m))) ((f) (a)))) (((((transpose) ) ((f) (((nat.S) ) (m)))) (((nat.S) ) (m))) ((f) (b)))) => ((((((permf2) (a)) (b)) ((((nat.le_S) (a)) (m)) (leam))) ((((nat.le_S) (b)) (m)) (lebm))) ((((((injective_transpose) ((f) (((nat.S) ) (m)))) (((nat.S) ) (m))) ((f) (a))) ((f) (b))) (H)))))))))) (_clearme)).
Definition bijn : (((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> Prop := fun (f:((nat.nat) ) -> (nat.nat) ) => fun (n:(nat.nat) ) => forall (m:(nat.nat) ), ((((nat.le) ) (m)) (n)) -> ((connectives.ex) ((nat.nat) )) (fun (p:(nat.nat) ) => (((connectives.And) ) ((((nat.le) ) (p)) (n))) ((((logic.eq) ((nat.nat) )) ((f) (p))) (m))).
Definition eq_to_bijn : forall (f:((nat.nat) ) -> (nat.nat) ), forall (g:((nat.nat) ) -> (nat.nat) ), forall (n:(nat.nat) ), (forall (i:(nat.nat) ), ((((nat.le) ) (i)) (n)) -> (((logic.eq) ((nat.nat) )) ((f) (i))) ((g) (i))) -> ((((bijn) ) (f)) (n)) -> (((bijn) ) (g)) (n) := fun (f:((nat.nat) ) -> (nat.nat) ) => fun (g:((nat.nat) ) -> (nat.nat) ) => fun (n:(nat.nat) ) => fun (H:forall (i:(nat.nat) ), ((((nat.le) ) (i)) (n)) -> (((logic.eq) ((nat.nat) )) ((f) (i))) ((g) (i))) => (fun (bijf:(((bijn) ) (f)) (n)) => (fun (i:(nat.nat) ) => fun (lein:(((nat.le) ) (i)) (n)) => ((((((connectives.match_ex_prop) ((nat.nat) )) (fun (p:(nat.nat) ) => (((connectives.And) ) ((((nat.le) ) (p)) (n))) ((((logic.eq) ((nat.nat) )) ((f) (p))) (i)))) (((connectives.ex) ((nat.nat) )) (fun (p:(nat.nat) ) => (((connectives.And) ) ((((nat.le) ) (p)) (n))) ((((logic.eq) ((nat.nat) )) ((g) (p))) (i))))) (fun (a:(nat.nat) ) => fun (_clearme:(((connectives.And) ) ((((nat.le) ) (a)) (n))) ((((logic.eq) ((nat.nat) )) ((f) (a))) (i))) => ((((((connectives.match_And_prop) ((((nat.le) ) (a)) (n))) ((((logic.eq) ((nat.nat) )) ((f) (a))) (i))) (((connectives.ex) ((nat.nat) )) (fun (p:(nat.nat) ) => (((connectives.And) ) ((((nat.le) ) (p)) (n))) ((((logic.eq) ((nat.nat) )) ((g) (p))) (i))))) (fun (lean:(((nat.le) ) (a)) (n)) => (fun (fa:(((logic.eq) ((nat.nat) )) ((f) (a))) (i)) => (((((connectives.ex_intro) ((nat.nat) )) (fun (x:(nat.nat) ) => (((connectives.And) ) ((((nat.le) ) (x)) (n))) ((((logic.eq) ((nat.nat) )) ((g) (x))) (i)))) (a)) (((((connectives.conj) ((((nat.le) ) (a)) (n))) ((((logic.eq) ((nat.nat) )) ((g) (a))) (i))) (lean)) (((((((logic.eq_ind) ((nat.nat) )) ((f) (a))) (fun (x_1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((g) (a))) (x_1))) (((((logic.sym_eq) ((nat.nat) )) ((f) (a))) ((g) (a))) (((H) (a)) (lean)))) (i)) (fa))))))) (_clearme)))) (((bijf) (i)) (lein))))).
Definition bijn_n_Sn : forall (f:((nat.nat) ) -> (nat.nat) ), forall (n:(nat.nat) ), ((((bijn) ) (f)) (n)) -> ((((logic.eq) ((nat.nat) )) ((f) (((nat.S) ) (n)))) (((nat.S) ) (n))) -> (((bijn) ) (f)) (((nat.S) ) (n)) := fun (f:((nat.nat) ) -> (nat.nat) ) => fun (n:(nat.nat) ) => fun (bijf:(((bijn) ) (f)) (n)) => (fun (fS:(((logic.eq) ((nat.nat) )) ((f) (((nat.S) ) (n)))) (((nat.S) ) (n))) => (fun (i:(nat.nat) ) => fun (lein:(((nat.le) ) (i)) (((nat.S) ) (n))) => (((((((connectives.match_Or_prop) ((((nat.lt) ) (i)) (((nat.S) ) (n)))) ((((logic.eq) ((nat.nat) )) (i)) (((nat.S) ) (n)))) (((connectives.ex) ((nat.nat) )) (fun (p:(nat.nat) ) => (((connectives.And) ) ((((nat.le) ) (p)) (((nat.S) ) (n)))) ((((logic.eq) ((nat.nat) )) ((f) (p))) (i))))) (fun (Hi:(((nat.lt) ) (i)) (((nat.S) ) (n))) => ((((((connectives.match_ex_prop) ((nat.nat) )) (fun (p:(nat.nat) ) => (((connectives.And) ) ((((nat.le) ) (p)) (n))) ((((logic.eq) ((nat.nat) )) ((f) (p))) (i)))) (((connectives.ex) ((nat.nat) )) (fun (p:(nat.nat) ) => (((connectives.And) ) ((((nat.le) ) (p)) (((nat.S) ) (n)))) ((((logic.eq) ((nat.nat) )) ((f) (p))) (i))))) (fun (a:(nat.nat) ) => fun (_clearme:(((connectives.And) ) ((((nat.le) ) (a)) (n))) ((((logic.eq) ((nat.nat) )) ((f) (a))) (i))) => ((((((connectives.match_And_prop) ((((nat.le) ) (a)) (n))) ((((logic.eq) ((nat.nat) )) ((f) (a))) (i))) (((connectives.ex) ((nat.nat) )) (fun (p:(nat.nat) ) => (((connectives.And) ) ((((nat.le) ) (p)) (((nat.S) ) (n)))) ((((logic.eq) ((nat.nat) )) ((f) (p))) (i))))) (fun (lean:(((nat.le) ) (a)) (n)) => (fun (fa:(((logic.eq) ((nat.nat) )) ((f) (a))) (i)) => (((((connectives.ex_intro) ((nat.nat) )) (fun (x:(nat.nat) ) => (((connectives.And) ) ((((nat.le) ) (x)) (((nat.S) ) (n)))) ((((logic.eq) ((nat.nat) )) ((f) (x))) (i)))) (a)) (((((connectives.conj) ((((nat.le) ) (a)) (((nat.S) ) (n)))) ((((logic.eq) ((nat.nat) )) ((f) (a))) (i))) ((((nat.le_S) (a)) (n)) (lean))) (((((((logic.rewrite_r) ((nat.nat) )) (i)) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__)) (i))) (((logic.refl) ((nat.nat) )) (i))) ((f) (a))) (fa))))))) (_clearme)))) (((bijf) (i)) ((((nat.le_S_S_to_le) (i)) (n)) (Hi)))))) (fun (Hi:(((logic.eq) ((nat.nat) )) (i)) (((nat.S) ) (n))) => (((((connectives.ex_intro) ((nat.nat) )) (fun (x:(nat.nat) ) => (((connectives.And) ) ((((nat.le) ) (x)) (((nat.S) ) (n)))) ((((logic.eq) ((nat.nat) )) ((f) (x))) (i)))) (i)) (((((connectives.conj) ((((nat.le) ) (i)) (((nat.S) ) (n)))) ((((logic.eq) ((nat.nat) )) ((f) (i))) (i))) (((((logic.eq_coerc) ((((nat.le) ) (i)) (i))) ((((nat.le) ) (i)) (((nat.S) ) (n)))) ((nat.le_n) (i))) (((((((logic.rewrite_l) ((nat.nat) )) (i)) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) (i)) (i))) ((((nat.le) ) (i)) (__)))) (((logic.refl) (Prop)) ((((nat.le) ) (i)) (i)))) (((nat.S) ) (n))) (Hi)))) (((((((logic.rewrite_r) ((nat.nat) )) (i)) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__)) (i))) (((logic.refl) ((nat.nat) )) (i))) ((f) (i))) (((((((logic.rewrite_r) ((nat.nat) )) (((nat.S) ) (n))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((f) (i))) (__))) (((((((logic.rewrite_r) ((nat.nat) )) (((nat.S) ) (n))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((f) (__))) (((nat.S) ) (n)))) (fS)) (i)) (Hi))) (i)) (Hi))))))) ((((nat.le_to_or_lt_eq) (i)) (((nat.S) ) (n))) (lein))))).
Definition bijn_fg : forall (f:((nat.nat) ) -> (nat.nat) ), forall (g:((nat.nat) ) -> (nat.nat) ), forall (n:(nat.nat) ), ((((bijn) ) (f)) (n)) -> ((((bijn) ) (g)) (n)) -> (((bijn) ) (fun (p:(nat.nat) ) => (f) ((g) (p)))) (n) := fun (f:((nat.nat) ) -> (nat.nat) ) => fun (g:((nat.nat) ) -> (nat.nat) ) => fun (n:(nat.nat) ) => fun (bijf:(((bijn) ) (f)) (n)) => (fun (bijg:(((bijn) ) (g)) (n)) => (fun (i:(nat.nat) ) => fun (lein:(((nat.le) ) (i)) (n)) => ((((((connectives.match_ex_prop) ((nat.nat) )) (fun (p:(nat.nat) ) => (((connectives.And) ) ((((nat.le) ) (p)) (n))) ((((logic.eq) ((nat.nat) )) ((f) (p))) (i)))) (((connectives.ex) ((nat.nat) )) (fun (p:(nat.nat) ) => (((connectives.And) ) ((((nat.le) ) (p)) (n))) ((((logic.eq) ((nat.nat) )) ((f) ((g) (p)))) (i))))) (fun (a:(nat.nat) ) => fun (_clearme:(((connectives.And) ) ((((nat.le) ) (a)) (n))) ((((logic.eq) ((nat.nat) )) ((f) (a))) (i))) => ((((((connectives.match_And_prop) ((((nat.le) ) (a)) (n))) ((((logic.eq) ((nat.nat) )) ((f) (a))) (i))) (((connectives.ex) ((nat.nat) )) (fun (p:(nat.nat) ) => (((connectives.And) ) ((((nat.le) ) (p)) (n))) ((((logic.eq) ((nat.nat) )) ((f) ((g) (p)))) (i))))) (fun (lean:(((nat.le) ) (a)) (n)) => (fun (ga:(((logic.eq) ((nat.nat) )) ((f) (a))) (i)) => ((((((connectives.match_ex_prop) ((nat.nat) )) (fun (p:(nat.nat) ) => (((connectives.And) ) ((((nat.le) ) (p)) (n))) ((((logic.eq) ((nat.nat) )) ((g) (p))) (a)))) (((connectives.ex) ((nat.nat) )) (fun (p:(nat.nat) ) => (((connectives.And) ) ((((nat.le) ) (p)) (n))) ((((logic.eq) ((nat.nat) )) ((f) ((g) (p)))) (i))))) (fun (b:(nat.nat) ) => fun (_clearme0:(((connectives.And) ) ((((nat.le) ) (b)) (n))) ((((logic.eq) ((nat.nat) )) ((g) (b))) (a))) => ((((((connectives.match_And_prop) ((((nat.le) ) (b)) (n))) ((((logic.eq) ((nat.nat) )) ((g) (b))) (a))) (((connectives.ex) ((nat.nat) )) (fun (p:(nat.nat) ) => (((connectives.And) ) ((((nat.le) ) (p)) (n))) ((((logic.eq) ((nat.nat) )) ((f) ((g) (p)))) (i))))) (fun (lebn:(((nat.le) ) (b)) (n)) => (fun (gb:(((logic.eq) ((nat.nat) )) ((g) (b))) (a)) => (((((connectives.ex_intro) ((nat.nat) )) (fun (x:(nat.nat) ) => (((connectives.And) ) ((((nat.le) ) (x)) (n))) ((((logic.eq) ((nat.nat) )) ((f) ((g) (x)))) (i)))) (b)) (((((connectives.conj) ((((nat.le) ) (b)) (n))) ((((logic.eq) ((nat.nat) )) ((f) ((g) (b)))) (i))) (lebn)) (((((((logic.rewrite_r) ((nat.nat) )) (a)) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((f) (__))) (i))) (((((((logic.rewrite_r) ((nat.nat) )) (i)) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__)) (i))) (((logic.refl) ((nat.nat) )) (i))) ((f) (a))) (ga))) ((g) (b))) (gb))))))) (_clearme0)))) (((bijg) (a)) (lean)))))) (_clearme)))) (((bijf) (i)) (lein))))).
Definition bijn_transpose : forall (n:(nat.nat) ), forall (i:(nat.nat) ), forall (j:(nat.nat) ), ((((nat.le) ) (i)) (n)) -> ((((nat.le) ) (j)) (n)) -> (((bijn) ) ((((transpose) ) (i)) (j))) (n) := fun (n:(nat.nat) ) => fun (i:(nat.nat) ) => fun (j:(nat.nat) ) => fun (lein:(((nat.le) ) (i)) (n)) => (fun (lejn:(((nat.le) ) (j)) (n)) => (fun (a:(nat.nat) ) => fun (lean:(((nat.le) ) (a)) (n)) => (((((((connectives.match_Or_prop) ((((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (a)) (i))) ((bool.true) ))) ((((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (a)) (i))) ((bool.false) ))) (((connectives.ex) ((nat.nat) )) (fun (p:(nat.nat) ) => (((connectives.And) ) ((((nat.le) ) (p)) (n))) ((((logic.eq) ((nat.nat) )) (((((transpose) ) (i)) (j)) (p))) (a))))) (fun (Hi:(((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (a)) (i))) ((bool.true) )) => (((((connectives.ex_intro) ((nat.nat) )) (fun (x:(nat.nat) ) => (((connectives.And) ) ((((nat.le) ) (x)) (n))) ((((logic.eq) ((nat.nat) )) (((((transpose) ) (i)) (j)) (x))) (a)))) (j)) (((((connectives.conj) ((((nat.le) ) (j)) (n))) ((((logic.eq) ((nat.nat) )) (((((transpose) ) (i)) (j)) (j))) (a))) (lejn)) (((((((logic.eq_ind_r) ((nat.nat) )) (i)) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (x)) (a))) (((((logic.sym_eq) ((nat.nat) )) (a)) (i)) ((((nat.eqb_true_to_eq) (a)) (i)) (Hi)))) (((((transpose) ) (i)) (j)) (j))) (((transpose_i_j_j) (i)) (j))))))) (fun (Hi:(((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (a)) (i))) ((bool.false) )) => (((((((connectives.match_Or_prop) ((((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (a)) (j))) ((bool.true) ))) ((((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (a)) (j))) ((bool.false) ))) (((connectives.ex) ((nat.nat) )) (fun (p:(nat.nat) ) => (((connectives.And) ) ((((nat.le) ) (p)) (n))) ((((logic.eq) ((nat.nat) )) (((((transpose) ) (i)) (j)) (p))) (a))))) (fun (Hj:(((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (a)) (j))) ((bool.true) )) => (((((connectives.ex_intro) ((nat.nat) )) (fun (x:(nat.nat) ) => (((connectives.And) ) ((((nat.le) ) (x)) (n))) ((((logic.eq) ((nat.nat) )) (((((transpose) ) (i)) (j)) (x))) (a)))) (i)) (((((connectives.conj) ((((nat.le) ) (i)) (n))) ((((logic.eq) ((nat.nat) )) (((((transpose) ) (i)) (j)) (i))) (a))) (lein)) (((((((logic.eq_ind_r) ((nat.nat) )) (j)) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (x)) (a))) (((((logic.sym_eq) ((nat.nat) )) (a)) (j)) ((((nat.eqb_true_to_eq) (a)) (j)) (Hj)))) (((((transpose) ) (i)) (j)) (i))) (((transpose_i_j_i) (i)) (j))))))) (fun (Hj:(((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (a)) (j))) ((bool.false) )) => (((((connectives.ex_intro) ((nat.nat) )) (fun (x:(nat.nat) ) => (((connectives.And) ) ((((nat.le) ) (x)) (n))) ((((logic.eq) ((nat.nat) )) (((((transpose) ) (i)) (j)) (x))) (a)))) (a)) (((((connectives.conj) ((((nat.le) ) (a)) (n))) ((((logic.eq) ((nat.nat) )) (((((transpose) ) (i)) (j)) (a))) (a))) (lean)) (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.false) )) (fun (x:(bool.bool) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (a)) ((((nat.eqb) ) (a)) (j)))) (x))) (a))) (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.false) )) (fun (x:(bool.bool) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (a)) (x))) ((bool.false) ))) (a))) ((((((bool.eq_match_bool_type_false) ((nat.nat) )) (i)) (a)) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (a)) ((bool.false) ))) ((bool.false) ))) (y))) ((((((bool.eq_match_bool_type_false) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (a)) ((bool.false) ))) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (a)) ((bool.false) ))) ((bool.false) ))) (y))) (((logic.refl) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (j)) (((((bool.match_bool_type) ((nat.nat) )) (i)) (a)) ((bool.false) ))) ((bool.false) )))))) ((((nat.eqb) ) (a)) (j))) (Hj))) ((((nat.eqb) ) (a)) (i))) (Hi)))))) ((bool.true_or_false) ((((nat.eqb) ) (a)) (j)))))) ((bool.true_or_false) ((((nat.eqb) ) (a)) (i)))))).
Definition permut_to_bijn : forall (n:(nat.nat) ), forall (f:((nat.nat) ) -> (nat.nat) ), ((((permut) ) (f)) (n)) -> (((bijn) ) (f)) (n) := fun (n:(nat.nat) ) => ((((nat.nat_ind) (fun (_x_365:(nat.nat) ) => forall (f:((nat.nat) ) -> (nat.nat) ), ((((permut) ) (f)) (_x_365)) -> (((bijn) ) (f)) (_x_365))) (fun (f:((nat.nat) ) -> (nat.nat) ) => fun (_clearme:(((connectives.And) ) (forall (i:(nat.nat) ), ((((nat.le) ) (i)) ((nat.O) )) -> (((nat.le) ) ((f) (i))) ((nat.O) ))) (forall (i:(nat.nat) ), forall (j:(nat.nat) ), ((((nat.le) ) (i)) ((nat.O) )) -> ((((nat.le) ) (j)) ((nat.O) )) -> ((((logic.eq) ((nat.nat) )) ((f) (i))) ((f) (j))) -> (((logic.eq) ((nat.nat) )) (i)) (j))) => ((((((connectives.match_And_prop) (forall (i:(nat.nat) ), ((((nat.le) ) (i)) ((nat.O) )) -> (((nat.le) ) ((f) (i))) ((nat.O) ))) (forall (i:(nat.nat) ), forall (j:(nat.nat) ), ((((nat.le) ) (i)) ((nat.O) )) -> ((((nat.le) ) (j)) ((nat.O) )) -> ((((logic.eq) ((nat.nat) )) ((f) (i))) ((f) (j))) -> (((logic.eq) ((nat.nat) )) (i)) (j))) (forall (m:(nat.nat) ), ((((nat.le) ) (m)) ((nat.O) )) -> ((connectives.ex) ((nat.nat) )) (fun (p:(nat.nat) ) => (((connectives.And) ) ((((nat.le) ) (p)) ((nat.O) ))) ((((logic.eq) ((nat.nat) )) ((f) (p))) (m))))) (fun (H:forall (i:(nat.nat) ), ((((nat.le) ) (i)) ((nat.O) )) -> (((nat.le) ) ((f) (i))) ((nat.O) )) => (fun (H1:forall (i:(nat.nat) ), forall (j:(nat.nat) ), ((((nat.le) ) (i)) ((nat.O) )) -> ((((nat.le) ) (j)) ((nat.O) )) -> ((((logic.eq) ((nat.nat) )) ((f) (i))) ((f) (j))) -> (((logic.eq) ((nat.nat) )) (i)) (j)) => (fun (m:(nat.nat) ) => fun (lem0:(((nat.le) ) (m)) ((nat.O) )) => (((((connectives.ex_intro) ((nat.nat) )) (fun (x:(nat.nat) ) => (((connectives.And) ) ((((nat.le) ) (x)) ((nat.O) ))) ((((logic.eq) ((nat.nat) )) ((f) (x))) (m)))) ((nat.O) )) (((((connectives.conj) ((((nat.le) ) ((nat.O) )) ((nat.O) ))) ((((logic.eq) ((nat.nat) )) ((f) ((nat.O) ))) (m))) ((nat.le_O_n) ((nat.O) ))) (((((nat.le_n_O_elim) (m)) (lem0)) (((logic.eq) ((nat.nat) )) ((f) ((nat.O) )))) (((((logic.sym_eq) ((nat.nat) )) ((nat.O) )) ((f) ((nat.O) ))) (((nat.le_n_O_to_eq) ((f) ((nat.O) ))) (((H) ((nat.O) )) ((nat.le_O_n) ((nat.O) )))))))))))) (_clearme)))) (fun (m:(nat.nat) ) => fun (Hind:forall (f:((nat.nat) ) -> (nat.nat) ), ((((permut) ) (f)) (m)) -> (((bijn) ) (f)) (m)) => (fun (f:((nat.nat) ) -> (nat.nat) ) => fun (permf:(((permut) ) (f)) (((nat.S) ) (m))) => ((((((eq_to_bijn) (fun (p:(nat.nat) ) => ((((transpose) ) ((f) (((nat.S) ) (m)))) (((nat.S) ) (m))) (((((transpose) ) ((f) (((nat.S) ) (m)))) (((nat.S) ) (m))) ((f) (p))))) (f)) (((nat.S) ) (m))) (fun (i:(nat.nat) ) => fun (lei:(((nat.le) ) (i)) (((nat.S) ) (m))) => ((((transpose_transpose) ((f) (((nat.S) ) (m)))) (((nat.S) ) (m))) ((f) (i))))) ((((((bijn_fg) ((((transpose) ) ((f) (((nat.S) ) (m)))) (((nat.S) ) (m)))) (fun (__:(nat.nat) ) => ((((transpose) ) ((f) (((nat.S) ) (m)))) (((nat.S) ) (m))) ((f) (__)))) (((nat.S) ) (m))) ((((((connectives.match_And_prop) (forall (i:(nat.nat) ), ((((nat.le) ) (i)) (((nat.S) ) (m))) -> (((nat.le) ) ((f) (i))) (((nat.S) ) (m)))) ((((injn) ) (f)) (((nat.S) ) (m)))) ((((bijn) ) ((((transpose) ) ((f) (((nat.S) ) (m)))) (((nat.S) ) (m)))) (((nat.S) ) (m)))) (fun (lef:forall (i:(nat.nat) ), ((((nat.le) ) (i)) (((nat.S) ) (m))) -> (((nat.le) ) ((f) (i))) (((nat.S) ) (m))) => (fun (__:(((injn) ) (f)) (((nat.S) ) (m))) => ((((((bijn_transpose) (((nat.S) ) (m))) ((f) (((nat.S) ) (m)))) (((nat.S) ) (m))) (((lef) (((nat.S) ) (m))) ((nat.le_n) (((nat.S) ) (m))))) ((nat.le_n) (((nat.S) ) (m))))))) (permf))) (((((bijn_n_Sn) (fun (__:(nat.nat) ) => ((((transpose) ) ((f) (((nat.S) ) (m)))) (((nat.S) ) (m))) ((f) (__)))) (m)) (((Hind) (fun (__:(nat.nat) ) => ((((transpose) ) ((f) (((nat.S) ) (m)))) (((nat.S) ) (m))) ((f) (__)))) ((((permut_S_to_permut_transpose) (f)) (m)) (permf)))) (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.true) )) (fun (x:(bool.bool) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (((nat.S) ) (m))) (((((bool.match_bool_type) ((nat.nat) )) ((f) (((nat.S) ) (m)))) ((f) (((nat.S) ) (m)))) ((((nat.eqb) ) ((f) (((nat.S) ) (m)))) (((nat.S) ) (m))))) (x))) (((nat.S) ) (m)))) ((((((bool.eq_match_bool_type_true) ((nat.nat) )) (((nat.S) ) (m))) (((((bool.match_bool_type) ((nat.nat) )) ((f) (((nat.S) ) (m)))) ((f) (((nat.S) ) (m)))) ((((nat.eqb) ) ((f) (((nat.S) ) (m)))) (((nat.S) ) (m))))) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (((nat.S) ) (m))) (((((bool.match_bool_type) ((nat.nat) )) ((f) (((nat.S) ) (m)))) ((f) (((nat.S) ) (m)))) ((((nat.eqb) ) ((f) (((nat.S) ) (m)))) (((nat.S) ) (m))))) ((bool.true) ))) (y))) (((logic.refl) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (((nat.S) ) (m))) (((((bool.match_bool_type) ((nat.nat) )) ((f) (((nat.S) ) (m)))) ((f) (((nat.S) ) (m)))) ((((nat.eqb) ) ((f) (((nat.S) ) (m)))) (((nat.S) ) (m))))) ((bool.true) ))))) ((((nat.eqb) ) ((f) (((nat.S) ) (m)))) ((f) (((nat.S) ) (m))))) ((nat.eqb_n_n) ((f) (((nat.S) ) (m))))))))))) (n).
Parameter invert_permut : ((nat.nat) ) -> (((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) .
Parameter invert_permut_body : ((nat.nat) ) -> (((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) .
Axiom axiom_invert_permut : forall (n:(nat.nat) ), (((connectives.equal) ((((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((invert_permut) ) (n))) ((((nat.filter_nat_type) ((((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((invert_permut_body) )) (n)).
Definition eq_invert_permut : forall (n:(nat.nat) ), (((leibniz.leibniz) ((((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((invert_permut) ) (n))) ((((nat.filter_nat_type) ((((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((invert_permut_body) )) (n)) := fun (n:(nat.nat) ) => ((((connectives.equal_leibniz) ((((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((invert_permut) ) (n))) ((((nat.filter_nat_type) ((((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((invert_permut_body) )) (n))) ((axiom_invert_permut) (n)).
Definition sym_eq_invert_permut : forall (n:(nat.nat) ), (((leibniz.leibniz) ((((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((((nat.filter_nat_type) ((((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((invert_permut_body) )) (n))) (((invert_permut) ) (n)) := fun (n:(nat.nat) ) => ((((leibniz.sym_leibniz) ((((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((invert_permut) ) (n))) ((((nat.filter_nat_type) ((((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((invert_permut_body) )) (n))) ((eq_invert_permut) (n)).
Axiom axiom_invert_permut_body_O : (((connectives.equal) ((((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((invert_permut_body) ) ((nat.O) ))) (fun (f:((nat.nat) ) -> (nat.nat) ) => fun (m:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) ((nat.O) )) ((((nat.eqb) ) (m)) ((f) ((nat.O) )))).
Definition eq_invert_permut_body_O : (((leibniz.leibniz) ((((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((invert_permut_body) ) ((nat.O) ))) (fun (f:((nat.nat) ) -> (nat.nat) ) => fun (m:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) ((nat.O) )) ((((nat.eqb) ) (m)) ((f) ((nat.O) )))) := ((((connectives.equal_leibniz) ((((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((invert_permut_body) ) ((nat.O) ))) (fun (f:((nat.nat) ) -> (nat.nat) ) => fun (m:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) ((nat.O) )) ((((nat.eqb) ) (m)) ((f) ((nat.O) ))))) (axiom_invert_permut_body_O).
Definition sym_eq_invert_permut_body_O : (((leibniz.leibniz) ((((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (fun (f:((nat.nat) ) -> (nat.nat) ) => fun (m:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) ((nat.O) )) ((((nat.eqb) ) (m)) ((f) ((nat.O) ))))) (((invert_permut_body) ) ((nat.O) )) := ((((leibniz.sym_leibniz) ((((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((invert_permut_body) ) ((nat.O) ))) (fun (f:((nat.nat) ) -> (nat.nat) ) => fun (m:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) ((nat.O) )) ((((nat.eqb) ) (m)) ((f) ((nat.O) ))))) (eq_invert_permut_body_O).
Axiom axiom_invert_permut_body_S : forall (n:(nat.nat) ), (((connectives.equal) ((((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((invert_permut_body) ) (((nat.S) ) (n)))) (fun (f:((nat.nat) ) -> (nat.nat) ) => fun (m:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) (((nat.S) ) (n))) (((((invert_permut) ) (n)) (f)) (m))) ((((nat.eqb) ) (m)) ((f) (((nat.S) ) (n))))).
Definition eq_invert_permut_body_S : forall (n:(nat.nat) ), (((leibniz.leibniz) ((((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((invert_permut_body) ) (((nat.S) ) (n)))) (fun (f:((nat.nat) ) -> (nat.nat) ) => fun (m:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) (((nat.S) ) (n))) (((((invert_permut) ) (n)) (f)) (m))) ((((nat.eqb) ) (m)) ((f) (((nat.S) ) (n))))) := fun (n:(nat.nat) ) => ((((connectives.equal_leibniz) ((((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((invert_permut_body) ) (((nat.S) ) (n)))) (fun (f:((nat.nat) ) -> (nat.nat) ) => fun (m:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) (((nat.S) ) (n))) (((((invert_permut) ) (n)) (f)) (m))) ((((nat.eqb) ) (m)) ((f) (((nat.S) ) (n)))))) ((axiom_invert_permut_body_S) (n)).
Definition sym_eq_invert_permut_body_S : forall (n:(nat.nat) ), (((leibniz.leibniz) ((((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (fun (f:((nat.nat) ) -> (nat.nat) ) => fun (m:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) (((nat.S) ) (n))) (((((invert_permut) ) (n)) (f)) (m))) ((((nat.eqb) ) (m)) ((f) (((nat.S) ) (n)))))) (((invert_permut_body) ) (((nat.S) ) (n))) := fun (n:(nat.nat) ) => ((((leibniz.sym_leibniz) ((((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((invert_permut_body) ) (((nat.S) ) (n)))) (fun (f:((nat.nat) ) -> (nat.nat) ) => fun (m:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) (((nat.S) ) (n))) (((((invert_permut) ) (n)) (f)) (m))) ((((nat.eqb) ) (m)) ((f) (((nat.S) ) (n)))))) ((eq_invert_permut_body_S) (n)).
Definition invert_permut_f : forall (f:((nat.nat) ) -> (nat.nat) ), forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((((nat.le) ) (m)) (n)) -> ((((injn) ) (f)) (n)) -> (((logic.eq) ((nat.nat) )) (((((invert_permut) ) (n)) (f)) ((f) (m)))) (m) := fun (f:((nat.nat) ) -> (nat.nat) ) => fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => fun (lenm:(((nat.le) ) (m)) (n)) => (((((((nat.le_ind) (m)) (fun (x_417:(nat.nat) ) => ((((injn) ) (f)) (x_417)) -> (((logic.eq) ((nat.nat) )) (((((invert_permut) ) (x_417)) (f)) ((f) (m)))) (m))) (((((nat.match_nat_prop) (fun (__:(nat.nat) ) => ((((injn) ) (f)) (__)) -> (((logic.eq) ((nat.nat) )) (((((invert_permut) ) (__)) (f)) ((f) (__)))) (__))) ((((sym_eq_invert_permut) ((nat.O) )) (fun (y:(((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => ((((injn) ) (f)) ((nat.O) )) -> (((logic.eq) ((nat.nat) )) (((y) (f)) ((f) ((nat.O) )))) ((nat.O) ))) (((((nat.sym_eq_filter_nat_type_O) ((((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((invert_permut_body) )) (fun (y:(((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => ((((injn) ) (f)) ((nat.O) )) -> (((logic.eq) ((nat.nat) )) (((y) (f)) ((f) ((nat.O) )))) ((nat.O) ))) (((sym_eq_invert_permut_body_O) (fun (y:(((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => ((((injn) ) (f)) ((nat.O) )) -> (((logic.eq) ((nat.nat) )) (((y) (f)) ((f) ((nat.O) )))) ((nat.O) ))) (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.true) )) (fun (x:(bool.bool) ) => (forall (i:(nat.nat) ), forall (j:(nat.nat) ), ((((nat.le) ) (i)) ((nat.O) )) -> ((((nat.le) ) (j)) ((nat.O) )) -> ((((logic.eq) ((nat.nat) )) ((f) (i))) ((f) (j))) -> (((logic.eq) ((nat.nat) )) (i)) (j)) -> (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) ((nat.O) )) (x))) ((nat.O) ))) (fun (auto:forall (i:(nat.nat) ), forall (j:(nat.nat) ), ((((nat.le) ) (i)) ((nat.O) )) -> ((((nat.le) ) (j)) ((nat.O) )) -> ((((logic.eq) ((nat.nat) )) ((f) (i))) ((f) (j))) -> (((logic.eq) ((nat.nat) )) (i)) (j)) => ((((((bool.eq_match_bool_type_true) ((nat.nat) )) ((nat.O) )) ((nat.O) )) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) ((nat.O) )) ((bool.true) ))) (y))) (((logic.refl) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) ((nat.O) )) ((bool.true) )))))) ((((nat.eqb) ) ((f) ((nat.O) ))) ((f) ((nat.O) )))) ((nat.eqb_n_n) ((f) ((nat.O) )))))))) (fun (a:(nat.nat) ) => (((sym_eq_invert_permut) (((nat.S) ) (a))) (fun (y:(((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => ((((injn) ) (f)) (((nat.S) ) (a))) -> (((logic.eq) ((nat.nat) )) (((y) (f)) ((f) (((nat.S) ) (a))))) (((nat.S) ) (a)))) ((((((nat.sym_eq_filter_nat_type_S) ((((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((invert_permut_body) )) (a)) (fun (y:(((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => ((((injn) ) (f)) (((nat.S) ) (a))) -> (((logic.eq) ((nat.nat) )) (((y) (f)) ((f) (((nat.S) ) (a))))) (((nat.S) ) (a)))) ((((sym_eq_invert_permut_body_S) (a)) (fun (y:(((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => ((((injn) ) (f)) (((nat.S) ) (a))) -> (((logic.eq) ((nat.nat) )) (((y) (f)) ((f) (((nat.S) ) (a))))) (((nat.S) ) (a)))) (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.true) )) (fun (x:(bool.bool) ) => (forall (i:(nat.nat) ), forall (j:(nat.nat) ), ((((nat.le) ) (i)) (((nat.S) ) (a))) -> ((((nat.le) ) (j)) (((nat.S) ) (a))) -> ((((logic.eq) ((nat.nat) )) ((f) (i))) ((f) (j))) -> (((logic.eq) ((nat.nat) )) (i)) (j)) -> (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (((nat.S) ) (a))) (((((invert_permut) ) (a)) (f)) ((f) (((nat.S) ) (a))))) (x))) (((nat.S) ) (a)))) (fun (auto:forall (i:(nat.nat) ), forall (j:(nat.nat) ), ((((nat.le) ) (i)) (((nat.S) ) (a))) -> ((((nat.le) ) (j)) (((nat.S) ) (a))) -> ((((logic.eq) ((nat.nat) )) ((f) (i))) ((f) (j))) -> (((logic.eq) ((nat.nat) )) (i)) (j)) => ((((((bool.eq_match_bool_type_true) ((nat.nat) )) (((nat.S) ) (a))) (((((invert_permut) ) (a)) (f)) ((f) (((nat.S) ) (a))))) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (((nat.S) ) (a))) (((((invert_permut) ) (a)) (f)) ((f) (((nat.S) ) (a))))) ((bool.true) ))) (y))) (((logic.refl) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (((nat.S) ) (a))) (((((invert_permut) ) (a)) (f)) ((f) (((nat.S) ) (a))))) ((bool.true) )))))) ((((nat.eqb) ) ((f) (((nat.S) ) (a)))) ((f) (((nat.S) ) (a))))) ((nat.eqb_n_n) ((f) (((nat.S) ) (a))))))))) (m))) (fun (m0:(nat.nat) ) => (((sym_eq_invert_permut) (((nat.S) ) (m0))) (fun (y:(((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) (m)) (m0)) -> (((((injn) ) (f)) (m0)) -> (((logic.eq) ((nat.nat) )) (((((invert_permut) ) (m0)) (f)) ((f) (m)))) (m)) -> ((((injn) ) (f)) (((nat.S) ) (m0))) -> (((logic.eq) ((nat.nat) )) (((y) (f)) ((f) (m)))) (m))) ((((((nat.sym_eq_filter_nat_type_S) ((((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((invert_permut_body) )) (m0)) (fun (y:(((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) (m)) (m0)) -> (((((injn) ) (f)) (m0)) -> (((logic.eq) ((nat.nat) )) (((((invert_permut) ) (m0)) (f)) ((f) (m)))) (m)) -> ((((injn) ) (f)) (((nat.S) ) (m0))) -> (((logic.eq) ((nat.nat) )) (((y) (f)) ((f) (m)))) (m))) ((((sym_eq_invert_permut_body_S) (m0)) (fun (y:(((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) (m)) (m0)) -> (((((injn) ) (f)) (m0)) -> (((logic.eq) ((nat.nat) )) (((((invert_permut) ) (m0)) (f)) ((f) (m)))) (m)) -> ((((injn) ) (f)) (((nat.S) ) (m0))) -> (((logic.eq) ((nat.nat) )) (((y) (f)) ((f) (m)))) (m))) (fun (lem:(((nat.le) ) (m)) (m0)) => (fun (H:((((injn) ) (f)) (m0)) -> (((logic.eq) ((nat.nat) )) (((((invert_permut) ) (m0)) (f)) ((f) (m)))) (m)) => (fun (H1:(((injn) ) (f)) (((nat.S) ) (m0))) => (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.false) )) (fun (x:(bool.bool) ) => (((logic.eq) ((nat.nat) )) (((((bool.match_bool_type) ((nat.nat) )) (((nat.S) ) (m0))) (((((invert_permut) ) (m0)) (f)) ((f) (m)))) (x))) (m))) ((((((bool.sym_eq_match_bool_type_false) ((nat.nat) )) (((nat.S) ) (m0))) (((((invert_permut) ) (m0)) (f)) ((f) (m)))) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (y)) (m))) ((H) ((((injn_Sn_n) (f)) (m0)) (H1))))) ((((nat.eqb) ) ((f) (m))) ((f) (((nat.S) ) (m0))))) ((((nat.not_eq_to_eqb_false) ((f) (m))) ((f) (((nat.S) ) (m0)))) (((connectives.nmk) ((((logic.eq) ((nat.nat) )) ((f) (m))) ((f) (((nat.S) ) (m0))))) (fun (eqf:(((logic.eq) ((nat.nat) )) ((f) (m))) ((f) (((nat.S) ) (m0)))) => ((((logic.absurd) ((((logic.eq) ((nat.nat) )) (m)) (((nat.S) ) (m0)))) ((((((H1) (m)) (((nat.S) ) (m0))) ((((nat.le_S) (m)) (m0)) (lem))) ((nat.le_n) (((nat.S) ) (m0)))) (((((((logic.rewrite_l) ((nat.nat) )) ((f) (m))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((f) (m))) (__))) (((logic.refl) ((nat.nat) )) ((f) (m)))) ((f) (((nat.S) ) (m0)))) (eqf)))) ((((nat.lt_to_not_eq) (m)) (((nat.S) ) (m0))) ((((nat.le_S_S) (m)) (m0)) (lem))))))))))))))) (n)) (lenm)).
Definition let_clause_1063 : forall (f:((nat.nat) ) -> (nat.nat) ), forall (n:(nat.nat) ), ((((permut) ) (f)) (n)) -> forall (i:(nat.nat) ), forall (j:(nat.nat) ), ((((nat.le) ) (i)) (n)) -> ((((nat.le) ) (j)) (n)) -> forall (a:(nat.nat) ), ((((connectives.And) ) ((((nat.le) ) (a)) (n))) ((((logic.eq) ((nat.nat) )) ((f) (a))) (i))) -> ((((nat.le) ) (a)) (n)) -> ((((logic.eq) ((nat.nat) )) ((f) (a))) (i)) -> forall (b:(nat.nat) ), ((((connectives.And) ) ((((nat.le) ) (b)) (n))) ((((logic.eq) ((nat.nat) )) ((f) (b))) (j))) -> ((((nat.le) ) (b)) (n)) -> ((((logic.eq) ((nat.nat) )) ((f) (b))) (j)) -> (forall (i0:(nat.nat) ), ((((nat.le) ) (i0)) (n)) -> (((nat.le) ) ((f) (i0))) (n)) -> ((((injn) ) (f)) (n)) -> ((((logic.eq) ((nat.nat) )) (a)) (b)) -> (((logic.eq) ((nat.nat) )) ((f) (a))) (j) := fun (f:((nat.nat) ) -> (nat.nat) ) => fun (n:(nat.nat) ) => fun (permf:(((permut) ) (f)) (n)) => (fun (i:(nat.nat) ) => fun (j:(nat.nat) ) => fun (lein:(((nat.le) ) (i)) (n)) => (fun (lejn:(((nat.le) ) (j)) (n)) => (fun (a:(nat.nat) ) => fun (_clearme:(((connectives.And) ) ((((nat.le) ) (a)) (n))) ((((logic.eq) ((nat.nat) )) ((f) (a))) (i))) => (fun (lean:(((nat.le) ) (a)) (n)) => (fun (fa:(((logic.eq) ((nat.nat) )) ((f) (a))) (i)) => (fun (b:(nat.nat) ) => fun (_clearme0:(((connectives.And) ) ((((nat.le) ) (b)) (n))) ((((logic.eq) ((nat.nat) )) ((f) (b))) (j))) => (fun (lebn:(((nat.le) ) (b)) (n)) => (fun (fb:(((logic.eq) ((nat.nat) )) ((f) (b))) (j)) => (fun (__:forall (i0:(nat.nat) ), ((((nat.le) ) (i0)) (n)) -> (((nat.le) ) ((f) (i0))) (n)) => (fun (injf:(((injn) ) (f)) (n)) => (fun (auto:(((logic.eq) ((nat.nat) )) (a)) (b)) => (((((((logic.rewrite_r) ((nat.nat) )) (b)) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((f) (__1))) (j))) (fb)) (a)) (auto))))))))))))).
Definition let_clause_1068 : forall (f:((nat.nat) ) -> (nat.nat) ), forall (n:(nat.nat) ), ((((permut) ) (f)) (n)) -> forall (i:(nat.nat) ), forall (j:(nat.nat) ), ((((nat.le) ) (i)) (n)) -> ((((nat.le) ) (j)) (n)) -> forall (a:(nat.nat) ), ((((connectives.And) ) ((((nat.le) ) (a)) (n))) ((((logic.eq) ((nat.nat) )) ((f) (a))) (i))) -> ((((nat.le) ) (a)) (n)) -> ((((logic.eq) ((nat.nat) )) ((f) (a))) (i)) -> forall (b:(nat.nat) ), ((((connectives.And) ) ((((nat.le) ) (b)) (n))) ((((logic.eq) ((nat.nat) )) ((f) (b))) (j))) -> ((((nat.le) ) (b)) (n)) -> ((((logic.eq) ((nat.nat) )) ((f) (b))) (j)) -> (forall (i0:(nat.nat) ), ((((nat.le) ) (i0)) (n)) -> (((nat.le) ) ((f) (i0))) (n)) -> ((((injn) ) (f)) (n)) -> ((((logic.eq) ((nat.nat) )) (a)) (b)) -> (((logic.eq) ((nat.nat) )) ((f) (a))) (i) := fun (f:((nat.nat) ) -> (nat.nat) ) => fun (n:(nat.nat) ) => fun (permf:(((permut) ) (f)) (n)) => (fun (i:(nat.nat) ) => fun (j:(nat.nat) ) => fun (lein:(((nat.le) ) (i)) (n)) => (fun (lejn:(((nat.le) ) (j)) (n)) => (fun (a:(nat.nat) ) => fun (_clearme:(((connectives.And) ) ((((nat.le) ) (a)) (n))) ((((logic.eq) ((nat.nat) )) ((f) (a))) (i))) => (fun (lean:(((nat.le) ) (a)) (n)) => (fun (fa:(((logic.eq) ((nat.nat) )) ((f) (a))) (i)) => (fun (b:(nat.nat) ) => fun (_clearme0:(((connectives.And) ) ((((nat.le) ) (b)) (n))) ((((logic.eq) ((nat.nat) )) ((f) (b))) (j))) => (fun (lebn:(((nat.le) ) (b)) (n)) => (fun (fb:(((logic.eq) ((nat.nat) )) ((f) (b))) (j)) => (fun (__:forall (i0:(nat.nat) ), ((((nat.le) ) (i0)) (n)) -> (((nat.le) ) ((f) (i0))) (n)) => (fun (injf:(((injn) ) (f)) (n)) => (fun (auto:(((logic.eq) ((nat.nat) )) (a)) (b)) => (((((((logic.rewrite_l) ((nat.nat) )) (j)) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((f) (a))) (__1))) (((((((((((((((((((let_clause_1063) (f)) (n)) (permf)) (i)) (j)) (lein)) (lejn)) (a)) (_clearme)) (lean)) (fa)) (b)) (_clearme0)) (lebn)) (fb)) (__)) (injf)) (auto))) (i)) (((((((logic.rewrite_l) ((nat.nat) )) ((f) (a))) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__1)) (i))) (fa)) (j)) (((((((((((((((((((let_clause_1063) (f)) (n)) (permf)) (i)) (j)) (lein)) (lejn)) (a)) (_clearme)) (lean)) (fa)) (b)) (_clearme0)) (lebn)) (fb)) (__)) (injf)) (auto))))))))))))))).
Definition injective_invert_permut : forall (f:((nat.nat) ) -> (nat.nat) ), forall (n:(nat.nat) ), ((((permut) ) (f)) (n)) -> (((injn) ) ((((invert_permut) ) (n)) (f))) (n) := fun (f:((nat.nat) ) -> (nat.nat) ) => fun (n:(nat.nat) ) => fun (permf:(((permut) ) (f)) (n)) => (fun (i:(nat.nat) ) => fun (j:(nat.nat) ) => fun (lein:(((nat.le) ) (i)) (n)) => (fun (lejn:(((nat.le) ) (j)) (n)) => ((((((connectives.match_ex_prop) ((nat.nat) )) (fun (p:(nat.nat) ) => (((connectives.And) ) ((((nat.le) ) (p)) (n))) ((((logic.eq) ((nat.nat) )) ((f) (p))) (i)))) (((((logic.eq) ((nat.nat) )) (((((invert_permut) ) (n)) (f)) (i))) (((((invert_permut) ) (n)) (f)) (j))) -> (((logic.eq) ((nat.nat) )) (i)) (j))) (fun (a:(nat.nat) ) => fun (_clearme:(((connectives.And) ) ((((nat.le) ) (a)) (n))) ((((logic.eq) ((nat.nat) )) ((f) (a))) (i))) => ((((((connectives.match_And_prop) ((((nat.le) ) (a)) (n))) ((((logic.eq) ((nat.nat) )) ((f) (a))) (i))) (((((logic.eq) ((nat.nat) )) (((((invert_permut) ) (n)) (f)) (i))) (((((invert_permut) ) (n)) (f)) (j))) -> (((logic.eq) ((nat.nat) )) (i)) (j))) (fun (lean:(((nat.le) ) (a)) (n)) => (fun (fa:(((logic.eq) ((nat.nat) )) ((f) (a))) (i)) => ((((((connectives.match_ex_prop) ((nat.nat) )) (fun (p:(nat.nat) ) => (((connectives.And) ) ((((nat.le) ) (p)) (n))) ((((logic.eq) ((nat.nat) )) ((f) (p))) (j)))) (((((logic.eq) ((nat.nat) )) (((((invert_permut) ) (n)) (f)) (i))) (((((invert_permut) ) (n)) (f)) (j))) -> (((logic.eq) ((nat.nat) )) (i)) (j))) (fun (b:(nat.nat) ) => fun (_clearme0:(((connectives.And) ) ((((nat.le) ) (b)) (n))) ((((logic.eq) ((nat.nat) )) ((f) (b))) (j))) => ((((((connectives.match_And_prop) ((((nat.le) ) (b)) (n))) ((((logic.eq) ((nat.nat) )) ((f) (b))) (j))) (((((logic.eq) ((nat.nat) )) (((((invert_permut) ) (n)) (f)) (i))) (((((invert_permut) ) (n)) (f)) (j))) -> (((logic.eq) ((nat.nat) )) (i)) (j))) (fun (lebn:(((nat.le) ) (b)) (n)) => (fun (fb:(((logic.eq) ((nat.nat) )) ((f) (b))) (j)) => ((((((connectives.match_And_prop) (forall (i1:(nat.nat) ), ((((nat.le) ) (i1)) (n)) -> (((nat.le) ) ((f) (i1))) (n))) ((((injn) ) (f)) (n))) (((((logic.eq) ((nat.nat) )) (((((invert_permut) ) (n)) (f)) (i))) (((((invert_permut) ) (n)) (f)) (j))) -> (((logic.eq) ((nat.nat) )) (i)) (j))) (fun (__:forall (i0:(nat.nat) ), ((((nat.le) ) (i0)) (n)) -> (((nat.le) ) ((f) (i0))) (n)) => (fun (injf:(((injn) ) (f)) (n)) => (((((((logic.eq_ind) ((nat.nat) )) ((f) (a))) (fun (x_1:(nat.nat) ) => ((((logic.eq) ((nat.nat) )) (((((invert_permut) ) (n)) (f)) (x_1))) (((((invert_permut) ) (n)) (f)) (j))) -> (((logic.eq) ((nat.nat) )) (x_1)) (j))) (((((((logic.eq_ind) ((nat.nat) )) ((f) (b))) (fun (x_1:(nat.nat) ) => ((((logic.eq) ((nat.nat) )) (((((invert_permut) ) (n)) (f)) ((f) (a)))) (((((invert_permut) ) (n)) (f)) (x_1))) -> (((logic.eq) ((nat.nat) )) ((f) (a))) (x_1))) (((((((logic.eq_ind_r) ((nat.nat) )) (a)) (fun (x:(nat.nat) ) => ((((logic.eq) ((nat.nat) )) (x)) (((((invert_permut) ) (n)) (f)) ((f) (b)))) -> (((logic.eq) ((nat.nat) )) ((f) (a))) ((f) (b)))) (((((((logic.eq_ind_r) ((nat.nat) )) (b)) (fun (x:(nat.nat) ) => ((((logic.eq) ((nat.nat) )) (a)) (x)) -> (((logic.eq) ((nat.nat) )) ((f) (a))) ((f) (b)))) (fun (auto:(((logic.eq) ((nat.nat) )) (a)) (b)) => (((((((logic.rewrite_r) ((nat.nat) )) (i)) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__1)) ((f) (b)))) (((((((logic.rewrite_l) ((nat.nat) )) (a)) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (i)) ((f) (__1)))) (((((((logic.rewrite_r) ((nat.nat) )) (i)) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (i)) (__1))) (((logic.refl) ((nat.nat) )) (i))) ((f) (a))) (((((((((((((((((((let_clause_1068) (f)) (n)) (permf)) (i)) (j)) (lein)) (lejn)) (a)) (_clearme)) (lean)) (fa)) (b)) (_clearme0)) (lebn)) (fb)) (__)) (injf)) (auto)))) (b)) (auto))) ((f) (a))) (((((((((((((((((((let_clause_1068) (f)) (n)) (permf)) (i)) (j)) (lein)) (lejn)) (a)) (_clearme)) (lean)) (fa)) (b)) (_clearme0)) (lebn)) (fb)) (__)) (injf)) (auto))))) (((((invert_permut) ) (n)) (f)) ((f) (b)))) ((((((invert_permut_f) (f)) (n)) (b)) (lebn)) (injf)))) (((((invert_permut) ) (n)) (f)) ((f) (a)))) ((((((invert_permut_f) (f)) (n)) (a)) (lean)) (injf)))) (j)) (fb))) (i)) (fa))))) (permf))))) (_clearme0)))) ((((((permut_to_bijn) (n)) (f)) (permf)) (j)) (lejn)))))) (_clearme)))) ((((((permut_to_bijn) (n)) (f)) (permf)) (i)) (lein))))).
Definition permut_invert_permut : forall (f:((nat.nat) ) -> (nat.nat) ), forall (n:(nat.nat) ), ((((permut) ) (f)) (n)) -> (((permut) ) ((((invert_permut) ) (n)) (f))) (n) := fun (f:((nat.nat) ) -> (nat.nat) ) => fun (n:(nat.nat) ) => fun (permf:(((permut) ) (f)) (n)) => (((((connectives.conj) (forall (x:(nat.nat) ), ((((nat.le) ) (x)) (n)) -> (((nat.le) ) (((((invert_permut) ) (n)) (f)) (x))) (n))) ((((injn) ) ((((invert_permut) ) (n)) (f))) (n))) (fun (i:(nat.nat) ) => fun (lein:(((nat.le) ) (i)) (n)) => (((((nat.nat_ind) (fun (_x_365:(nat.nat) ) => (((nat.le) ) (((((invert_permut) ) (_x_365)) (f)) (i))) (_x_365))) ((((sym_eq_invert_permut) ((nat.O) )) (fun (y:(((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => (((nat.le) ) (((y) (f)) (i))) ((nat.O) ))) (((((nat.sym_eq_filter_nat_type_O) ((((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((invert_permut_body) )) (fun (y:(((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => (((nat.le) ) (((y) (f)) (i))) ((nat.O) ))) (((sym_eq_invert_permut_body_O) (fun (y:(((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => (((nat.le) ) (((y) (f)) (i))) ((nat.O) ))) (((((bool.match_bool_prop) (fun (__:(bool.bool) ) => (((nat.le) ) (((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) ((nat.O) )) (__))) ((nat.O) ))) ((((((bool.eq_match_bool_type_true) ((nat.nat) )) ((nat.O) )) ((nat.O) )) (fun (y:(nat.nat) ) => (((nat.le) ) (((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) ((nat.O) )) ((bool.true) ))) (y))) ((nat.le_n) (((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) ((nat.O) )) ((bool.true) ))))) ((((((bool.eq_match_bool_type_false) ((nat.nat) )) ((nat.O) )) ((nat.O) )) (fun (y:(nat.nat) ) => (((nat.le) ) (((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) ((nat.O) )) ((bool.false) ))) (y))) ((nat.le_n) (((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) ((nat.O) )) ((bool.false) ))))) ((((nat.eqb) ) (i)) ((f) ((nat.O) )))))))) (fun (n1:(nat.nat) ) => (((sym_eq_invert_permut) (((nat.S) ) (n1))) (fun (y:(((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) (((((invert_permut) ) (n1)) (f)) (i))) (n1)) -> (((nat.le) ) (((y) (f)) (i))) (((nat.S) ) (n1)))) ((((((nat.sym_eq_filter_nat_type_S) ((((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((invert_permut_body) )) (n1)) (fun (y:(((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) (((((invert_permut) ) (n1)) (f)) (i))) (n1)) -> (((nat.le) ) (((y) (f)) (i))) (((nat.S) ) (n1)))) ((((sym_eq_invert_permut_body_S) (n1)) (fun (y:(((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) (((((invert_permut) ) (n1)) (f)) (i))) (n1)) -> (((nat.le) ) (((y) (f)) (i))) (((nat.S) ) (n1)))) (fun (Hind:(((nat.le) ) (((((invert_permut) ) (n1)) (f)) (i))) (n1)) => (((((bool.match_bool_prop) (fun (__:(bool.bool) ) => (((nat.le) ) (((((bool.match_bool_type) ((nat.nat) )) (((nat.S) ) (n1))) (((((invert_permut) ) (n1)) (f)) (i))) (__))) (((nat.S) ) (n1)))) ((((((bool.eq_match_bool_type_true) ((nat.nat) )) (((nat.S) ) (n1))) (((((invert_permut) ) (n1)) (f)) (i))) (fun (y:(nat.nat) ) => (((nat.le) ) (((((bool.match_bool_type) ((nat.nat) )) (((nat.S) ) (n1))) (((((invert_permut) ) (n1)) (f)) (i))) ((bool.true) ))) (y))) ((nat.le_n) (((((bool.match_bool_type) ((nat.nat) )) (((nat.S) ) (n1))) (((((invert_permut) ) (n1)) (f)) (i))) ((bool.true) ))))) ((((((bool.sym_eq_match_bool_type_false) ((nat.nat) )) (((nat.S) ) (n1))) (((((invert_permut) ) (n1)) (f)) (i))) (fun (y:(nat.nat) ) => (((nat.le) ) (y)) (((nat.S) ) (n1)))) ((((nat.le_S) (((((invert_permut) ) (n1)) (f)) (i))) (n1)) (Hind)))) ((((nat.eqb) ) (i)) ((f) (((nat.S) ) (n1)))))))))) (n)))) ((((injective_invert_permut) (f)) (n)) (permf))).
Definition f_invert_permut : forall (f:((nat.nat) ) -> (nat.nat) ), forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((((nat.le) ) (m)) (n)) -> ((((permut) ) (f)) (n)) -> (((logic.eq) ((nat.nat) )) ((f) (((((invert_permut) ) (n)) (f)) (m)))) (m) := fun (f:((nat.nat) ) -> (nat.nat) ) => fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => fun (lemn:(((nat.le) ) (m)) (n)) => (fun (permf:(((permut) ) (f)) (n)) => ((((((connectives.match_And_prop) (forall (i:(nat.nat) ), ((((nat.le) ) (i)) (n)) -> (((nat.le) ) (((((invert_permut) ) (n)) (f)) (i))) (n))) ((((injn) ) ((((invert_permut) ) (n)) (f))) (n))) ((((logic.eq) ((nat.nat) )) ((f) (((((invert_permut) ) (n)) (f)) (m)))) (m))) (fun (Hle:forall (i:(nat.nat) ), ((((nat.le) ) (i)) (n)) -> (((nat.le) ) (((((invert_permut) ) (n)) (f)) (i))) (n)) => (fun (Hinj:(((injn) ) ((((invert_permut) ) (n)) (f))) (n)) => ((((((connectives.match_And_prop) (forall (i:(nat.nat) ), ((((nat.le) ) (i)) (n)) -> (((nat.le) ) ((f) (i))) (n))) ((((injn) ) (f)) (n))) ((((logic.eq) ((nat.nat) )) ((f) (((((invert_permut) ) (n)) (f)) (m)))) (m))) (fun (lef:forall (i:(nat.nat) ), ((((nat.le) ) (i)) (n)) -> (((nat.le) ) ((f) (i))) (n)) => (fun (injf:(((injn) ) (f)) (n)) => (((((((((injective_invert_permut) (f)) (n)) (permf)) ((f) (((((invert_permut) ) (n)) (f)) (m)))) (m)) (((lef) (((((invert_permut) ) (n)) (f)) (m))) (((Hle) (m)) (lemn)))) (lemn)) ((((((invert_permut_f) (f)) (n)) (((((invert_permut) ) (n)) (f)) (m))) (((Hle) (m)) (lemn))) (injf)))))) (permf))))) ((((permut_invert_permut) (f)) (n)) (permf)))).
