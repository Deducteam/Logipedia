Require Import bool.
Require Import connectives.
Require Import leibniz.
Require Import logic.
Require Import relations.
Parameter nat : Type.
Parameter O : (nat) .
Parameter S : ((nat) ) -> (nat) .
Axiom match_nat_prop : forall (return_:((nat) ) -> Prop), ((return_) ((O) )) -> (forall (n:(nat) ), (return_) (((S) ) (n))) -> forall (z:(nat) ), (return_) (z).
Parameter match_nat_type : forall (return_:Type), (return_) -> (((nat) ) -> return_) -> ((nat) ) -> return_.
Axiom axiom_match_nat_type_O : forall return_type, forall (case_O:return_type), forall (case_S:((nat) ) -> return_type), (((connectives.equal) (return_type)) (((((match_nat_type) (return_type)) (case_O)) (case_S)) ((O) ))) (case_O).
Definition eq_match_nat_type_O : forall return_type, forall (case_O:return_type), forall (case_S:((nat) ) -> return_type), (((leibniz.leibniz) (return_type)) (((((match_nat_type) (return_type)) (case_O)) (case_S)) ((O) ))) (case_O) := fun (return_type:Type) => fun (case_O:return_type) => fun (case_S:((nat) ) -> return_type) => ((((connectives.equal_leibniz) (return_type)) (((((match_nat_type) (return_type)) (case_O)) (case_S)) ((O) ))) (case_O)) ((((axiom_match_nat_type_O) (return_type)) (case_O)) (case_S)).
Definition sym_eq_match_nat_type_O : forall return_type, forall (case_O:return_type), forall (case_S:((nat) ) -> return_type), (((leibniz.leibniz) (return_type)) (case_O)) (((((match_nat_type) (return_type)) (case_O)) (case_S)) ((O) )) := fun (return_type:Type) => fun (case_O:return_type) => fun (case_S:((nat) ) -> return_type) => ((((leibniz.sym_leibniz) (return_type)) (((((match_nat_type) (return_type)) (case_O)) (case_S)) ((O) ))) (case_O)) ((((eq_match_nat_type_O) (return_type)) (case_O)) (case_S)).
Axiom axiom_match_nat_type_S : forall return_type, forall (case_O:return_type), forall (case_S:((nat) ) -> return_type), forall (n:(nat) ), (((connectives.equal) (return_type)) (((((match_nat_type) (return_type)) (case_O)) (case_S)) (((S) ) (n)))) ((case_S) (n)).
Definition eq_match_nat_type_S : forall return_type, forall (case_O:return_type), forall (case_S:((nat) ) -> return_type), forall (n:(nat) ), (((leibniz.leibniz) (return_type)) (((((match_nat_type) (return_type)) (case_O)) (case_S)) (((S) ) (n)))) ((case_S) (n)) := fun (return_type:Type) => fun (case_O:return_type) => fun (case_S:((nat) ) -> return_type) => fun (n:(nat) ) => ((((connectives.equal_leibniz) (return_type)) (((((match_nat_type) (return_type)) (case_O)) (case_S)) (((S) ) (n)))) ((case_S) (n))) (((((axiom_match_nat_type_S) (return_type)) (case_O)) (case_S)) (n)).
Definition sym_eq_match_nat_type_S : forall return_type, forall (case_O:return_type), forall (case_S:((nat) ) -> return_type), forall (n:(nat) ), (((leibniz.leibniz) (return_type)) ((case_S) (n))) (((((match_nat_type) (return_type)) (case_O)) (case_S)) (((S) ) (n))) := fun (return_type:Type) => fun (case_O:return_type) => fun (case_S:((nat) ) -> return_type) => fun (n:(nat) ) => ((((leibniz.sym_leibniz) (return_type)) (((((match_nat_type) (return_type)) (case_O)) (case_S)) (((S) ) (n)))) ((case_S) (n))) (((((eq_match_nat_type_S) (return_type)) (case_O)) (case_S)) (n)).
Parameter filter_nat_type : forall (return_:Type), (((nat) ) -> return_) -> ((nat) ) -> return_.
Axiom axiom_filter_nat_type_O : forall return_type, forall (return_:((nat) ) -> return_type), (((connectives.equal) (return_type)) ((((filter_nat_type) (return_type)) (return_)) ((O) ))) ((return_) ((O) )).
Definition eq_filter_nat_type_O : forall return_type, forall (return_:((nat) ) -> return_type), (((leibniz.leibniz) (return_type)) ((((filter_nat_type) (return_type)) (return_)) ((O) ))) ((return_) ((O) )) := fun (return_type:Type) => fun (return_:((nat) ) -> return_type) => ((((connectives.equal_leibniz) (return_type)) ((((filter_nat_type) (return_type)) (return_)) ((O) ))) ((return_) ((O) ))) (((axiom_filter_nat_type_O) (return_type)) (return_)).
Definition sym_eq_filter_nat_type_O : forall return_type, forall (return_:((nat) ) -> return_type), (((leibniz.leibniz) (return_type)) ((return_) ((O) ))) ((((filter_nat_type) (return_type)) (return_)) ((O) )) := fun (return_type:Type) => fun (return_:((nat) ) -> return_type) => ((((leibniz.sym_leibniz) (return_type)) ((((filter_nat_type) (return_type)) (return_)) ((O) ))) ((return_) ((O) ))) (((eq_filter_nat_type_O) (return_type)) (return_)).
Axiom axiom_filter_nat_type_S : forall return_type, forall (return_:((nat) ) -> return_type), forall (n:(nat) ), (((connectives.equal) (return_type)) ((((filter_nat_type) (return_type)) (return_)) (((S) ) (n)))) ((return_) (((S) ) (n))).
Definition eq_filter_nat_type_S : forall return_type, forall (return_:((nat) ) -> return_type), forall (n:(nat) ), (((leibniz.leibniz) (return_type)) ((((filter_nat_type) (return_type)) (return_)) (((S) ) (n)))) ((return_) (((S) ) (n))) := fun (return_type:Type) => fun (return_:((nat) ) -> return_type) => fun (n:(nat) ) => ((((connectives.equal_leibniz) (return_type)) ((((filter_nat_type) (return_type)) (return_)) (((S) ) (n)))) ((return_) (((S) ) (n)))) ((((axiom_filter_nat_type_S) (return_type)) (return_)) (n)).
Definition sym_eq_filter_nat_type_S : forall return_type, forall (return_:((nat) ) -> return_type), forall (n:(nat) ), (((leibniz.leibniz) (return_type)) ((return_) (((S) ) (n)))) ((((filter_nat_type) (return_type)) (return_)) (((S) ) (n))) := fun (return_type:Type) => fun (return_:((nat) ) -> return_type) => fun (n:(nat) ) => ((((leibniz.sym_leibniz) (return_type)) ((((filter_nat_type) (return_type)) (return_)) (((S) ) (n)))) ((return_) (((S) ) (n)))) ((((eq_filter_nat_type_S) (return_type)) (return_)) (n)).
Axiom nat_ind : forall (Q:((nat) ) -> Prop), ((Q) ((O) )) -> (forall (x:(nat) ), ((Q) (x)) -> (Q) (((S) ) (x))) -> forall (x:(nat) ), (Q) (x).
Definition pred : ((nat) ) -> (nat)  := fun (n:(nat) ) => ((((match_nat_type) ((nat) )) ((O) )) (fun (p:(nat) ) => p)) (n).
Definition not_zero : ((nat) ) -> Prop := fun (n:(nat) ) => ((((match_nat_type) (Prop)) ((connectives.False) )) (fun (p:(nat) ) => (connectives.True) )) (n).
Parameter le : ((nat) ) -> ((nat) ) -> Prop.
Axiom le_n : forall (n:(nat) ), (((le) ) (n)) (n).
Axiom le_S : forall (n:(nat) ), forall (m:(nat) ), ((((le) ) (n)) (m)) -> (((le) ) (n)) (((S) ) (m)).
Axiom match_le_prop : forall (n:(nat) ), forall (return_:((nat) ) -> Prop), ((return_) (n)) -> (forall (m:(nat) ), (return_) (((S) ) (m))) -> forall (m:(nat) ), ((((le) ) (n)) (m)) -> (return_) (m).
Axiom le_ind : forall (n:(nat) ), forall (Q:((nat) ) -> Prop), ((Q) (n)) -> (forall (m:(nat) ), ((((le) ) (n)) (m)) -> ((Q) (m)) -> (Q) (((S) ) (m))) -> forall (m:(nat) ), ((((le) ) (n)) (m)) -> (Q) (m).
Definition lt : ((nat) ) -> ((nat) ) -> Prop := fun (n:(nat) ) => fun (m:(nat) ) => (((le) ) (((S) ) (n))) (m).
Parameter plus : ((nat) ) -> ((nat) ) -> (nat) .
Parameter plus_body : ((nat) ) -> ((nat) ) -> (nat) .
Axiom axiom_plus : forall (n:(nat) ), (((connectives.equal) (((nat) ) -> (nat) )) (((plus) ) (n))) ((((filter_nat_type) (((nat) ) -> (nat) )) ((plus_body) )) (n)).
Definition eq_plus : forall (n:(nat) ), (((leibniz.leibniz) (((nat) ) -> (nat) )) (((plus) ) (n))) ((((filter_nat_type) (((nat) ) -> (nat) )) ((plus_body) )) (n)) := fun (n:(nat) ) => ((((connectives.equal_leibniz) (((nat) ) -> (nat) )) (((plus) ) (n))) ((((filter_nat_type) (((nat) ) -> (nat) )) ((plus_body) )) (n))) ((axiom_plus) (n)).
Definition sym_eq_plus : forall (n:(nat) ), (((leibniz.leibniz) (((nat) ) -> (nat) )) ((((filter_nat_type) (((nat) ) -> (nat) )) ((plus_body) )) (n))) (((plus) ) (n)) := fun (n:(nat) ) => ((((leibniz.sym_leibniz) (((nat) ) -> (nat) )) (((plus) ) (n))) ((((filter_nat_type) (((nat) ) -> (nat) )) ((plus_body) )) (n))) ((eq_plus) (n)).
Axiom axiom_plus_body_O : (((connectives.equal) (((nat) ) -> (nat) )) (((plus_body) ) ((O) ))) (fun (m:(nat) ) => m).
Definition eq_plus_body_O : (((leibniz.leibniz) (((nat) ) -> (nat) )) (((plus_body) ) ((O) ))) (fun (m:(nat) ) => m) := ((((connectives.equal_leibniz) (((nat) ) -> (nat) )) (((plus_body) ) ((O) ))) (fun (m:(nat) ) => m)) (axiom_plus_body_O).
Definition sym_eq_plus_body_O : (((leibniz.leibniz) (((nat) ) -> (nat) )) (fun (m:(nat) ) => m)) (((plus_body) ) ((O) )) := ((((leibniz.sym_leibniz) (((nat) ) -> (nat) )) (((plus_body) ) ((O) ))) (fun (m:(nat) ) => m)) (eq_plus_body_O).
Axiom axiom_plus_body_S : forall (n:(nat) ), (((connectives.equal) (((nat) ) -> (nat) )) (((plus_body) ) (((S) ) (n)))) (fun (m:(nat) ) => ((S) ) ((((plus) ) (n)) (m))).
Definition eq_plus_body_S : forall (n:(nat) ), (((leibniz.leibniz) (((nat) ) -> (nat) )) (((plus_body) ) (((S) ) (n)))) (fun (m:(nat) ) => ((S) ) ((((plus) ) (n)) (m))) := fun (n:(nat) ) => ((((connectives.equal_leibniz) (((nat) ) -> (nat) )) (((plus_body) ) (((S) ) (n)))) (fun (m:(nat) ) => ((S) ) ((((plus) ) (n)) (m)))) ((axiom_plus_body_S) (n)).
Definition sym_eq_plus_body_S : forall (n:(nat) ), (((leibniz.leibniz) (((nat) ) -> (nat) )) (fun (m:(nat) ) => ((S) ) ((((plus) ) (n)) (m)))) (((plus_body) ) (((S) ) (n))) := fun (n:(nat) ) => ((((leibniz.sym_leibniz) (((nat) ) -> (nat) )) (((plus_body) ) (((S) ) (n)))) (fun (m:(nat) ) => ((S) ) ((((plus) ) (n)) (m)))) ((eq_plus_body_S) (n)).
Parameter times : ((nat) ) -> ((nat) ) -> (nat) .
Parameter times_body : ((nat) ) -> ((nat) ) -> (nat) .
Axiom axiom_times : forall (n:(nat) ), (((connectives.equal) (((nat) ) -> (nat) )) (((times) ) (n))) ((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) (n)).
Definition eq_times : forall (n:(nat) ), (((leibniz.leibniz) (((nat) ) -> (nat) )) (((times) ) (n))) ((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) (n)) := fun (n:(nat) ) => ((((connectives.equal_leibniz) (((nat) ) -> (nat) )) (((times) ) (n))) ((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) (n))) ((axiom_times) (n)).
Definition sym_eq_times : forall (n:(nat) ), (((leibniz.leibniz) (((nat) ) -> (nat) )) ((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) (n))) (((times) ) (n)) := fun (n:(nat) ) => ((((leibniz.sym_leibniz) (((nat) ) -> (nat) )) (((times) ) (n))) ((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) (n))) ((eq_times) (n)).
Axiom axiom_times_body_O : (((connectives.equal) (((nat) ) -> (nat) )) (((times_body) ) ((O) ))) (fun (m:(nat) ) => (O) ).
Definition eq_times_body_O : (((leibniz.leibniz) (((nat) ) -> (nat) )) (((times_body) ) ((O) ))) (fun (m:(nat) ) => (O) ) := ((((connectives.equal_leibniz) (((nat) ) -> (nat) )) (((times_body) ) ((O) ))) (fun (m:(nat) ) => (O) )) (axiom_times_body_O).
Definition sym_eq_times_body_O : (((leibniz.leibniz) (((nat) ) -> (nat) )) (fun (m:(nat) ) => (O) )) (((times_body) ) ((O) )) := ((((leibniz.sym_leibniz) (((nat) ) -> (nat) )) (((times_body) ) ((O) ))) (fun (m:(nat) ) => (O) )) (eq_times_body_O).
Axiom axiom_times_body_S : forall (n:(nat) ), (((connectives.equal) (((nat) ) -> (nat) )) (((times_body) ) (((S) ) (n)))) (fun (m:(nat) ) => (((plus) ) (m)) ((((times) ) (n)) (m))).
Definition eq_times_body_S : forall (n:(nat) ), (((leibniz.leibniz) (((nat) ) -> (nat) )) (((times_body) ) (((S) ) (n)))) (fun (m:(nat) ) => (((plus) ) (m)) ((((times) ) (n)) (m))) := fun (n:(nat) ) => ((((connectives.equal_leibniz) (((nat) ) -> (nat) )) (((times_body) ) (((S) ) (n)))) (fun (m:(nat) ) => (((plus) ) (m)) ((((times) ) (n)) (m)))) ((axiom_times_body_S) (n)).
Definition sym_eq_times_body_S : forall (n:(nat) ), (((leibniz.leibniz) (((nat) ) -> (nat) )) (fun (m:(nat) ) => (((plus) ) (m)) ((((times) ) (n)) (m)))) (((times_body) ) (((S) ) (n))) := fun (n:(nat) ) => ((((leibniz.sym_leibniz) (((nat) ) -> (nat) )) (((times_body) ) (((S) ) (n)))) (fun (m:(nat) ) => (((plus) ) (m)) ((((times) ) (n)) (m)))) ((eq_times_body_S) (n)).
Parameter minus : ((nat) ) -> ((nat) ) -> (nat) .
Parameter minus_body : ((nat) ) -> ((nat) ) -> (nat) .
Axiom axiom_minus : forall (n:(nat) ), (((connectives.equal) (((nat) ) -> (nat) )) (((minus) ) (n))) ((((filter_nat_type) (((nat) ) -> (nat) )) ((minus_body) )) (n)).
Definition eq_minus : forall (n:(nat) ), (((leibniz.leibniz) (((nat) ) -> (nat) )) (((minus) ) (n))) ((((filter_nat_type) (((nat) ) -> (nat) )) ((minus_body) )) (n)) := fun (n:(nat) ) => ((((connectives.equal_leibniz) (((nat) ) -> (nat) )) (((minus) ) (n))) ((((filter_nat_type) (((nat) ) -> (nat) )) ((minus_body) )) (n))) ((axiom_minus) (n)).
Definition sym_eq_minus : forall (n:(nat) ), (((leibniz.leibniz) (((nat) ) -> (nat) )) ((((filter_nat_type) (((nat) ) -> (nat) )) ((minus_body) )) (n))) (((minus) ) (n)) := fun (n:(nat) ) => ((((leibniz.sym_leibniz) (((nat) ) -> (nat) )) (((minus) ) (n))) ((((filter_nat_type) (((nat) ) -> (nat) )) ((minus_body) )) (n))) ((eq_minus) (n)).
Axiom axiom_minus_body_O : (((connectives.equal) (((nat) ) -> (nat) )) (((minus_body) ) ((O) ))) (fun (m:(nat) ) => (O) ).
Definition eq_minus_body_O : (((leibniz.leibniz) (((nat) ) -> (nat) )) (((minus_body) ) ((O) ))) (fun (m:(nat) ) => (O) ) := ((((connectives.equal_leibniz) (((nat) ) -> (nat) )) (((minus_body) ) ((O) ))) (fun (m:(nat) ) => (O) )) (axiom_minus_body_O).
Definition sym_eq_minus_body_O : (((leibniz.leibniz) (((nat) ) -> (nat) )) (fun (m:(nat) ) => (O) )) (((minus_body) ) ((O) )) := ((((leibniz.sym_leibniz) (((nat) ) -> (nat) )) (((minus_body) ) ((O) ))) (fun (m:(nat) ) => (O) )) (eq_minus_body_O).
Axiom axiom_minus_body_S : forall (n:(nat) ), (((connectives.equal) (((nat) ) -> (nat) )) (((minus_body) ) (((S) ) (n)))) (fun (m:(nat) ) => ((((match_nat_type) ((nat) )) (((S) ) (n))) (fun (q:(nat) ) => (((minus) ) (n)) (q))) (m)).
Definition eq_minus_body_S : forall (n:(nat) ), (((leibniz.leibniz) (((nat) ) -> (nat) )) (((minus_body) ) (((S) ) (n)))) (fun (m:(nat) ) => ((((match_nat_type) ((nat) )) (((S) ) (n))) (fun (q:(nat) ) => (((minus) ) (n)) (q))) (m)) := fun (n:(nat) ) => ((((connectives.equal_leibniz) (((nat) ) -> (nat) )) (((minus_body) ) (((S) ) (n)))) (fun (m:(nat) ) => ((((match_nat_type) ((nat) )) (((S) ) (n))) (fun (q:(nat) ) => (((minus) ) (n)) (q))) (m))) ((axiom_minus_body_S) (n)).
Definition sym_eq_minus_body_S : forall (n:(nat) ), (((leibniz.leibniz) (((nat) ) -> (nat) )) (fun (m:(nat) ) => ((((match_nat_type) ((nat) )) (((S) ) (n))) (fun (q:(nat) ) => (((minus) ) (n)) (q))) (m))) (((minus_body) ) (((S) ) (n))) := fun (n:(nat) ) => ((((leibniz.sym_leibniz) (((nat) ) -> (nat) )) (((minus_body) ) (((S) ) (n)))) (fun (m:(nat) ) => ((((match_nat_type) ((nat) )) (((S) ) (n))) (fun (q:(nat) ) => (((minus) ) (n)) (q))) (m))) ((eq_minus_body_S) (n)).
Definition nat_case : forall (n:(nat) ), forall (P:((nat) ) -> Prop), (((((logic.eq) ((nat) )) (n)) ((O) )) -> (P) ((O) )) -> (forall (m:(nat) ), ((((logic.eq) ((nat) )) (n)) (((S) ) (m))) -> (P) (((S) ) (m))) -> (P) (n) := fun (n:(nat) ) => fun (P:((nat) ) -> Prop) => ((((nat_ind) (fun (_x_365:(nat) ) => (((((logic.eq) ((nat) )) (_x_365)) ((O) )) -> (P) ((O) )) -> (forall (m:(nat) ), ((((logic.eq) ((nat) )) (_x_365)) (((S) ) (m))) -> (P) (((S) ) (m))) -> (P) (_x_365))) (fun (auto:((((logic.eq) ((nat) )) ((O) )) ((O) )) -> (P) ((O) )) => (fun (auto':forall (m:(nat) ), ((((logic.eq) ((nat) )) ((O) )) (((S) ) (m))) -> (P) (((S) ) (m))) => ((auto) (((logic.refl) ((nat) )) ((O) )))))) (fun (x_366:(nat) ) => fun (_x_368:(((((logic.eq) ((nat) )) (x_366)) ((O) )) -> (P) ((O) )) -> (forall (m:(nat) ), ((((logic.eq) ((nat) )) (x_366)) (((S) ) (m))) -> (P) (((S) ) (m))) -> (P) (x_366)) => (fun (auto:((((logic.eq) ((nat) )) (((S) ) (x_366))) ((O) )) -> (P) ((O) )) => (fun (auto':forall (m:(nat) ), ((((logic.eq) ((nat) )) (((S) ) (x_366))) (((S) ) (m))) -> (P) (((S) ) (m))) => (((auto') (x_366)) (((logic.refl) ((nat) )) (((S) ) (x_366)))))))) (n).
Definition nat_elim2 : forall (R:((nat) ) -> ((nat) ) -> Prop), (forall (n:(nat) ), ((R) ((O) )) (n)) -> (forall (n:(nat) ), ((R) (((S) ) (n))) ((O) )) -> (forall (n:(nat) ), forall (m:(nat) ), (((R) (n)) (m)) -> ((R) (((S) ) (n))) (((S) ) (m))) -> forall (n:(nat) ), forall (m:(nat) ), ((R) (n)) (m) := fun (R:((nat) ) -> ((nat) ) -> Prop) => fun (ROn:forall (n:(nat) ), ((R) ((O) )) (n)) => (fun (RSO:forall (n:(nat) ), ((R) (((S) ) (n))) ((O) )) => (fun (RSS:forall (n:(nat) ), forall (m:(nat) ), (((R) (n)) (m)) -> ((R) (((S) ) (n))) (((S) ) (m))) => (fun (n:(nat) ) => ((((nat_ind) (fun (_x_365:(nat) ) => forall (m:(nat) ), ((R) (_x_365)) (m))) (fun (m:(nat) ) => (ROn) (m))) (fun (n0:(nat) ) => fun (Rn0m:forall (m:(nat) ), ((R) (n0)) (m)) => (fun (m:(nat) ) => ((((match_nat_prop) (fun (__:(nat) ) => ((R) (((S) ) (n0))) (__))) ((RSO) (n0))) (fun (auto:(nat) ) => (((RSS) (n0)) (auto)) ((Rn0m) (auto)))) (m)))) (n)))).
Definition le_gen : forall (P:((nat) ) -> Prop), forall (n:(nat) ), (forall (i:(nat) ), ((((le) ) (i)) (n)) -> (P) (i)) -> (P) (n) := fun (P:((nat) ) -> Prop) => fun (n:(nat) ) => fun (auto:forall (i:(nat) ), ((((le) ) (i)) (n)) -> (P) (i)) => (((auto) (n)) ((le_n) (n))).
Definition pred_Sn : forall (n:(nat) ), (((logic.eq) ((nat) )) (n)) (((pred) ) (((S) ) (n))) := fun (n:(nat) ) => ((((((sym_eq_match_nat_type_S) ((nat) )) ((O) )) (fun (p:(nat) ) => p)) (n)) (fun (y:(nat) ) => (((logic.eq) ((nat) )) (n)) (y))) (((logic.refl) ((nat) )) (n)).
Definition injective_S : ((relations.injective) ((nat) ) ((nat) )) ((S) ) := fun (x:(nat) ) => fun (y:(nat) ) => fun (auto:(((logic.eq) ((nat) )) (((S) ) (x))) (((S) ) (y))) => (((((((logic.rewrite_l) ((nat) )) (y)) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (__)) (y))) (((logic.refl) ((nat) )) (y))) (x)) (((((((logic.rewrite_r) ((nat) )) (((pred) ) (((S) ) (x)))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (y)) (__))) (((((((logic.rewrite_r) ((nat) )) (((S) ) (y))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (y)) (((pred) ) (__)))) ((pred_Sn) (y))) (((S) ) (x))) (auto))) (x)) ((pred_Sn) (x)))).
Definition S_pred : forall (n:(nat) ), ((((lt) ) ((O) )) (n)) -> (((logic.eq) ((nat) )) (((S) ) (((pred) ) (n)))) (n) := fun (n:(nat) ) => fun (posn:(((lt) ) ((O) )) (n)) => (((((((match_le_prop) (((S) ) ((O) ))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (((S) ) (((pred) ) (__)))) (__))) (((((((logic.rewrite_l) ((nat) )) ((O) )) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (((S) ) (__))) (((S) ) ((O) )))) (((logic.refl) ((nat) )) (((S) ) ((O) )))) (((pred) ) (((S) ) ((O) )))) ((pred_Sn) ((O) )))) (fun (m:(nat) ) => ((((((logic.rewrite_l) ((nat) )) (m)) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (((S) ) (__))) (((S) ) (m)))) (((logic.refl) ((nat) )) (((S) ) (m)))) (((pred) ) (((S) ) (m)))) ((pred_Sn) (m)))) (n)) (posn)).
Definition plus_O_n : forall (n:(nat) ), (((logic.eq) ((nat) )) (n)) ((((plus) ) ((O) )) (n)) := fun (n:(nat) ) => (((sym_eq_plus) ((O) )) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) (n)) ((y) (n)))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((plus_body) )) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) (n)) ((y) (n)))) (((sym_eq_plus_body_O) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) (n)) ((y) (n)))) (((logic.refl) ((nat) )) (n)))).
Definition plus_n_O : forall (n:(nat) ), (((logic.eq) ((nat) )) (n)) ((((plus) ) (n)) ((O) )) := fun (n:(nat) ) => ((((nat_ind) (fun (_x_365:(nat) ) => (((logic.eq) ((nat) )) (_x_365)) ((((plus) ) (_x_365)) ((O) )))) ((((sym_eq_plus) ((O) )) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((O) )) ((y) ((O) )))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((plus_body) )) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((O) )) ((y) ((O) )))) (((sym_eq_plus_body_O) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((O) )) ((y) ((O) )))) (((logic.refl) ((nat) )) ((O) )))))) (fun (x_366:(nat) ) => fun (_x_368:(((logic.eq) ((nat) )) (x_366)) ((((plus) ) (x_366)) ((O) ))) => ((((sym_eq_plus) (((S) ) (x_366))) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) (((S) ) (x_366))) ((y) ((O) )))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((plus_body) )) (x_366)) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) (((S) ) (x_366))) ((y) ((O) )))) ((((sym_eq_plus_body_S) (x_366)) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) (((S) ) (x_366))) ((y) ((O) )))) (((((((logic.rewrite_l) ((nat) )) (x_366)) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (((S) ) (x_366))) (((S) ) (__)))) (((logic.refl) ((nat) )) (((S) ) (x_366)))) ((((plus) ) (x_366)) ((O) ))) (_x_368))))))) (n).
Definition plus_n_Sm : forall (n:(nat) ), forall (m:(nat) ), (((logic.eq) ((nat) )) (((S) ) ((((plus) ) (n)) (m)))) ((((plus) ) (n)) (((S) ) (m))) := fun (n:(nat) ) => ((((nat_ind) (fun (_x_365:(nat) ) => forall (m:(nat) ), (((logic.eq) ((nat) )) (((S) ) ((((plus) ) (_x_365)) (m)))) ((((plus) ) (_x_365)) (((S) ) (m))))) (fun (m:(nat) ) => (((sym_eq_plus) ((O) )) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) (((S) ) ((y) (m)))) ((((plus) ) ((O) )) (((S) ) (m))))) ((((sym_eq_plus) ((O) )) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) (((S) ) (((((filter_nat_type) (((nat) ) -> (nat) )) ((plus_body) )) ((O) )) (m)))) ((y) (((S) ) (m))))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((plus_body) )) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) (((S) ) (((((filter_nat_type) (((nat) ) -> (nat) )) ((plus_body) )) ((O) )) (m)))) ((y) (((S) ) (m))))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((plus_body) )) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) (((S) ) ((y) (m)))) ((((plus_body) ) ((O) )) (((S) ) (m))))) (((sym_eq_plus_body_O) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) (((S) ) ((y) (m)))) ((((plus_body) ) ((O) )) (((S) ) (m))))) (((sym_eq_plus_body_O) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) (((S) ) (m))) ((y) (((S) ) (m))))) (((logic.refl) ((nat) )) (((S) ) (m)))))))))) (fun (x_366:(nat) ) => fun (_x_368:forall (m:(nat) ), (((logic.eq) ((nat) )) (((S) ) ((((plus) ) (x_366)) (m)))) ((((plus) ) (x_366)) (((S) ) (m)))) => (fun (m:(nat) ) => (((sym_eq_plus) (((S) ) (x_366))) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) (((S) ) ((y) (m)))) ((((plus) ) (((S) ) (x_366))) (((S) ) (m))))) ((((sym_eq_plus) (((S) ) (x_366))) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) (((S) ) (((((filter_nat_type) (((nat) ) -> (nat) )) ((plus_body) )) (((S) ) (x_366))) (m)))) ((y) (((S) ) (m))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((plus_body) )) (x_366)) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) (((S) ) (((((filter_nat_type) (((nat) ) -> (nat) )) ((plus_body) )) (((S) ) (x_366))) (m)))) ((y) (((S) ) (m))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((plus_body) )) (x_366)) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) (((S) ) ((y) (m)))) ((((plus_body) ) (((S) ) (x_366))) (((S) ) (m))))) ((((sym_eq_plus_body_S) (x_366)) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) (((S) ) ((y) (m)))) ((((plus_body) ) (((S) ) (x_366))) (((S) ) (m))))) ((((sym_eq_plus_body_S) (x_366)) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) (((S) ) (((S) ) ((((plus) ) (x_366)) (m))))) ((y) (((S) ) (m))))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (x_366)) (((S) ) (m)))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (((S) ) (__))) (((S) ) ((((plus) ) (x_366)) (((S) ) (m)))))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (x_366)) (((S) ) (((S) ) (m))))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (__)) (((S) ) ((((plus) ) (x_366)) (((S) ) (m)))))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (x_366)) (((S) ) (((S) ) (m))))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (x_366)) (((S) ) (((S) ) (m))))) (__))) (((logic.refl) ((nat) )) ((((plus) ) (x_366)) (((S) ) (((S) ) (m)))))) (((S) ) ((((plus) ) (x_366)) (((S) ) (m))))) ((_x_368) (((S) ) (m))))) (((S) ) ((((plus) ) (x_366)) (((S) ) (m))))) ((_x_368) (((S) ) (m))))) (((S) ) ((((plus) ) (x_366)) (m)))) ((_x_368) (m))))))))))) (n).
Definition commutative_plus : ((relations.commutative) ((nat) )) ((plus) ) := fun (n:(nat) ) => ((((nat_ind) (fun (_x_365:(nat) ) => forall (y:(nat) ), (((logic.eq) ((nat) )) ((((plus) ) (_x_365)) (y))) ((((plus) ) (y)) (_x_365)))) (fun (y:(nat) ) => (((sym_eq_plus) ((O) )) (fun (z:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((z) (y))) ((((plus) ) (y)) ((O) )))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((plus_body) )) (fun (z:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((z) (y))) ((((plus) ) (y)) ((O) )))) (((sym_eq_plus_body_O) (fun (z:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((z) (y))) ((((plus) ) (y)) ((O) )))) (((((((logic.rewrite_l) ((nat) )) (y)) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (y)) (__))) (((logic.refl) ((nat) )) (y))) ((((plus) ) (y)) ((O) ))) ((plus_n_O) (y))))))) (fun (x_366:(nat) ) => fun (_x_368:forall (y:(nat) ), (((logic.eq) ((nat) )) ((((plus) ) (x_366)) (y))) ((((plus) ) (y)) (x_366))) => (fun (y:(nat) ) => (((sym_eq_plus) (((S) ) (x_366))) (fun (z:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((z) (y))) ((((plus) ) (y)) (((S) ) (x_366))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((plus_body) )) (x_366)) (fun (z:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((z) (y))) ((((plus) ) (y)) (((S) ) (x_366))))) ((((sym_eq_plus_body_S) (x_366)) (fun (z:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((z) (y))) ((((plus) ) (y)) (((S) ) (x_366))))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (x_366)) (((S) ) (y)))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (__)) ((((plus) ) (y)) (((S) ) (x_366))))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (y)) (((S) ) (x_366)))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (__)) ((((plus) ) (y)) (((S) ) (x_366))))) (((logic.refl) ((nat) )) ((((plus) ) (y)) (((S) ) (x_366))))) ((((plus) ) (x_366)) (((S) ) (y)))) (((((((logic.rewrite_l) ((nat) )) (((S) ) ((((plus) ) (x_366)) (y)))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (__)) ((((plus) ) (y)) (((S) ) (x_366))))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (y)) (x_366))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (((S) ) (__))) ((((plus) ) (y)) (((S) ) (x_366))))) (((plus_n_Sm) (y)) (x_366))) ((((plus) ) (x_366)) (y))) ((_x_368) (y)))) ((((plus) ) (x_366)) (((S) ) (y)))) (((plus_n_Sm) (x_366)) (y))))) (((S) ) ((((plus) ) (x_366)) (y)))) (((plus_n_Sm) (x_366)) (y)))))))) (n).
Definition associative_plus : ((relations.associative) ((nat) )) ((plus) ) := fun (n:(nat) ) => ((((nat_ind) (fun (_x_365:(nat) ) => forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((((plus) ) ((((plus) ) (_x_365)) (y))) (z))) ((((plus) ) (_x_365)) ((((plus) ) (y)) (z))))) (fun (y:(nat) ) => fun (z:(nat) ) => (((sym_eq_plus) ((O) )) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((plus) ) ((((plus) ) ((O) )) (y))) (z))) ((x) ((((plus) ) (y)) (z))))) ((((sym_eq_plus) ((O) )) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((plus) ) ((x) (y))) (z))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((plus_body) )) ((O) )) ((((plus) ) (y)) (z))))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((plus_body) )) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((plus) ) ((x) (y))) (z))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((plus_body) )) ((O) )) ((((plus) ) (y)) (z))))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((plus_body) )) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((plus) ) ((((plus_body) ) ((O) )) (y))) (z))) ((x) ((((plus) ) (y)) (z))))) (((sym_eq_plus_body_O) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((plus) ) ((((plus_body) ) ((O) )) (y))) (z))) ((x) ((((plus) ) (y)) (z))))) (((sym_eq_plus_body_O) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((plus) ) ((x) (y))) (z))) ((((plus) ) (y)) (z)))) (((logic.refl) ((nat) )) ((((plus) ) (y)) (z)))))))))) (fun (x_366:(nat) ) => fun (_x_368:forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((((plus) ) ((((plus) ) (x_366)) (y))) (z))) ((((plus) ) (x_366)) ((((plus) ) (y)) (z)))) => (fun (y:(nat) ) => fun (z:(nat) ) => (((sym_eq_plus) (((S) ) (x_366))) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((plus) ) ((((plus) ) (((S) ) (x_366))) (y))) (z))) ((x) ((((plus) ) (y)) (z))))) ((((sym_eq_plus) (((S) ) (x_366))) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((plus) ) ((x) (y))) (z))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((plus_body) )) (((S) ) (x_366))) ((((plus) ) (y)) (z))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((plus_body) )) (x_366)) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((plus) ) ((x) (y))) (z))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((plus_body) )) (((S) ) (x_366))) ((((plus) ) (y)) (z))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((plus_body) )) (x_366)) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((plus) ) ((((plus_body) ) (((S) ) (x_366))) (y))) (z))) ((x) ((((plus) ) (y)) (z))))) ((((sym_eq_plus_body_S) (x_366)) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((plus) ) ((((plus_body) ) (((S) ) (x_366))) (y))) (z))) ((x) ((((plus) ) (y)) (z))))) ((((sym_eq_plus_body_S) (x_366)) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((plus) ) ((x) (y))) (z))) (((S) ) ((((plus) ) (x_366)) ((((plus) ) (y)) (z)))))) ((((sym_eq_plus) (((S) ) ((((plus) ) (x_366)) (y)))) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((x) (z))) (((S) ) ((((plus) ) (x_366)) ((((plus) ) (y)) (z)))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((plus_body) )) ((((plus) ) (x_366)) (y))) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((x) (z))) (((S) ) ((((plus) ) (x_366)) ((((plus) ) (y)) (z)))))) ((((sym_eq_plus_body_S) ((((plus) ) (x_366)) (y))) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((x) (z))) (((S) ) ((((plus) ) (x_366)) ((((plus) ) (y)) (z)))))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (x_366)) ((((plus) ) (y)) (z)))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (((S) ) (__))) (((S) ) ((((plus) ) (x_366)) ((((plus) ) (y)) (z)))))) (((logic.refl) ((nat) )) (((S) ) ((((plus) ) (x_366)) ((((plus) ) (y)) (z)))))) ((((plus) ) ((((plus) ) (x_366)) (y))) (z))) (((_x_368) (y)) (z)))))))))))))) (n).
Definition assoc_plus1 : forall (a:(nat) ), forall (b:(nat) ), forall (c:(nat) ), (((logic.eq) ((nat) )) ((((plus) ) (c)) ((((plus) ) (b)) (a)))) ((((plus) ) ((((plus) ) (b)) (c))) (a)) := fun (a:(nat) ) => fun (b:(nat) ) => fun (c:(nat) ) => ((((((logic.rewrite_r) ((nat) )) ((((plus) ) (a)) (b))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (c)) (__))) ((((plus) ) ((((plus) ) (b)) (c))) (a)))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (a)) ((((plus) ) (b)) (c)))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (c)) ((((plus) ) (a)) (b)))) (__))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (a)) ((((plus) ) (b)) (c)))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (__)) ((((plus) ) (a)) ((((plus) ) (b)) (c))))) (((logic.refl) ((nat) )) ((((plus) ) (a)) ((((plus) ) (b)) (c))))) ((((plus) ) (c)) ((((plus) ) (a)) (b)))) (((((((logic.rewrite_l) ((nat) )) ((((plus) ) ((((plus) ) (a)) (b))) (c))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (c)) ((((plus) ) (a)) (b)))) (__))) (((commutative_plus) (c)) ((((plus) ) (a)) (b)))) ((((plus) ) (a)) ((((plus) ) (b)) (c)))) ((((associative_plus) (a)) (b)) (c))))) ((((plus) ) ((((plus) ) (b)) (c))) (a))) (((commutative_plus) ((((plus) ) (b)) (c))) (a)))) ((((plus) ) (b)) (a))) (((commutative_plus) (b)) (a)).
Definition injective_plus_r : forall (n:(nat) ), ((relations.injective) ((nat) ) ((nat) )) (fun (m:(nat) ) => (((plus) ) (n)) (m)) := fun (n:(nat) ) => ((((nat_ind) (fun (_x_365:(nat) ) => ((relations.injective) ((nat) ) ((nat) )) (fun (m:(nat) ) => (((plus) ) (_x_365)) (m)))) ((((sym_eq_plus) ((O) )) (fun (y:((nat) ) -> (nat) ) => ((relations.injective) ((nat) ) ((nat) )) (fun (m:(nat) ) => (y) (m)))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((plus_body) )) (fun (y:((nat) ) -> (nat) ) => ((relations.injective) ((nat) ) ((nat) )) (fun (m:(nat) ) => (y) (m)))) (((sym_eq_plus_body_O) (fun (y:((nat) ) -> (nat) ) => ((relations.injective) ((nat) ) ((nat) )) (fun (m:(nat) ) => (y) (m)))) (fun (x:(nat) ) => fun (y:(nat) ) => fun (auto:(((logic.eq) ((nat) )) (x)) (y)) => (((((((logic.rewrite_l) ((nat) )) (x)) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (x)) (__))) (((logic.refl) ((nat) )) (x))) (y)) (auto))))))) (fun (x_366:(nat) ) => fun (_x_368:forall (x:(nat) ), forall (y:(nat) ), ((((logic.eq) ((nat) )) ((((plus) ) (x_366)) (x))) ((((plus) ) (x_366)) (y))) -> (((logic.eq) ((nat) )) (x)) (y)) => ((((sym_eq_plus) (((S) ) (x_366))) (fun (y:((nat) ) -> (nat) ) => ((relations.injective) ((nat) ) ((nat) )) (fun (m:(nat) ) => (y) (m)))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((plus_body) )) (x_366)) (fun (y:((nat) ) -> (nat) ) => ((relations.injective) ((nat) ) ((nat) )) (fun (m:(nat) ) => (y) (m)))) ((((sym_eq_plus_body_S) (x_366)) (fun (y:((nat) ) -> (nat) ) => ((relations.injective) ((nat) ) ((nat) )) (fun (m:(nat) ) => (y) (m)))) (fun (x:(nat) ) => fun (y:(nat) ) => fun (auto:(((logic.eq) ((nat) )) (((S) ) ((((plus) ) (x_366)) (x)))) (((S) ) ((((plus) ) (x_366)) (y)))) => ((((_x_368) (x)) (y)) ((((injective_S) ((((plus) ) (x_366)) (x))) ((((plus) ) (x_366)) (y))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (x_366)) (((S) ) (x)))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (__)) (((S) ) ((((plus) ) (x_366)) (y))))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (x_366)) (((S) ) (y)))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (x_366)) (((S) ) (x)))) (__))) (((((((logic.rewrite_l) ((nat) )) ((((plus) ) (x_366)) (((S) ) (x)))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (x_366)) (((S) ) (x)))) (__))) (((logic.refl) ((nat) )) ((((plus) ) (x_366)) (((S) ) (x))))) ((((plus) ) (x_366)) (((S) ) (y)))) (((((((logic.rewrite_l) ((nat) )) (((S) ) ((((plus) ) (x_366)) (y)))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (x_366)) (((S) ) (x)))) (__))) (((((((logic.rewrite_l) ((nat) )) (((S) ) ((((plus) ) (x_366)) (x)))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (__)) (((S) ) ((((plus) ) (x_366)) (y))))) (auto)) ((((plus) ) (x_366)) (((S) ) (x)))) (((plus_n_Sm) (x_366)) (x)))) ((((plus) ) (x_366)) (((S) ) (y)))) (((plus_n_Sm) (x_366)) (y))))) (((S) ) ((((plus) ) (x_366)) (y)))) (((plus_n_Sm) (x_366)) (y)))) (((S) ) ((((plus) ) (x_366)) (x)))) (((plus_n_Sm) (x_366)) (x))))))))))) (n).
Definition times_Sn_m : forall (n:(nat) ), forall (m:(nat) ), (((logic.eq) ((nat) )) ((((plus) ) (m)) ((((times) ) (n)) (m)))) ((((times) ) (((S) ) (n))) (m)) := fun (n:(nat) ) => fun (m:(nat) ) => (((sym_eq_times) (((S) ) (n))) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (m)) ((((times) ) (n)) (m)))) ((y) (m)))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((times_body) )) (n)) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (m)) ((((times) ) (n)) (m)))) ((y) (m)))) ((((sym_eq_times_body_S) (n)) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (m)) ((((times) ) (n)) (m)))) ((y) (m)))) (((logic.refl) ((nat) )) ((((plus) ) (m)) ((((times) ) (n)) (m)))))).
Definition times_O_n : forall (n:(nat) ), (((logic.eq) ((nat) )) ((O) )) ((((times) ) ((O) )) (n)) := fun (n:(nat) ) => (((sym_eq_times) ((O) )) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((O) )) ((y) (n)))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((times_body) )) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((O) )) ((y) (n)))) (((sym_eq_times_body_O) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((O) )) ((y) (n)))) (((logic.refl) ((nat) )) ((O) )))).
Definition times_n_O : forall (n:(nat) ), (((logic.eq) ((nat) )) ((O) )) ((((times) ) (n)) ((O) )) := fun (n:(nat) ) => ((((nat_ind) (fun (_x_365:(nat) ) => (((logic.eq) ((nat) )) ((O) )) ((((times) ) (_x_365)) ((O) )))) (((((((logic.rewrite_l) ((nat) )) ((O) )) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((O) )) (__))) (((logic.refl) ((nat) )) ((O) ))) ((((times) ) ((O) )) ((O) ))) ((times_O_n) ((O) )))) (fun (x_366:(nat) ) => fun (_x_368:(((logic.eq) ((nat) )) ((O) )) ((((times) ) (x_366)) ((O) ))) => (((((((logic.rewrite_l) ((nat) )) ((((plus) ) ((O) )) ((((times) ) (x_366)) ((O) )))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((O) )) (__))) (((((((logic.rewrite_l) ((nat) )) ((O) )) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((O) )) ((((plus) ) ((O) )) (__)))) (((((((logic.rewrite_l) ((nat) )) ((O) )) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((O) )) (__))) (((logic.refl) ((nat) )) ((O) ))) ((((plus) ) ((O) )) ((O) ))) ((plus_O_n) ((O) )))) ((((times) ) (x_366)) ((O) ))) (_x_368))) ((((times) ) (((S) ) (x_366))) ((O) ))) (((times_Sn_m) (x_366)) ((O) ))))) (n).
Definition times_n_Sm : forall (n:(nat) ), forall (m:(nat) ), (((logic.eq) ((nat) )) ((((plus) ) (n)) ((((times) ) (n)) (m)))) ((((times) ) (n)) (((S) ) (m))) := fun (n:(nat) ) => ((((nat_ind) (fun (_x_365:(nat) ) => forall (m:(nat) ), (((logic.eq) ((nat) )) ((((plus) ) (_x_365)) ((((times) ) (_x_365)) (m)))) ((((times) ) (_x_365)) (((S) ) (m))))) ((((sym_eq_times) ((O) )) (fun (y:((nat) ) -> (nat) ) => forall (m:(nat) ), (((logic.eq) ((nat) )) ((((plus) ) ((O) )) ((((times) ) ((O) )) (m)))) ((y) (((S) ) (m))))) ((((sym_eq_times) ((O) )) (fun (y:((nat) ) -> (nat) ) => forall (m:(nat) ), (((logic.eq) ((nat) )) ((((plus) ) ((O) )) ((y) (m)))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) ((O) )) (((S) ) (m))))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((times_body) )) (fun (y:((nat) ) -> (nat) ) => forall (m:(nat) ), (((logic.eq) ((nat) )) ((((plus) ) ((O) )) ((y) (m)))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) ((O) )) (((S) ) (m))))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((times_body) )) (fun (y:((nat) ) -> (nat) ) => forall (m:(nat) ), (((logic.eq) ((nat) )) ((((plus) ) ((O) )) ((((times_body) ) ((O) )) (m)))) ((y) (((S) ) (m))))) (((sym_eq_times_body_O) (fun (y:((nat) ) -> (nat) ) => forall (m:(nat) ), (((logic.eq) ((nat) )) ((((plus) ) ((O) )) ((((times_body) ) ((O) )) (m)))) ((y) (((S) ) (m))))) (((sym_eq_times_body_O) (fun (y:((nat) ) -> (nat) ) => forall (m:(nat) ), (((logic.eq) ((nat) )) ((((plus) ) ((O) )) ((y) (m)))) ((O) ))) ((((sym_eq_plus) ((O) )) (fun (y:((nat) ) -> (nat) ) => forall (m:(nat) ), (((logic.eq) ((nat) )) ((y) ((O) ))) ((O) ))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((plus_body) )) (fun (y:((nat) ) -> (nat) ) => forall (m:(nat) ), (((logic.eq) ((nat) )) ((y) ((O) ))) ((O) ))) (((sym_eq_plus_body_O) (fun (y:((nat) ) -> (nat) ) => forall (m:(nat) ), (((logic.eq) ((nat) )) ((y) ((O) ))) ((O) ))) (fun (_m:(nat) ) => ((logic.refl) ((nat) )) ((O) )))))))))))) (fun (x_366:(nat) ) => fun (_x_368:forall (m:(nat) ), (((logic.eq) ((nat) )) ((((plus) ) (x_366)) ((((times) ) (x_366)) (m)))) ((((times) ) (x_366)) (((S) ) (m)))) => (fun (m:(nat) ) => (((sym_eq_times) (((S) ) (x_366))) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (((S) ) (x_366))) ((((times) ) (((S) ) (x_366))) (m)))) ((y) (((S) ) (m))))) ((((sym_eq_times) (((S) ) (x_366))) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (((S) ) (x_366))) ((y) (m)))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) (((S) ) (x_366))) (((S) ) (m))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((times_body) )) (x_366)) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (((S) ) (x_366))) ((y) (m)))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) (((S) ) (x_366))) (((S) ) (m))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((times_body) )) (x_366)) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (((S) ) (x_366))) ((((times_body) ) (((S) ) (x_366))) (m)))) ((y) (((S) ) (m))))) ((((sym_eq_times_body_S) (x_366)) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (((S) ) (x_366))) ((((times_body) ) (((S) ) (x_366))) (m)))) ((y) (((S) ) (m))))) ((((sym_eq_times_body_S) (x_366)) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (((S) ) (x_366))) ((y) (m)))) ((((plus) ) (((S) ) (m))) ((((times) ) (x_366)) (((S) ) (m)))))) ((((sym_eq_plus) (((S) ) (x_366))) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((y) ((((plus) ) (m)) ((((times) ) (x_366)) (m))))) ((((plus) ) (((S) ) (m))) ((((times) ) (x_366)) (((S) ) (m)))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((plus_body) )) (x_366)) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((y) ((((plus) ) (m)) ((((times) ) (x_366)) (m))))) ((((plus) ) (((S) ) (m))) ((((times) ) (x_366)) (((S) ) (m)))))) ((((sym_eq_plus_body_S) (x_366)) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((y) ((((plus) ) (m)) ((((times) ) (x_366)) (m))))) ((((plus) ) (((S) ) (m))) ((((times) ) (x_366)) (((S) ) (m)))))) ((((sym_eq_plus) (((S) ) (m))) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) (((S) ) ((((plus) ) (x_366)) ((((plus) ) (m)) ((((times) ) (x_366)) (m)))))) ((y) ((((times) ) (x_366)) (((S) ) (m)))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((plus_body) )) (m)) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) (((S) ) ((((plus) ) (x_366)) ((((plus) ) (m)) ((((times) ) (x_366)) (m)))))) ((y) ((((times) ) (x_366)) (((S) ) (m)))))) ((((sym_eq_plus_body_S) (m)) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) (((S) ) ((((plus) ) (x_366)) ((((plus) ) (m)) ((((times) ) (x_366)) (m)))))) ((y) ((((times) ) (x_366)) (((S) ) (m)))))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (x_366)) (((S) ) ((((plus) ) (m)) ((((times) ) (x_366)) (m)))))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (__)) (((S) ) ((((plus) ) (m)) ((((times) ) (x_366)) (((S) ) (m))))))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (m)) (((S) ) ((((times) ) (x_366)) (m))))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (x_366)) (__))) (((S) ) ((((plus) ) (m)) ((((times) ) (x_366)) (((S) ) (m))))))) (((((((logic.rewrite_l) ((nat) )) ((((plus) ) (x_366)) ((((times) ) (x_366)) (m)))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (x_366)) ((((plus) ) (m)) (((S) ) ((((times) ) (x_366)) (m)))))) (((S) ) ((((plus) ) (m)) (__))))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (x_366)) ((((plus) ) (m)) ((((times) ) (x_366)) (m))))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (x_366)) ((((plus) ) (m)) (((S) ) ((((times) ) (x_366)) (m)))))) (((S) ) (__)))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (x_366)) (((S) ) ((((plus) ) (m)) ((((times) ) (x_366)) (m)))))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (x_366)) ((((plus) ) (m)) (((S) ) ((((times) ) (x_366)) (m)))))) (__))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (m)) (((S) ) ((((times) ) (x_366)) (m))))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (x_366)) ((((plus) ) (m)) (((S) ) ((((times) ) (x_366)) (m)))))) ((((plus) ) (x_366)) (__)))) (((logic.refl) ((nat) )) ((((plus) ) (x_366)) ((((plus) ) (m)) (((S) ) ((((times) ) (x_366)) (m))))))) (((S) ) ((((plus) ) (m)) ((((times) ) (x_366)) (m))))) (((plus_n_Sm) (m)) ((((times) ) (x_366)) (m))))) (((S) ) ((((plus) ) (x_366)) ((((plus) ) (m)) ((((times) ) (x_366)) (m)))))) (((plus_n_Sm) (x_366)) ((((plus) ) (m)) ((((times) ) (x_366)) (m)))))) ((((plus) ) (m)) ((((plus) ) (x_366)) ((((times) ) (x_366)) (m))))) (((((((logic.rewrite_l) ((nat) )) ((((plus) ) ((((plus) ) (x_366)) (m))) ((((times) ) (x_366)) (m)))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (m)) ((((plus) ) (x_366)) ((((times) ) (x_366)) (m))))) (__))) ((((assoc_plus1) ((((times) ) (x_366)) (m))) (x_366)) (m))) ((((plus) ) (x_366)) ((((plus) ) (m)) ((((times) ) (x_366)) (m))))) ((((associative_plus) (x_366)) (m)) ((((times) ) (x_366)) (m)))))) ((((times) ) (x_366)) (((S) ) (m)))) ((_x_368) (m)))) (((S) ) ((((plus) ) (m)) ((((times) ) (x_366)) (m))))) (((plus_n_Sm) (m)) ((((times) ) (x_366)) (m))))) (((S) ) ((((plus) ) (x_366)) ((((plus) ) (m)) ((((times) ) (x_366)) (m)))))) (((plus_n_Sm) (x_366)) ((((plus) ) (m)) ((((times) ) (x_366)) (m))))))))))))))))))) (n).
Definition commutative_times : ((relations.commutative) ((nat) )) ((times) ) := fun (n:(nat) ) => ((((nat_ind) (fun (_x_365:(nat) ) => forall (y:(nat) ), (((logic.eq) ((nat) )) ((((times) ) (_x_365)) (y))) ((((times) ) (y)) (_x_365)))) ((((sym_eq_times) ((O) )) (fun (y:((nat) ) -> (nat) ) => forall (z:(nat) ), (((logic.eq) ((nat) )) ((y) (z))) ((((times) ) (z)) ((O) )))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((times_body) )) (fun (y:((nat) ) -> (nat) ) => forall (z:(nat) ), (((logic.eq) ((nat) )) ((y) (z))) ((((times) ) (z)) ((O) )))) (((sym_eq_times_body_O) (fun (y:((nat) ) -> (nat) ) => forall (z:(nat) ), (((logic.eq) ((nat) )) ((y) (z))) ((((times) ) (z)) ((O) )))) (fun (y:(nat) ) => ((((((logic.rewrite_l) ((nat) )) ((O) )) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((O) )) (__))) (((logic.refl) ((nat) )) ((O) ))) ((((times) ) (y)) ((O) ))) ((times_n_O) (y))))))) (fun (x_366:(nat) ) => fun (_x_368:forall (y:(nat) ), (((logic.eq) ((nat) )) ((((times) ) (x_366)) (y))) ((((times) ) (y)) (x_366))) => (fun (y:(nat) ) => (((sym_eq_times) (((S) ) (x_366))) (fun (z:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((z) (y))) ((((times) ) (y)) (((S) ) (x_366))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((times_body) )) (x_366)) (fun (z:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((z) (y))) ((((times) ) (y)) (((S) ) (x_366))))) ((((sym_eq_times_body_S) (x_366)) (fun (z:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((z) (y))) ((((times) ) (y)) (((S) ) (x_366))))) (((((((logic.rewrite_l) ((nat) )) ((((plus) ) (y)) ((((times) ) (y)) (x_366)))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (y)) ((((times) ) (x_366)) (y)))) (__))) (((((((logic.rewrite_l) ((nat) )) ((((times) ) (x_366)) (y))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (y)) ((((times) ) (x_366)) (y)))) ((((plus) ) (y)) (__)))) (((logic.refl) ((nat) )) ((((plus) ) (y)) ((((times) ) (x_366)) (y))))) ((((times) ) (y)) (x_366))) ((_x_368) (y)))) ((((times) ) (y)) (((S) ) (x_366)))) (((times_n_Sm) (y)) (x_366)))))))) (n).
Definition distributive_times_plus : (((relations.distributive) ((nat) )) ((times) )) ((plus) ) := fun (n:(nat) ) => ((((nat_ind) (fun (_x_365:(nat) ) => forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((((times) ) (_x_365)) ((((plus) ) (y)) (z)))) ((((plus) ) ((((times) ) (_x_365)) (y))) ((((times) ) (_x_365)) (z))))) ((((sym_eq_times) ((O) )) (fun (x:((nat) ) -> (nat) ) => forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((((times) ) ((O) )) ((((plus) ) (y)) (z)))) ((((plus) ) ((((times) ) ((O) )) (y))) ((x) (z))))) ((((sym_eq_times) ((O) )) (fun (x:((nat) ) -> (nat) ) => forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((((times) ) ((O) )) ((((plus) ) (y)) (z)))) ((((plus) ) ((x) (y))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) ((O) )) (z))))) ((((sym_eq_times) ((O) )) (fun (x:((nat) ) -> (nat) ) => forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((x) ((((plus) ) (y)) (z)))) ((((plus) ) (((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) ((O) )) (y))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) ((O) )) (z))))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((times_body) )) (fun (x:((nat) ) -> (nat) ) => forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((x) ((((plus) ) (y)) (z)))) ((((plus) ) (((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) ((O) )) (y))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) ((O) )) (z))))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((times_body) )) (fun (x:((nat) ) -> (nat) ) => forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((((times_body) ) ((O) )) ((((plus) ) (y)) (z)))) ((((plus) ) ((x) (y))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) ((O) )) (z))))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((times_body) )) (fun (x:((nat) ) -> (nat) ) => forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((((times_body) ) ((O) )) ((((plus) ) (y)) (z)))) ((((plus) ) ((((times_body) ) ((O) )) (y))) ((x) (z))))) (((sym_eq_times_body_O) (fun (x:((nat) ) -> (nat) ) => forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((((times_body) ) ((O) )) ((((plus) ) (y)) (z)))) ((((plus) ) ((((times_body) ) ((O) )) (y))) ((x) (z))))) (((sym_eq_times_body_O) (fun (x:((nat) ) -> (nat) ) => forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((((times_body) ) ((O) )) ((((plus) ) (y)) (z)))) ((((plus) ) ((x) (y))) ((O) )))) (((sym_eq_times_body_O) (fun (x:((nat) ) -> (nat) ) => forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((x) ((((plus) ) (y)) (z)))) ((((plus) ) ((O) )) ((O) )))) ((((sym_eq_plus) ((O) )) (fun (x:((nat) ) -> (nat) ) => forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((O) )) ((x) ((O) )))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((plus_body) )) (fun (x:((nat) ) -> (nat) ) => forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((O) )) ((x) ((O) )))) (((sym_eq_plus_body_O) (fun (x:((nat) ) -> (nat) ) => forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((O) )) ((x) ((O) )))) (fun (_y:(nat) ) => fun (_z:(nat) ) => ((logic.refl) ((nat) )) ((O) ))))))))))))))) (fun (x_366:(nat) ) => fun (_x_368:forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((((times) ) (x_366)) ((((plus) ) (y)) (z)))) ((((plus) ) ((((times) ) (x_366)) (y))) ((((times) ) (x_366)) (z)))) => (fun (y:(nat) ) => fun (z:(nat) ) => (((sym_eq_times) (((S) ) (x_366))) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((times) ) (((S) ) (x_366))) ((((plus) ) (y)) (z)))) ((((plus) ) ((((times) ) (((S) ) (x_366))) (y))) ((x) (z))))) ((((sym_eq_times) (((S) ) (x_366))) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((times) ) (((S) ) (x_366))) ((((plus) ) (y)) (z)))) ((((plus) ) ((x) (y))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) (((S) ) (x_366))) (z))))) ((((sym_eq_times) (((S) ) (x_366))) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((x) ((((plus) ) (y)) (z)))) ((((plus) ) (((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) (((S) ) (x_366))) (y))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) (((S) ) (x_366))) (z))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((times_body) )) (x_366)) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((x) ((((plus) ) (y)) (z)))) ((((plus) ) (((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) (((S) ) (x_366))) (y))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) (((S) ) (x_366))) (z))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((times_body) )) (x_366)) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((times_body) ) (((S) ) (x_366))) ((((plus) ) (y)) (z)))) ((((plus) ) ((x) (y))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) (((S) ) (x_366))) (z))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((times_body) )) (x_366)) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((times_body) ) (((S) ) (x_366))) ((((plus) ) (y)) (z)))) ((((plus) ) ((((times_body) ) (((S) ) (x_366))) (y))) ((x) (z))))) ((((sym_eq_times_body_S) (x_366)) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((times_body) ) (((S) ) (x_366))) ((((plus) ) (y)) (z)))) ((((plus) ) ((((times_body) ) (((S) ) (x_366))) (y))) ((x) (z))))) ((((sym_eq_times_body_S) (x_366)) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((times_body) ) (((S) ) (x_366))) ((((plus) ) (y)) (z)))) ((((plus) ) ((x) (y))) ((((plus) ) (z)) ((((times) ) (x_366)) (z)))))) ((((sym_eq_times_body_S) (x_366)) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((x) ((((plus) ) (y)) (z)))) ((((plus) ) ((((plus) ) (y)) ((((times) ) (x_366)) (y)))) ((((plus) ) (z)) ((((times) ) (x_366)) (z)))))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (y)) ((((plus) ) (z)) ((((times) ) (x_366)) ((((plus) ) (y)) (z)))))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (__)) ((((plus) ) ((((plus) ) (y)) ((((times) ) (x_366)) (y)))) ((((plus) ) (z)) ((((times) ) (x_366)) (z)))))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (y)) ((((plus) ) ((((times) ) (x_366)) (y))) ((((plus) ) (z)) ((((times) ) (x_366)) (z)))))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (y)) ((((plus) ) (z)) ((((times) ) (x_366)) ((((plus) ) (y)) (z)))))) (__))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (z)) ((((plus) ) ((((times) ) (x_366)) (y))) ((((times) ) (x_366)) (z))))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (y)) ((((plus) ) (z)) ((((times) ) (x_366)) ((((plus) ) (y)) (z)))))) ((((plus) ) (y)) (__)))) (((((((logic.rewrite_l) ((nat) )) ((((times) ) (x_366)) ((((plus) ) (y)) (z)))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (y)) ((((plus) ) (z)) ((((times) ) (x_366)) ((((plus) ) (y)) (z)))))) ((((plus) ) (y)) ((((plus) ) (z)) (__))))) (((logic.refl) ((nat) )) ((((plus) ) (y)) ((((plus) ) (z)) ((((times) ) (x_366)) ((((plus) ) (y)) (z))))))) ((((plus) ) ((((times) ) (x_366)) (y))) ((((times) ) (x_366)) (z)))) (((_x_368) (y)) (z)))) ((((plus) ) ((((times) ) (x_366)) (y))) ((((plus) ) (z)) ((((times) ) (x_366)) (z))))) (((((((logic.rewrite_l) ((nat) )) ((((plus) ) ((((plus) ) (z)) ((((times) ) (x_366)) (y)))) ((((times) ) (x_366)) (z)))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((plus) ) ((((times) ) (x_366)) (y))) ((((plus) ) (z)) ((((times) ) (x_366)) (z))))) (__))) ((((assoc_plus1) ((((times) ) (x_366)) (z))) (z)) ((((times) ) (x_366)) (y)))) ((((plus) ) (z)) ((((plus) ) ((((times) ) (x_366)) (y))) ((((times) ) (x_366)) (z))))) ((((associative_plus) (z)) ((((times) ) (x_366)) (y))) ((((times) ) (x_366)) (z)))))) ((((plus) ) ((((plus) ) (y)) ((((times) ) (x_366)) (y)))) ((((plus) ) (z)) ((((times) ) (x_366)) (z))))) ((((associative_plus) (y)) ((((times) ) (x_366)) (y))) ((((plus) ) (z)) ((((times) ) (x_366)) (z)))))) ((((plus) ) ((((plus) ) (y)) (z))) ((((times) ) (x_366)) ((((plus) ) (y)) (z))))) ((((associative_plus) (y)) (z)) ((((times) ) (x_366)) ((((plus) ) (y)) (z)))))))))))))))) (n).
Definition distributive_times_plus_r : forall (a:(nat) ), forall (b:(nat) ), forall (c:(nat) ), (((logic.eq) ((nat) )) ((((times) ) ((((plus) ) (b)) (c))) (a))) ((((plus) ) ((((times) ) (b)) (a))) ((((times) ) (c)) (a))) := fun (a:(nat) ) => fun (b:(nat) ) => fun (c:(nat) ) => ((((((logic.rewrite_r) ((nat) )) ((((times) ) (a)) ((((plus) ) (b)) (c)))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (__)) ((((plus) ) ((((times) ) (b)) (a))) ((((times) ) (c)) (a))))) (((((((logic.rewrite_r) ((nat) )) ((((times) ) (a)) (b))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((times) ) (a)) ((((plus) ) (b)) (c)))) ((((plus) ) (__)) ((((times) ) (c)) (a))))) (((((((logic.rewrite_r) ((nat) )) ((((times) ) (a)) (c))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((times) ) (a)) ((((plus) ) (b)) (c)))) ((((plus) ) ((((times) ) (a)) (b))) (__)))) (((((((logic.rewrite_l) ((nat) )) ((((times) ) (a)) ((((plus) ) (b)) (c)))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((times) ) (a)) ((((plus) ) (b)) (c)))) (__))) (((logic.refl) ((nat) )) ((((times) ) (a)) ((((plus) ) (b)) (c))))) ((((plus) ) ((((times) ) (a)) (b))) ((((times) ) (a)) (c)))) ((((distributive_times_plus) (a)) (b)) (c)))) ((((times) ) (c)) (a))) (((commutative_times) (c)) (a)))) ((((times) ) (b)) (a))) (((commutative_times) (b)) (a)))) ((((times) ) ((((plus) ) (b)) (c))) (a))) (((commutative_times) ((((plus) ) (b)) (c))) (a)).
Definition associative_times : ((relations.associative) ((nat) )) ((times) ) := fun (n:(nat) ) => ((((nat_ind) (fun (_x_365:(nat) ) => forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((((times) ) ((((times) ) (_x_365)) (y))) (z))) ((((times) ) (_x_365)) ((((times) ) (y)) (z))))) ((((sym_eq_times) ((O) )) (fun (x:((nat) ) -> (nat) ) => forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((((times) ) ((((times) ) ((O) )) (y))) (z))) ((x) ((((times) ) (y)) (z))))) ((((sym_eq_times) ((O) )) (fun (x:((nat) ) -> (nat) ) => forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((((times) ) ((x) (y))) (z))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) ((O) )) ((((times) ) (y)) (z))))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((times_body) )) (fun (x:((nat) ) -> (nat) ) => forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((((times) ) ((x) (y))) (z))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) ((O) )) ((((times) ) (y)) (z))))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((times_body) )) (fun (x:((nat) ) -> (nat) ) => forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((((times) ) ((((times_body) ) ((O) )) (y))) (z))) ((x) ((((times) ) (y)) (z))))) (((sym_eq_times_body_O) (fun (x:((nat) ) -> (nat) ) => forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((((times) ) ((((times_body) ) ((O) )) (y))) (z))) ((x) ((((times) ) (y)) (z))))) (((sym_eq_times_body_O) (fun (x:((nat) ) -> (nat) ) => forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((((times) ) ((x) (y))) (z))) ((O) ))) ((((sym_eq_times) ((O) )) (fun (x:((nat) ) -> (nat) ) => forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((x) (z))) ((O) ))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((times_body) )) (fun (x:((nat) ) -> (nat) ) => forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((x) (z))) ((O) ))) (((sym_eq_times_body_O) (fun (x:((nat) ) -> (nat) ) => forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((x) (z))) ((O) ))) (fun (_y:(nat) ) => fun (_z:(nat) ) => ((logic.refl) ((nat) )) ((O) )))))))))))) (fun (x_366:(nat) ) => fun (_x_368:forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((((times) ) ((((times) ) (x_366)) (y))) (z))) ((((times) ) (x_366)) ((((times) ) (y)) (z)))) => (fun (y:(nat) ) => fun (z:(nat) ) => (((sym_eq_times) (((S) ) (x_366))) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((times) ) ((((times) ) (((S) ) (x_366))) (y))) (z))) ((x) ((((times) ) (y)) (z))))) ((((sym_eq_times) (((S) ) (x_366))) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((times) ) ((x) (y))) (z))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) (((S) ) (x_366))) ((((times) ) (y)) (z))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((times_body) )) (x_366)) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((times) ) ((x) (y))) (z))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) (((S) ) (x_366))) ((((times) ) (y)) (z))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((times_body) )) (x_366)) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((times) ) ((((times_body) ) (((S) ) (x_366))) (y))) (z))) ((x) ((((times) ) (y)) (z))))) ((((sym_eq_times_body_S) (x_366)) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((times) ) ((((times_body) ) (((S) ) (x_366))) (y))) (z))) ((x) ((((times) ) (y)) (z))))) ((((sym_eq_times_body_S) (x_366)) (fun (x:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((times) ) ((x) (y))) (z))) ((((plus) ) ((((times) ) (y)) (z))) ((((times) ) (x_366)) ((((times) ) (y)) (z)))))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) ((((times) ) (y)) (z))) ((((times) ) (x_366)) ((((times) ) (y)) (z))))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (__)) ((((plus) ) ((((times) ) (y)) (z))) ((((times) ) (x_366)) ((((times) ) (y)) (z)))))) (((logic.refl) ((nat) )) ((((plus) ) ((((times) ) (y)) (z))) ((((times) ) (x_366)) ((((times) ) (y)) (z)))))) ((((times) ) ((((plus) ) (y)) ((((times) ) (x_366)) (y)))) (z))) (((((((logic.rewrite_l) ((nat) )) ((((times) ) ((((times) ) (x_366)) (y))) (z))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((times) ) ((((plus) ) (y)) ((((times) ) (x_366)) (y)))) (z))) ((((plus) ) ((((times) ) (y)) (z))) (__)))) ((((distributive_times_plus_r) (z)) (y)) ((((times) ) (x_366)) (y)))) ((((times) ) (x_366)) ((((times) ) (y)) (z)))) (((_x_368) (y)) (z)))))))))))) (n).
Definition times_times : forall (x:(nat) ), forall (y:(nat) ), forall (z:(nat) ), (((logic.eq) ((nat) )) ((((times) ) (x)) ((((times) ) (y)) (z)))) ((((times) ) (y)) ((((times) ) (x)) (z))) := fun (x:(nat) ) => fun (y:(nat) ) => fun (z:(nat) ) => ((((((logic.rewrite_r) ((nat) )) ((((times) ) (y)) ((((times) ) (x)) (z)))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (__)) ((((times) ) (y)) ((((times) ) (x)) (z))))) (((logic.refl) ((nat) )) ((((times) ) (y)) ((((times) ) (x)) (z))))) ((((times) ) (x)) ((((times) ) (y)) (z)))) (((((((logic.rewrite_l) ((nat) )) ((((times) ) ((((times) ) (x)) (y))) (z))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (__)) ((((times) ) (y)) ((((times) ) (x)) (z))))) (((((((logic.rewrite_l) ((nat) )) ((((times) ) (y)) (x))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((times) ) (__)) (z))) ((((times) ) (y)) ((((times) ) (x)) (z))))) ((((associative_times) (y)) (x)) (z))) ((((times) ) (x)) (y))) (((commutative_times) (y)) (x)))) ((((times) ) (x)) ((((times) ) (y)) (z)))) ((((associative_times) (x)) (y)) (z))).
Definition times_n_1 : forall (n:(nat) ), (((logic.eq) ((nat) )) (n)) ((((times) ) (n)) (((S) ) ((O) ))) := fun (n:(nat) ) => ((((((logic.rewrite_l) ((nat) )) ((((plus) ) (n)) ((((times) ) (n)) ((O) )))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (n)) (__))) (((((((logic.rewrite_l) ((nat) )) ((O) )) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (n)) ((((plus) ) (n)) (__)))) (((((((logic.rewrite_l) ((nat) )) (n)) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (n)) (__))) (((logic.refl) ((nat) )) (n))) ((((plus) ) (n)) ((O) ))) ((plus_n_O) (n)))) ((((times) ) (n)) ((O) ))) ((times_n_O) (n)))) ((((times) ) (n)) (((S) ) ((O) )))) (((times_n_Sm) (n)) ((O) )).
Definition minus_S_S : forall (n:(nat) ), forall (m:(nat) ), (((logic.eq) ((nat) )) ((((minus) ) (((S) ) (n))) (((S) ) (m)))) ((((minus) ) (n)) (m)) := fun (n:(nat) ) => fun (m:(nat) ) => ((((((eq_match_nat_type_S) ((nat) )) (((S) ) (n))) (fun (q:(nat) ) => (((minus) ) (n)) (q))) (m)) (fun (y:(nat) ) => (((logic.eq) ((nat) )) ((((minus) ) (((S) ) (n))) (((S) ) (m)))) (y))) ((((eq_minus_body_S) (n)) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((minus) ) (((S) ) (n))) (((S) ) (m)))) ((y) (((S) ) (m))))) ((((((eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((minus_body) )) (n)) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((minus) ) (((S) ) (n))) (((S) ) (m)))) ((y) (((S) ) (m))))) ((((eq_minus) (((S) ) (n))) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((minus) ) (((S) ) (n))) (((S) ) (m)))) ((y) (((S) ) (m))))) (((logic.refl) ((nat) )) ((((minus) ) (((S) ) (n))) (((S) ) (m))))))).
Definition minus_O_n : forall (n:(nat) ), (((logic.eq) ((nat) )) ((O) )) ((((minus) ) ((O) )) (n)) := fun (n:(nat) ) => ((((match_nat_prop) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((O) )) ((((minus) ) ((O) )) (__)))) ((((sym_eq_minus) ((O) )) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((O) )) ((y) ((O) )))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((minus_body) )) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((O) )) ((y) ((O) )))) (((sym_eq_minus_body_O) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((O) )) ((y) ((O) )))) (((logic.refl) ((nat) )) ((O) )))))) ((((sym_eq_minus) ((O) )) (fun (y:((nat) ) -> (nat) ) => forall (n0:(nat) ), (((logic.eq) ((nat) )) ((O) )) ((y) (((S) ) (n0))))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((minus_body) )) (fun (y:((nat) ) -> (nat) ) => forall (n0:(nat) ), (((logic.eq) ((nat) )) ((O) )) ((y) (((S) ) (n0))))) (((sym_eq_minus_body_O) (fun (y:((nat) ) -> (nat) ) => forall (n0:(nat) ), (((logic.eq) ((nat) )) ((O) )) ((y) (((S) ) (n0))))) (fun (auto:(nat) ) => ((logic.refl) ((nat) )) ((O) )))))) (n).
Definition minus_n_O : forall (n:(nat) ), (((logic.eq) ((nat) )) (n)) ((((minus) ) (n)) ((O) )) := fun (n:(nat) ) => ((((match_nat_prop) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (__)) ((((minus) ) (__)) ((O) )))) (((((((logic.rewrite_l) ((nat) )) ((O) )) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((O) )) (__))) (((logic.refl) ((nat) )) ((O) ))) ((((minus) ) ((O) )) ((O) ))) ((minus_O_n) ((O) )))) (fun (auto:(nat) ) => (((sym_eq_minus) (((S) ) (auto))) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) (((S) ) (auto))) ((y) ((O) )))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((minus_body) )) (auto)) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) (((S) ) (auto))) ((y) ((O) )))) ((((sym_eq_minus_body_S) (auto)) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) (((S) ) (auto))) ((y) ((O) )))) ((((((sym_eq_match_nat_type_O) ((nat) )) (((S) ) (auto))) (fun (q:(nat) ) => (((minus) ) (auto)) (q))) (fun (y:(nat) ) => (((logic.eq) ((nat) )) (((S) ) (auto))) (y))) (((logic.refl) ((nat) )) (((S) ) (auto)))))))) (n).
Definition minus_n_n : forall (n:(nat) ), (((logic.eq) ((nat) )) ((O) )) ((((minus) ) (n)) (n)) := fun (n:(nat) ) => ((((nat_ind) (fun (_x_365:(nat) ) => (((logic.eq) ((nat) )) ((O) )) ((((minus) ) (_x_365)) (_x_365)))) (((((((logic.rewrite_l) ((nat) )) ((O) )) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((O) )) (__))) (((logic.refl) ((nat) )) ((O) ))) ((((minus) ) ((O) )) ((O) ))) ((minus_O_n) ((O) )))) (fun (x_366:(nat) ) => fun (_x_368:(((logic.eq) ((nat) )) ((O) )) ((((minus) ) (x_366)) (x_366))) => (((((((logic.rewrite_r) ((nat) )) ((((minus) ) (x_366)) (x_366))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((O) )) (__))) (((((((logic.rewrite_l) ((nat) )) ((O) )) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((O) )) (__))) (((logic.refl) ((nat) )) ((O) ))) ((((minus) ) (x_366)) (x_366))) (_x_368))) ((((minus) ) (((S) ) (x_366))) (((S) ) (x_366)))) (((minus_S_S) (x_366)) (x_366))))) (n).
Definition eq_minus_S_pred : forall (n:(nat) ), forall (m:(nat) ), (((logic.eq) ((nat) )) ((((minus) ) (n)) (((S) ) (m)))) (((pred) ) ((((minus) ) (n)) (m))) := ((((nat_elim2) (fun (__:(nat) ) => fun (_0:(nat) ) => (((logic.eq) ((nat) )) ((((minus) ) (__)) (((S) ) (_0)))) (((pred) ) ((((minus) ) (__)) (_0))))) (fun (_n:(nat) ) => (((sym_eq_minus) ((O) )) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((minus) ) ((O) )) (((S) ) (_n)))) (((pred) ) ((y) (_n))))) ((((sym_eq_minus) ((O) )) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((y) (((S) ) (_n)))) (((pred) ) (((((filter_nat_type) (((nat) ) -> (nat) )) ((minus_body) )) ((O) )) (_n))))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((minus_body) )) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((y) (((S) ) (_n)))) (((pred) ) (((((filter_nat_type) (((nat) ) -> (nat) )) ((minus_body) )) ((O) )) (_n))))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((minus_body) )) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((minus_body) ) ((O) )) (((S) ) (_n)))) (((pred) ) ((y) (_n))))) (((sym_eq_minus_body_O) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((minus_body) ) ((O) )) (((S) ) (_n)))) (((pred) ) ((y) (_n))))) (((sym_eq_minus_body_O) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((y) (((S) ) (_n)))) (((((match_nat_type) ((nat) )) ((O) )) (fun (p:(nat) ) => p)) ((O) )))) ((((((sym_eq_match_nat_type_O) ((nat) )) ((O) )) (fun (p:(nat) ) => p)) (fun (y:(nat) ) => (((logic.eq) ((nat) )) ((O) )) (y))) (((logic.refl) ((nat) )) ((O) )))))))))) (fun (n:(nat) ) => (((sym_eq_minus) (((S) ) (n))) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((minus) ) (((S) ) (n))) (((S) ) ((O) )))) (((pred) ) ((y) ((O) ))))) ((((sym_eq_minus) (((S) ) (n))) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((y) (((S) ) ((O) )))) (((pred) ) (((((filter_nat_type) (((nat) ) -> (nat) )) ((minus_body) )) (((S) ) (n))) ((O) ))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((minus_body) )) (n)) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((y) (((S) ) ((O) )))) (((pred) ) (((((filter_nat_type) (((nat) ) -> (nat) )) ((minus_body) )) (((S) ) (n))) ((O) ))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((minus_body) )) (n)) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((minus_body) ) (((S) ) (n))) (((S) ) ((O) )))) (((pred) ) ((y) ((O) ))))) ((((sym_eq_minus_body_S) (n)) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((((minus_body) ) (((S) ) (n))) (((S) ) ((O) )))) (((pred) ) ((y) ((O) ))))) ((((sym_eq_minus_body_S) (n)) (fun (y:((nat) ) -> (nat) ) => (((logic.eq) ((nat) )) ((y) (((S) ) ((O) )))) (((pred) ) (((((match_nat_type) ((nat) )) (((S) ) (n))) (fun (q:(nat) ) => (((minus) ) (n)) (q))) ((O) ))))) (((((((sym_eq_match_nat_type_S) ((nat) )) (((S) ) (n))) (fun (q:(nat) ) => (((minus) ) (n)) (q))) ((O) )) (fun (y:(nat) ) => (((logic.eq) ((nat) )) (y)) (((((match_nat_type) ((nat) )) ((O) )) (fun (p:(nat) ) => p)) (((((match_nat_type) ((nat) )) (((S) ) (n))) (fun (q:(nat) ) => (((minus) ) (n)) (q))) ((O) ))))) ((((((sym_eq_match_nat_type_O) ((nat) )) (((S) ) (n))) (fun (q:(nat) ) => (((minus) ) (n)) (q))) (fun (y:(nat) ) => (((logic.eq) ((nat) )) ((((minus) ) (n)) ((O) ))) (((((match_nat_type) ((nat) )) ((O) )) (fun (p:(nat) ) => p)) (y)))) (((((((sym_eq_match_nat_type_S) ((nat) )) ((O) )) (fun (q:(nat) ) => q)) (n)) (fun (y:(nat) ) => (((logic.eq) ((nat) )) ((((minus) ) (n)) ((O) ))) (y))) (((((((logic.rewrite_l) ((nat) )) (n)) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (__)) (n))) (((logic.refl) ((nat) )) (n))) ((((minus) ) (n)) ((O) ))) ((minus_n_O) (n))))))))))))) (fun (n:(nat) ) => fun (m:(nat) ) => (((sym_eq_minus) (((S) ) (n))) (fun (y:((nat) ) -> (nat) ) => ((((logic.eq) ((nat) )) ((((minus) ) (n)) (((S) ) (m)))) (((pred) ) ((((minus) ) (n)) (m)))) -> (((logic.eq) ((nat) )) ((((minus) ) (((S) ) (n))) (((S) ) (((S) ) (m))))) (((pred) ) ((y) (((S) ) (m)))))) ((((sym_eq_minus) (((S) ) (n))) (fun (y:((nat) ) -> (nat) ) => ((((logic.eq) ((nat) )) ((((minus) ) (n)) (((S) ) (m)))) (((pred) ) ((((minus) ) (n)) (m)))) -> (((logic.eq) ((nat) )) ((y) (((S) ) (((S) ) (m))))) (((pred) ) (((((filter_nat_type) (((nat) ) -> (nat) )) ((minus_body) )) (((S) ) (n))) (((S) ) (m)))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((minus_body) )) (n)) (fun (y:((nat) ) -> (nat) ) => ((((logic.eq) ((nat) )) ((((minus) ) (n)) (((S) ) (m)))) (((pred) ) ((((minus) ) (n)) (m)))) -> (((logic.eq) ((nat) )) ((y) (((S) ) (((S) ) (m))))) (((pred) ) (((((filter_nat_type) (((nat) ) -> (nat) )) ((minus_body) )) (((S) ) (n))) (((S) ) (m)))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((minus_body) )) (n)) (fun (y:((nat) ) -> (nat) ) => ((((logic.eq) ((nat) )) ((((minus) ) (n)) (((S) ) (m)))) (((pred) ) ((((minus) ) (n)) (m)))) -> (((logic.eq) ((nat) )) ((((minus_body) ) (((S) ) (n))) (((S) ) (((S) ) (m))))) (((pred) ) ((y) (((S) ) (m)))))) ((((sym_eq_minus_body_S) (n)) (fun (y:((nat) ) -> (nat) ) => ((((logic.eq) ((nat) )) ((((minus) ) (n)) (((S) ) (m)))) (((pred) ) ((((minus) ) (n)) (m)))) -> (((logic.eq) ((nat) )) ((((minus_body) ) (((S) ) (n))) (((S) ) (((S) ) (m))))) (((pred) ) ((y) (((S) ) (m)))))) ((((sym_eq_minus_body_S) (n)) (fun (y:((nat) ) -> (nat) ) => ((((logic.eq) ((nat) )) ((((minus) ) (n)) (((S) ) (m)))) (((pred) ) ((((minus) ) (n)) (m)))) -> (((logic.eq) ((nat) )) ((y) (((S) ) (((S) ) (m))))) (((pred) ) (((((match_nat_type) ((nat) )) (((S) ) (n))) (fun (q:(nat) ) => (((minus) ) (n)) (q))) (((S) ) (m)))))) (((((((sym_eq_match_nat_type_S) ((nat) )) (((S) ) (n))) (fun (q:(nat) ) => (((minus) ) (n)) (q))) (((S) ) (m))) (fun (y:(nat) ) => ((((logic.eq) ((nat) )) ((((minus) ) (n)) (((S) ) (m)))) (((pred) ) ((((minus) ) (n)) (m)))) -> (((logic.eq) ((nat) )) (y)) (((((match_nat_type) ((nat) )) ((O) )) (fun (p:(nat) ) => p)) (((((match_nat_type) ((nat) )) (((S) ) (n))) (fun (q:(nat) ) => (((minus) ) (n)) (q))) (((S) ) (m)))))) (((((((sym_eq_match_nat_type_S) ((nat) )) (((S) ) (n))) (fun (q:(nat) ) => (((minus) ) (n)) (q))) (m)) (fun (y:(nat) ) => ((((logic.eq) ((nat) )) ((((minus) ) (n)) (((S) ) (m)))) (((pred) ) ((((minus) ) (n)) (m)))) -> (((logic.eq) ((nat) )) ((((minus) ) (n)) (((S) ) (m)))) (((((match_nat_type) ((nat) )) ((O) )) (fun (p:(nat) ) => p)) (y)))) (fun (auto:(((logic.eq) ((nat) )) ((((minus) ) (n)) (((S) ) (m)))) (((((match_nat_type) ((nat) )) ((O) )) (fun (p:(nat) ) => p)) ((((minus) ) (n)) (m)))) => (((((((logic.rewrite_r) ((nat) )) (((((match_nat_type) ((nat) )) ((O) )) (fun (p:(nat) ) => p)) ((((minus) ) (n)) (m)))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (__)) (((((match_nat_type) ((nat) )) ((O) )) (fun (p:(nat) ) => p)) ((((minus) ) (n)) (m))))) (((logic.refl) ((nat) )) (((((match_nat_type) ((nat) )) ((O) )) (fun (p:(nat) ) => p)) ((((minus) ) (n)) (m))))) ((((minus) ) (n)) (((S) ) (m)))) (auto))))))))))).
Definition not_eq_S : forall (n:(nat) ), forall (m:(nat) ), (((connectives.Not) ) ((((logic.eq) ((nat) )) (n)) (m))) -> ((connectives.Not) ) ((((logic.eq) ((nat) )) (((S) ) (n))) (((S) ) (m))) := fun (n:(nat) ) => fun (m:(nat) ) => fun (auto:((connectives.Not) ) ((((logic.eq) ((nat) )) (n)) (m))) => (((((logic.not_to_not) ((((logic.eq) ((nat) )) (((S) ) (n))) (((S) ) (m)))) ((((logic.eq) ((nat) )) (n)) (m))) (fun (auto':(((logic.eq) ((nat) )) (((S) ) (n))) (((S) ) (m))) => (((((((logic.rewrite_l) ((nat) )) (m)) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (__)) (m))) (((logic.refl) ((nat) )) (m))) (n)) (((((((logic.rewrite_r) ((nat) )) (((pred) ) (((S) ) (n)))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (m)) (__))) (((((((logic.rewrite_r) ((nat) )) (((S) ) (m))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (m)) (((pred) ) (__)))) ((pred_Sn) (m))) (((S) ) (n))) (auto'))) (n)) ((pred_Sn) (n)))))) (auto)).
Definition not_eq_O_S : forall (n:(nat) ), ((connectives.Not) ) ((((logic.eq) ((nat) )) ((O) )) (((S) ) (n))) := fun (n:(nat) ) => ((connectives.nmk) ((((logic.eq) ((nat) )) ((O) )) (((S) ) (n)))) (fun (eqOS:(((logic.eq) ((nat) )) ((O) )) (((S) ) (n))) => ((((((eq_match_nat_type_O) (Prop)) ((connectives.False) )) (fun (p:(nat) ) => (connectives.True) )) (fun (y:Prop) => y)) (((((((logic.eq_ind_r) ((nat) )) (((S) ) (n))) (fun (x:(nat) ) => ((not_zero) ) (x))) (((((((sym_eq_match_nat_type_S) (Prop)) ((connectives.False) )) (fun (p:(nat) ) => (connectives.True) )) (n)) (fun (y:Prop) => y)) (connectives.I))) ((O) )) (eqOS)))).
Definition lt_to_not_zero : forall (n:(nat) ), forall (m:(nat) ), ((((lt) ) (n)) (m)) -> ((not_zero) ) (m) := fun (n:(nat) ) => fun (m:(nat) ) => fun (Hlt:(((lt) ) (n)) (m)) => (((((((le_ind) (((S) ) (n))) (fun (x_417:(nat) ) => ((not_zero) ) (x_417))) (((((((sym_eq_match_nat_type_S) (Prop)) ((connectives.False) )) (fun (p:(nat) ) => (connectives.True) )) (n)) (fun (y:Prop) => y)) (connectives.I))) (fun (m0:(nat) ) => fun (_x_419:(((le) ) (((S) ) (n))) (m0)) => (fun (_x_421:((not_zero) ) (m0)) => (((((((sym_eq_match_nat_type_S) (Prop)) ((connectives.False) )) (fun (p:(nat) ) => (connectives.True) )) (m0)) (fun (y:Prop) => y)) (connectives.I))))) (m)) (Hlt)).
Definition le_S_S : forall (n:(nat) ), forall (m:(nat) ), ((((le) ) (n)) (m)) -> (((le) ) (((S) ) (n))) (((S) ) (m)) := fun (n:(nat) ) => fun (m:(nat) ) => fun (lenm:(((le) ) (n)) (m)) => (((((((le_ind) (n)) (fun (x_417:(nat) ) => (((le) ) (((S) ) (n))) (((S) ) (x_417)))) ((le_n) (((S) ) (n)))) (fun (m0:(nat) ) => fun (_x_419:(((le) ) (n)) (m0)) => (fun (_x_421:(((le) ) (((S) ) (n))) (((S) ) (m0))) => ((((le_S) (((S) ) (n))) (((S) ) (m0))) (_x_421))))) (m)) (lenm)).
Definition le_O_n : forall (n:(nat) ), (((le) ) ((O) )) (n) := fun (n:(nat) ) => ((((nat_ind) (((le) ) ((O) ))) ((le_n) ((O) ))) (fun (x_366:(nat) ) => fun (_x_368:(((le) ) ((O) )) (x_366)) => ((((le_S) ((O) )) (x_366)) (_x_368)))) (n).
Definition le_n_Sn : forall (n:(nat) ), (((le) ) (n)) (((S) ) (n)) := fun (n:(nat) ) => (((le_S) (n)) (n)) ((le_n) (n)).
Definition transitive_le : ((relations.transitive) ((nat) )) ((le) ) := fun (a:(nat) ) => fun (b:(nat) ) => fun (c:(nat) ) => fun (leab:(((le) ) (a)) (b)) => (fun (lebc:(((le) ) (b)) (c)) => (((((((le_ind) (b)) (fun (x_417:(nat) ) => (((le) ) (a)) (x_417))) (leab)) (fun (m:(nat) ) => fun (_x_419:(((le) ) (b)) (m)) => (fun (_x_421:(((le) ) (a)) (m)) => ((((le_S) (a)) (m)) (_x_421))))) (c)) (lebc))).
Definition le_pred_n : forall (n:(nat) ), (((le) ) (((pred) ) (n))) (n) := fun (n:(nat) ) => ((((nat_ind) (fun (_x_365:(nat) ) => (((le) ) (((pred) ) (_x_365))) (_x_365))) ((((((eq_match_nat_type_O) ((nat) )) ((O) )) (fun (p:(nat) ) => p)) (fun (y:(nat) ) => (((le) ) (((((match_nat_type) ((nat) )) ((O) )) (fun (p:(nat) ) => p)) ((O) ))) (y))) ((le_n) (((pred) ) ((O) ))))) (fun (x_366:(nat) ) => fun (_x_368:(((le) ) (((pred) ) (x_366))) (x_366)) => (((((((eq_match_nat_type_S) ((nat) )) ((O) )) (fun (p:(nat) ) => p)) (x_366)) (fun (y:(nat) ) => (((le) ) (((pred) ) (((S) ) (x_366)))) (((S) ) (y)))) ((le_n_Sn) (((pred) ) (((S) ) (x_366))))))) (n).
Definition monotonic_pred : (((relations.monotonic) ((nat) )) ((le) )) ((pred) ) := fun (n:(nat) ) => fun (m:(nat) ) => fun (lenm:(((le) ) (n)) (m)) => (((((((le_ind) (n)) (fun (x_417:(nat) ) => (((le) ) (((pred) ) (n))) (((pred) ) (x_417)))) ((le_n) (((pred) ) (n)))) (fun (m0:(nat) ) => fun (_x_419:(((le) ) (n)) (m0)) => (fun (_x_421:(((le) ) (((pred) ) (n))) (((pred) ) (m0))) => ((((((transitive_le) (((pred) ) (n))) (n)) (((pred) ) (((S) ) (m0)))) ((le_pred_n) (n))) (((((((sym_eq_match_nat_type_S) ((nat) )) ((O) )) (fun (p:(nat) ) => p)) (m0)) (fun (y:(nat) ) => (((le) ) (n)) (y))) (_x_419)))))) (m)) (lenm)).
Definition le_S_S_to_le : forall (n:(nat) ), forall (m:(nat) ), ((((le) ) (((S) ) (n))) (((S) ) (m))) -> (((le) ) (n)) (m) := fun (n:(nat) ) => fun (m:(nat) ) => fun (auto:(((le) ) (((S) ) (n))) (((S) ) (m))) => (((((((eq_match_nat_type_S) ((nat) )) ((O) )) (fun (p:(nat) ) => p)) (m)) (fun (y:(nat) ) => (((le) ) (n)) (y))) (((((((eq_match_nat_type_S) ((nat) )) ((O) )) (fun (p:(nat) ) => p)) (n)) (fun (y:(nat) ) => (((le) ) (y)) (((((match_nat_type) ((nat) )) ((O) )) (fun (p:(nat) ) => p)) (((S) ) (m))))) ((((monotonic_pred) (((S) ) (n))) (((S) ) (m))) (auto)))).
Definition monotonic_le_plus_r : forall (n:(nat) ), (((relations.monotonic) ((nat) )) ((le) )) (fun (m:(nat) ) => (((plus) ) (n)) (m)) := fun (n:(nat) ) => fun (a:(nat) ) => fun (b:(nat) ) => ((((nat_ind) (fun (_x_365:(nat) ) => ((((le) ) (a)) (b)) -> (((le) ) ((((plus) ) (_x_365)) (a))) ((((plus) ) (_x_365)) (b)))) ((((sym_eq_plus) ((O) )) (fun (y:((nat) ) -> (nat) ) => ((((le) ) (a)) (b)) -> (((le) ) ((((plus) ) ((O) )) (a))) ((y) (b)))) ((((sym_eq_plus) ((O) )) (fun (y:((nat) ) -> (nat) ) => ((((le) ) (a)) (b)) -> (((le) ) ((y) (a))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((plus_body) )) ((O) )) (b)))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((plus_body) )) (fun (y:((nat) ) -> (nat) ) => ((((le) ) (a)) (b)) -> (((le) ) ((y) (a))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((plus_body) )) ((O) )) (b)))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((plus_body) )) (fun (y:((nat) ) -> (nat) ) => ((((le) ) (a)) (b)) -> (((le) ) ((((plus_body) ) ((O) )) (a))) ((y) (b)))) (((sym_eq_plus_body_O) (fun (y:((nat) ) -> (nat) ) => ((((le) ) (a)) (b)) -> (((le) ) ((((plus_body) ) ((O) )) (a))) ((y) (b)))) (((sym_eq_plus_body_O) (fun (y:((nat) ) -> (nat) ) => ((((le) ) (a)) (b)) -> (((le) ) ((y) (a))) (b))) (fun (auto:(((le) ) (a)) (b)) => (auto))))))))) (fun (m:(nat) ) => fun (H:((((le) ) (a)) (b)) -> (((le) ) ((((plus) ) (m)) (a))) ((((plus) ) (m)) (b))) => (fun (leab:(((le) ) (a)) (b)) => ((((sym_eq_plus) (((S) ) (m))) (fun (y:((nat) ) -> (nat) ) => (((le) ) ((((plus) ) (((S) ) (m))) (a))) ((y) (b)))) ((((sym_eq_plus) (((S) ) (m))) (fun (y:((nat) ) -> (nat) ) => (((le) ) ((y) (a))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((plus_body) )) (((S) ) (m))) (b)))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((plus_body) )) (m)) (fun (y:((nat) ) -> (nat) ) => (((le) ) ((y) (a))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((plus_body) )) (((S) ) (m))) (b)))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((plus_body) )) (m)) (fun (y:((nat) ) -> (nat) ) => (((le) ) ((((plus_body) ) (((S) ) (m))) (a))) ((y) (b)))) ((((sym_eq_plus_body_S) (m)) (fun (y:((nat) ) -> (nat) ) => (((le) ) ((((plus_body) ) (((S) ) (m))) (a))) ((y) (b)))) ((((sym_eq_plus_body_S) (m)) (fun (y:((nat) ) -> (nat) ) => (((le) ) ((y) (a))) (((S) ) ((((plus) ) (m)) (b))))) ((((le_S_S) ((((plus) ) (m)) (a))) ((((plus) ) (m)) (b))) ((H) (leab)))))))))))) (n).
Definition monotonic_le_plus_l : forall (m:(nat) ), (((relations.monotonic) ((nat) )) ((le) )) (fun (n:(nat) ) => (((plus) ) (n)) (m)) := fun (m:(nat) ) => fun (x:(nat) ) => fun (y:(nat) ) => fun (auto:(((le) ) (x)) (y)) => (((((logic.eq_coerc) ((((le) ) ((((plus) ) (m)) (x))) ((((plus) ) (m)) (y)))) ((((le) ) ((((plus) ) (x)) (m))) ((((plus) ) (y)) (m)))) (((((monotonic_le_plus_r) (m)) (x)) (y)) (auto))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (m)) (x))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) ((((plus) ) (m)) (x))) ((((plus) ) (m)) (y)))) ((((le) ) (__)) ((((plus) ) (y)) (m))))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (m)) (y))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) ((((plus) ) (m)) (x))) ((((plus) ) (m)) (y)))) ((((le) ) ((((plus) ) (m)) (x))) (__)))) (((logic.refl) (Prop)) ((((le) ) ((((plus) ) (m)) (x))) ((((plus) ) (m)) (y))))) ((((plus) ) (y)) (m))) (((commutative_plus) (y)) (m)))) ((((plus) ) (x)) (m))) (((commutative_plus) (x)) (m)))).
Definition le_plus : forall (n1:(nat) ), forall (n2:(nat) ), forall (m1:(nat) ), forall (m2:(nat) ), ((((le) ) (n1)) (n2)) -> ((((le) ) (m1)) (m2)) -> (((le) ) ((((plus) ) (n1)) (m1))) ((((plus) ) (n2)) (m2)) := fun (n1:(nat) ) => fun (n2:(nat) ) => fun (m1:(nat) ) => fun (m2:(nat) ) => fun (len:(((le) ) (n1)) (n2)) => (fun (lem:(((le) ) (m1)) (m2)) => ((((((transitive_le) ((((plus) ) (n1)) (m1))) ((((plus) ) (n1)) (m2))) ((((plus) ) (n2)) (m2))) (((((monotonic_le_plus_r) (n1)) (m1)) (m2)) (lem))) (((((monotonic_le_plus_l) (m2)) (n1)) (n2)) (len)))).
Definition le_plus_n : forall (n:(nat) ), forall (m:(nat) ), (((le) ) (m)) ((((plus) ) (n)) (m)) := fun (n:(nat) ) => fun (m:(nat) ) => ((((logic.eq_coerc) ((((le) ) ((((plus) ) ((O) )) (m))) ((((plus) ) (n)) (m)))) ((((le) ) (m)) ((((plus) ) (n)) (m)))) (((((monotonic_le_plus_l) (m)) ((O) )) (n)) ((le_O_n) (n)))) (((((((logic.rewrite_l) ((nat) )) (m)) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (__)) ((((plus) ) (n)) (m)))) ((((le) ) (m)) ((((plus) ) (n)) (m))))) (((logic.refl) (Prop)) ((((le) ) (m)) ((((plus) ) (n)) (m))))) ((((plus) ) ((O) )) (m))) ((plus_O_n) (m))).
Definition le_plus_b : forall (b:(nat) ), forall (n:(nat) ), forall (m:(nat) ), ((((le) ) ((((plus) ) (n)) (b))) (m)) -> (((le) ) (n)) (m) := fun (b:(nat) ) => fun (n:(nat) ) => fun (m:(nat) ) => fun (auto:(((le) ) ((((plus) ) (n)) (b))) (m)) => ((((((transitive_le) (n)) ((((plus) ) (n)) (b))) (m)) (((((logic.eq_coerc) ((((le) ) (n)) ((((plus) ) (b)) (n)))) ((((le) ) (n)) ((((plus) ) (n)) (b)))) (((le_plus_n) (b)) (n))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (b)) (n))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (n)) ((((plus) ) (b)) (n)))) ((((le) ) (n)) (__)))) (((logic.refl) (Prop)) ((((le) ) (n)) ((((plus) ) (b)) (n))))) ((((plus) ) (n)) (b))) (((commutative_plus) (n)) (b))))) (auto)).
Definition le_plus_n_r : forall (n:(nat) ), forall (m:(nat) ), (((le) ) (m)) ((((plus) ) (m)) (n)) := fun (n:(nat) ) => fun (m:(nat) ) => ((((logic.eq_coerc) ((((le) ) (m)) ((((plus) ) (n)) (m)))) ((((le) ) (m)) ((((plus) ) (m)) (n)))) (((le_plus_n) (n)) (m))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (n)) (m))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (m)) ((((plus) ) (n)) (m)))) ((((le) ) (m)) (__)))) (((logic.refl) (Prop)) ((((le) ) (m)) ((((plus) ) (n)) (m))))) ((((plus) ) (m)) (n))) (((commutative_plus) (m)) (n))).
Definition le_plus_to_le : forall (a:(nat) ), forall (n:(nat) ), forall (m:(nat) ), ((((le) ) ((((plus) ) (a)) (n))) ((((plus) ) (a)) (m))) -> (((le) ) (n)) (m) := fun (a:(nat) ) => ((((nat_ind) (fun (_x_365:(nat) ) => forall (n:(nat) ), forall (m:(nat) ), ((((le) ) ((((plus) ) (_x_365)) (n))) ((((plus) ) (_x_365)) (m))) -> (((le) ) (n)) (m))) (fun (n:(nat) ) => fun (m:(nat) ) => (((sym_eq_plus) ((O) )) (fun (y:((nat) ) -> (nat) ) => ((((le) ) ((((plus) ) ((O) )) (n))) ((y) (m))) -> (((le) ) (n)) (m))) ((((sym_eq_plus) ((O) )) (fun (y:((nat) ) -> (nat) ) => ((((le) ) ((y) (n))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((plus_body) )) ((O) )) (m))) -> (((le) ) (n)) (m))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((plus_body) )) (fun (y:((nat) ) -> (nat) ) => ((((le) ) ((y) (n))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((plus_body) )) ((O) )) (m))) -> (((le) ) (n)) (m))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((plus_body) )) (fun (y:((nat) ) -> (nat) ) => ((((le) ) ((((plus_body) ) ((O) )) (n))) ((y) (m))) -> (((le) ) (n)) (m))) (((sym_eq_plus_body_O) (fun (y:((nat) ) -> (nat) ) => ((((le) ) ((((plus_body) ) ((O) )) (n))) ((y) (m))) -> (((le) ) (n)) (m))) (((sym_eq_plus_body_O) (fun (y:((nat) ) -> (nat) ) => ((((le) ) ((y) (n))) (m)) -> (((le) ) (n)) (m))) (fun (auto:(((le) ) (n)) (m)) => (auto))))))))) (fun (x_366:(nat) ) => fun (_x_368:forall (n:(nat) ), forall (m:(nat) ), ((((le) ) ((((plus) ) (x_366)) (n))) ((((plus) ) (x_366)) (m))) -> (((le) ) (n)) (m)) => (fun (n:(nat) ) => fun (m:(nat) ) => (((sym_eq_plus) (((S) ) (x_366))) (fun (y:((nat) ) -> (nat) ) => ((((le) ) ((((plus) ) (((S) ) (x_366))) (n))) ((y) (m))) -> (((le) ) (n)) (m))) ((((sym_eq_plus) (((S) ) (x_366))) (fun (y:((nat) ) -> (nat) ) => ((((le) ) ((y) (n))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((plus_body) )) (((S) ) (x_366))) (m))) -> (((le) ) (n)) (m))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((plus_body) )) (x_366)) (fun (y:((nat) ) -> (nat) ) => ((((le) ) ((y) (n))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((plus_body) )) (((S) ) (x_366))) (m))) -> (((le) ) (n)) (m))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((plus_body) )) (x_366)) (fun (y:((nat) ) -> (nat) ) => ((((le) ) ((((plus_body) ) (((S) ) (x_366))) (n))) ((y) (m))) -> (((le) ) (n)) (m))) ((((sym_eq_plus_body_S) (x_366)) (fun (y:((nat) ) -> (nat) ) => ((((le) ) ((((plus_body) ) (((S) ) (x_366))) (n))) ((y) (m))) -> (((le) ) (n)) (m))) ((((sym_eq_plus_body_S) (x_366)) (fun (y:((nat) ) -> (nat) ) => ((((le) ) ((y) (n))) (((S) ) ((((plus) ) (x_366)) (m)))) -> (((le) ) (n)) (m))) (fun (auto:(((le) ) (((S) ) ((((plus) ) (x_366)) (n)))) (((S) ) ((((plus) ) (x_366)) (m)))) => (((((logic.eq_coerc) ((((le) ) (((pred) ) (((S) ) (n)))) (((pred) ) (((S) ) (m))))) ((((le) ) (n)) (m))) ((((monotonic_pred) (((S) ) (n))) (((S) ) (m))) ((((_x_368) (((S) ) (n))) (((S) ) (m))) (((((logic.eq_coerc) ((((le) ) (((S) ) ((((plus) ) (x_366)) (n)))) (((S) ) ((((plus) ) (x_366)) (m))))) ((((le) ) ((((plus) ) (x_366)) (((S) ) (n)))) ((((plus) ) (x_366)) (((S) ) (m))))) (auto)) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (x_366)) (((S) ) (n)))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (__)) (((S) ) ((((plus) ) (x_366)) (m))))) ((((le) ) ((((plus) ) (x_366)) (((S) ) (n)))) ((((plus) ) (x_366)) (((S) ) (m)))))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (x_366)) (((S) ) (m)))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) ((((plus) ) (x_366)) (((S) ) (n)))) (__))) ((((le) ) ((((plus) ) (x_366)) (((S) ) (n)))) ((((plus) ) (x_366)) (((S) ) (m)))))) (((logic.refl) (Prop)) ((((le) ) ((((plus) ) (x_366)) (((S) ) (n)))) ((((plus) ) (x_366)) (((S) ) (m)))))) (((S) ) ((((plus) ) (x_366)) (m)))) (((plus_n_Sm) (x_366)) (m)))) (((S) ) ((((plus) ) (x_366)) (n)))) (((plus_n_Sm) (x_366)) (n))))))) (((((((logic.rewrite_l) ((nat) )) (n)) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (__)) (((pred) ) (((S) ) (m))))) ((((le) ) (n)) (m)))) (((((((logic.rewrite_l) ((nat) )) (m)) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (n)) (__))) ((((le) ) (n)) (m)))) (((logic.refl) (Prop)) ((((le) ) (n)) (m)))) (((pred) ) (((S) ) (m)))) ((pred_Sn) (m)))) (((pred) ) (((S) ) (n)))) ((pred_Sn) (n))))))))))))) (a).
Definition le_plus_to_le_r : forall (a:(nat) ), forall (n:(nat) ), forall (m:(nat) ), ((((le) ) ((((plus) ) (n)) (a))) ((((plus) ) (m)) (a))) -> (((le) ) (n)) (m) := fun (a:(nat) ) => fun (n:(nat) ) => fun (m:(nat) ) => fun (auto:(((le) ) ((((plus) ) (n)) (a))) ((((plus) ) (m)) (a))) => (((((le_plus_to_le) (a)) (n)) (m)) (((((logic.eq_coerc) ((((le) ) ((((plus) ) (n)) (a))) ((((plus) ) (m)) (a)))) ((((le) ) ((((plus) ) (a)) (n))) ((((plus) ) (a)) (m)))) (auto)) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (a)) (n))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (__)) ((((plus) ) (m)) (a)))) ((((le) ) ((((plus) ) (a)) (n))) ((((plus) ) (a)) (m))))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (a)) (m))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) ((((plus) ) (a)) (n))) (__))) ((((le) ) ((((plus) ) (a)) (n))) ((((plus) ) (a)) (m))))) (((logic.refl) (Prop)) ((((le) ) ((((plus) ) (a)) (n))) ((((plus) ) (a)) (m))))) ((((plus) ) (m)) (a))) (((commutative_plus) (m)) (a)))) ((((plus) ) (n)) (a))) (((commutative_plus) (n)) (a))))).
Definition monotonic_le_times_r : forall (n:(nat) ), (((relations.monotonic) ((nat) )) ((le) )) (fun (m:(nat) ) => (((times) ) (n)) (m)) := fun (n:(nat) ) => fun (x:(nat) ) => fun (y:(nat) ) => fun (lexy:(((le) ) (x)) (y)) => (((((nat_ind) (fun (_x_365:(nat) ) => (((le) ) ((((times) ) (_x_365)) (x))) ((((times) ) (_x_365)) (y)))) ((((sym_eq_times) ((O) )) (fun (z:((nat) ) -> (nat) ) => (((le) ) ((((times) ) ((O) )) (x))) ((z) (y)))) ((((sym_eq_times) ((O) )) (fun (z:((nat) ) -> (nat) ) => (((le) ) ((z) (x))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) ((O) )) (y)))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((times_body) )) (fun (z:((nat) ) -> (nat) ) => (((le) ) ((z) (x))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) ((O) )) (y)))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((times_body) )) (fun (z:((nat) ) -> (nat) ) => (((le) ) ((((times_body) ) ((O) )) (x))) ((z) (y)))) (((sym_eq_times_body_O) (fun (z:((nat) ) -> (nat) ) => (((le) ) ((((times_body) ) ((O) )) (x))) ((z) (y)))) (((sym_eq_times_body_O) (fun (z:((nat) ) -> (nat) ) => (((le) ) ((z) (x))) ((O) ))) ((le_O_n) ((O) ))))))))) (fun (a:(nat) ) => fun (lea:(((le) ) ((((times) ) (a)) (x))) ((((times) ) (a)) (y))) => ((((sym_eq_times) (((S) ) (a))) (fun (z:((nat) ) -> (nat) ) => (((le) ) ((((times) ) (((S) ) (a))) (x))) ((z) (y)))) ((((sym_eq_times) (((S) ) (a))) (fun (z:((nat) ) -> (nat) ) => (((le) ) ((z) (x))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) (((S) ) (a))) (y)))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((times_body) )) (a)) (fun (z:((nat) ) -> (nat) ) => (((le) ) ((z) (x))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((times_body) )) (((S) ) (a))) (y)))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((times_body) )) (a)) (fun (z:((nat) ) -> (nat) ) => (((le) ) ((((times_body) ) (((S) ) (a))) (x))) ((z) (y)))) ((((sym_eq_times_body_S) (a)) (fun (z:((nat) ) -> (nat) ) => (((le) ) ((((times_body) ) (((S) ) (a))) (x))) ((z) (y)))) ((((sym_eq_times_body_S) (a)) (fun (z:((nat) ) -> (nat) ) => (((le) ) ((z) (x))) ((((plus) ) (y)) ((((times) ) (a)) (y))))) (((((((le_plus) (x)) (y)) ((((times) ) (a)) (x))) ((((times) ) (a)) (y))) (lexy)) (lea)))))))))) (n)).
Definition le_times : forall (n1:(nat) ), forall (n2:(nat) ), forall (m1:(nat) ), forall (m2:(nat) ), ((((le) ) (n1)) (n2)) -> ((((le) ) (m1)) (m2)) -> (((le) ) ((((times) ) (n1)) (m1))) ((((times) ) (n2)) (m2)) := fun (n1:(nat) ) => fun (n2:(nat) ) => fun (m1:(nat) ) => fun (m2:(nat) ) => fun (len:(((le) ) (n1)) (n2)) => (fun (lem:(((le) ) (m1)) (m2)) => ((((((transitive_le) ((((times) ) (n1)) (m1))) ((((times) ) (n1)) (m2))) ((((times) ) (n2)) (m2))) (((((monotonic_le_times_r) (n1)) (m1)) (m2)) (lem))) (((((logic.eq_coerc) ((((le) ) ((((times) ) (m2)) (n1))) ((((times) ) (m2)) (n2)))) ((((le) ) ((((times) ) (n1)) (m2))) ((((times) ) (n2)) (m2)))) (((((monotonic_le_times_r) (m2)) (n1)) (n2)) (len))) (((((((logic.rewrite_r) ((nat) )) ((((times) ) (n1)) (m2))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (__)) ((((times) ) (m2)) (n2)))) ((((le) ) ((((times) ) (n1)) (m2))) ((((times) ) (n2)) (m2))))) (((((((logic.rewrite_r) ((nat) )) ((((times) ) (n2)) (m2))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) ((((times) ) (n1)) (m2))) (__))) ((((le) ) ((((times) ) (n1)) (m2))) ((((times) ) (n2)) (m2))))) (((logic.refl) (Prop)) ((((le) ) ((((times) ) (n1)) (m2))) ((((times) ) (n2)) (m2))))) ((((times) ) (m2)) (n2))) (((commutative_times) (m2)) (n2)))) ((((times) ) (m2)) (n1))) (((commutative_times) (m2)) (n1)))))).
Definition le_plus_minus_m_m : forall (n:(nat) ), forall (m:(nat) ), (((le) ) (n)) ((((plus) ) ((((minus) ) (n)) (m))) (m)) := fun (n:(nat) ) => ((((nat_ind) (fun (_x_365:(nat) ) => forall (m:(nat) ), (((le) ) (_x_365)) ((((plus) ) ((((minus) ) (_x_365)) (m))) (m)))) ((((sym_eq_minus) ((O) )) (fun (y:((nat) ) -> (nat) ) => forall (m:(nat) ), (((le) ) ((O) )) ((((plus) ) ((y) (m))) (m)))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((minus_body) )) (fun (y:((nat) ) -> (nat) ) => forall (m:(nat) ), (((le) ) ((O) )) ((((plus) ) ((y) (m))) (m)))) (((sym_eq_minus_body_O) (fun (y:((nat) ) -> (nat) ) => forall (m:(nat) ), (((le) ) ((O) )) ((((plus) ) ((y) (m))) (m)))) (fun (m:(nat) ) => ((le_plus_n_r) (m)) ((O) )))))) (fun (a:(nat) ) => fun (Hind:forall (m:(nat) ), (((le) ) (a)) ((((plus) ) ((((minus) ) (a)) (m))) (m))) => (fun (m:(nat) ) => ((((match_nat_prop) (fun (__:(nat) ) => (((le) ) (((S) ) (a))) ((((plus) ) ((((minus) ) (((S) ) (a))) (__))) (__)))) ((((sym_eq_minus) (((S) ) (a))) (fun (y:((nat) ) -> (nat) ) => (((le) ) (((S) ) (a))) ((((plus) ) ((y) ((O) ))) ((O) )))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((minus_body) )) (a)) (fun (y:((nat) ) -> (nat) ) => (((le) ) (((S) ) (a))) ((((plus) ) ((y) ((O) ))) ((O) )))) ((((sym_eq_minus_body_S) (a)) (fun (y:((nat) ) -> (nat) ) => (((le) ) (((S) ) (a))) ((((plus) ) ((y) ((O) ))) ((O) )))) ((((((sym_eq_match_nat_type_O) ((nat) )) (((S) ) (a))) (fun (q:(nat) ) => (((minus) ) (a)) (q))) (fun (y:(nat) ) => (((le) ) (((S) ) (a))) ((((plus) ) (y)) ((O) )))) (((le_plus_n_r) ((O) )) (((S) ) (a)))))))) (fun (n0:(nat) ) => (((sym_eq_minus) (((S) ) (a))) (fun (y:((nat) ) -> (nat) ) => (((le) ) (((S) ) (a))) ((((plus) ) ((y) (((S) ) (n0)))) (((S) ) (n0))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((minus_body) )) (a)) (fun (y:((nat) ) -> (nat) ) => (((le) ) (((S) ) (a))) ((((plus) ) ((y) (((S) ) (n0)))) (((S) ) (n0))))) ((((sym_eq_minus_body_S) (a)) (fun (y:((nat) ) -> (nat) ) => (((le) ) (((S) ) (a))) ((((plus) ) ((y) (((S) ) (n0)))) (((S) ) (n0))))) (((((((sym_eq_match_nat_type_S) ((nat) )) (((S) ) (a))) (fun (q:(nat) ) => (((minus) ) (a)) (q))) (n0)) (fun (y:(nat) ) => (((le) ) (((S) ) (a))) ((((plus) ) (y)) (((S) ) (n0))))) (((((logic.eq_coerc) ((((le) ) (((S) ) (a))) (((S) ) ((((plus) ) ((((minus) ) (a)) (n0))) (n0))))) ((((le) ) (((S) ) (a))) ((((plus) ) ((((minus) ) (a)) (n0))) (((S) ) (n0))))) ((((le_S_S) (a)) ((((plus) ) ((((minus) ) (a)) (n0))) (n0))) ((Hind) (n0)))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) ((((minus) ) (a)) (n0))) (((S) ) (n0)))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (((S) ) (a))) (__))) ((((le) ) (((S) ) (a))) ((((plus) ) ((((minus) ) (a)) (n0))) (((S) ) (n0)))))) (((logic.refl) (Prop)) ((((le) ) (((S) ) (a))) ((((plus) ) ((((minus) ) (a)) (n0))) (((S) ) (n0)))))) (((S) ) ((((plus) ) ((((minus) ) (a)) (n0))) (n0)))) (((plus_n_Sm) ((((minus) ) (a)) (n0))) (n0))))))))) (m)))) (n).
Definition le_plus_to_minus_r : forall (a:(nat) ), forall (b:(nat) ), forall (c:(nat) ), ((((le) ) ((((plus) ) (a)) (b))) (c)) -> (((le) ) (a)) ((((minus) ) (c)) (b)) := fun (a:(nat) ) => fun (b:(nat) ) => fun (c:(nat) ) => fun (H:(((le) ) ((((plus) ) (a)) (b))) (c)) => (((((le_plus_to_le_r) (b)) (a)) ((((minus) ) (c)) (b))) ((((((transitive_le) ((((plus) ) (a)) (b))) (c)) ((((plus) ) ((((minus) ) (c)) (b))) (b))) (H)) (((le_plus_minus_m_m) (c)) (b)))).
Definition lt_to_le : forall (x:(nat) ), forall (y:(nat) ), ((((lt) ) (x)) (y)) -> (((le) ) (x)) (y) := fun (x:(nat) ) => fun (y:(nat) ) => fun (auto:(((lt) ) (x)) (y)) => (((((le_plus_b) (((S) ) ((O) ))) (x)) (y)) (((((logic.eq_coerc) ((((le) ) (((S) ) (x))) (y))) ((((le) ) ((((plus) ) (x)) (((S) ) ((O) )))) (y))) (auto)) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (x)) (((S) ) ((O) )))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (__)) (y))) ((((le) ) ((((plus) ) (x)) (((S) ) ((O) )))) (y)))) (((logic.refl) (Prop)) ((((le) ) ((((plus) ) (x)) (((S) ) ((O) )))) (y)))) (((S) ) (x))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (x)) ((O) ))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (((S) ) (__))) ((((plus) ) (x)) (((S) ) ((O) ))))) (((plus_n_Sm) (x)) ((O) ))) (x)) ((plus_n_O) (x)))))).
Definition transitive_lt : ((relations.transitive) ((nat) )) ((lt) ) := fun (a:(nat) ) => fun (b:(nat) ) => fun (c:(nat) ) => fun (ltab:(((lt) ) (a)) (b)) => (fun (ltbc:(((lt) ) (b)) (c)) => (((((((le_ind) (((S) ) (b))) (fun (x_417:(nat) ) => (((lt) ) (a)) (x_417))) ((((le_S) (((S) ) (a))) (b)) (ltab))) (fun (m:(nat) ) => fun (_x_419:(((le) ) (((S) ) (b))) (m)) => (fun (_x_421:(((lt) ) (a)) (m)) => ((((le_S) (((S) ) (a))) (m)) (_x_421))))) (c)) (ltbc))).
Definition lt_to_le_to_lt : forall (n:(nat) ), forall (m:(nat) ), forall (p:(nat) ), ((((lt) ) (n)) (m)) -> ((((le) ) (m)) (p)) -> (((lt) ) (n)) (p) := fun (n:(nat) ) => fun (m:(nat) ) => fun (p:(nat) ) => fun (H:(((lt) ) (n)) (m)) => (fun (H1:(((le) ) (m)) (p)) => (((((((le_ind) (m)) (fun (x_417:(nat) ) => (((lt) ) (n)) (x_417))) (H)) (fun (m0:(nat) ) => fun (_x_419:(((le) ) (m)) (m0)) => (fun (_x_421:(((lt) ) (n)) (m0)) => ((((((transitive_lt) (n)) (m0)) (((S) ) (m0))) (_x_421)) (((((logic.eq_coerc) ((((le) ) (((S) ) (m0))) ((((plus) ) ((O) )) (((S) ) (m0))))) ((((le) ) (((S) ) (m0))) (((S) ) (m0)))) (((le_plus_n) ((O) )) (((S) ) (m0)))) (((((((logic.rewrite_l) ((nat) )) (((S) ) (m0))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (((S) ) (m0))) (__))) ((((le) ) (((S) ) (m0))) (((S) ) (m0))))) (((logic.refl) (Prop)) ((((le) ) (((S) ) (m0))) (((S) ) (m0))))) ((((plus) ) ((O) )) (((S) ) (m0)))) ((plus_O_n) (((S) ) (m0))))))))) (p)) (H1))).
Definition le_to_lt_to_lt : forall (n:(nat) ), forall (m:(nat) ), forall (p:(nat) ), ((((le) ) (n)) (m)) -> ((((lt) ) (m)) (p)) -> (((lt) ) (n)) (p) := fun (n:(nat) ) => fun (m:(nat) ) => fun (p:(nat) ) => fun (H:(((le) ) (n)) (m)) => (((((((le_ind) (n)) (fun (x_417:(nat) ) => ((((lt) ) (x_417)) (p)) -> (((lt) ) (n)) (p))) (fun (auto:(((lt) ) (n)) (p)) => (auto))) (fun (m0:(nat) ) => fun (_x_419:(((le) ) (n)) (m0)) => (fun (_x_421:((((lt) ) (m0)) (p)) -> (((lt) ) (n)) (p)) => (fun (auto:(((lt) ) (((S) ) (m0))) (p)) => ((_x_421) ((((((transitive_lt) (m0)) (((S) ) (m0))) (p)) (((((logic.eq_coerc) ((((le) ) (((S) ) (m0))) ((((plus) ) ((O) )) (((S) ) (m0))))) ((((le) ) (((S) ) (m0))) (((S) ) (m0)))) (((le_plus_n) ((O) )) (((S) ) (m0)))) (((((((logic.rewrite_l) ((nat) )) (((S) ) (m0))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (((S) ) (m0))) (__))) ((((le) ) (((S) ) (m0))) (((S) ) (m0))))) (((logic.refl) (Prop)) ((((le) ) (((S) ) (m0))) (((S) ) (m0))))) ((((plus) ) ((O) )) (((S) ) (m0)))) ((plus_O_n) (((S) ) (m0)))))) (auto))))))) (m)) (H)).
Definition lt_S_to_lt : forall (n:(nat) ), forall (m:(nat) ), ((((lt) ) (((S) ) (n))) (m)) -> (((lt) ) (n)) (m) := fun (n:(nat) ) => fun (m:(nat) ) => fun (auto:(((lt) ) (((S) ) (n))) (m)) => ((((((transitive_lt) (n)) (((S) ) (n))) (m)) (((((logic.eq_coerc) ((((le) ) (((S) ) (n))) ((((plus) ) ((O) )) (((S) ) (n))))) ((((le) ) (((S) ) (n))) (((S) ) (n)))) (((le_plus_n) ((O) )) (((S) ) (n)))) (((((((logic.rewrite_l) ((nat) )) (((S) ) (n))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (((S) ) (n))) (__))) ((((le) ) (((S) ) (n))) (((S) ) (n))))) (((logic.refl) (Prop)) ((((le) ) (((S) ) (n))) (((S) ) (n))))) ((((plus) ) ((O) )) (((S) ) (n)))) ((plus_O_n) (((S) ) (n)))))) (auto)).
Definition ltn_to_ltO : forall (n:(nat) ), forall (m:(nat) ), ((((lt) ) (n)) (m)) -> (((lt) ) ((O) )) (m) := fun (n:(nat) ) => fun (m:(nat) ) => fun (auto:(((lt) ) (n)) (m)) => ((((((lt_to_le_to_lt) ((O) )) (((S) ) (n))) (m)) (((((logic.eq_coerc) ((((le) ) (((S) ) ((O) ))) ((((plus) ) (n)) (((S) ) ((O) ))))) ((((le) ) (((S) ) ((O) ))) (((S) ) (n)))) (((le_plus_n) (n)) (((S) ) ((O) )))) (((((((logic.rewrite_l) ((nat) )) (((S) ) (n))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (((S) ) ((O) ))) (__))) ((((le) ) (((S) ) ((O) ))) (((S) ) (n))))) (((logic.refl) (Prop)) ((((le) ) (((S) ) ((O) ))) (((S) ) (n))))) ((((plus) ) (n)) (((S) ) ((O) )))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (n)) ((O) ))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (((S) ) (__))) ((((plus) ) (n)) (((S) ) ((O) ))))) (((plus_n_Sm) (n)) ((O) ))) (n)) ((plus_n_O) (n)))))) (auto)).
Definition lt_O_S : forall (n:(nat) ), (((lt) ) ((O) )) (((S) ) (n)) := fun (n:(nat) ) => (((ltn_to_ltO) (n)) (((S) ) (n))) (((((logic.eq_coerc) ((((le) ) (((S) ) (n))) ((((plus) ) ((O) )) (((S) ) (n))))) ((((le) ) (((S) ) (n))) (((S) ) (n)))) (((le_plus_n) ((O) )) (((S) ) (n)))) (((((((logic.rewrite_l) ((nat) )) (((S) ) (n))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (((S) ) (n))) (__))) ((((le) ) (((S) ) (n))) (((S) ) (n))))) (((logic.refl) (Prop)) ((((le) ) (((S) ) (n))) (((S) ) (n))))) ((((plus) ) ((O) )) (((S) ) (n)))) ((plus_O_n) (((S) ) (n))))).
Definition monotonic_lt_plus_r : forall (n:(nat) ), (((relations.monotonic) ((nat) )) ((lt) )) (fun (m:(nat) ) => (((plus) ) (n)) (m)) := fun (n:(nat) ) => fun (x:(nat) ) => fun (y:(nat) ) => fun (auto:(((lt) ) (x)) (y)) => (((((logic.eq_coerc) ((((le) ) ((((plus) ) (n)) (((S) ) (x)))) ((((plus) ) (n)) (y)))) ((((le) ) (((S) ) ((((plus) ) (n)) (x)))) ((((plus) ) (n)) (y)))) (((((monotonic_le_plus_r) (n)) (((S) ) (x))) (y)) (auto))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (n)) (((S) ) (x)))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) ((((plus) ) (n)) (((S) ) (x)))) ((((plus) ) (n)) (y)))) ((((le) ) (__)) ((((plus) ) (n)) (y))))) (((logic.refl) (Prop)) ((((le) ) ((((plus) ) (n)) (((S) ) (x)))) ((((plus) ) (n)) (y))))) (((S) ) ((((plus) ) (n)) (x)))) (((plus_n_Sm) (n)) (x)))).
Definition monotonic_lt_plus_l : forall (n:(nat) ), (((relations.monotonic) ((nat) )) ((lt) )) (fun (m:(nat) ) => (((plus) ) (m)) (n)) := fun (n:(nat) ) => fun (x:(nat) ) => fun (y:(nat) ) => fun (auto:(((lt) ) (x)) (y)) => (((((logic.eq_coerc) ((((le) ) ((((plus) ) (n)) (((S) ) (x)))) ((((plus) ) (n)) (y)))) ((((le) ) (((S) ) ((((plus) ) (x)) (n)))) ((((plus) ) (y)) (n)))) (((((monotonic_le_plus_r) (n)) (((S) ) (x))) (y)) (auto))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (n)) (x))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) ((((plus) ) (n)) (((S) ) (x)))) ((((plus) ) (n)) (y)))) ((((le) ) (((S) ) (__))) ((((plus) ) (y)) (n))))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (n)) (((S) ) (x)))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) ((((plus) ) (n)) (((S) ) (x)))) ((((plus) ) (n)) (y)))) ((((le) ) (__)) ((((plus) ) (y)) (n))))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (n)) (y))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) ((((plus) ) (n)) (((S) ) (x)))) ((((plus) ) (n)) (y)))) ((((le) ) ((((plus) ) (n)) (((S) ) (x)))) (__)))) (((logic.refl) (Prop)) ((((le) ) ((((plus) ) (n)) (((S) ) (x)))) ((((plus) ) (n)) (y))))) ((((plus) ) (y)) (n))) (((commutative_plus) (y)) (n)))) (((S) ) ((((plus) ) (n)) (x)))) (((plus_n_Sm) (n)) (x)))) ((((plus) ) (x)) (n))) (((commutative_plus) (x)) (n)))).
Definition monotonic_lt_times_r : forall (c:(nat) ), ((((lt) ) ((O) )) (c)) -> (((relations.monotonic) ((nat) )) ((lt) )) (fun (t:(nat) ) => (((times) ) (c)) (t)) := fun (c:(nat) ) => fun (posc:(((lt) ) ((O) )) (c)) => (fun (n:(nat) ) => fun (m:(nat) ) => fun (ltnm:(((lt) ) (n)) (m)) => (((((((le_ind) (((S) ) (n))) (fun (x_417:(nat) ) => (((lt) ) ((((times) ) (c)) (n))) ((((times) ) (c)) (x_417)))) (((((logic.eq_coerc) ((((le) ) (((S) ) ((((plus) ) ((O) )) ((((times) ) (c)) (n))))) ((((plus) ) (c)) ((((times) ) (c)) (n))))) ((((le) ) (((S) ) ((((times) ) (c)) (n)))) ((((times) ) (c)) (((S) ) (n))))) (((((monotonic_lt_plus_l) ((((times) ) (c)) (n))) ((O) )) (c)) (posc))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) ((O) )) (((S) ) ((((times) ) (c)) (n))))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (__)) ((((plus) ) (c)) ((((times) ) (c)) (n))))) ((((le) ) (((S) ) ((((times) ) (c)) (n)))) ((((times) ) (c)) (((S) ) (n)))))) (((((((logic.rewrite_l) ((nat) )) ((((plus) ) (c)) ((((times) ) (c)) (n)))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) ((((plus) ) ((O) )) (((S) ) ((((times) ) (c)) (n))))) ((((plus) ) (c)) ((((times) ) (c)) (n))))) ((((le) ) (((S) ) ((((times) ) (c)) (n)))) (__)))) (((((((logic.rewrite_l) ((nat) )) (((S) ) ((((times) ) (c)) (n)))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (__)) ((((plus) ) (c)) ((((times) ) (c)) (n))))) ((((le) ) (((S) ) ((((times) ) (c)) (n)))) ((((plus) ) (c)) ((((times) ) (c)) (n)))))) (((logic.refl) (Prop)) ((((le) ) (((S) ) ((((times) ) (c)) (n)))) ((((plus) ) (c)) ((((times) ) (c)) (n)))))) ((((plus) ) ((O) )) (((S) ) ((((times) ) (c)) (n))))) ((plus_O_n) (((S) ) ((((times) ) (c)) (n)))))) ((((times) ) (c)) (((S) ) (n)))) (((times_n_Sm) (c)) (n)))) (((S) ) ((((plus) ) ((O) )) ((((times) ) (c)) (n))))) (((plus_n_Sm) ((O) )) ((((times) ) (c)) (n)))))) (fun (a:(nat) ) => fun (__:(((le) ) (((S) ) (n))) (a)) => (fun (lt1:(((le) ) (((S) ) ((((times) ) (c)) (n)))) ((((times) ) (c)) (a))) => ((((((transitive_le) (((S) ) ((((times) ) (c)) (n)))) ((((times) ) (c)) (a))) ((((times) ) (c)) (((S) ) (a)))) (lt1)) (((((logic.eq_coerc) ((((le) ) ((((times) ) (c)) (a))) ((((plus) ) ((((times) ) (c)) (a))) (c)))) ((((le) ) ((((times) ) (c)) (a))) ((((times) ) (c)) (((S) ) (a))))) (((le_plus_n_r) (c)) ((((times) ) (c)) (a)))) (((((((logic.rewrite_l) ((nat) )) ((((plus) ) (c)) ((((times) ) (c)) (a)))) (fun (__1:(nat) ) => (((logic.eq) (Prop)) ((((le) ) ((((times) ) (c)) (a))) ((((plus) ) ((((times) ) (c)) (a))) (c)))) ((((le) ) ((((times) ) (c)) (a))) (__1)))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (c)) ((((times) ) (c)) (a)))) (fun (__1:(nat) ) => (((logic.eq) (Prop)) ((((le) ) ((((times) ) (c)) (a))) (__1))) ((((le) ) ((((times) ) (c)) (a))) ((((plus) ) (c)) ((((times) ) (c)) (a)))))) (((logic.refl) (Prop)) ((((le) ) ((((times) ) (c)) (a))) ((((plus) ) (c)) ((((times) ) (c)) (a)))))) ((((plus) ) ((((times) ) (c)) (a))) (c))) (((commutative_plus) ((((times) ) (c)) (a))) (c)))) ((((times) ) (c)) (((S) ) (a)))) (((times_n_Sm) (c)) (a)))))))) (m)) (ltnm))).
Definition monotonic_lt_times_l : forall (c:(nat) ), ((((lt) ) ((O) )) (c)) -> (((relations.monotonic) ((nat) )) ((lt) )) (fun (t:(nat) ) => (((times) ) (t)) (c)) := fun (c:(nat) ) => fun (auto:(((lt) ) ((O) )) (c)) => (fun (x:(nat) ) => fun (y:(nat) ) => fun (auto':(((lt) ) (x)) (y)) => (((((logic.eq_coerc) ((((le) ) (((S) ) ((((times) ) (c)) (x)))) ((((times) ) (c)) (y)))) ((((le) ) (((S) ) ((((times) ) (x)) (c)))) ((((times) ) (y)) (c)))) ((((((monotonic_lt_times_r) (c)) (auto)) (x)) (y)) (auto'))) (((((((logic.rewrite_r) ((nat) )) ((((times) ) (c)) (x))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (((S) ) ((((times) ) (c)) (x)))) ((((times) ) (c)) (y)))) ((((le) ) (((S) ) (__))) ((((times) ) (y)) (c))))) (((((((logic.rewrite_r) ((nat) )) ((((times) ) (c)) (y))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (((S) ) ((((times) ) (c)) (x)))) ((((times) ) (c)) (y)))) ((((le) ) (((S) ) ((((times) ) (c)) (x)))) (__)))) (((logic.refl) (Prop)) ((((le) ) (((S) ) ((((times) ) (c)) (x)))) ((((times) ) (c)) (y))))) ((((times) ) (y)) (c))) (((commutative_times) (y)) (c)))) ((((times) ) (x)) (c))) (((commutative_times) (x)) (c))))).
Definition lt_to_le_to_lt_times : forall (n:(nat) ), forall (m:(nat) ), forall (p:(nat) ), forall (q:(nat) ), ((((lt) ) (n)) (m)) -> ((((le) ) (p)) (q)) -> ((((lt) ) ((O) )) (q)) -> (((lt) ) ((((times) ) (n)) (p))) ((((times) ) (m)) (q)) := fun (n:(nat) ) => fun (m:(nat) ) => fun (p:(nat) ) => fun (q:(nat) ) => fun (ltnm:(((lt) ) (n)) (m)) => (fun (lepq:(((le) ) (p)) (q)) => (fun (posq:(((lt) ) ((O) )) (q)) => ((((((le_to_lt_to_lt) ((((times) ) (n)) (p))) ((((times) ) (n)) (q))) ((((times) ) (m)) (q))) (((((monotonic_le_times_r) (n)) (p)) (q)) (lepq))) ((((((monotonic_lt_times_l) (q)) (posq)) (n)) (m)) (ltnm))))).
Definition lt_times : forall (n:(nat) ), forall (m:(nat) ), forall (p:(nat) ), forall (q:(nat) ), ((((lt) ) (n)) (m)) -> ((((lt) ) (p)) (q)) -> (((lt) ) ((((times) ) (n)) (p))) ((((times) ) (m)) (q)) := fun (n:(nat) ) => fun (m:(nat) ) => fun (p:(nat) ) => fun (q:(nat) ) => fun (ltnm:(((lt) ) (n)) (m)) => (fun (ltpq:(((lt) ) (p)) (q)) => ((((((((lt_to_le_to_lt_times) (n)) (m)) (p)) (q)) (ltnm)) ((((lt_to_le) (p)) (q)) (ltpq))) ((((ltn_to_ltO) (p)) (q)) (ltpq)))).
Definition lt_plus_to_minus_r : forall (a:(nat) ), forall (b:(nat) ), forall (c:(nat) ), ((((lt) ) ((((plus) ) (a)) (b))) (c)) -> (((lt) ) (a)) ((((minus) ) (c)) (b)) := fun (a:(nat) ) => fun (b:(nat) ) => fun (c:(nat) ) => fun (H:(((lt) ) ((((plus) ) (a)) (b))) (c)) => (((((le_plus_to_minus_r) (((S) ) (a))) (b)) (c)) ((((sym_eq_plus) (((S) ) (a))) (fun (y:((nat) ) -> (nat) ) => (((le) ) ((y) (b))) (c))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((plus_body) )) (a)) (fun (y:((nat) ) -> (nat) ) => (((le) ) ((y) (b))) (c))) ((((sym_eq_plus_body_S) (a)) (fun (y:((nat) ) -> (nat) ) => (((le) ) ((y) (b))) (c))) (H))))).
Definition lt_plus_Sn_r : forall (a:(nat) ), forall (x:(nat) ), forall (n:(nat) ), (((lt) ) (a)) ((((plus) ) ((((plus) ) (a)) (x))) (((S) ) (n))) := fun (a:(nat) ) => fun (x:(nat) ) => fun (n:(nat) ) => ((((logic.eq_coerc) ((((le) ) (((S) ) (a))) (((S) ) ((((plus) ) ((((plus) ) (a)) (x))) (n))))) ((((le) ) (((S) ) (a))) ((((plus) ) ((((plus) ) (a)) (x))) (((S) ) (n))))) ((((le_S_S) (a)) ((((plus) ) ((((plus) ) (a)) (x))) (n))) (((((logic.eq_coerc) ((((le) ) (a)) ((((plus) ) (a)) ((((plus) ) (x)) (n))))) ((((le) ) (a)) ((((plus) ) ((((plus) ) (a)) (x))) (n)))) (((le_plus_n_r) ((((plus) ) (x)) (n))) (a))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (n)) ((((plus) ) (a)) (x)))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (a)) ((((plus) ) (a)) ((((plus) ) (x)) (n))))) ((((le) ) (a)) (__)))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (a)) ((((plus) ) (n)) (x)))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (a)) ((((plus) ) (a)) ((((plus) ) (x)) (n))))) ((((le) ) (a)) (__)))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (x)) (n))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (a)) ((((plus) ) (a)) ((((plus) ) (x)) (n))))) ((((le) ) (a)) ((((plus) ) (a)) (__))))) (((logic.refl) (Prop)) ((((le) ) (a)) ((((plus) ) (a)) ((((plus) ) (x)) (n)))))) ((((plus) ) (n)) (x))) (((commutative_plus) (n)) (x)))) ((((plus) ) (n)) ((((plus) ) (a)) (x)))) (((((((logic.rewrite_l) ((nat) )) ((((plus) ) ((((plus) ) (a)) (n))) (x))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (n)) ((((plus) ) (a)) (x)))) (__))) ((((assoc_plus1) (x)) (a)) (n))) ((((plus) ) (a)) ((((plus) ) (n)) (x)))) ((((associative_plus) (a)) (n)) (x))))) ((((plus) ) ((((plus) ) (a)) (x))) (n))) (((commutative_plus) ((((plus) ) (a)) (x))) (n)))))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (a)) ((((plus) ) (x)) (((S) ) (n))))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (((S) ) (a))) (((S) ) ((((plus) ) ((((plus) ) (a)) (x))) (n))))) ((((le) ) (((S) ) (a))) (__)))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) ((((plus) ) (a)) (x))) (((S) ) (n)))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (((S) ) (a))) (__))) ((((le) ) (((S) ) (a))) ((((plus) ) (a)) ((((plus) ) (x)) (((S) ) (n))))))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (a)) ((((plus) ) (x)) (((S) ) (n))))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (((S) ) (a))) (__))) ((((le) ) (((S) ) (a))) ((((plus) ) (a)) ((((plus) ) (x)) (((S) ) (n))))))) (((logic.refl) (Prop)) ((((le) ) (((S) ) (a))) ((((plus) ) (a)) ((((plus) ) (x)) (((S) ) (n))))))) ((((plus) ) ((((plus) ) (a)) (x))) (((S) ) (n)))) ((((associative_plus) (a)) (x)) (((S) ) (n))))) (((S) ) ((((plus) ) ((((plus) ) (a)) (x))) (n)))) (((plus_n_Sm) ((((plus) ) (a)) (x))) (n)))) ((((plus) ) ((((plus) ) (a)) (x))) (((S) ) (n)))) ((((associative_plus) (a)) (x)) (((S) ) (n)))).
Definition not_le_Sn_O : forall (n:(nat) ), ((connectives.Not) ) ((((le) ) (((S) ) (n))) ((O) )) := fun (n:(nat) ) => ((connectives.nmk) ((((le) ) (((S) ) (n))) ((O) ))) (fun (Hlen0:(((le) ) (((S) ) (n))) ((O) )) => ((((((eq_match_nat_type_O) (Prop)) ((connectives.False) )) (fun (p:(nat) ) => (connectives.True) )) (fun (y:Prop) => y)) ((((lt_to_not_zero) (n)) ((O) )) (Hlen0)))).
Definition not_le_to_not_le_S_S : forall (n:(nat) ), forall (m:(nat) ), (((connectives.Not) ) ((((le) ) (n)) (m))) -> ((connectives.Not) ) ((((le) ) (((S) ) (n))) (((S) ) (m))) := fun (n:(nat) ) => fun (m:(nat) ) => fun (auto:((connectives.Not) ) ((((le) ) (n)) (m))) => (((((logic.not_to_not) ((((le) ) (((S) ) (n))) (((S) ) (m)))) ((((le) ) (n)) (m))) (fun (auto':(((le) ) (((S) ) (n))) (((S) ) (m))) => (((((logic.eq_coerc) ((((le) ) (((pred) ) (((S) ) (n)))) (((pred) ) (((S) ) (m))))) ((((le) ) (n)) (m))) ((((monotonic_pred) (((S) ) (n))) (((S) ) (m))) (auto'))) (((((((logic.rewrite_l) ((nat) )) (n)) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (__)) (((pred) ) (((S) ) (m))))) ((((le) ) (n)) (m)))) (((((((logic.rewrite_l) ((nat) )) (m)) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (n)) (__))) ((((le) ) (n)) (m)))) (((logic.refl) (Prop)) ((((le) ) (n)) (m)))) (((pred) ) (((S) ) (m)))) ((pred_Sn) (m)))) (((pred) ) (((S) ) (n)))) ((pred_Sn) (n)))))) (auto)).
Definition not_le_S_S_to_not_le : forall (n:(nat) ), forall (m:(nat) ), (((connectives.Not) ) ((((le) ) (((S) ) (n))) (((S) ) (m)))) -> ((connectives.Not) ) ((((le) ) (n)) (m)) := fun (n:(nat) ) => fun (m:(nat) ) => fun (auto:((connectives.Not) ) ((((le) ) (((S) ) (n))) (((S) ) (m)))) => (((((logic.not_to_not) ((((le) ) (n)) (m))) ((((le) ) (((S) ) (n))) (((S) ) (m)))) (fun (auto':(((le) ) (n)) (m)) => ((((le_S_S) (n)) (m)) (auto')))) (auto)).
Definition not_le_Sn_n : forall (n:(nat) ), ((connectives.Not) ) ((((le) ) (((S) ) (n))) (n)) := fun (n:(nat) ) => ((((nat_ind) (fun (_x_365:(nat) ) => ((connectives.Not) ) ((((le) ) (((S) ) (_x_365))) (_x_365)))) ((not_le_Sn_O) ((O) ))) (fun (x_366:(nat) ) => fun (_x_368:((connectives.Not) ) ((((le) ) (((S) ) (x_366))) (x_366))) => ((((not_le_to_not_le_S_S) (((S) ) (x_366))) (x_366)) (_x_368)))) (n).
Definition lt_to_not_le : forall (n:(nat) ), forall (m:(nat) ), ((((lt) ) (n)) (m)) -> ((connectives.Not) ) ((((le) ) (m)) (n)) := fun (n:(nat) ) => fun (m:(nat) ) => fun (Hltnm:(((lt) ) (n)) (m)) => (((((((le_ind) (((S) ) (n))) (fun (x_417:(nat) ) => ((connectives.Not) ) ((((le) ) (x_417)) (n)))) ((not_le_Sn_n) (n))) (fun (m0:(nat) ) => fun (_x_419:(((le) ) (((S) ) (n))) (m0)) => (fun (_x_421:((connectives.Not) ) ((((le) ) (m0)) (n))) => (((((logic.not_to_not) ((((le) ) (((S) ) (m0))) (n))) ((((le) ) (m0)) (n))) (fun (auto:(((le) ) (((S) ) (m0))) (n)) => ((((lt_to_le) (m0)) (n)) (auto)))) (_x_421))))) (m)) (Hltnm)).
Definition not_le_to_lt : forall (n:(nat) ), forall (m:(nat) ), (((connectives.Not) ) ((((le) ) (n)) (m))) -> (((lt) ) (m)) (n) := ((((nat_elim2) (fun (__:(nat) ) => fun (_0:(nat) ) => (((connectives.Not) ) ((((le) ) (__)) (_0))) -> (((lt) ) (_0)) (__))) (fun (n:(nat) ) => fun (abs:((connectives.Not) ) ((((le) ) ((O) )) (n))) => (((connectives.falsity) ((((lt) ) (n)) ((O) ))) ((((logic.absurd) ((((le) ) ((O) )) (n))) (((((logic.eq_coerc) ((((le) ) ((O) )) ((((plus) ) (n)) ((O) )))) ((((le) ) ((O) )) (n))) (((le_plus_n) (n)) ((O) ))) (((((((logic.rewrite_l) ((nat) )) (n)) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) ((O) )) (__))) ((((le) ) ((O) )) (n)))) (((logic.refl) (Prop)) ((((le) ) ((O) )) (n)))) ((((plus) ) (n)) ((O) ))) ((plus_n_O) (n))))) (abs))))) (fun (n:(nat) ) => fun (auto:((connectives.Not) ) ((((le) ) (((S) ) (n))) ((O) ))) => ((lt_O_S) (n)))) (fun (n:(nat) ) => fun (m:(nat) ) => fun (Hind:(((connectives.Not) ) ((((le) ) (n)) (m))) -> (((lt) ) (m)) (n)) => (fun (HnotleSS:((connectives.Not) ) ((((le) ) (((S) ) (n))) (((S) ) (m)))) => ((((le_S_S) (((S) ) (m))) (n)) ((Hind) ((((not_le_S_S_to_not_le) (n)) (m)) (HnotleSS)))))).
Definition not_lt_to_le : forall (n:(nat) ), forall (m:(nat) ), (((connectives.Not) ) ((((lt) ) (n)) (m))) -> (((le) ) (m)) (n) := fun (n:(nat) ) => fun (m:(nat) ) => fun (H:((connectives.Not) ) ((((lt) ) (n)) (m))) => ((((le_S_S_to_le) (m)) (n)) ((((not_le_to_lt) (((S) ) (n))) (m)) (((((logic.not_to_not) ((((le) ) (((S) ) (n))) (m))) ((((lt) ) (n)) (m))) (fun (auto:(((le) ) (((S) ) (n))) (m)) => (auto))) (H)))).
Definition le_to_not_lt : forall (n:(nat) ), forall (m:(nat) ), ((((le) ) (n)) (m)) -> ((connectives.Not) ) ((((lt) ) (m)) (n)) := fun (n:(nat) ) => fun (m:(nat) ) => fun (H:(((le) ) (n)) (m)) => ((((lt_to_not_le) (n)) (((S) ) (m))) ((((((le_to_lt_to_lt) (n)) (m)) (((S) ) (m))) (H)) (((((logic.eq_coerc) ((((le) ) (((S) ) (m))) ((((plus) ) ((O) )) (((S) ) (m))))) ((((le) ) (((S) ) (m))) (((S) ) (m)))) (((le_plus_n) ((O) )) (((S) ) (m)))) (((((((logic.rewrite_l) ((nat) )) (((S) ) (m))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (((S) ) (m))) (__))) ((((le) ) (((S) ) (m))) (((S) ) (m))))) (((logic.refl) (Prop)) ((((le) ) (((S) ) (m))) (((S) ) (m))))) ((((plus) ) ((O) )) (((S) ) (m)))) ((plus_O_n) (((S) ) (m))))))).
Definition decidable_le : forall (n:(nat) ), forall (m:(nat) ), ((logic.decidable) ) ((((le) ) (n)) (m)) := ((((nat_elim2) (fun (__:(nat) ) => fun (_0:(nat) ) => ((logic.decidable) ) ((((le) ) (__)) (_0)))) (fun (n:(nat) ) => (((connectives.or_introl) ((((le) ) ((O) )) (n))) (((connectives.Not) ) ((((le) ) ((O) )) (n)))) ((le_O_n) (n)))) (fun (n:(nat) ) => (((connectives.or_intror) ((((le) ) (((S) ) (n))) ((O) ))) (((connectives.Not) ) ((((le) ) (((S) ) (n))) ((O) )))) ((not_le_Sn_O) (n)))) (fun (n:(nat) ) => fun (m:(nat) ) => fun (_clearme:((logic.decidable) ) ((((le) ) (n)) (m))) => (((((((connectives.match_Or_prop) ((((le) ) (n)) (m))) (((connectives.Not) ) ((((le) ) (n)) (m)))) (((logic.decidable) ) ((((le) ) (((S) ) (n))) (((S) ) (m))))) (fun (auto:(((le) ) (n)) (m)) => ((((connectives.or_introl) ((((le) ) (((S) ) (n))) (((S) ) (m)))) (((connectives.Not) ) ((((le) ) (((S) ) (n))) (((S) ) (m))))) ((((le_S_S) (n)) (m)) (auto))))) (fun (auto:((connectives.Not) ) ((((le) ) (n)) (m))) => ((((connectives.or_intror) ((((le) ) (((S) ) (n))) (((S) ) (m)))) (((connectives.Not) ) ((((le) ) (((S) ) (n))) (((S) ) (m))))) ((((not_le_to_not_le_S_S) (n)) (m)) (auto))))) (_clearme))).
Definition decidable_lt : forall (n:(nat) ), forall (m:(nat) ), ((logic.decidable) ) ((((lt) ) (n)) (m)) := fun (n:(nat) ) => fun (m:(nat) ) => ((decidable_le) (((S) ) (n))) (m).
Definition le_to_or_lt_eq : forall (n:(nat) ), forall (m:(nat) ), ((((le) ) (n)) (m)) -> (((connectives.Or) ) ((((lt) ) (n)) (m))) ((((logic.eq) ((nat) )) (n)) (m)) := fun (n:(nat) ) => fun (m:(nat) ) => fun (lenm:(((le) ) (n)) (m)) => (((((((le_ind) (n)) (fun (x_417:(nat) ) => (((connectives.Or) ) ((((lt) ) (n)) (x_417))) ((((logic.eq) ((nat) )) (n)) (x_417)))) ((((relations.RC_reflexive) ((nat) )) ((lt) )) (n))) (fun (m0:(nat) ) => fun (_x_419:(((le) ) (n)) (m0)) => (fun (_x_421:(((connectives.Or) ) ((((lt) ) (n)) (m0))) ((((logic.eq) ((nat) )) (n)) (m0))) => ((((connectives.or_introl) ((((lt) ) (n)) (((S) ) (m0)))) ((((logic.eq) ((nat) )) (n)) (((S) ) (m0)))) ((((((le_to_lt_to_lt) (n)) (m0)) (((S) ) (m0))) (_x_419)) (((((logic.eq_coerc) ((((le) ) (((S) ) (m0))) ((((plus) ) ((O) )) (((S) ) (m0))))) ((((le) ) (((S) ) (m0))) (((S) ) (m0)))) (((le_plus_n) ((O) )) (((S) ) (m0)))) (((((((logic.rewrite_l) ((nat) )) (((S) ) (m0))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (((S) ) (m0))) (__))) ((((le) ) (((S) ) (m0))) (((S) ) (m0))))) (((logic.refl) (Prop)) ((((le) ) (((S) ) (m0))) (((S) ) (m0))))) ((((plus) ) ((O) )) (((S) ) (m0)))) ((plus_O_n) (((S) ) (m0)))))))))) (m)) (lenm)).
Definition lt_O_n_elim : forall (n:(nat) ), ((((lt) ) ((O) )) (n)) -> forall (P:((nat) ) -> Prop), (forall (m:(nat) ), (P) (((S) ) (m))) -> (P) (n) := fun (n:(nat) ) => ((((nat_ind) (fun (_x_365:(nat) ) => ((((lt) ) ((O) )) (_x_365)) -> forall (P:((nat) ) -> Prop), (forall (m:(nat) ), (P) (((S) ) (m))) -> (P) (_x_365))) (fun (abs:(((lt) ) ((O) )) ((O) )) => (((connectives.falsity) (forall (P:((nat) ) -> Prop), (forall (m:(nat) ), (P) (((S) ) (m))) -> (P) ((O) ))) ((((logic.absurd) ((((le) ) (((S) ) ((O) ))) ((O) ))) (abs)) ((not_le_Sn_O) ((O) )))))) (fun (x_366:(nat) ) => fun (_x_368:((((lt) ) ((O) )) (x_366)) -> forall (P:((nat) ) -> Prop), (forall (m:(nat) ), (P) (((S) ) (m))) -> (P) (x_366)) => (fun (auto:(((lt) ) ((O) )) (((S) ) (x_366))) => (fun (P:((nat) ) -> Prop) => fun (auto':forall (m:(nat) ), (P) (((S) ) (m))) => ((auto') (x_366)))))) (n).
Definition le_n_O_elim : forall (n:(nat) ), ((((le) ) (n)) ((O) )) -> forall (P:((nat) ) -> Prop), ((P) ((O) )) -> (P) (n) := fun (n:(nat) ) => ((((match_nat_prop) (fun (__:(nat) ) => ((((le) ) (__)) ((O) )) -> forall (P:((nat) ) -> Prop), ((P) ((O) )) -> (P) (__))) (fun (auto:(((le) ) ((O) )) ((O) )) => (fun (P:((nat) ) -> Prop) => fun (auto':(P) ((O) )) => (auto')))) (fun (a:(nat) ) => fun (abs:(((le) ) (((S) ) (a))) ((O) )) => (((connectives.falsity) (forall (P:((nat) ) -> Prop), ((P) ((O) )) -> (P) (((S) ) (a)))) ((((logic.absurd) ((((le) ) (((S) ) (a))) ((O) ))) (abs)) ((not_le_Sn_O) (a)))))) (n).
Definition lt_to_not_eq : forall (n:(nat) ), forall (m:(nat) ), ((((lt) ) (n)) (m)) -> ((connectives.Not) ) ((((logic.eq) ((nat) )) (n)) (m)) := fun (n:(nat) ) => fun (m:(nat) ) => fun (H:(((lt) ) (n)) (m)) => (((((logic.not_to_not) ((((logic.eq) ((nat) )) (n)) (m))) ((connectives.False) )) (fun (auto:(((logic.eq) ((nat) )) (n)) (m)) => ((((logic.absurd) ((((le) ) (((S) ) (n))) (n))) (((((logic.eq_coerc) ((((le) ) (((S) ) (n))) (m))) ((((le) ) (((S) ) (n))) (n))) (H)) (((((((logic.rewrite_l) ((nat) )) (n)) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (((S) ) (n))) (__))) ((((le) ) (((S) ) (n))) (n)))) (((logic.refl) (Prop)) ((((le) ) (((S) ) (n))) (n)))) (m)) (auto)))) ((not_le_Sn_n) (n))))) (((connectives.nmk) ((connectives.False) )) (fun (auto:(connectives.False) ) => (auto)))).
Definition le_n_O_to_eq : forall (n:(nat) ), ((((le) ) (n)) ((O) )) -> (((logic.eq) ((nat) )) ((O) )) (n) := fun (n:(nat) ) => ((((match_nat_prop) (fun (__:(nat) ) => ((((le) ) (__)) ((O) )) -> (((logic.eq) ((nat) )) ((O) )) (__))) (fun (auto:(((le) ) ((O) )) ((O) )) => (((logic.refl) ((nat) )) ((O) )))) (fun (a:(nat) ) => fun (abs:(((le) ) (((S) ) (a))) ((O) )) => (((connectives.falsity) ((((logic.eq) ((nat) )) ((O) )) (((S) ) (a)))) ((((logic.absurd) ((((le) ) (((S) ) (a))) ((O) ))) (abs)) ((not_le_Sn_O) (a)))))) (n).
Definition le_to_le_to_eq : forall (n:(nat) ), forall (m:(nat) ), ((((le) ) (n)) (m)) -> ((((le) ) (m)) (n)) -> (((logic.eq) ((nat) )) (n)) (m) := ((((nat_elim2) (fun (__:(nat) ) => fun (_0:(nat) ) => ((((le) ) (__)) (_0)) -> ((((le) ) (_0)) (__)) -> (((logic.eq) ((nat) )) (__)) (_0))) (fun (n:(nat) ) => fun (auto:(((le) ) ((O) )) (n)) => (fun (auto':(((le) ) (n)) ((O) )) => (((((logic.sym_eq) ((nat) )) (n)) ((O) )) (((((logic.sym_eq) ((nat) )) ((O) )) (n)) (((((logic.eq_coerc) ((((logic.eq) ((nat) )) ((O) )) (n))) ((((logic.eq) ((nat) )) ((O) )) (n))) (((le_n_O_to_eq) (n)) (auto'))) (((logic.refl) (Prop)) ((((logic.eq) ((nat) )) ((O) )) (n))))))))) (fun (n:(nat) ) => fun (auto:(((le) ) (((S) ) (n))) ((O) )) => (fun (auto':(((le) ) ((O) )) (((S) ) (n))) => (((((logic.sym_eq) ((nat) )) ((O) )) (((S) ) (n))) (((le_n_O_to_eq) (((S) ) (n))) (auto)))))) (fun (n:(nat) ) => fun (m:(nat) ) => fun (auto:((((le) ) (n)) (m)) -> ((((le) ) (m)) (n)) -> (((logic.eq) ((nat) )) (n)) (m)) => (fun (auto':(((le) ) (((S) ) (n))) (((S) ) (m))) => (fun (auto'':(((le) ) (((S) ) (m))) (((S) ) (n))) => (((((((logic.eq_f) ((nat) )) ((nat) )) ((S) )) (n)) (m)) (((auto) (((((logic.eq_coerc) ((((le) ) (((pred) ) (((S) ) (n)))) (((pred) ) (((S) ) (m))))) ((((le) ) (n)) (m))) ((((monotonic_pred) (((S) ) (n))) (((S) ) (m))) (auto'))) (((((((logic.rewrite_l) ((nat) )) (n)) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (__)) (((pred) ) (((S) ) (m))))) ((((le) ) (n)) (m)))) (((((((logic.rewrite_l) ((nat) )) (m)) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (n)) (__))) ((((le) ) (n)) (m)))) (((logic.refl) (Prop)) ((((le) ) (n)) (m)))) (((pred) ) (((S) ) (m)))) ((pred_Sn) (m)))) (((pred) ) (((S) ) (n)))) ((pred_Sn) (n))))) (((((logic.eq_coerc) ((((le) ) (((pred) ) (((S) ) (m)))) (((pred) ) (((S) ) (n))))) ((((le) ) (m)) (n))) ((((monotonic_pred) (((S) ) (m))) (((S) ) (n))) (auto''))) (((((((logic.rewrite_l) ((nat) )) (m)) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (__)) (((pred) ) (((S) ) (n))))) ((((le) ) (m)) (n)))) (((((((logic.rewrite_l) ((nat) )) (n)) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (m)) (__))) ((((le) ) (m)) (n)))) (((logic.refl) (Prop)) ((((le) ) (m)) (n)))) (((pred) ) (((S) ) (n)))) ((pred_Sn) (n)))) (((pred) ) (((S) ) (m)))) ((pred_Sn) (m))))))))).
Definition plus_minus : forall (m:(nat) ), forall (n:(nat) ), forall (p:(nat) ), ((((le) ) (m)) (n)) -> (((logic.eq) ((nat) )) ((((plus) ) ((((minus) ) (n)) (m))) (p))) ((((minus) ) ((((plus) ) (n)) (p))) (m)) := ((((nat_elim2) (fun (__:(nat) ) => fun (_0:(nat) ) => forall (p:(nat) ), ((((le) ) (__)) (_0)) -> (((logic.eq) ((nat) )) ((((plus) ) ((((minus) ) (_0)) (__))) (p))) ((((minus) ) ((((plus) ) (_0)) (p))) (__)))) (fun (n:(nat) ) => fun (p:(nat) ) => fun (auto:(((le) ) ((O) )) (n)) => (((((((logic.rewrite_l) ((nat) )) (n)) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (__)) (p))) ((((minus) ) ((((plus) ) (n)) (p))) ((O) )))) (((((((logic.rewrite_l) ((nat) )) ((((plus) ) (n)) (p))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((plus) ) (n)) (p))) (__))) (((logic.refl) ((nat) )) ((((plus) ) (n)) (p)))) ((((minus) ) ((((plus) ) (n)) (p))) ((O) ))) ((minus_n_O) ((((plus) ) (n)) (p))))) ((((minus) ) (n)) ((O) ))) ((minus_n_O) (n))))) (fun (n:(nat) ) => fun (p:(nat) ) => fun (abs:(((le) ) (((S) ) (n))) ((O) )) => (((connectives.falsity) ((((logic.eq) ((nat) )) ((((plus) ) ((((minus) ) ((O) )) (((S) ) (n)))) (p))) ((((minus) ) ((((plus) ) ((O) )) (p))) (((S) ) (n))))) ((((logic.absurd) ((((le) ) (((S) ) (n))) ((O) ))) (abs)) ((not_le_Sn_O) (n)))))) (fun (n:(nat) ) => fun (m:(nat) ) => (((sym_eq_minus) (((S) ) (m))) (fun (y:((nat) ) -> (nat) ) => (forall (p:(nat) ), ((((le) ) (n)) (m)) -> (((logic.eq) ((nat) )) ((((plus) ) ((((minus) ) (m)) (n))) (p))) ((((minus) ) ((((plus) ) (m)) (p))) (n))) -> forall (p:(nat) ), ((((le) ) (((S) ) (n))) (((S) ) (m))) -> (((logic.eq) ((nat) )) ((((plus) ) ((y) (((S) ) (n)))) (p))) ((((minus) ) ((((plus) ) (((S) ) (m))) (p))) (((S) ) (n))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((minus_body) )) (m)) (fun (y:((nat) ) -> (nat) ) => (forall (p:(nat) ), ((((le) ) (n)) (m)) -> (((logic.eq) ((nat) )) ((((plus) ) ((((minus) ) (m)) (n))) (p))) ((((minus) ) ((((plus) ) (m)) (p))) (n))) -> forall (p:(nat) ), ((((le) ) (((S) ) (n))) (((S) ) (m))) -> (((logic.eq) ((nat) )) ((((plus) ) ((y) (((S) ) (n)))) (p))) ((((minus) ) ((((plus) ) (((S) ) (m))) (p))) (((S) ) (n))))) ((((sym_eq_minus_body_S) (m)) (fun (y:((nat) ) -> (nat) ) => (forall (p:(nat) ), ((((le) ) (n)) (m)) -> (((logic.eq) ((nat) )) ((((plus) ) ((((minus) ) (m)) (n))) (p))) ((((minus) ) ((((plus) ) (m)) (p))) (n))) -> forall (p:(nat) ), ((((le) ) (((S) ) (n))) (((S) ) (m))) -> (((logic.eq) ((nat) )) ((((plus) ) ((y) (((S) ) (n)))) (p))) ((((minus) ) ((((plus) ) (((S) ) (m))) (p))) (((S) ) (n))))) (fun (auto:forall (p:(nat) ), ((((le) ) (n)) (m)) -> (((logic.eq) ((nat) )) ((((plus) ) ((((minus) ) (m)) (n))) (p))) ((((minus) ) ((((plus) ) (m)) (p))) (n))) => (fun (p:(nat) ) => ((((((sym_eq_match_nat_type_S) ((nat) )) (((S) ) (m))) (fun (q:(nat) ) => (((minus) ) (m)) (q))) (n)) (fun (y:(nat) ) => ((((le) ) (((S) ) (n))) (((S) ) (m))) -> (((logic.eq) ((nat) )) ((((plus) ) (y)) (p))) ((((minus) ) ((((plus) ) (((S) ) (m))) (p))) (((S) ) (n))))) ((((sym_eq_minus) ((((plus) ) (((S) ) (m))) (p))) (fun (y:((nat) ) -> (nat) ) => ((((le) ) (((S) ) (n))) (((S) ) (m))) -> (((logic.eq) ((nat) )) ((((plus) ) ((((minus) ) (m)) (n))) (p))) ((y) (((S) ) (n))))) ((((sym_eq_plus) (((S) ) (m))) (fun (y:((nat) ) -> (nat) ) => ((((le) ) (((S) ) (n))) (((S) ) (m))) -> (((logic.eq) ((nat) )) ((((plus) ) ((((minus) ) (m)) (n))) (p))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((minus_body) )) ((y) (p))) (((S) ) (n))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((plus_body) )) (m)) (fun (y:((nat) ) -> (nat) ) => ((((le) ) (((S) ) (n))) (((S) ) (m))) -> (((logic.eq) ((nat) )) ((((plus) ) ((((minus) ) (m)) (n))) (p))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((minus_body) )) ((y) (p))) (((S) ) (n))))) ((((sym_eq_plus_body_S) (m)) (fun (y:((nat) ) -> (nat) ) => ((((le) ) (((S) ) (n))) (((S) ) (m))) -> (((logic.eq) ((nat) )) ((((plus) ) ((((minus) ) (m)) (n))) (p))) (((((filter_nat_type) (((nat) ) -> (nat) )) ((minus_body) )) ((y) (p))) (((S) ) (n))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((minus_body) )) ((((plus) ) (m)) (p))) (fun (y:((nat) ) -> (nat) ) => ((((le) ) (((S) ) (n))) (((S) ) (m))) -> (((logic.eq) ((nat) )) ((((plus) ) ((((minus) ) (m)) (n))) (p))) ((y) (((S) ) (n))))) ((((eq_plus_body_S) (m)) (fun (y:((nat) ) -> (nat) ) => ((((le) ) (((S) ) (n))) (((S) ) (m))) -> (((logic.eq) ((nat) )) ((((plus) ) ((((minus) ) (m)) (n))) (p))) ((((minus_body) ) ((y) (p))) (((S) ) (n))))) ((((((eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((plus_body) )) (m)) (fun (y:((nat) ) -> (nat) ) => ((((le) ) (((S) ) (n))) (((S) ) (m))) -> (((logic.eq) ((nat) )) ((((plus) ) ((((minus) ) (m)) (n))) (p))) ((((minus_body) ) ((y) (p))) (((S) ) (n))))) ((((eq_plus) (((S) ) (m))) (fun (y:((nat) ) -> (nat) ) => ((((le) ) (((S) ) (n))) (((S) ) (m))) -> (((logic.eq) ((nat) )) ((((plus) ) ((((minus) ) (m)) (n))) (p))) ((((minus_body) ) ((y) (p))) (((S) ) (n))))) ((((sym_eq_plus) (((S) ) (m))) (fun (y:((nat) ) -> (nat) ) => ((((le) ) (((S) ) (n))) (((S) ) (m))) -> (((logic.eq) ((nat) )) ((((plus) ) ((((minus) ) (m)) (n))) (p))) ((((minus_body) ) ((y) (p))) (((S) ) (n))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((plus_body) )) (m)) (fun (y:((nat) ) -> (nat) ) => ((((le) ) (((S) ) (n))) (((S) ) (m))) -> (((logic.eq) ((nat) )) ((((plus) ) ((((minus) ) (m)) (n))) (p))) ((((minus_body) ) ((y) (p))) (((S) ) (n))))) ((((sym_eq_plus_body_S) (m)) (fun (y:((nat) ) -> (nat) ) => ((((le) ) (((S) ) (n))) (((S) ) (m))) -> (((logic.eq) ((nat) )) ((((plus) ) ((((minus) ) (m)) (n))) (p))) ((((minus_body) ) ((y) (p))) (((S) ) (n))))) ((((sym_eq_minus_body_S) ((((plus) ) (m)) (p))) (fun (y:((nat) ) -> (nat) ) => ((((le) ) (((S) ) (n))) (((S) ) (m))) -> (((logic.eq) ((nat) )) ((((plus) ) ((((minus) ) (m)) (n))) (p))) ((y) (((S) ) (n))))) (((((((sym_eq_match_nat_type_S) ((nat) )) (((S) ) ((((plus) ) (m)) (p)))) (fun (q:(nat) ) => (((minus) ) ((((plus) ) (m)) (p))) (q))) (n)) (fun (y:(nat) ) => ((((le) ) (((S) ) (n))) (((S) ) (m))) -> (((logic.eq) ((nat) )) ((((plus) ) ((((minus) ) (m)) (n))) (p))) (y))) (fun (auto':(((le) ) (((S) ) (n))) (((S) ) (m))) => (((auto) (p)) (((((logic.eq_coerc) ((((le) ) (((pred) ) (((S) ) (n)))) (((pred) ) (((S) ) (m))))) ((((le) ) (n)) (m))) ((((monotonic_pred) (((S) ) (n))) (((S) ) (m))) (auto'))) (((((((logic.rewrite_l) ((nat) )) (n)) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (__)) (((pred) ) (((S) ) (m))))) ((((le) ) (n)) (m)))) (((((((logic.rewrite_l) ((nat) )) (m)) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (n)) (__))) ((((le) ) (n)) (m)))) (((logic.refl) (Prop)) ((((le) ) (n)) (m)))) (((pred) ) (((S) ) (m)))) ((pred_Sn) (m)))) (((pred) ) (((S) ) (n)))) ((pred_Sn) (n)))))))))))))))))))))))).
Definition minus_plus_m_m : forall (n:(nat) ), forall (m:(nat) ), (((logic.eq) ((nat) )) (n)) ((((minus) ) ((((plus) ) (n)) (m))) (m)) := fun (n:(nat) ) => fun (m:(nat) ) => ((((logic.eq_coerc) ((((logic.eq) ((nat) )) ((((plus) ) ((((minus) ) (m)) (m))) (n))) ((((minus) ) ((((plus) ) (m)) (n))) (m)))) ((((logic.eq) ((nat) )) (n)) ((((minus) ) ((((plus) ) (n)) (m))) (m)))) (((((plus_minus) (m)) (m)) (n)) ((le_n) (m)))) (((((((logic.rewrite_l) ((nat) )) ((O) )) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((logic.eq) ((nat) )) ((((plus) ) (__)) (n))) ((((minus) ) ((((plus) ) (m)) (n))) (m)))) ((((logic.eq) ((nat) )) (n)) ((((minus) ) ((((plus) ) (n)) (m))) (m))))) (((((((logic.rewrite_l) ((nat) )) (n)) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((logic.eq) ((nat) )) (__)) ((((minus) ) ((((plus) ) (m)) (n))) (m)))) ((((logic.eq) ((nat) )) (n)) ((((minus) ) ((((plus) ) (n)) (m))) (m))))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (n)) (m))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((logic.eq) ((nat) )) (n)) ((((minus) ) (__)) (m)))) ((((logic.eq) ((nat) )) (n)) ((((minus) ) ((((plus) ) (n)) (m))) (m))))) (((logic.refl) (Prop)) ((((logic.eq) ((nat) )) (n)) ((((minus) ) ((((plus) ) (n)) (m))) (m))))) ((((plus) ) (m)) (n))) (((commutative_plus) (m)) (n)))) ((((plus) ) ((O) )) (n))) ((plus_O_n) (n)))) ((((minus) ) (m)) (m))) ((minus_n_n) (m))).
Definition plus_minus_m_m : forall (n:(nat) ), forall (m:(nat) ), ((((le) ) (m)) (n)) -> (((logic.eq) ((nat) )) (n)) ((((plus) ) ((((minus) ) (n)) (m))) (m)) := fun (n:(nat) ) => fun (m:(nat) ) => fun (lemn:(((le) ) (m)) (n)) => (((((logic.sym_eq) ((nat) )) ((((plus) ) ((((minus) ) (n)) (m))) (m))) (n)) (((((logic.eq_coerc) ((((logic.eq) ((nat) )) ((((plus) ) ((((minus) ) (n)) (m))) (m))) ((((minus) ) ((((plus) ) (n)) (m))) (m)))) ((((logic.eq) ((nat) )) ((((plus) ) ((((minus) ) (n)) (m))) (m))) (n))) (((((plus_minus) (m)) (n)) (m)) (lemn))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (m)) ((((minus) ) (n)) (m)))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((logic.eq) ((nat) )) ((((plus) ) ((((minus) ) (n)) (m))) (m))) ((((minus) ) ((((plus) ) (n)) (m))) (m)))) ((((logic.eq) ((nat) )) (__)) (n)))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (m)) ((((minus) ) (n)) (m)))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((logic.eq) ((nat) )) (__)) ((((minus) ) ((((plus) ) (n)) (m))) (m)))) ((((logic.eq) ((nat) )) ((((plus) ) (m)) ((((minus) ) (n)) (m)))) (n)))) (((((((logic.rewrite_l) ((nat) )) (n)) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((logic.eq) ((nat) )) ((((plus) ) (m)) ((((minus) ) (n)) (m)))) (__))) ((((logic.eq) ((nat) )) ((((plus) ) (m)) ((((minus) ) (n)) (m)))) (n)))) (((logic.refl) (Prop)) ((((logic.eq) ((nat) )) ((((plus) ) (m)) ((((minus) ) (n)) (m)))) (n)))) ((((minus) ) ((((plus) ) (n)) (m))) (m))) (((minus_plus_m_m) (n)) (m)))) ((((plus) ) ((((minus) ) (n)) (m))) (m))) (((commutative_plus) ((((minus) ) (n)) (m))) (m)))) ((((plus) ) ((((minus) ) (n)) (m))) (m))) (((commutative_plus) ((((minus) ) (n)) (m))) (m))))).
Definition minus_to_plus : forall (n:(nat) ), forall (m:(nat) ), forall (p:(nat) ), ((((le) ) (m)) (n)) -> ((((logic.eq) ((nat) )) ((((minus) ) (n)) (m))) (p)) -> (((logic.eq) ((nat) )) (n)) ((((plus) ) (m)) (p)) := fun (n:(nat) ) => fun (m:(nat) ) => fun (p:(nat) ) => fun (lemn:(((le) ) (m)) (n)) => (fun (eqp:(((logic.eq) ((nat) )) ((((minus) ) (n)) (m))) (p)) => (((((logic.eq_coerc) ((((logic.eq) ((nat) )) (n)) ((((plus) ) ((((minus) ) (n)) (m))) (m)))) ((((logic.eq) ((nat) )) (n)) ((((plus) ) (m)) (p)))) ((((plus_minus_m_m) (n)) (m)) (lemn))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (m)) ((((minus) ) (n)) (m)))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((logic.eq) ((nat) )) (n)) (__))) ((((logic.eq) ((nat) )) (n)) ((((plus) ) (m)) (p))))) (((((((logic.rewrite_r) ((nat) )) (p)) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((logic.eq) ((nat) )) (n)) ((((plus) ) (m)) (__)))) ((((logic.eq) ((nat) )) (n)) ((((plus) ) (m)) (p))))) (((logic.refl) (Prop)) ((((logic.eq) ((nat) )) (n)) ((((plus) ) (m)) (p))))) ((((minus) ) (n)) (m))) (eqp))) ((((plus) ) ((((minus) ) (n)) (m))) (m))) (((commutative_plus) ((((minus) ) (n)) (m))) (m))))).
Definition plus_to_minus : forall (n:(nat) ), forall (m:(nat) ), forall (p:(nat) ), ((((logic.eq) ((nat) )) (n)) ((((plus) ) (m)) (p))) -> (((logic.eq) ((nat) )) ((((minus) ) (n)) (m))) (p) := fun (n:(nat) ) => fun (m:(nat) ) => fun (p:(nat) ) => fun (eqp:(((logic.eq) ((nat) )) (n)) ((((plus) ) (m)) (p))) => (((((logic.sym_eq) ((nat) )) (p)) ((((minus) ) (n)) (m))) (((((logic.eq_coerc) ((((logic.eq) ((nat) )) (p)) ((((minus) ) ((((plus) ) (p)) (m))) (m)))) ((((logic.eq) ((nat) )) (p)) ((((minus) ) (n)) (m)))) (((minus_plus_m_m) (p)) (m))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (m)) (p))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((logic.eq) ((nat) )) (p)) ((((minus) ) (__)) (m)))) ((((logic.eq) ((nat) )) (p)) ((((minus) ) (n)) (m))))) (((((((logic.rewrite_l) ((nat) )) (n)) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((logic.eq) ((nat) )) (p)) ((((minus) ) (__)) (m)))) ((((logic.eq) ((nat) )) (p)) ((((minus) ) (n)) (m))))) (((logic.refl) (Prop)) ((((logic.eq) ((nat) )) (p)) ((((minus) ) (n)) (m))))) ((((plus) ) (m)) (p))) (eqp))) ((((plus) ) (p)) (m))) (((commutative_plus) (p)) (m))))).
Definition monotonic_le_minus_l : forall (p:(nat) ), forall (q:(nat) ), forall (n:(nat) ), ((((le) ) (q)) (p)) -> (((le) ) ((((minus) ) (q)) (n))) ((((minus) ) (p)) (n)) := ((((nat_elim2) (fun (__:(nat) ) => fun (_0:(nat) ) => forall (n:(nat) ), ((((le) ) (_0)) (__)) -> (((le) ) ((((minus) ) (_0)) (n))) ((((minus) ) (__)) (n)))) (fun (p:(nat) ) => fun (q:(nat) ) => fun (lePO:(((le) ) (p)) ((O) )) => (((((le_n_O_elim) (p)) (lePO)) (fun (__:(nat) ) => (((le) ) ((((minus) ) (__)) (q))) ((((minus) ) ((O) )) (q)))) ((le_n) ((((minus) ) ((O) )) (q)))))) (fun (p:(nat) ) => fun (q:(nat) ) => (((sym_eq_minus) (((S) ) (p))) (fun (y:((nat) ) -> (nat) ) => ((((le) ) ((O) )) (((S) ) (p))) -> (((le) ) ((((minus) ) ((O) )) (q))) ((y) (q)))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((minus_body) )) (p)) (fun (y:((nat) ) -> (nat) ) => ((((le) ) ((O) )) (((S) ) (p))) -> (((le) ) ((((minus) ) ((O) )) (q))) ((y) (q)))) ((((sym_eq_minus_body_S) (p)) (fun (y:((nat) ) -> (nat) ) => ((((le) ) ((O) )) (((S) ) (p))) -> (((le) ) ((((minus) ) ((O) )) (q))) ((y) (q)))) (((eq_plus_body_O) (fun (y:((nat) ) -> (nat) ) => ((((le) ) ((O) )) (((S) ) (p))) -> (((le) ) ((((minus) ) ((O) )) (q))) ((y) (((((match_nat_type) ((nat) )) (((S) ) (p))) (fun (q0:(nat) ) => (((minus) ) (p)) (q0))) (q))))) (((((eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((plus_body) )) (fun (y:((nat) ) -> (nat) ) => ((((le) ) ((O) )) (((S) ) (p))) -> (((le) ) ((((minus) ) ((O) )) (q))) ((y) (((((match_nat_type) ((nat) )) (((S) ) (p))) (fun (q0:(nat) ) => (((minus) ) (p)) (q0))) (q))))) ((((eq_plus) ((O) )) (fun (y:((nat) ) -> (nat) ) => ((((le) ) ((O) )) (((S) ) (p))) -> (((le) ) ((((minus) ) ((O) )) (q))) ((y) (((((match_nat_type) ((nat) )) (((S) ) (p))) (fun (q0:(nat) ) => (((minus) ) (p)) (q0))) (q))))) (((eq_minus_body_O) (fun (y:((nat) ) -> (nat) ) => ((((le) ) ((O) )) (((S) ) (p))) -> (((le) ) ((((minus) ) ((O) )) (q))) ((((plus) ) ((y) (((((match_nat_type) ((nat) )) (((S) ) (p))) (fun (q0:(nat) ) => (((minus) ) (p)) (q0))) (q)))) (((((match_nat_type) ((nat) )) (((S) ) (p))) (fun (q0:(nat) ) => (((minus) ) (p)) (q0))) (q))))) (((((eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((minus_body) )) (fun (y:((nat) ) -> (nat) ) => ((((le) ) ((O) )) (((S) ) (p))) -> (((le) ) ((((minus) ) ((O) )) (q))) ((((plus) ) ((y) (((((match_nat_type) ((nat) )) (((S) ) (p))) (fun (q0:(nat) ) => (((minus) ) (p)) (q0))) (q)))) (((((match_nat_type) ((nat) )) (((S) ) (p))) (fun (q0:(nat) ) => (((minus) ) (p)) (q0))) (q))))) ((((eq_minus) ((O) )) (fun (y:((nat) ) -> (nat) ) => ((((le) ) ((O) )) (((S) ) (p))) -> (((le) ) ((((minus) ) ((O) )) (q))) ((((plus) ) ((y) (((((match_nat_type) ((nat) )) (((S) ) (p))) (fun (q0:(nat) ) => (((minus) ) (p)) (q0))) (q)))) (((((match_nat_type) ((nat) )) (((S) ) (p))) (fun (q0:(nat) ) => (((minus) ) (p)) (q0))) (q))))) (((eq_minus_body_O) (fun (y:((nat) ) -> (nat) ) => ((((le) ) ((O) )) (((S) ) (p))) -> (((le) ) ((((minus) ) ((O) )) (q))) ((((plus) ) ((((minus) ) ((y) (q))) (((((match_nat_type) ((nat) )) (((S) ) (p))) (fun (q0:(nat) ) => (((minus) ) (p)) (q0))) (q)))) (((((match_nat_type) ((nat) )) (((S) ) (p))) (fun (q0:(nat) ) => (((minus) ) (p)) (q0))) (q))))) (((((eq_filter_nat_type_O) (((nat) ) -> (nat) )) ((minus_body) )) (fun (y:((nat) ) -> (nat) ) => ((((le) ) ((O) )) (((S) ) (p))) -> (((le) ) ((((minus) ) ((O) )) (q))) ((((plus) ) ((((minus) ) ((y) (q))) (((((match_nat_type) ((nat) )) (((S) ) (p))) (fun (q0:(nat) ) => (((minus) ) (p)) (q0))) (q)))) (((((match_nat_type) ((nat) )) (((S) ) (p))) (fun (q0:(nat) ) => (((minus) ) (p)) (q0))) (q))))) ((((eq_minus) ((O) )) (fun (y:((nat) ) -> (nat) ) => ((((le) ) ((O) )) (((S) ) (p))) -> (((le) ) ((((minus) ) ((O) )) (q))) ((((plus) ) ((((minus) ) ((y) (q))) (((((match_nat_type) ((nat) )) (((S) ) (p))) (fun (q0:(nat) ) => (((minus) ) (p)) (q0))) (q)))) (((((match_nat_type) ((nat) )) (((S) ) (p))) (fun (q0:(nat) ) => (((minus) ) (p)) (q0))) (q))))) (fun (auto:(((le) ) ((O) )) (((S) ) (p))) => (((le_plus_minus_m_m) ((((minus) ) ((O) )) (q))) (((((match_nat_type) ((nat) )) (((S) ) (p))) (fun (q0:(nat) ) => (((minus) ) (p)) (q0))) (q))))))))))))))))) (fun (p:(nat) ) => fun (q:(nat) ) => fun (Hind:forall (n0:(nat) ), ((((le) ) (q)) (p)) -> (((le) ) ((((minus) ) (q)) (n0))) ((((minus) ) (p)) (n0))) => (fun (n:(nat) ) => ((((match_nat_prop) (fun (__:(nat) ) => ((((le) ) (((S) ) (q))) (((S) ) (p))) -> (((le) ) ((((minus) ) (((S) ) (q))) (__))) ((((minus) ) (((S) ) (p))) (__)))) ((((sym_eq_minus) (((S) ) (q))) (fun (y:((nat) ) -> (nat) ) => ((((le) ) (((S) ) (q))) (((S) ) (p))) -> (((le) ) ((y) ((O) ))) ((((minus) ) (((S) ) (p))) ((O) )))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((minus_body) )) (q)) (fun (y:((nat) ) -> (nat) ) => ((((le) ) (((S) ) (q))) (((S) ) (p))) -> (((le) ) ((y) ((O) ))) ((((minus) ) (((S) ) (p))) ((O) )))) ((((sym_eq_minus_body_S) (q)) (fun (y:((nat) ) -> (nat) ) => ((((le) ) (((S) ) (q))) (((S) ) (p))) -> (((le) ) ((y) ((O) ))) ((((minus) ) (((S) ) (p))) ((O) )))) ((((((sym_eq_match_nat_type_O) ((nat) )) (((S) ) (q))) (fun (z:(nat) ) => (((minus) ) (q)) (z))) (fun (y:(nat) ) => ((((le) ) (((S) ) (q))) (((S) ) (p))) -> (((le) ) (y)) ((((minus) ) (((S) ) (p))) ((O) )))) ((((sym_eq_minus) (((S) ) (p))) (fun (y:((nat) ) -> (nat) ) => ((((le) ) (((S) ) (q))) (((S) ) (p))) -> (((le) ) (((S) ) (q))) ((y) ((O) )))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((minus_body) )) (p)) (fun (y:((nat) ) -> (nat) ) => ((((le) ) (((S) ) (q))) (((S) ) (p))) -> (((le) ) (((S) ) (q))) ((y) ((O) )))) ((((sym_eq_minus_body_S) (p)) (fun (y:((nat) ) -> (nat) ) => ((((le) ) (((S) ) (q))) (((S) ) (p))) -> (((le) ) (((S) ) (q))) ((y) ((O) )))) ((((((sym_eq_match_nat_type_O) ((nat) )) (((S) ) (p))) (fun (q0:(nat) ) => (((minus) ) (p)) (q0))) (fun (y:(nat) ) => ((((le) ) (((S) ) (q))) (((S) ) (p))) -> (((le) ) (((S) ) (q))) (y))) (fun (auto:(((le) ) (((S) ) (q))) (((S) ) (p))) => (auto))))))))))) ((((sym_eq_minus) (((S) ) (q))) (fun (y:((nat) ) -> (nat) ) => forall (a:(nat) ), ((((le) ) (((S) ) (q))) (((S) ) (p))) -> (((le) ) ((y) (((S) ) (a)))) ((((minus) ) (((S) ) (p))) (((S) ) (a))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((minus_body) )) (q)) (fun (y:((nat) ) -> (nat) ) => forall (a:(nat) ), ((((le) ) (((S) ) (q))) (((S) ) (p))) -> (((le) ) ((y) (((S) ) (a)))) ((((minus) ) (((S) ) (p))) (((S) ) (a))))) ((((sym_eq_minus_body_S) (q)) (fun (y:((nat) ) -> (nat) ) => forall (a:(nat) ), ((((le) ) (((S) ) (q))) (((S) ) (p))) -> (((le) ) ((y) (((S) ) (a)))) ((((minus) ) (((S) ) (p))) (((S) ) (a))))) (fun (a:(nat) ) => ((((((sym_eq_match_nat_type_S) ((nat) )) (((S) ) (q))) (fun (z:(nat) ) => (((minus) ) (q)) (z))) (a)) (fun (y:(nat) ) => ((((le) ) (((S) ) (q))) (((S) ) (p))) -> (((le) ) (y)) ((((minus) ) (((S) ) (p))) (((S) ) (a))))) ((((sym_eq_minus) (((S) ) (p))) (fun (y:((nat) ) -> (nat) ) => ((((le) ) (((S) ) (q))) (((S) ) (p))) -> (((le) ) ((((minus) ) (q)) (a))) ((y) (((S) ) (a))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (nat) )) ((minus_body) )) (p)) (fun (y:((nat) ) -> (nat) ) => ((((le) ) (((S) ) (q))) (((S) ) (p))) -> (((le) ) ((((minus) ) (q)) (a))) ((y) (((S) ) (a))))) ((((sym_eq_minus_body_S) (p)) (fun (y:((nat) ) -> (nat) ) => ((((le) ) (((S) ) (q))) (((S) ) (p))) -> (((le) ) ((((minus) ) (q)) (a))) ((y) (((S) ) (a))))) (((((((sym_eq_match_nat_type_S) ((nat) )) (((S) ) (p))) (fun (q0:(nat) ) => (((minus) ) (p)) (q0))) (a)) (fun (y:(nat) ) => ((((le) ) (((S) ) (q))) (((S) ) (p))) -> (((le) ) ((((minus) ) (q)) (a))) (y))) (fun (leSS:(((le) ) (((S) ) (q))) (((S) ) (p))) => (((Hind) (a)) (((((logic.eq_coerc) ((((le) ) (((pred) ) (((S) ) (q)))) (((pred) ) (((S) ) (p))))) ((((le) ) (q)) (p))) ((((monotonic_pred) (((S) ) (q))) (((S) ) (p))) (leSS))) (((((((logic.rewrite_l) ((nat) )) (q)) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (__)) (((pred) ) (((S) ) (p))))) ((((le) ) (q)) (p)))) (((((((logic.rewrite_l) ((nat) )) (p)) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (q)) (__))) ((((le) ) (q)) (p)))) (((logic.refl) (Prop)) ((((le) ) (q)) (p)))) (((pred) ) (((S) ) (p)))) ((pred_Sn) (p)))) (((pred) ) (((S) ) (q)))) ((pred_Sn) (q))))))))))))))) (n))).
Definition le_plus_to_minus : forall (n:(nat) ), forall (m:(nat) ), forall (p:(nat) ), ((((le) ) (n)) ((((plus) ) (p)) (m))) -> (((le) ) ((((minus) ) (n)) (m))) (p) := fun (n:(nat) ) => fun (m:(nat) ) => fun (p:(nat) ) => fun (lep:(((le) ) (n)) ((((plus) ) (p)) (m))) => (((((logic.eq_coerc) ((((le) ) ((((minus) ) (n)) (m))) ((((minus) ) ((((plus) ) (p)) (m))) (m)))) ((((le) ) ((((minus) ) (n)) (m))) (p))) (((((monotonic_le_minus_l) ((((plus) ) (p)) (m))) (n)) (m)) (lep))) (((((((logic.rewrite_l) ((nat) )) (p)) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) ((((minus) ) (n)) (m))) (__))) ((((le) ) ((((minus) ) (n)) (m))) (p)))) (((logic.refl) (Prop)) ((((le) ) ((((minus) ) (n)) (m))) (p)))) ((((minus) ) ((((plus) ) (p)) (m))) (m))) (((minus_plus_m_m) (p)) (m)))).
Definition monotonic_le_minus_r : forall (p:(nat) ), forall (q:(nat) ), forall (n:(nat) ), ((((le) ) (q)) (p)) -> (((le) ) ((((minus) ) (n)) (p))) ((((minus) ) (n)) (q)) := fun (p:(nat) ) => fun (q:(nat) ) => fun (n:(nat) ) => fun (lepq:(((le) ) (q)) (p)) => (((((le_plus_to_minus) (n)) (p)) ((((minus) ) (n)) (q))) ((((((transitive_le) (n)) ((((plus) ) ((((minus) ) (n)) (q))) (q))) ((((plus) ) ((((minus) ) (n)) (q))) (p))) (((le_plus_minus_m_m) (n)) (q))) (((((monotonic_le_plus_r) ((((minus) ) (n)) (q))) (q)) (p)) (lepq)))).
Definition minus_le : forall (x:(nat) ), forall (y:(nat) ), (((le) ) ((((minus) ) (x)) (y))) (x) := fun (x:(nat) ) => fun (y:(nat) ) => ((((logic.eq_coerc) ((((le) ) ((((minus) ) (x)) (y))) ((((minus) ) ((((plus) ) (x)) (y))) (y)))) ((((le) ) ((((minus) ) (x)) (y))) (x))) (((((monotonic_le_minus_l) ((((plus) ) (x)) (y))) (x)) (y)) (((le_plus_n_r) (y)) (x)))) (((((((logic.rewrite_l) ((nat) )) (x)) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) ((((minus) ) (x)) (y))) (__))) ((((le) ) ((((minus) ) (x)) (y))) (x)))) (((logic.refl) (Prop)) ((((le) ) ((((minus) ) (x)) (y))) (x)))) ((((minus) ) ((((plus) ) (x)) (y))) (y))) (((minus_plus_m_m) (x)) (y))).
Definition not_eq_to_le_to_lt : forall (n:(nat) ), forall (m:(nat) ), (((connectives.Not) ) ((((logic.eq) ((nat) )) (n)) (m))) -> ((((le) ) (n)) (m)) -> (((lt) ) (n)) (m) := fun (n:(nat) ) => fun (m:(nat) ) => fun (Hneq:((connectives.Not) ) ((((logic.eq) ((nat) )) (n)) (m))) => (fun (Hle:(((le) ) (n)) (m)) => (((((((connectives.match_Or_prop) ((((lt) ) (n)) (m))) ((((logic.eq) ((nat) )) (n)) (m))) ((((lt) ) (n)) (m))) (fun (auto:(((lt) ) (n)) (m)) => (auto))) (fun (Heq:(((logic.eq) ((nat) )) (n)) (m)) => ((((not_le_to_lt) (m)) (n)) (((((logic.not_to_not) ((((le) ) (m)) (n))) ((((logic.eq) ((nat) )) (n)) (m))) (fun (auto:(((le) ) (m)) (n)) => (((((((logic.rewrite_l) ((nat) )) (n)) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (n)) (__))) (((logic.refl) ((nat) )) (n))) (m)) (Heq)))) (Hneq))))) ((((le_to_or_lt_eq) (n)) (m)) (Hle)))).
Definition eq_minus_O : forall (n:(nat) ), forall (m:(nat) ), ((((le) ) (n)) (m)) -> (((logic.eq) ((nat) )) ((((minus) ) (n)) (m))) ((O) ) := fun (n:(nat) ) => fun (m:(nat) ) => fun (lenm:(((le) ) (n)) (m)) => (((((le_n_O_elim) ((((minus) ) (n)) (m))) (((((logic.eq_coerc) ((((le) ) ((((minus) ) (n)) (m))) ((((minus) ) (n)) (n)))) ((((le) ) ((((minus) ) (n)) (m))) ((O) ))) (((((monotonic_le_minus_r) (m)) (n)) (n)) (lenm))) (((((((logic.rewrite_l) ((nat) )) ((O) )) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) ((((minus) ) (n)) (m))) (__))) ((((le) ) ((((minus) ) (n)) (m))) ((O) )))) (((logic.refl) (Prop)) ((((le) ) ((((minus) ) (n)) (m))) ((O) )))) ((((minus) ) (n)) (n))) ((minus_n_n) (n))))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (__)) ((O) ))) (((logic.refl) ((nat) )) ((O) ))).
Definition distributive_times_minus : (((relations.distributive) ((nat) )) ((times) )) ((minus) ) := fun (a:(nat) ) => fun (b:(nat) ) => fun (c:(nat) ) => ((((((connectives.match_Or_prop) ((((lt) ) (b)) (c))) (((connectives.Not) ) ((((lt) ) (b)) (c)))) ((((logic.eq) ((nat) )) ((((times) ) (a)) ((((minus) ) (b)) (c)))) ((((minus) ) ((((times) ) (a)) (b))) ((((times) ) (a)) (c))))) (fun (Hbc:(((lt) ) (b)) (c)) => (((((((logic.eq_ind_r) ((nat) )) ((O) )) (fun (x:(nat) ) => (((logic.eq) ((nat) )) ((((times) ) (a)) (x))) ((((minus) ) ((((times) ) (a)) (b))) ((((times) ) (a)) (c))))) (((((((logic.eq_ind_r) ((nat) )) ((O) )) (fun (x:(nat) ) => (((logic.eq) ((nat) )) ((((times) ) (a)) ((O) ))) (x))) (((((((logic.rewrite_l) ((nat) )) ((O) )) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (__)) ((O) ))) (((logic.refl) ((nat) )) ((O) ))) ((((times) ) (a)) ((O) ))) ((times_n_O) (a)))) ((((minus) ) ((((times) ) (a)) (b))) ((((times) ) (a)) (c)))) ((((eq_minus_O) ((((times) ) (a)) (b))) ((((times) ) (a)) (c))) (((((monotonic_le_times_r) (a)) (b)) (c)) ((((lt_to_le) (b)) (c)) (Hbc)))))) ((((minus) ) (b)) (c))) ((((eq_minus_O) (b)) (c)) ((((lt_to_le) (b)) (c)) (Hbc)))))) (fun (Hbc:((connectives.Not) ) ((((lt) ) (b)) (c))) => (((((logic.sym_eq) ((nat) )) ((((minus) ) ((((times) ) (a)) (b))) ((((times) ) (a)) (c)))) ((((times) ) (a)) ((((minus) ) (b)) (c)))) (((((logic.eq_coerc) ((((logic.eq) ((nat) )) ((((minus) ) ((((times) ) (a)) (b))) ((((times) ) (a)) (c)))) ((((times) ) (a)) ((((minus) ) (b)) (c))))) ((((logic.eq) ((nat) )) ((((minus) ) ((((times) ) (a)) (b))) ((((times) ) (a)) (c)))) ((((times) ) (a)) ((((minus) ) (b)) (c))))) (((((plus_to_minus) ((((times) ) (a)) (b))) ((((times) ) (a)) (c))) ((((times) ) (a)) ((((minus) ) (b)) (c)))) (((((((logic.eq_ind) ((nat) )) ((((times) ) (a)) ((((plus) ) (c)) ((((minus) ) (b)) (c))))) (fun (x_1:(nat) ) => (((logic.eq) ((nat) )) ((((times) ) (a)) (b))) (x_1))) (((((((logic.eq_f) ((nat) )) ((nat) )) (((times) ) (a))) (b)) ((((plus) ) (c)) ((((minus) ) (b)) (c)))) (((((logic.eq_coerc) ((((logic.eq) ((nat) )) (b)) ((((plus) ) ((((minus) ) (b)) (c))) (c)))) ((((logic.eq) ((nat) )) (b)) ((((plus) ) (c)) ((((minus) ) (b)) (c))))) ((((plus_minus_m_m) (b)) (c)) ((((not_lt_to_le) (b)) (c)) (Hbc)))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (c)) ((((minus) ) (b)) (c)))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((logic.eq) ((nat) )) (b)) (__))) ((((logic.eq) ((nat) )) (b)) ((((plus) ) (c)) ((((minus) ) (b)) (c)))))) (((logic.refl) (Prop)) ((((logic.eq) ((nat) )) (b)) ((((plus) ) (c)) ((((minus) ) (b)) (c)))))) ((((plus) ) ((((minus) ) (b)) (c))) (c))) (((commutative_plus) ((((minus) ) (b)) (c))) (c)))))) ((((plus) ) ((((times) ) (a)) (c))) ((((times) ) (a)) ((((minus) ) (b)) (c))))) ((((distributive_times_plus) (a)) (c)) ((((minus) ) (b)) (c)))))) (((logic.refl) (Prop)) ((((logic.eq) ((nat) )) ((((minus) ) ((((times) ) (a)) (b))) ((((times) ) (a)) (c)))) ((((times) ) (a)) ((((minus) ) (b)) (c))))))))) (((decidable_lt) (b)) (c)).
Definition minus_plus : forall (n:(nat) ), forall (m:(nat) ), forall (p:(nat) ), (((logic.eq) ((nat) )) ((((minus) ) ((((minus) ) (n)) (m))) (p))) ((((minus) ) (n)) ((((plus) ) (m)) (p))) := fun (n:(nat) ) => fun (m:(nat) ) => fun (p:(nat) ) => ((((((connectives.match_Or_prop) ((((le) ) ((((plus) ) (m)) (p))) (n))) (((connectives.Not) ) ((((le) ) ((((plus) ) (m)) (p))) (n)))) ((((logic.eq) ((nat) )) ((((minus) ) ((((minus) ) (n)) (m))) (p))) ((((minus) ) (n)) ((((plus) ) (m)) (p))))) (fun (Hlt:(((le) ) ((((plus) ) (m)) (p))) (n)) => (((((plus_to_minus) ((((minus) ) (n)) (m))) (p)) ((((minus) ) (n)) ((((plus) ) (m)) (p)))) (((((plus_to_minus) (n)) (m)) ((((plus) ) (p)) ((((minus) ) (n)) ((((plus) ) (m)) (p))))) (((((((logic.eq_ind) ((nat) )) ((((plus) ) ((((plus) ) (m)) (p))) ((((minus) ) (n)) ((((plus) ) (m)) (p))))) (fun (x_1:(nat) ) => (((logic.eq) ((nat) )) (n)) (x_1))) ((((((minus_to_plus) (n)) ((((plus) ) (m)) (p))) ((((minus) ) (n)) ((((plus) ) (m)) (p)))) (Hlt)) (((logic.refl) ((nat) )) ((((minus) ) (n)) ((((plus) ) (m)) (p)))))) ((((plus) ) (m)) ((((plus) ) (p)) ((((minus) ) (n)) ((((plus) ) (m)) (p)))))) ((((associative_plus) (m)) (p)) ((((minus) ) (n)) ((((plus) ) (m)) (p))))))))) (fun (Hlt:((connectives.Not) ) ((((le) ) ((((plus) ) (m)) (p))) (n))) => (((((((logic.eq_ind_r) ((nat) )) ((O) )) (fun (x:(nat) ) => (((logic.eq) ((nat) )) (x)) ((((minus) ) (n)) ((((plus) ) (m)) (p))))) (((((logic.sym_eq) ((nat) )) ((((minus) ) (n)) ((((plus) ) (m)) (p)))) ((O) )) (((((logic.eq_coerc) ((((logic.eq) ((nat) )) ((((minus) ) (n)) ((((plus) ) (m)) (p)))) ((O) ))) ((((logic.eq) ((nat) )) ((((minus) ) (n)) ((((plus) ) (m)) (p)))) ((O) ))) ((((eq_minus_O) (n)) ((((plus) ) (m)) (p))) ((((((transitive_le) (n)) (((S) ) (n))) ((((plus) ) (m)) (p))) ((le_n_Sn) (n))) ((((not_le_to_lt) ((((plus) ) (m)) (p))) (n)) (Hlt))))) (((logic.refl) (Prop)) ((((logic.eq) ((nat) )) ((((minus) ) (n)) ((((plus) ) (m)) (p)))) ((O) )))))) ((((minus) ) ((((minus) ) (n)) (m))) (p))) ((((eq_minus_O) ((((minus) ) (n)) (m))) (p)) (((((logic.eq_coerc) ((((le) ) ((((minus) ) (n)) (m))) ((((minus) ) ((((plus) ) (p)) (m))) (m)))) ((((le) ) ((((minus) ) (n)) (m))) (p))) (((((monotonic_le_minus_l) ((((plus) ) (p)) (m))) (n)) (m)) (((((logic.eq_coerc) ((((le) ) (n)) ((((plus) ) (m)) (p)))) ((((le) ) (n)) ((((plus) ) (p)) (m)))) ((((((transitive_le) (n)) (((S) ) (n))) ((((plus) ) (m)) (p))) ((le_n_Sn) (n))) ((((not_le_to_lt) ((((plus) ) (m)) (p))) (n)) (Hlt)))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (m)) (p))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) (n)) ((((plus) ) (m)) (p)))) ((((le) ) (n)) (__)))) (((logic.refl) (Prop)) ((((le) ) (n)) ((((plus) ) (m)) (p))))) ((((plus) ) (p)) (m))) (((commutative_plus) (p)) (m)))))) (((((((logic.rewrite_l) ((nat) )) (p)) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) ((((minus) ) (n)) (m))) (__))) ((((le) ) ((((minus) ) (n)) (m))) (p)))) (((logic.refl) (Prop)) ((((le) ) ((((minus) ) (n)) (m))) (p)))) ((((minus) ) ((((plus) ) (p)) (m))) (m))) (((minus_plus_m_m) (p)) (m)))))))) (((decidable_le) ((((plus) ) (m)) (p))) (n)).
Definition minus_minus : forall (n:(nat) ), forall (m:(nat) ), forall (p:(nat) ), ((((le) ) (p)) (m)) -> ((((le) ) (m)) (n)) -> (((logic.eq) ((nat) )) ((((plus) ) (p)) ((((minus) ) (n)) (m)))) ((((minus) ) (n)) ((((minus) ) (m)) (p))) := fun (n:(nat) ) => fun (m:(nat) ) => fun (p:(nat) ) => fun (lepm:(((le) ) (p)) (m)) => (fun (lemn:(((le) ) (m)) (n)) => (((((logic.sym_eq) ((nat) )) ((((minus) ) (n)) ((((minus) ) (m)) (p)))) ((((plus) ) (p)) ((((minus) ) (n)) (m)))) (((((plus_to_minus) (n)) ((((minus) ) (m)) (p))) ((((plus) ) (p)) ((((minus) ) (n)) (m)))) (((((((logic.eq_ind) ((nat) )) ((((plus) ) ((((plus) ) ((((minus) ) (m)) (p))) (p))) ((((minus) ) (n)) (m)))) (fun (x_1:(nat) ) => (((logic.eq) ((nat) )) (n)) (x_1))) (((((((logic.eq_ind) ((nat) )) (m)) (fun (x_1:(nat) ) => (((logic.eq) ((nat) )) (n)) ((((plus) ) (x_1)) ((((minus) ) (n)) (m))))) (((((((logic.eq_ind) ((nat) )) ((((plus) ) ((((minus) ) (n)) (m))) (m))) (fun (x_1:(nat) ) => (((logic.eq) ((nat) )) (n)) (x_1))) (((((((logic.eq_ind) ((nat) )) (n)) (fun (x_1:(nat) ) => (((logic.eq) ((nat) )) (n)) (x_1))) (((logic.refl) ((nat) )) (n))) ((((plus) ) ((((minus) ) (n)) (m))) (m))) ((((plus_minus_m_m) (n)) (m)) (lemn)))) ((((plus) ) (m)) ((((minus) ) (n)) (m)))) (((commutative_plus) ((((minus) ) (n)) (m))) (m)))) ((((plus) ) ((((minus) ) (m)) (p))) (p))) ((((plus_minus_m_m) (m)) (p)) (lepm)))) ((((plus) ) ((((minus) ) (m)) (p))) ((((plus) ) (p)) ((((minus) ) (n)) (m))))) ((((associative_plus) ((((minus) ) (m)) (p))) (p)) ((((minus) ) (n)) (m))))))).
Definition minus_minus_comm : forall (a:(nat) ), forall (b:(nat) ), forall (c:(nat) ), (((logic.eq) ((nat) )) ((((minus) ) ((((minus) ) (a)) (b))) (c))) ((((minus) ) ((((minus) ) (a)) (c))) (b)) := fun (a:(nat) ) => fun (b:(nat) ) => fun (c:(nat) ) => ((((le_to_le_to_eq) ((((minus) ) ((((minus) ) (a)) (b))) (c))) ((((minus) ) ((((minus) ) (a)) (c))) (b))) (((((logic.eq_coerc) ((((le) ) ((((minus) ) ((((minus) ) (a)) (b))) (c))) ((((minus) ) ((((plus) ) ((((minus) ) ((((minus) ) (a)) (c))) (b))) (c))) (c)))) ((((le) ) ((((minus) ) ((((minus) ) (a)) (b))) (c))) ((((minus) ) ((((minus) ) (a)) (c))) (b)))) (((((monotonic_le_minus_l) ((((plus) ) ((((minus) ) ((((minus) ) (a)) (c))) (b))) (c))) ((((minus) ) (a)) (b))) (c)) (((((logic.eq_coerc) ((((le) ) ((((minus) ) (a)) (b))) ((((plus) ) ((((minus) ) ((((minus) ) (a)) (b))) (c))) (c)))) ((((le) ) ((((minus) ) (a)) (b))) ((((plus) ) ((((minus) ) ((((minus) ) (a)) (c))) (b))) (c)))) (((le_plus_minus_m_m) ((((minus) ) (a)) (b))) (c))) (((((((logic.rewrite_r) ((nat) )) ((((minus) ) (a)) ((((plus) ) (b)) (c)))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) ((((minus) ) (a)) (b))) ((((plus) ) (__)) (c)))) ((((le) ) ((((minus) ) (a)) (b))) ((((plus) ) ((((minus) ) ((((minus) ) (a)) (c))) (b))) (c))))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (c)) ((((minus) ) (a)) ((((plus) ) (b)) (c))))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) ((((minus) ) (a)) (b))) (__))) ((((le) ) ((((minus) ) (a)) (b))) ((((plus) ) ((((minus) ) ((((minus) ) (a)) (c))) (b))) (c))))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (c)) ((((minus) ) ((((minus) ) (a)) (c))) (b)))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) ((((minus) ) (a)) (b))) ((((plus) ) (c)) ((((minus) ) (a)) ((((plus) ) (b)) (c)))))) ((((le) ) ((((minus) ) (a)) (b))) (__)))) (((((((logic.rewrite_l) ((nat) )) ((((minus) ) ((((minus) ) (a)) (c))) (b))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) ((((minus) ) (a)) (b))) ((((plus) ) (c)) (__)))) ((((le) ) ((((minus) ) (a)) (b))) ((((plus) ) (c)) ((((minus) ) ((((minus) ) (a)) (c))) (b)))))) (((logic.refl) (Prop)) ((((le) ) ((((minus) ) (a)) (b))) ((((plus) ) (c)) ((((minus) ) ((((minus) ) (a)) (c))) (b)))))) ((((minus) ) (a)) ((((plus) ) (b)) (c)))) (((((((logic.rewrite_l) ((nat) )) ((((plus) ) (c)) (b))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((minus) ) ((((minus) ) (a)) (c))) (b))) ((((minus) ) (a)) (__)))) ((((minus_plus) (a)) (c)) (b))) ((((plus) ) (b)) (c))) (((commutative_plus) (c)) (b))))) ((((plus) ) ((((minus) ) ((((minus) ) (a)) (c))) (b))) (c))) (((commutative_plus) ((((minus) ) ((((minus) ) (a)) (c))) (b))) (c)))) ((((plus) ) ((((minus) ) (a)) ((((plus) ) (b)) (c)))) (c))) (((commutative_plus) ((((minus) ) (a)) ((((plus) ) (b)) (c)))) (c)))) ((((minus) ) ((((minus) ) (a)) (b))) (c))) ((((minus_plus) (a)) (b)) (c)))))) (((((((logic.rewrite_l) ((nat) )) ((((minus) ) ((((minus) ) (a)) (c))) (b))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) ((((minus) ) ((((minus) ) (a)) (b))) (c))) (__))) ((((le) ) ((((minus) ) ((((minus) ) (a)) (b))) (c))) ((((minus) ) ((((minus) ) (a)) (c))) (b))))) (((logic.refl) (Prop)) ((((le) ) ((((minus) ) ((((minus) ) (a)) (b))) (c))) ((((minus) ) ((((minus) ) (a)) (c))) (b))))) ((((minus) ) ((((plus) ) ((((minus) ) ((((minus) ) (a)) (c))) (b))) (c))) (c))) (((minus_plus_m_m) ((((minus) ) ((((minus) ) (a)) (c))) (b))) (c))))) (((((logic.eq_coerc) ((((le) ) ((((minus) ) ((((minus) ) (a)) (c))) (b))) ((((minus) ) ((((plus) ) ((((minus) ) ((((minus) ) (a)) (b))) (c))) (b))) (b)))) ((((le) ) ((((minus) ) ((((minus) ) (a)) (c))) (b))) ((((minus) ) ((((minus) ) (a)) (b))) (c)))) (((((monotonic_le_minus_l) ((((plus) ) ((((minus) ) ((((minus) ) (a)) (b))) (c))) (b))) ((((minus) ) (a)) (c))) (b)) (((((logic.eq_coerc) ((((le) ) ((((minus) ) (a)) (c))) ((((plus) ) ((((minus) ) ((((minus) ) (a)) (c))) (b))) (b)))) ((((le) ) ((((minus) ) (a)) (c))) ((((plus) ) ((((minus) ) ((((minus) ) (a)) (b))) (c))) (b)))) (((le_plus_minus_m_m) ((((minus) ) (a)) (c))) (b))) (((((((logic.rewrite_r) ((nat) )) ((((minus) ) (a)) ((((plus) ) (c)) (b)))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) ((((minus) ) (a)) (c))) ((((plus) ) (__)) (b)))) ((((le) ) ((((minus) ) (a)) (c))) ((((plus) ) ((((minus) ) ((((minus) ) (a)) (b))) (c))) (b))))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (b)) ((((minus) ) (a)) ((((plus) ) (c)) (b))))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) ((((minus) ) (a)) (c))) (__))) ((((le) ) ((((minus) ) (a)) (c))) ((((plus) ) ((((minus) ) ((((minus) ) (a)) (b))) (c))) (b))))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (b)) ((((minus) ) ((((minus) ) (a)) (b))) (c)))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) ((((minus) ) (a)) (c))) ((((plus) ) (b)) ((((minus) ) (a)) ((((plus) ) (c)) (b)))))) ((((le) ) ((((minus) ) (a)) (c))) (__)))) (((((((logic.rewrite_l) ((nat) )) ((((minus) ) ((((minus) ) (a)) (b))) (c))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) ((((minus) ) (a)) (c))) ((((plus) ) (b)) (__)))) ((((le) ) ((((minus) ) (a)) (c))) ((((plus) ) (b)) ((((minus) ) ((((minus) ) (a)) (b))) (c)))))) (((logic.refl) (Prop)) ((((le) ) ((((minus) ) (a)) (c))) ((((plus) ) (b)) ((((minus) ) ((((minus) ) (a)) (b))) (c)))))) ((((minus) ) (a)) ((((plus) ) (c)) (b)))) (((((((logic.rewrite_l) ((nat) )) ((((plus) ) (b)) (c))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((minus) ) ((((minus) ) (a)) (b))) (c))) ((((minus) ) (a)) (__)))) ((((minus_plus) (a)) (b)) (c))) ((((plus) ) (c)) (b))) (((commutative_plus) (b)) (c))))) ((((plus) ) ((((minus) ) ((((minus) ) (a)) (b))) (c))) (b))) (((commutative_plus) ((((minus) ) ((((minus) ) (a)) (b))) (c))) (b)))) ((((plus) ) ((((minus) ) (a)) ((((plus) ) (c)) (b)))) (b))) (((commutative_plus) ((((minus) ) (a)) ((((plus) ) (c)) (b)))) (b)))) ((((minus) ) ((((minus) ) (a)) (c))) (b))) ((((minus_plus) (a)) (c)) (b)))))) (((((((logic.rewrite_l) ((nat) )) ((((minus) ) ((((minus) ) (a)) (b))) (c))) (fun (__:(nat) ) => (((logic.eq) (Prop)) ((((le) ) ((((minus) ) ((((minus) ) (a)) (c))) (b))) (__))) ((((le) ) ((((minus) ) ((((minus) ) (a)) (c))) (b))) ((((minus) ) ((((minus) ) (a)) (b))) (c))))) (((logic.refl) (Prop)) ((((le) ) ((((minus) ) ((((minus) ) (a)) (c))) (b))) ((((minus) ) ((((minus) ) (a)) (b))) (c))))) ((((minus) ) ((((plus) ) ((((minus) ) ((((minus) ) (a)) (b))) (c))) (b))) (b))) (((minus_plus_m_m) ((((minus) ) ((((minus) ) (a)) (b))) (c))) (b)))).
Definition minus_le_minus_minus_comm : forall (b:(nat) ), forall (c:(nat) ), forall (a:(nat) ), ((((le) ) (c)) (b)) -> (((logic.eq) ((nat) )) ((((minus) ) (a)) ((((minus) ) (b)) (c)))) ((((minus) ) ((((plus) ) (a)) (c))) (b)) := fun (b:(nat) ) => fun (c:(nat) ) => fun (a:(nat) ) => fun (H:(((le) ) (c)) (b)) => (((((((logic.eq_ind_r) ((nat) )) ((((plus) ) ((((minus) ) (b)) (c))) (c))) (fun (x:(nat) ) => (((logic.eq) ((nat) )) ((((minus) ) (a)) ((((minus) ) (b)) (c)))) ((((minus) ) ((((plus) ) (a)) (c))) (x)))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (c)) (a))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((minus) ) (a)) ((((minus) ) (b)) (c)))) ((((minus) ) (__)) ((((plus) ) ((((minus) ) (b)) (c))) (c))))) (((((((logic.rewrite_r) ((nat) )) ((((plus) ) (c)) ((((minus) ) (b)) (c)))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((minus) ) (a)) ((((minus) ) (b)) (c)))) ((((minus) ) ((((plus) ) (c)) (a))) (__)))) (((((((logic.rewrite_l) ((nat) )) ((((minus) ) ((((minus) ) ((((plus) ) (c)) (a))) (c))) ((((minus) ) (b)) (c)))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((minus) ) (a)) ((((minus) ) (b)) (c)))) (__))) (((((((logic.rewrite_r) ((nat) )) ((((minus) ) ((((plus) ) (c)) (a))) (c))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((minus) ) (__)) ((((minus) ) (b)) (c)))) ((((minus) ) ((((minus) ) ((((plus) ) (c)) (a))) (c))) ((((minus) ) (b)) (c))))) (((logic.refl) ((nat) )) ((((minus) ) ((((minus) ) ((((plus) ) (c)) (a))) (c))) ((((minus) ) (b)) (c))))) (a)) (((((((logic.rewrite_l) ((nat) )) ((((plus) ) (a)) (c))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (a)) ((((minus) ) (__)) (c)))) (((minus_plus_m_m) (a)) (c))) ((((plus) ) (c)) (a))) (((commutative_plus) (a)) (c))))) ((((minus) ) ((((plus) ) (c)) (a))) ((((plus) ) (c)) ((((minus) ) (b)) (c))))) ((((minus_plus) ((((plus) ) (c)) (a))) (c)) ((((minus) ) (b)) (c))))) ((((plus) ) ((((minus) ) (b)) (c))) (c))) (((commutative_plus) ((((minus) ) (b)) (c))) (c)))) ((((plus) ) (a)) (c))) (((commutative_plus) (a)) (c)))) (b)) ((((plus_minus_m_m) (b)) (c)) (H))).
Definition minus_plus_plus_l : forall (x:(nat) ), forall (y:(nat) ), forall (h:(nat) ), (((logic.eq) ((nat) )) ((((minus) ) ((((plus) ) (x)) (h))) ((((plus) ) (y)) (h)))) ((((minus) ) (x)) (y)) := fun (x:(nat) ) => fun (y:(nat) ) => fun (h:(nat) ) => ((((((logic.rewrite_l) ((nat) )) ((((minus) ) ((((minus) ) ((((plus) ) (x)) (h))) (y))) (h))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (__)) ((((minus) ) (x)) (y)))) (((((((logic.rewrite_r) ((nat) )) ((((minus) ) (x)) (y))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (__)) ((((minus) ) (x)) (y)))) (((logic.refl) ((nat) )) ((((minus) ) (x)) (y)))) ((((minus) ) ((((minus) ) ((((plus) ) (x)) (h))) (y))) (h))) (((((((logic.rewrite_r) ((nat) )) ((((minus) ) ((((plus) ) (x)) (h))) (h))) (fun (__:(nat) ) => (((logic.eq) ((nat) )) ((((minus) ) ((((minus) ) ((((plus) ) (x)) (h))) (y))) (h))) ((((minus) ) (__)) (y)))) ((((minus_minus_comm) ((((plus) ) (x)) (h))) (y)) (h))) (x)) (((minus_plus_m_m) (x)) (h))))) ((((minus) ) ((((plus) ) (x)) (h))) ((((plus) ) (y)) (h)))) ((((minus_plus) ((((plus) ) (x)) (h))) (y)) (h)).
Parameter eqb : ((nat) ) -> ((nat) ) -> (bool.bool) .
Parameter eqb_body : ((nat) ) -> ((nat) ) -> (bool.bool) .
Axiom axiom_eqb : forall (n:(nat) ), (((connectives.equal) (((nat) ) -> (bool.bool) )) (((eqb) ) (n))) ((((filter_nat_type) (((nat) ) -> (bool.bool) )) ((eqb_body) )) (n)).
Definition eq_eqb : forall (n:(nat) ), (((leibniz.leibniz) (((nat) ) -> (bool.bool) )) (((eqb) ) (n))) ((((filter_nat_type) (((nat) ) -> (bool.bool) )) ((eqb_body) )) (n)) := fun (n:(nat) ) => ((((connectives.equal_leibniz) (((nat) ) -> (bool.bool) )) (((eqb) ) (n))) ((((filter_nat_type) (((nat) ) -> (bool.bool) )) ((eqb_body) )) (n))) ((axiom_eqb) (n)).
Definition sym_eq_eqb : forall (n:(nat) ), (((leibniz.leibniz) (((nat) ) -> (bool.bool) )) ((((filter_nat_type) (((nat) ) -> (bool.bool) )) ((eqb_body) )) (n))) (((eqb) ) (n)) := fun (n:(nat) ) => ((((leibniz.sym_leibniz) (((nat) ) -> (bool.bool) )) (((eqb) ) (n))) ((((filter_nat_type) (((nat) ) -> (bool.bool) )) ((eqb_body) )) (n))) ((eq_eqb) (n)).
Axiom axiom_eqb_body_O : (((connectives.equal) (((nat) ) -> (bool.bool) )) (((eqb_body) ) ((O) ))) (fun (m:(nat) ) => ((((match_nat_type) ((bool.bool) )) ((bool.true) )) (fun (q:(nat) ) => (bool.false) )) (m)).
Definition eq_eqb_body_O : (((leibniz.leibniz) (((nat) ) -> (bool.bool) )) (((eqb_body) ) ((O) ))) (fun (m:(nat) ) => ((((match_nat_type) ((bool.bool) )) ((bool.true) )) (fun (q:(nat) ) => (bool.false) )) (m)) := ((((connectives.equal_leibniz) (((nat) ) -> (bool.bool) )) (((eqb_body) ) ((O) ))) (fun (m:(nat) ) => ((((match_nat_type) ((bool.bool) )) ((bool.true) )) (fun (q:(nat) ) => (bool.false) )) (m))) (axiom_eqb_body_O).
Definition sym_eq_eqb_body_O : (((leibniz.leibniz) (((nat) ) -> (bool.bool) )) (fun (m:(nat) ) => ((((match_nat_type) ((bool.bool) )) ((bool.true) )) (fun (q:(nat) ) => (bool.false) )) (m))) (((eqb_body) ) ((O) )) := ((((leibniz.sym_leibniz) (((nat) ) -> (bool.bool) )) (((eqb_body) ) ((O) ))) (fun (m:(nat) ) => ((((match_nat_type) ((bool.bool) )) ((bool.true) )) (fun (q:(nat) ) => (bool.false) )) (m))) (eq_eqb_body_O).
Axiom axiom_eqb_body_S : forall (n:(nat) ), (((connectives.equal) (((nat) ) -> (bool.bool) )) (((eqb_body) ) (((S) ) (n)))) (fun (m:(nat) ) => ((((match_nat_type) ((bool.bool) )) ((bool.false) )) (fun (q:(nat) ) => (((eqb) ) (n)) (q))) (m)).
Definition eq_eqb_body_S : forall (n:(nat) ), (((leibniz.leibniz) (((nat) ) -> (bool.bool) )) (((eqb_body) ) (((S) ) (n)))) (fun (m:(nat) ) => ((((match_nat_type) ((bool.bool) )) ((bool.false) )) (fun (q:(nat) ) => (((eqb) ) (n)) (q))) (m)) := fun (n:(nat) ) => ((((connectives.equal_leibniz) (((nat) ) -> (bool.bool) )) (((eqb_body) ) (((S) ) (n)))) (fun (m:(nat) ) => ((((match_nat_type) ((bool.bool) )) ((bool.false) )) (fun (q:(nat) ) => (((eqb) ) (n)) (q))) (m))) ((axiom_eqb_body_S) (n)).
Definition sym_eq_eqb_body_S : forall (n:(nat) ), (((leibniz.leibniz) (((nat) ) -> (bool.bool) )) (fun (m:(nat) ) => ((((match_nat_type) ((bool.bool) )) ((bool.false) )) (fun (q:(nat) ) => (((eqb) ) (n)) (q))) (m))) (((eqb_body) ) (((S) ) (n))) := fun (n:(nat) ) => ((((leibniz.sym_leibniz) (((nat) ) -> (bool.bool) )) (((eqb_body) ) (((S) ) (n)))) (fun (m:(nat) ) => ((((match_nat_type) ((bool.bool) )) ((bool.false) )) (fun (q:(nat) ) => (((eqb) ) (n)) (q))) (m))) ((eq_eqb_body_S) (n)).
Definition eqb_elim : forall (n:(nat) ), forall (m:(nat) ), forall (P:((bool.bool) ) -> Prop), (((((logic.eq) ((nat) )) (n)) (m)) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((logic.eq) ((nat) )) (n)) (m))) -> (P) ((bool.false) )) -> (P) ((((eqb) ) (n)) (m)) := ((((nat_elim2) (fun (__:(nat) ) => fun (_0:(nat) ) => forall (P:((bool.bool) ) -> Prop), (((((logic.eq) ((nat) )) (__)) (_0)) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((logic.eq) ((nat) )) (__)) (_0))) -> (P) ((bool.false) )) -> (P) ((((eqb) ) (__)) (_0)))) (fun (n:(nat) ) => ((((match_nat_prop) (fun (__:(nat) ) => forall (P:((bool.bool) ) -> Prop), (((((logic.eq) ((nat) )) ((O) )) (__)) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((logic.eq) ((nat) )) ((O) )) (__))) -> (P) ((bool.false) )) -> (P) ((((eqb) ) ((O) )) (__)))) ((((sym_eq_eqb) ((O) )) (fun (y:((nat) ) -> (bool.bool) ) => forall (P:((bool.bool) ) -> Prop), (((((logic.eq) ((nat) )) ((O) )) ((O) )) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((logic.eq) ((nat) )) ((O) )) ((O) ))) -> (P) ((bool.false) )) -> (P) ((y) ((O) )))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (bool.bool) )) ((eqb_body) )) (fun (y:((nat) ) -> (bool.bool) ) => forall (P:((bool.bool) ) -> Prop), (((((logic.eq) ((nat) )) ((O) )) ((O) )) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((logic.eq) ((nat) )) ((O) )) ((O) ))) -> (P) ((bool.false) )) -> (P) ((y) ((O) )))) (((sym_eq_eqb_body_O) (fun (y:((nat) ) -> (bool.bool) ) => forall (P:((bool.bool) ) -> Prop), (((((logic.eq) ((nat) )) ((O) )) ((O) )) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((logic.eq) ((nat) )) ((O) )) ((O) ))) -> (P) ((bool.false) )) -> (P) ((y) ((O) )))) ((((((sym_eq_match_nat_type_O) ((bool.bool) )) ((bool.true) )) (fun (q:(nat) ) => (bool.false) )) (fun (y:(bool.bool) ) => forall (P:((bool.bool) ) -> Prop), (((((logic.eq) ((nat) )) ((O) )) ((O) )) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((logic.eq) ((nat) )) ((O) )) ((O) ))) -> (P) ((bool.false) )) -> (P) (y))) (fun (P:((bool.bool) ) -> Prop) => fun (auto:((((logic.eq) ((nat) )) ((O) )) ((O) )) -> (P) ((bool.true) )) => (fun (auto':(((connectives.Not) ) ((((logic.eq) ((nat) )) ((O) )) ((O) ))) -> (P) ((bool.false) )) => ((auto) (((logic.refl) ((nat) )) ((O) )))))))))) (fun (auto:(nat) ) => (((sym_eq_eqb) ((O) )) (fun (y:((nat) ) -> (bool.bool) ) => forall (P:((bool.bool) ) -> Prop), (((((logic.eq) ((nat) )) ((O) )) (((S) ) (auto))) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((logic.eq) ((nat) )) ((O) )) (((S) ) (auto)))) -> (P) ((bool.false) )) -> (P) ((y) (((S) ) (auto))))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (bool.bool) )) ((eqb_body) )) (fun (y:((nat) ) -> (bool.bool) ) => forall (P:((bool.bool) ) -> Prop), (((((logic.eq) ((nat) )) ((O) )) (((S) ) (auto))) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((logic.eq) ((nat) )) ((O) )) (((S) ) (auto)))) -> (P) ((bool.false) )) -> (P) ((y) (((S) ) (auto))))) (((sym_eq_eqb_body_O) (fun (y:((nat) ) -> (bool.bool) ) => forall (P:((bool.bool) ) -> Prop), (((((logic.eq) ((nat) )) ((O) )) (((S) ) (auto))) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((logic.eq) ((nat) )) ((O) )) (((S) ) (auto)))) -> (P) ((bool.false) )) -> (P) ((y) (((S) ) (auto))))) (((((((sym_eq_match_nat_type_S) ((bool.bool) )) ((bool.true) )) (fun (q:(nat) ) => (bool.false) )) (auto)) (fun (y:(bool.bool) ) => forall (P:((bool.bool) ) -> Prop), (((((logic.eq) ((nat) )) ((O) )) (((S) ) (auto))) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((logic.eq) ((nat) )) ((O) )) (((S) ) (auto)))) -> (P) ((bool.false) )) -> (P) (y))) (fun (P:((bool.bool) ) -> Prop) => fun (auto':((((logic.eq) ((nat) )) ((O) )) (((S) ) (auto))) -> (P) ((bool.true) )) => (fun (auto'':(((connectives.Not) ) ((((logic.eq) ((nat) )) ((O) )) (((S) ) (auto)))) -> (P) ((bool.false) )) => ((auto'') ((not_eq_O_S) (auto)))))))))) (n))) (fun (n:(nat) ) => (((sym_eq_eqb) (((S) ) (n))) (fun (y:((nat) ) -> (bool.bool) ) => forall (P:((bool.bool) ) -> Prop), (((((logic.eq) ((nat) )) (((S) ) (n))) ((O) )) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((logic.eq) ((nat) )) (((S) ) (n))) ((O) ))) -> (P) ((bool.false) )) -> (P) ((y) ((O) )))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (bool.bool) )) ((eqb_body) )) (n)) (fun (y:((nat) ) -> (bool.bool) ) => forall (P:((bool.bool) ) -> Prop), (((((logic.eq) ((nat) )) (((S) ) (n))) ((O) )) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((logic.eq) ((nat) )) (((S) ) (n))) ((O) ))) -> (P) ((bool.false) )) -> (P) ((y) ((O) )))) ((((sym_eq_eqb_body_S) (n)) (fun (y:((nat) ) -> (bool.bool) ) => forall (P:((bool.bool) ) -> Prop), (((((logic.eq) ((nat) )) (((S) ) (n))) ((O) )) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((logic.eq) ((nat) )) (((S) ) (n))) ((O) ))) -> (P) ((bool.false) )) -> (P) ((y) ((O) )))) ((((((sym_eq_match_nat_type_O) ((bool.bool) )) ((bool.false) )) (fun (q:(nat) ) => (((eqb) ) (n)) (q))) (fun (y:(bool.bool) ) => forall (P:((bool.bool) ) -> Prop), (((((logic.eq) ((nat) )) (((S) ) (n))) ((O) )) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((logic.eq) ((nat) )) (((S) ) (n))) ((O) ))) -> (P) ((bool.false) )) -> (P) (y))) (fun (P:((bool.bool) ) -> Prop) => fun (auto:((((logic.eq) ((nat) )) (((S) ) (n))) ((O) )) -> (P) ((bool.true) )) => (fun (auto':(((connectives.Not) ) ((((logic.eq) ((nat) )) (((S) ) (n))) ((O) ))) -> (P) ((bool.false) )) => ((auto') (((((logic.sym_not_eq) ((nat) )) ((O) )) (((S) ) (n))) ((not_eq_O_S) (n))))))))))) (fun (n:(nat) ) => fun (m:(nat) ) => (((sym_eq_eqb) (((S) ) (n))) (fun (y:((nat) ) -> (bool.bool) ) => (forall (P:((bool.bool) ) -> Prop), (((((logic.eq) ((nat) )) (n)) (m)) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((logic.eq) ((nat) )) (n)) (m))) -> (P) ((bool.false) )) -> (P) ((((eqb) ) (n)) (m))) -> forall (P:((bool.bool) ) -> Prop), (((((logic.eq) ((nat) )) (((S) ) (n))) (((S) ) (m))) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((logic.eq) ((nat) )) (((S) ) (n))) (((S) ) (m)))) -> (P) ((bool.false) )) -> (P) ((y) (((S) ) (m))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (bool.bool) )) ((eqb_body) )) (n)) (fun (y:((nat) ) -> (bool.bool) ) => (forall (P:((bool.bool) ) -> Prop), (((((logic.eq) ((nat) )) (n)) (m)) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((logic.eq) ((nat) )) (n)) (m))) -> (P) ((bool.false) )) -> (P) ((((eqb) ) (n)) (m))) -> forall (P:((bool.bool) ) -> Prop), (((((logic.eq) ((nat) )) (((S) ) (n))) (((S) ) (m))) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((logic.eq) ((nat) )) (((S) ) (n))) (((S) ) (m)))) -> (P) ((bool.false) )) -> (P) ((y) (((S) ) (m))))) ((((sym_eq_eqb_body_S) (n)) (fun (y:((nat) ) -> (bool.bool) ) => (forall (P:((bool.bool) ) -> Prop), (((((logic.eq) ((nat) )) (n)) (m)) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((logic.eq) ((nat) )) (n)) (m))) -> (P) ((bool.false) )) -> (P) ((((eqb) ) (n)) (m))) -> forall (P:((bool.bool) ) -> Prop), (((((logic.eq) ((nat) )) (((S) ) (n))) (((S) ) (m))) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((logic.eq) ((nat) )) (((S) ) (n))) (((S) ) (m)))) -> (P) ((bool.false) )) -> (P) ((y) (((S) ) (m))))) (((((((sym_eq_match_nat_type_S) ((bool.bool) )) ((bool.false) )) (fun (q:(nat) ) => (((eqb) ) (n)) (q))) (m)) (fun (y:(bool.bool) ) => (forall (P:((bool.bool) ) -> Prop), (((((logic.eq) ((nat) )) (n)) (m)) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((logic.eq) ((nat) )) (n)) (m))) -> (P) ((bool.false) )) -> (P) ((((eqb) ) (n)) (m))) -> forall (P:((bool.bool) ) -> Prop), (((((logic.eq) ((nat) )) (((S) ) (n))) (((S) ) (m))) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((logic.eq) ((nat) )) (((S) ) (n))) (((S) ) (m)))) -> (P) ((bool.false) )) -> (P) (y))) (fun (auto:forall (P:((bool.bool) ) -> Prop), (((((logic.eq) ((nat) )) (n)) (m)) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((logic.eq) ((nat) )) (n)) (m))) -> (P) ((bool.false) )) -> (P) ((((eqb) ) (n)) (m))) => (fun (P:((bool.bool) ) -> Prop) => fun (auto':((((logic.eq) ((nat) )) (((S) ) (n))) (((S) ) (m))) -> (P) ((bool.true) )) => (fun (auto'':(((connectives.Not) ) ((((logic.eq) ((nat) )) (((S) ) (n))) (((S) ) (m)))) -> (P) ((bool.false) )) => ((((auto) (P)) (fun (auto''':(((logic.eq) ((nat) )) (n)) (m)) => ((auto') (((((((logic.rewrite_l) ((nat) )) (n)) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (((S) ) (n))) (((S) ) (__)))) (((logic.refl) ((nat) )) (((S) ) (n)))) (m)) (auto'''))))) (fun (auto''':((connectives.Not) ) ((((logic.eq) ((nat) )) (n)) (m))) => ((auto'') ((((not_eq_S) (n)) (m)) (auto''')))))))))))).
Definition eqb_n_n : forall (n:(nat) ), (((logic.eq) ((bool.bool) )) ((((eqb) ) (n)) (n))) ((bool.true) ) := fun (n:(nat) ) => ((((nat_ind) (fun (_x_365:(nat) ) => (((logic.eq) ((bool.bool) )) ((((eqb) ) (_x_365)) (_x_365))) ((bool.true) ))) ((((sym_eq_eqb) ((O) )) (fun (y:((nat) ) -> (bool.bool) ) => (((logic.eq) ((bool.bool) )) ((y) ((O) ))) ((bool.true) ))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (bool.bool) )) ((eqb_body) )) (fun (y:((nat) ) -> (bool.bool) ) => (((logic.eq) ((bool.bool) )) ((y) ((O) ))) ((bool.true) ))) (((sym_eq_eqb_body_O) (fun (y:((nat) ) -> (bool.bool) ) => (((logic.eq) ((bool.bool) )) ((y) ((O) ))) ((bool.true) ))) ((((((sym_eq_match_nat_type_O) ((bool.bool) )) ((bool.true) )) (fun (q:(nat) ) => (bool.false) )) (fun (y:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (y)) ((bool.true) ))) (((logic.refl) ((bool.bool) )) ((bool.true) ))))))) (fun (x_366:(nat) ) => (((sym_eq_eqb) (((S) ) (x_366))) (fun (y:((nat) ) -> (bool.bool) ) => ((((logic.eq) ((bool.bool) )) ((((eqb) ) (x_366)) (x_366))) ((bool.true) )) -> (((logic.eq) ((bool.bool) )) ((y) (((S) ) (x_366)))) ((bool.true) ))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (bool.bool) )) ((eqb_body) )) (x_366)) (fun (y:((nat) ) -> (bool.bool) ) => ((((logic.eq) ((bool.bool) )) ((((eqb) ) (x_366)) (x_366))) ((bool.true) )) -> (((logic.eq) ((bool.bool) )) ((y) (((S) ) (x_366)))) ((bool.true) ))) ((((sym_eq_eqb_body_S) (x_366)) (fun (y:((nat) ) -> (bool.bool) ) => ((((logic.eq) ((bool.bool) )) ((((eqb) ) (x_366)) (x_366))) ((bool.true) )) -> (((logic.eq) ((bool.bool) )) ((y) (((S) ) (x_366)))) ((bool.true) ))) (((((((sym_eq_match_nat_type_S) ((bool.bool) )) ((bool.false) )) (fun (q:(nat) ) => (((eqb) ) (x_366)) (q))) (x_366)) (fun (y:(bool.bool) ) => ((((logic.eq) ((bool.bool) )) ((((eqb) ) (x_366)) (x_366))) ((bool.true) )) -> (((logic.eq) ((bool.bool) )) (y)) ((bool.true) ))) (fun (_x_368:(((logic.eq) ((bool.bool) )) ((((eqb) ) (x_366)) (x_366))) ((bool.true) )) => (((((((logic.rewrite_r) ((bool.bool) )) ((bool.true) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.true) ))) (((logic.refl) ((bool.bool) )) ((bool.true) ))) ((((eqb) ) (x_366)) (x_366))) (_x_368)))))))) (n).
Definition eqb_true_to_eq : forall (n:(nat) ), forall (m:(nat) ), ((((logic.eq) ((bool.bool) )) ((((eqb) ) (n)) (m))) ((bool.true) )) -> (((logic.eq) ((nat) )) (n)) (m) := fun (n:(nat) ) => fun (m:(nat) ) => (((((eqb_elim) (n)) (m)) (fun (__:(bool.bool) ) => ((((logic.eq) ((bool.bool) )) (__)) ((bool.true) )) -> (((logic.eq) ((nat) )) (n)) (m))) (fun (auto:(((logic.eq) ((nat) )) (n)) (m)) => (fun (auto':(((logic.eq) ((bool.bool) )) ((bool.true) )) ((bool.true) )) => (((((((logic.rewrite_l) ((nat) )) (n)) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (n)) (__))) (((logic.refl) ((nat) )) (n))) (m)) (auto))))) (fun (__:((connectives.Not) ) ((((logic.eq) ((nat) )) (n)) (m))) => (fun (abs:(((logic.eq) ((bool.bool) )) ((bool.false) )) ((bool.true) )) => (((connectives.falsity) ((((logic.eq) ((nat) )) (n)) (m))) ((((logic.absurd) ((((logic.eq) ((bool.bool) )) ((bool.true) )) ((bool.false) ))) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.true) )) (fun (__1:(bool.bool) ) => (((logic.eq) ((bool.bool) )) ((bool.true) )) (__1))) (((logic.refl) ((bool.bool) )) ((bool.true) ))) ((bool.false) )) (abs))) (bool.not_eq_true_false))))).
Definition eqb_false_to_not_eq : forall (n:(nat) ), forall (m:(nat) ), ((((logic.eq) ((bool.bool) )) ((((eqb) ) (n)) (m))) ((bool.false) )) -> ((connectives.Not) ) ((((logic.eq) ((nat) )) (n)) (m)) := fun (n:(nat) ) => fun (m:(nat) ) => (((((eqb_elim) (n)) (m)) (fun (__:(bool.bool) ) => ((((logic.eq) ((bool.bool) )) (__)) ((bool.false) )) -> ((connectives.Not) ) ((((logic.eq) ((nat) )) (n)) (m)))) (fun (auto:(((logic.eq) ((nat) )) (n)) (m)) => (fun (auto':(((logic.eq) ((bool.bool) )) ((bool.true) )) ((bool.false) )) => (((((logic.not_to_not) ((((logic.eq) ((nat) )) (n)) (m))) ((((logic.eq) ((bool.bool) )) ((bool.true) )) ((bool.false) ))) (fun (auto'':(((logic.eq) ((nat) )) (n)) (m)) => (((((((logic.rewrite_l) ((bool.bool) )) ((bool.true) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) ((bool.true) )) (__))) (((logic.refl) ((bool.bool) )) ((bool.true) ))) ((bool.false) )) (auto')))) (bool.not_eq_true_false))))) (fun (auto:((connectives.Not) ) ((((logic.eq) ((nat) )) (n)) (m))) => (fun (auto':(((logic.eq) ((bool.bool) )) ((bool.false) )) ((bool.false) )) => (auto))).
Definition eq_to_eqb_true : forall (n:(nat) ), forall (m:(nat) ), ((((logic.eq) ((nat) )) (n)) (m)) -> (((logic.eq) ((bool.bool) )) ((((eqb) ) (n)) (m))) ((bool.true) ) := fun (n:(nat) ) => fun (m:(nat) ) => fun (auto:(((logic.eq) ((nat) )) (n)) (m)) => (((((((logic.rewrite_l) ((nat) )) (n)) (fun (__:(nat) ) => (((logic.eq) ((bool.bool) )) ((((eqb) ) (n)) (__))) ((bool.true) ))) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.true) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.true) ))) (((logic.refl) ((bool.bool) )) ((bool.true) ))) ((((eqb) ) (n)) (n))) ((eqb_n_n) (n)))) (m)) (auto)).
Definition not_eq_to_eqb_false : forall (n:(nat) ), forall (m:(nat) ), (((connectives.Not) ) ((((logic.eq) ((nat) )) (n)) (m))) -> (((logic.eq) ((bool.bool) )) ((((eqb) ) (n)) (m))) ((bool.false) ) := fun (n:(nat) ) => fun (m:(nat) ) => fun (noteq:((connectives.Not) ) ((((logic.eq) ((nat) )) (n)) (m))) => ((((((eqb_elim) (n)) (m)) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.false) ))) (fun (Heq:(((logic.eq) ((nat) )) (n)) (m)) => (((connectives.falsity) ((((logic.eq) ((bool.bool) )) ((bool.true) )) ((bool.false) ))) ((((logic.absurd) ((((logic.eq) ((nat) )) (n)) (m))) (((((((logic.rewrite_l) ((nat) )) (n)) (fun (__:(nat) ) => (((logic.eq) ((nat) )) (n)) (__))) (((logic.refl) ((nat) )) (n))) (m)) (Heq))) (noteq))))) (fun (auto:((connectives.Not) ) ((((logic.eq) ((nat) )) (n)) (m))) => (((logic.refl) ((bool.bool) )) ((bool.false) )))).
Parameter leb : ((nat) ) -> ((nat) ) -> (bool.bool) .
Parameter leb_body : ((nat) ) -> ((nat) ) -> (bool.bool) .
Axiom axiom_leb : forall (n:(nat) ), (((connectives.equal) (((nat) ) -> (bool.bool) )) (((leb) ) (n))) ((((filter_nat_type) (((nat) ) -> (bool.bool) )) ((leb_body) )) (n)).
Definition eq_leb : forall (n:(nat) ), (((leibniz.leibniz) (((nat) ) -> (bool.bool) )) (((leb) ) (n))) ((((filter_nat_type) (((nat) ) -> (bool.bool) )) ((leb_body) )) (n)) := fun (n:(nat) ) => ((((connectives.equal_leibniz) (((nat) ) -> (bool.bool) )) (((leb) ) (n))) ((((filter_nat_type) (((nat) ) -> (bool.bool) )) ((leb_body) )) (n))) ((axiom_leb) (n)).
Definition sym_eq_leb : forall (n:(nat) ), (((leibniz.leibniz) (((nat) ) -> (bool.bool) )) ((((filter_nat_type) (((nat) ) -> (bool.bool) )) ((leb_body) )) (n))) (((leb) ) (n)) := fun (n:(nat) ) => ((((leibniz.sym_leibniz) (((nat) ) -> (bool.bool) )) (((leb) ) (n))) ((((filter_nat_type) (((nat) ) -> (bool.bool) )) ((leb_body) )) (n))) ((eq_leb) (n)).
Axiom axiom_leb_body_O : (((connectives.equal) (((nat) ) -> (bool.bool) )) (((leb_body) ) ((O) ))) (fun (m:(nat) ) => (bool.true) ).
Definition eq_leb_body_O : (((leibniz.leibniz) (((nat) ) -> (bool.bool) )) (((leb_body) ) ((O) ))) (fun (m:(nat) ) => (bool.true) ) := ((((connectives.equal_leibniz) (((nat) ) -> (bool.bool) )) (((leb_body) ) ((O) ))) (fun (m:(nat) ) => (bool.true) )) (axiom_leb_body_O).
Definition sym_eq_leb_body_O : (((leibniz.leibniz) (((nat) ) -> (bool.bool) )) (fun (m:(nat) ) => (bool.true) )) (((leb_body) ) ((O) )) := ((((leibniz.sym_leibniz) (((nat) ) -> (bool.bool) )) (((leb_body) ) ((O) ))) (fun (m:(nat) ) => (bool.true) )) (eq_leb_body_O).
Axiom axiom_leb_body_S : forall (n:(nat) ), (((connectives.equal) (((nat) ) -> (bool.bool) )) (((leb_body) ) (((S) ) (n)))) (fun (m:(nat) ) => ((((match_nat_type) ((bool.bool) )) ((bool.false) )) (fun (q:(nat) ) => (((leb) ) (n)) (q))) (m)).
Definition eq_leb_body_S : forall (n:(nat) ), (((leibniz.leibniz) (((nat) ) -> (bool.bool) )) (((leb_body) ) (((S) ) (n)))) (fun (m:(nat) ) => ((((match_nat_type) ((bool.bool) )) ((bool.false) )) (fun (q:(nat) ) => (((leb) ) (n)) (q))) (m)) := fun (n:(nat) ) => ((((connectives.equal_leibniz) (((nat) ) -> (bool.bool) )) (((leb_body) ) (((S) ) (n)))) (fun (m:(nat) ) => ((((match_nat_type) ((bool.bool) )) ((bool.false) )) (fun (q:(nat) ) => (((leb) ) (n)) (q))) (m))) ((axiom_leb_body_S) (n)).
Definition sym_eq_leb_body_S : forall (n:(nat) ), (((leibniz.leibniz) (((nat) ) -> (bool.bool) )) (fun (m:(nat) ) => ((((match_nat_type) ((bool.bool) )) ((bool.false) )) (fun (q:(nat) ) => (((leb) ) (n)) (q))) (m))) (((leb_body) ) (((S) ) (n))) := fun (n:(nat) ) => ((((leibniz.sym_leibniz) (((nat) ) -> (bool.bool) )) (((leb_body) ) (((S) ) (n)))) (fun (m:(nat) ) => ((((match_nat_type) ((bool.bool) )) ((bool.false) )) (fun (q:(nat) ) => (((leb) ) (n)) (q))) (m))) ((eq_leb_body_S) (n)).
Definition leb_elim : forall (n:(nat) ), forall (m:(nat) ), forall (P:((bool.bool) ) -> Prop), (((((le) ) (n)) (m)) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((le) ) (n)) (m))) -> (P) ((bool.false) )) -> (P) ((((leb) ) (n)) (m)) := ((((nat_elim2) (fun (__:(nat) ) => fun (_0:(nat) ) => forall (P:((bool.bool) ) -> Prop), (((((le) ) (__)) (_0)) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((le) ) (__)) (_0))) -> (P) ((bool.false) )) -> (P) ((((leb) ) (__)) (_0)))) (fun (n:(nat) ) => (((sym_eq_leb) ((O) )) (fun (y:((nat) ) -> (bool.bool) ) => forall (P:((bool.bool) ) -> Prop), (((((le) ) ((O) )) (n)) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((le) ) ((O) )) (n))) -> (P) ((bool.false) )) -> (P) ((y) (n)))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (bool.bool) )) ((leb_body) )) (fun (y:((nat) ) -> (bool.bool) ) => forall (P:((bool.bool) ) -> Prop), (((((le) ) ((O) )) (n)) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((le) ) ((O) )) (n))) -> (P) ((bool.false) )) -> (P) ((y) (n)))) (((sym_eq_leb_body_O) (fun (y:((nat) ) -> (bool.bool) ) => forall (P:((bool.bool) ) -> Prop), (((((le) ) ((O) )) (n)) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((le) ) ((O) )) (n))) -> (P) ((bool.false) )) -> (P) ((y) (n)))) (fun (P:((bool.bool) ) -> Prop) => fun (auto:((((le) ) ((O) )) (n)) -> (P) ((bool.true) )) => (fun (auto':(((connectives.Not) ) ((((le) ) ((O) )) (n))) -> (P) ((bool.false) )) => ((auto) ((le_O_n) (n))))))))) (fun (n:(nat) ) => (((sym_eq_leb) (((S) ) (n))) (fun (y:((nat) ) -> (bool.bool) ) => forall (P:((bool.bool) ) -> Prop), (((((le) ) (((S) ) (n))) ((O) )) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((le) ) (((S) ) (n))) ((O) ))) -> (P) ((bool.false) )) -> (P) ((y) ((O) )))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (bool.bool) )) ((leb_body) )) (n)) (fun (y:((nat) ) -> (bool.bool) ) => forall (P:((bool.bool) ) -> Prop), (((((le) ) (((S) ) (n))) ((O) )) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((le) ) (((S) ) (n))) ((O) ))) -> (P) ((bool.false) )) -> (P) ((y) ((O) )))) ((((sym_eq_leb_body_S) (n)) (fun (y:((nat) ) -> (bool.bool) ) => forall (P:((bool.bool) ) -> Prop), (((((le) ) (((S) ) (n))) ((O) )) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((le) ) (((S) ) (n))) ((O) ))) -> (P) ((bool.false) )) -> (P) ((y) ((O) )))) ((((((sym_eq_match_nat_type_O) ((bool.bool) )) ((bool.false) )) (fun (q:(nat) ) => (((leb) ) (n)) (q))) (fun (y:(bool.bool) ) => forall (P:((bool.bool) ) -> Prop), (((((le) ) (((S) ) (n))) ((O) )) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((le) ) (((S) ) (n))) ((O) ))) -> (P) ((bool.false) )) -> (P) (y))) (fun (P:((bool.bool) ) -> Prop) => fun (auto:((((le) ) (((S) ) (n))) ((O) )) -> (P) ((bool.true) )) => (fun (auto':(((connectives.Not) ) ((((le) ) (((S) ) (n))) ((O) ))) -> (P) ((bool.false) )) => ((auto') ((not_le_Sn_O) (n)))))))))) (fun (n:(nat) ) => fun (m:(nat) ) => (((sym_eq_leb) (((S) ) (n))) (fun (y:((nat) ) -> (bool.bool) ) => (forall (P:((bool.bool) ) -> Prop), (((((le) ) (n)) (m)) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((le) ) (n)) (m))) -> (P) ((bool.false) )) -> (P) ((((leb) ) (n)) (m))) -> forall (P:((bool.bool) ) -> Prop), (((((le) ) (((S) ) (n))) (((S) ) (m))) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((le) ) (((S) ) (n))) (((S) ) (m)))) -> (P) ((bool.false) )) -> (P) ((y) (((S) ) (m))))) ((((((sym_eq_filter_nat_type_S) (((nat) ) -> (bool.bool) )) ((leb_body) )) (n)) (fun (y:((nat) ) -> (bool.bool) ) => (forall (P:((bool.bool) ) -> Prop), (((((le) ) (n)) (m)) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((le) ) (n)) (m))) -> (P) ((bool.false) )) -> (P) ((((leb) ) (n)) (m))) -> forall (P:((bool.bool) ) -> Prop), (((((le) ) (((S) ) (n))) (((S) ) (m))) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((le) ) (((S) ) (n))) (((S) ) (m)))) -> (P) ((bool.false) )) -> (P) ((y) (((S) ) (m))))) ((((sym_eq_leb_body_S) (n)) (fun (y:((nat) ) -> (bool.bool) ) => (forall (P:((bool.bool) ) -> Prop), (((((le) ) (n)) (m)) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((le) ) (n)) (m))) -> (P) ((bool.false) )) -> (P) ((((leb) ) (n)) (m))) -> forall (P:((bool.bool) ) -> Prop), (((((le) ) (((S) ) (n))) (((S) ) (m))) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((le) ) (((S) ) (n))) (((S) ) (m)))) -> (P) ((bool.false) )) -> (P) ((y) (((S) ) (m))))) (((((((sym_eq_match_nat_type_S) ((bool.bool) )) ((bool.false) )) (fun (q:(nat) ) => (((leb) ) (n)) (q))) (m)) (fun (y:(bool.bool) ) => (forall (P:((bool.bool) ) -> Prop), (((((le) ) (n)) (m)) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((le) ) (n)) (m))) -> (P) ((bool.false) )) -> (P) ((((leb) ) (n)) (m))) -> forall (P:((bool.bool) ) -> Prop), (((((le) ) (((S) ) (n))) (((S) ) (m))) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((le) ) (((S) ) (n))) (((S) ) (m)))) -> (P) ((bool.false) )) -> (P) (y))) (fun (Hind:forall (P:((bool.bool) ) -> Prop), (((((le) ) (n)) (m)) -> (P) ((bool.true) )) -> ((((connectives.Not) ) ((((le) ) (n)) (m))) -> (P) ((bool.false) )) -> (P) ((((leb) ) (n)) (m))) => (fun (P:((bool.bool) ) -> Prop) => fun (Pt:((((le) ) (((S) ) (n))) (((S) ) (m))) -> (P) ((bool.true) )) => (fun (Pf:(((connectives.Not) ) ((((le) ) (((S) ) (n))) (((S) ) (m)))) -> (P) ((bool.false) )) => ((((Hind) (P)) (fun (lenm:(((le) ) (n)) (m)) => ((Pt) ((((le_S_S) (n)) (m)) (lenm))))) (fun (nlenm:((connectives.Not) ) ((((le) ) (n)) (m))) => ((Pf) ((((not_le_to_not_le_S_S) (n)) (m)) (nlenm)))))))))))).
Definition leb_true_to_le : forall (n:(nat) ), forall (m:(nat) ), ((((logic.eq) ((bool.bool) )) ((((leb) ) (n)) (m))) ((bool.true) )) -> (((le) ) (n)) (m) := fun (n:(nat) ) => fun (m:(nat) ) => (((((leb_elim) (n)) (m)) (fun (__:(bool.bool) ) => ((((logic.eq) ((bool.bool) )) (__)) ((bool.true) )) -> (((le) ) (n)) (m))) (fun (auto:(((le) ) (n)) (m)) => (fun (auto':(((logic.eq) ((bool.bool) )) ((bool.true) )) ((bool.true) )) => (auto)))) (fun (__:((connectives.Not) ) ((((le) ) (n)) (m))) => (fun (abs:(((logic.eq) ((bool.bool) )) ((bool.false) )) ((bool.true) )) => (((connectives.falsity) ((((le) ) (n)) (m))) ((((logic.absurd) ((((logic.eq) ((bool.bool) )) ((bool.true) )) ((bool.false) ))) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.true) )) (fun (__1:(bool.bool) ) => (((logic.eq) ((bool.bool) )) ((bool.true) )) (__1))) (((logic.refl) ((bool.bool) )) ((bool.true) ))) ((bool.false) )) (abs))) (bool.not_eq_true_false))))).
Definition le_to_leb_true : forall (n:(nat) ), forall (m:(nat) ), ((((le) ) (n)) (m)) -> (((logic.eq) ((bool.bool) )) ((((leb) ) (n)) (m))) ((bool.true) ) := fun (n:(nat) ) => fun (m:(nat) ) => (((((leb_elim) (n)) (m)) (fun (__:(bool.bool) ) => ((((le) ) (n)) (m)) -> (((logic.eq) ((bool.bool) )) (__)) ((bool.true) ))) (fun (auto:(((le) ) (n)) (m)) => (fun (auto':(((le) ) (n)) (m)) => (((logic.refl) ((bool.bool) )) ((bool.true) ))))) (fun (H:((connectives.Not) ) ((((le) ) (n)) (m))) => (fun (H1:(((le) ) (n)) (m)) => (((connectives.falsity) ((((logic.eq) ((bool.bool) )) ((bool.false) )) ((bool.true) ))) ((((logic.absurd) ((((le) ) (n)) (m))) (H1)) (H))))).
Definition not_le_to_leb_false : forall (n:(nat) ), forall (m:(nat) ), (((connectives.Not) ) ((((le) ) (n)) (m))) -> (((logic.eq) ((bool.bool) )) ((((leb) ) (n)) (m))) ((bool.false) ) := fun (n:(nat) ) => fun (m:(nat) ) => (((((leb_elim) (n)) (m)) (fun (__:(bool.bool) ) => (((connectives.Not) ) ((((le) ) (n)) (m))) -> (((logic.eq) ((bool.bool) )) (__)) ((bool.false) ))) (fun (H:(((le) ) (n)) (m)) => (fun (H1:((connectives.Not) ) ((((le) ) (n)) (m))) => (((connectives.falsity) ((((logic.eq) ((bool.bool) )) ((bool.true) )) ((bool.false) ))) ((((logic.absurd) ((((le) ) (n)) (m))) (H)) (H1)))))) (fun (auto:((connectives.Not) ) ((((le) ) (n)) (m))) => (fun (auto':((connectives.Not) ) ((((le) ) (n)) (m))) => (((logic.refl) ((bool.bool) )) ((bool.false) )))).
