Require Import bool.
Require Import connectives.
Require Import div_mod.
Require Import leibniz.
Require Import logic.
Require Import nat.
Definition sameF_upto : forall (A:Type), ((nat.nat) ) -> (((nat.nat) ) -> A) -> (((nat.nat) ) -> A) -> Prop := fun (A:Type) => fun (k:(nat.nat) ) => fun (f:((nat.nat) ) -> A) => fun (g:((nat.nat) ) -> A) => forall (i:(nat.nat) ), ((((nat.lt) ) (i)) (k)) -> (((logic.eq) (A)) ((f) (i))) ((g) (i)).
Definition sameF_p : forall (A:Type), ((nat.nat) ) -> (((nat.nat) ) -> (bool.bool) ) -> (((nat.nat) ) -> A) -> (((nat.nat) ) -> A) -> Prop := fun (A:Type) => fun (k:(nat.nat) ) => fun (p:((nat.nat) ) -> (bool.bool) ) => fun (f:((nat.nat) ) -> A) => fun (g:((nat.nat) ) -> A) => forall (i:(nat.nat) ), ((((nat.lt) ) (i)) (k)) -> ((((logic.eq) ((bool.bool) )) ((p) (i))) ((bool.true) )) -> (((logic.eq) (A)) ((f) (i))) ((g) (i)).
Definition sameF_upto_le : forall A, forall (f:((nat.nat) ) -> A), forall (g:((nat.nat) ) -> A), forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((((nat.le) ) (n)) (m)) -> (((((sameF_upto) (A)) (m)) (f)) (g)) -> ((((sameF_upto) (A)) (n)) (f)) (g) := fun (A:Type) => fun (f:((nat.nat) ) -> A) => fun (g:((nat.nat) ) -> A) => fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => fun (lenm:(((nat.le) ) (n)) (m)) => (fun (samef:((((sameF_upto) (A)) (m)) (f)) (g)) => (fun (i:(nat.nat) ) => fun (ltin:(((nat.lt) ) (i)) (n)) => (((samef) (i)) ((((((nat.lt_to_le_to_lt) (i)) (n)) (m)) (ltin)) (lenm))))).
Definition sameF_p_le : forall A, forall (p:((nat.nat) ) -> (bool.bool) ), forall (f:((nat.nat) ) -> A), forall (g:((nat.nat) ) -> A), forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((((nat.le) ) (n)) (m)) -> ((((((sameF_p) (A)) (m)) (p)) (f)) (g)) -> (((((sameF_p) (A)) (n)) (p)) (f)) (g) := fun (A:Type) => fun (p:((nat.nat) ) -> (bool.bool) ) => fun (f:((nat.nat) ) -> A) => fun (g:((nat.nat) ) -> A) => fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => fun (lenm:(((nat.le) ) (n)) (m)) => (fun (samef:(((((sameF_p) (A)) (m)) (p)) (f)) (g)) => (fun (i:(nat.nat) ) => fun (ltin:(((nat.lt) ) (i)) (n)) => (fun (pi:(((logic.eq) ((bool.bool) )) ((p) (i))) ((bool.true) )) => ((((samef) (i)) ((((((nat.lt_to_le_to_lt) (i)) (n)) (m)) (ltin)) (lenm))) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.true) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.true) ))) (((logic.refl) ((bool.bool) )) ((bool.true) ))) ((p) (i))) (pi)))))).
Parameter bigop : forall (H:Type), ((nat.nat) ) -> (((nat.nat) ) -> (bool.bool) ) -> (H) -> ((H) -> (H) -> H) -> (((nat.nat) ) -> H) -> H.
Parameter bigop_body : forall (H:Type), ((nat.nat) ) -> (((nat.nat) ) -> (bool.bool) ) -> (H) -> ((H) -> (H) -> H) -> (((nat.nat) ) -> H) -> H.
Axiom axiom_bigop_O : forall H, (((connectives.equal) ((((nat.nat) ) -> (bool.bool) ) -> (H) -> ((H) -> (H) -> H) -> (((nat.nat) ) -> H) -> H)) (((bigop) (H)) ((nat.O) ))) (((bigop_body) (H)) ((nat.O) )).
Definition eq_bigop_O : forall H, (((leibniz.leibniz) ((((nat.nat) ) -> (bool.bool) ) -> (H) -> ((H) -> (H) -> H) -> (((nat.nat) ) -> H) -> H)) (((bigop) (H)) ((nat.O) ))) (((bigop_body) (H)) ((nat.O) )) := fun (H:Type) => ((((connectives.equal_leibniz) ((((nat.nat) ) -> (bool.bool) ) -> (H) -> ((H) -> (H) -> H) -> (((nat.nat) ) -> H) -> H)) (((bigop) (H)) ((nat.O) ))) (((bigop_body) (H)) ((nat.O) ))) ((axiom_bigop_O) (H)).
Definition sym_eq_bigop_O : forall H, (((leibniz.leibniz) ((((nat.nat) ) -> (bool.bool) ) -> (H) -> ((H) -> (H) -> H) -> (((nat.nat) ) -> H) -> H)) (((bigop_body) (H)) ((nat.O) ))) (((bigop) (H)) ((nat.O) )) := fun (H:Type) => ((((leibniz.sym_leibniz) ((((nat.nat) ) -> (bool.bool) ) -> (H) -> ((H) -> (H) -> H) -> (((nat.nat) ) -> H) -> H)) (((bigop) (H)) ((nat.O) ))) (((bigop_body) (H)) ((nat.O) ))) ((eq_bigop_O) (H)).
Axiom axiom_bigop_S : forall H, forall (n:(nat.nat) ), (((connectives.equal) ((((nat.nat) ) -> (bool.bool) ) -> (H) -> ((H) -> (H) -> H) -> (((nat.nat) ) -> H) -> H)) (((bigop) (H)) (((nat.S) ) (n)))) (((bigop_body) (H)) (((nat.S) ) (n))).
Definition eq_bigop_S : forall H, forall (n:(nat.nat) ), (((leibniz.leibniz) ((((nat.nat) ) -> (bool.bool) ) -> (H) -> ((H) -> (H) -> H) -> (((nat.nat) ) -> H) -> H)) (((bigop) (H)) (((nat.S) ) (n)))) (((bigop_body) (H)) (((nat.S) ) (n))) := fun (H:Type) => fun (n:(nat.nat) ) => ((((connectives.equal_leibniz) ((((nat.nat) ) -> (bool.bool) ) -> (H) -> ((H) -> (H) -> H) -> (((nat.nat) ) -> H) -> H)) (((bigop) (H)) (((nat.S) ) (n)))) (((bigop_body) (H)) (((nat.S) ) (n)))) (((axiom_bigop_S) (H)) (n)).
Definition sym_eq_bigop_S : forall H, forall (n:(nat.nat) ), (((leibniz.leibniz) ((((nat.nat) ) -> (bool.bool) ) -> (H) -> ((H) -> (H) -> H) -> (((nat.nat) ) -> H) -> H)) (((bigop_body) (H)) (((nat.S) ) (n)))) (((bigop) (H)) (((nat.S) ) (n))) := fun (H:Type) => fun (n:(nat.nat) ) => ((((leibniz.sym_leibniz) ((((nat.nat) ) -> (bool.bool) ) -> (H) -> ((H) -> (H) -> H) -> (((nat.nat) ) -> H) -> H)) (((bigop) (H)) (((nat.S) ) (n)))) (((bigop_body) (H)) (((nat.S) ) (n)))) (((eq_bigop_S) (H)) (n)).
Axiom axiom_bigop_body_O : forall H, (((connectives.equal) ((((nat.nat) ) -> (bool.bool) ) -> (H) -> ((H) -> (H) -> H) -> (((nat.nat) ) -> H) -> H)) (((bigop_body) (H)) ((nat.O) ))) (fun (p:((nat.nat) ) -> (bool.bool) ) => fun (nil:H) => fun (op:(H) -> (H) -> H) => fun (f:((nat.nat) ) -> H) => nil).
Definition eq_bigop_body_O : forall H, (((leibniz.leibniz) ((((nat.nat) ) -> (bool.bool) ) -> (H) -> ((H) -> (H) -> H) -> (((nat.nat) ) -> H) -> H)) (((bigop_body) (H)) ((nat.O) ))) (fun (p:((nat.nat) ) -> (bool.bool) ) => fun (nil:H) => fun (op:(H) -> (H) -> H) => fun (f:((nat.nat) ) -> H) => nil) := fun (H:Type) => ((((connectives.equal_leibniz) ((((nat.nat) ) -> (bool.bool) ) -> (H) -> ((H) -> (H) -> H) -> (((nat.nat) ) -> H) -> H)) (((bigop_body) (H)) ((nat.O) ))) (fun (p:((nat.nat) ) -> (bool.bool) ) => fun (nil:H) => fun (op:(H) -> (H) -> H) => fun (f:((nat.nat) ) -> H) => nil)) ((axiom_bigop_body_O) (H)).
Definition sym_eq_bigop_body_O : forall H, (((leibniz.leibniz) ((((nat.nat) ) -> (bool.bool) ) -> (H) -> ((H) -> (H) -> H) -> (((nat.nat) ) -> H) -> H)) (fun (p:((nat.nat) ) -> (bool.bool) ) => fun (nil:H) => fun (op:(H) -> (H) -> H) => fun (f:((nat.nat) ) -> H) => nil)) (((bigop_body) (H)) ((nat.O) )) := fun (H:Type) => ((((leibniz.sym_leibniz) ((((nat.nat) ) -> (bool.bool) ) -> (H) -> ((H) -> (H) -> H) -> (((nat.nat) ) -> H) -> H)) (((bigop_body) (H)) ((nat.O) ))) (fun (p:((nat.nat) ) -> (bool.bool) ) => fun (nil:H) => fun (op:(H) -> (H) -> H) => fun (f:((nat.nat) ) -> H) => nil)) ((eq_bigop_body_O) (H)).
Axiom axiom_bigop_body_S : forall H, forall (n:(nat.nat) ), (((connectives.equal) ((((nat.nat) ) -> (bool.bool) ) -> (H) -> ((H) -> (H) -> H) -> (((nat.nat) ) -> H) -> H)) (((bigop_body) (H)) (((nat.S) ) (n)))) (fun (p:((nat.nat) ) -> (bool.bool) ) => fun (nil:H) => fun (op:(H) -> (H) -> H) => fun (f:((nat.nat) ) -> H) => ((((bool.match_bool_type) (H)) (((op) ((f) (n))) (((((((bigop) (H)) (n)) (p)) (nil)) (op)) (f)))) (((((((bigop) (H)) (n)) (p)) (nil)) (op)) (f))) ((p) (n))).
Definition eq_bigop_body_S : forall H, forall (n:(nat.nat) ), (((leibniz.leibniz) ((((nat.nat) ) -> (bool.bool) ) -> (H) -> ((H) -> (H) -> H) -> (((nat.nat) ) -> H) -> H)) (((bigop_body) (H)) (((nat.S) ) (n)))) (fun (p:((nat.nat) ) -> (bool.bool) ) => fun (nil:H) => fun (op:(H) -> (H) -> H) => fun (f:((nat.nat) ) -> H) => ((((bool.match_bool_type) (H)) (((op) ((f) (n))) (((((((bigop) (H)) (n)) (p)) (nil)) (op)) (f)))) (((((((bigop) (H)) (n)) (p)) (nil)) (op)) (f))) ((p) (n))) := fun (H:Type) => fun (n:(nat.nat) ) => ((((connectives.equal_leibniz) ((((nat.nat) ) -> (bool.bool) ) -> (H) -> ((H) -> (H) -> H) -> (((nat.nat) ) -> H) -> H)) (((bigop_body) (H)) (((nat.S) ) (n)))) (fun (p:((nat.nat) ) -> (bool.bool) ) => fun (nil:H) => fun (op:(H) -> (H) -> H) => fun (f:((nat.nat) ) -> H) => ((((bool.match_bool_type) (H)) (((op) ((f) (n))) (((((((bigop) (H)) (n)) (p)) (nil)) (op)) (f)))) (((((((bigop) (H)) (n)) (p)) (nil)) (op)) (f))) ((p) (n)))) (((axiom_bigop_body_S) (H)) (n)).
Definition sym_eq_bigop_body_S : forall H, forall (n:(nat.nat) ), (((leibniz.leibniz) ((((nat.nat) ) -> (bool.bool) ) -> (H) -> ((H) -> (H) -> H) -> (((nat.nat) ) -> H) -> H)) (fun (p:((nat.nat) ) -> (bool.bool) ) => fun (nil:H) => fun (op:(H) -> (H) -> H) => fun (f:((nat.nat) ) -> H) => ((((bool.match_bool_type) (H)) (((op) ((f) (n))) (((((((bigop) (H)) (n)) (p)) (nil)) (op)) (f)))) (((((((bigop) (H)) (n)) (p)) (nil)) (op)) (f))) ((p) (n)))) (((bigop_body) (H)) (((nat.S) ) (n))) := fun (H:Type) => fun (n:(nat.nat) ) => ((((leibniz.sym_leibniz) ((((nat.nat) ) -> (bool.bool) ) -> (H) -> ((H) -> (H) -> H) -> (((nat.nat) ) -> H) -> H)) (((bigop_body) (H)) (((nat.S) ) (n)))) (fun (p:((nat.nat) ) -> (bool.bool) ) => fun (nil:H) => fun (op:(H) -> (H) -> H) => fun (f:((nat.nat) ) -> H) => ((((bool.match_bool_type) (H)) (((op) ((f) (n))) (((((((bigop) (H)) (n)) (p)) (nil)) (op)) (f)))) (((((((bigop) (H)) (n)) (p)) (nil)) (op)) (f))) ((p) (n)))) (((eq_bigop_body_S) (H)) (n)).
Definition bigop_Strue : forall B, forall (k:(nat.nat) ), forall (p:((nat.nat) ) -> (bool.bool) ), forall (nil:B), forall (op:(B) -> (B) -> B), forall (f:((nat.nat) ) -> B), ((((logic.eq) ((bool.bool) )) ((p) (k))) ((bool.true) )) -> (((logic.eq) (B)) (((((((bigop) (B)) (((nat.S) ) (k))) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (((op) ((f) (k))) (((((((bigop) (B)) (k)) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) := fun (B:Type) => fun (k:(nat.nat) ) => fun (p:((nat.nat) ) -> (bool.bool) ) => fun (nil:B) => fun (op:(B) -> (B) -> B) => fun (f:((nat.nat) ) -> B) => ((((sym_eq_bigop_S) (B)) (k)) (fun (y:(((nat.nat) ) -> (bool.bool) ) -> (B) -> ((B) -> (B) -> B) -> (((nat.nat) ) -> B) -> B) => ((((logic.eq) ((bool.bool) )) ((p) (k))) ((bool.true) )) -> (((logic.eq) (B)) (((((y) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (((op) ((f) (k))) (((((((bigop) (B)) (k)) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))))) (((((sym_eq_bigop_body_S) (B)) (k)) (fun (y:(((nat.nat) ) -> (bool.bool) ) -> (B) -> ((B) -> (B) -> B) -> (((nat.nat) ) -> B) -> B) => ((((logic.eq) ((bool.bool) )) ((p) (k))) ((bool.true) )) -> (((logic.eq) (B)) (((((y) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (((op) ((f) (k))) (((((((bigop) (B)) (k)) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))))) (fun (H:(((logic.eq) ((bool.bool) )) ((p) (k))) ((bool.true) )) => (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.true) )) (fun (x:(bool.bool) ) => (((logic.eq) (B)) (((((bool.match_bool_type) (B)) (((op) ((f) (k))) (((((((bigop) (B)) (k)) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i))))) (((((((bigop) (B)) (k)) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (x))) (((op) ((f) (k))) (((((((bigop) (B)) (k)) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))))) ((((((bool.eq_match_bool_type_true) (B)) (((op) ((f) (k))) (((((((bigop) (B)) (k)) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i))))) (((((((bigop) (B)) (k)) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (fun (y:B) => (((logic.eq) (B)) (((((bool.match_bool_type) (B)) (((op) ((f) (k))) (((((((bigop) (B)) (k)) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i))))) (((((((bigop) (B)) (k)) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) ((bool.true) ))) (y))) (((logic.refl) (B)) (((((bool.match_bool_type) (B)) (((op) ((f) (k))) (((((((bigop) (B)) (k)) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i))))) (((((((bigop) (B)) (k)) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) ((bool.true) ))))) ((p) (k))) (H)))).
Definition bigop_Sfalse : forall B, forall (k:(nat.nat) ), forall (p:((nat.nat) ) -> (bool.bool) ), forall (nil:B), forall (op:(B) -> (B) -> B), forall (f:((nat.nat) ) -> B), ((((logic.eq) ((bool.bool) )) ((p) (k))) ((bool.false) )) -> (((logic.eq) (B)) (((((((bigop) (B)) (((nat.S) ) (k))) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (((((((bigop) (B)) (k)) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i))) := fun (B:Type) => fun (k:(nat.nat) ) => fun (p:((nat.nat) ) -> (bool.bool) ) => fun (nil:B) => fun (op:(B) -> (B) -> B) => fun (f:((nat.nat) ) -> B) => ((((sym_eq_bigop_S) (B)) (k)) (fun (y:(((nat.nat) ) -> (bool.bool) ) -> (B) -> ((B) -> (B) -> B) -> (((nat.nat) ) -> B) -> B) => ((((logic.eq) ((bool.bool) )) ((p) (k))) ((bool.false) )) -> (((logic.eq) (B)) (((((y) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (((((((bigop) (B)) (k)) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i))))) (((((sym_eq_bigop_body_S) (B)) (k)) (fun (y:(((nat.nat) ) -> (bool.bool) ) -> (B) -> ((B) -> (B) -> B) -> (((nat.nat) ) -> B) -> B) => ((((logic.eq) ((bool.bool) )) ((p) (k))) ((bool.false) )) -> (((logic.eq) (B)) (((((y) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (((((((bigop) (B)) (k)) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i))))) (fun (H:(((logic.eq) ((bool.bool) )) ((p) (k))) ((bool.false) )) => (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.false) )) (fun (x:(bool.bool) ) => (((logic.eq) (B)) (((((bool.match_bool_type) (B)) (((op) ((f) (k))) (((((((bigop) (B)) (k)) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i))))) (((((((bigop) (B)) (k)) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (x))) (((((((bigop) (B)) (k)) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i))))) ((((((bool.eq_match_bool_type_false) (B)) (((op) ((f) (k))) (((((((bigop) (B)) (k)) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i))))) (((((((bigop) (B)) (k)) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (fun (y:B) => (((logic.eq) (B)) (((((bool.match_bool_type) (B)) (((op) ((f) (k))) (((((((bigop) (B)) (k)) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i))))) (((((((bigop) (B)) (k)) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) ((bool.false) ))) (y))) (((logic.refl) (B)) (((((bool.match_bool_type) (B)) (((op) ((f) (k))) (((((((bigop) (B)) (k)) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i))))) (((((((bigop) (B)) (k)) (fun (i:(nat.nat) ) => (p) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) ((bool.false) ))))) ((p) (k))) (H)))).
Definition same_bigop : forall B, forall (k:(nat.nat) ), forall (p1:((nat.nat) ) -> (bool.bool) ), forall (p2:((nat.nat) ) -> (bool.bool) ), forall (nil:B), forall (op:(B) -> (B) -> B), forall (f:((nat.nat) ) -> B), forall (g:((nat.nat) ) -> B), (((((sameF_upto) ((bool.bool) )) (k)) (p1)) (p2)) -> ((((((sameF_p) (B)) (k)) (p1)) (f)) (g)) -> (((logic.eq) (B)) (((((((bigop) (B)) (k)) (fun (i:(nat.nat) ) => (p1) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (((((((bigop) (B)) (k)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i))) := fun (B:Type) => fun (k:(nat.nat) ) => fun (p1:((nat.nat) ) -> (bool.bool) ) => fun (p2:((nat.nat) ) -> (bool.bool) ) => fun (nil:B) => fun (op:(B) -> (B) -> B) => fun (f:((nat.nat) ) -> B) => fun (g:((nat.nat) ) -> B) => ((((nat.nat_ind) (fun (_x_365:(nat.nat) ) => (((((sameF_upto) ((bool.bool) )) (_x_365)) (p1)) (p2)) -> ((((((sameF_p) (B)) (_x_365)) (p1)) (f)) (g)) -> (((logic.eq) (B)) (((((((bigop) (B)) (_x_365)) (fun (i:(nat.nat) ) => (p1) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (((((((bigop) (B)) (_x_365)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i))))) ((((sym_eq_bigop_O) (B)) (fun (y:(((nat.nat) ) -> (bool.bool) ) -> (B) -> ((B) -> (B) -> B) -> (((nat.nat) ) -> B) -> B) => (((((sameF_upto) ((bool.bool) )) ((nat.O) )) (p1)) (p2)) -> ((((((sameF_p) (B)) ((nat.O) )) (p1)) (f)) (g)) -> (((logic.eq) (B)) (((((((bigop) (B)) ((nat.O) )) (fun (i:(nat.nat) ) => (p1) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (((((y) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i))))) ((((sym_eq_bigop_body_O) (B)) (fun (y:(((nat.nat) ) -> (bool.bool) ) -> (B) -> ((B) -> (B) -> B) -> (((nat.nat) ) -> B) -> B) => (((((sameF_upto) ((bool.bool) )) ((nat.O) )) (p1)) (p2)) -> ((((((sameF_p) (B)) ((nat.O) )) (p1)) (f)) (g)) -> (((logic.eq) (B)) (((((((bigop) (B)) ((nat.O) )) (fun (i:(nat.nat) ) => (p1) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (((((y) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i))))) ((((eq_bigop_body_O) (B)) (fun (y:(((nat.nat) ) -> (bool.bool) ) -> (B) -> ((B) -> (B) -> B) -> (((nat.nat) ) -> B) -> B) => (((((sameF_upto) ((bool.bool) )) ((nat.O) )) (p1)) (p2)) -> ((((((sameF_p) (B)) ((nat.O) )) (p1)) (f)) (g)) -> (((logic.eq) (B)) (((((((bigop) (B)) ((nat.O) )) (fun (i:(nat.nat) ) => (p1) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (((((y) (fun (i:(nat.nat) ) => (p1) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i))))) ((((eq_bigop_O) (B)) (fun (y:(((nat.nat) ) -> (bool.bool) ) -> (B) -> ((B) -> (B) -> B) -> (((nat.nat) ) -> B) -> B) => (((((sameF_upto) ((bool.bool) )) ((nat.O) )) (p1)) (p2)) -> ((((((sameF_p) (B)) ((nat.O) )) (p1)) (f)) (g)) -> (((logic.eq) (B)) (((((((bigop) (B)) ((nat.O) )) (fun (i:(nat.nat) ) => (p1) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (((((y) (fun (i:(nat.nat) ) => (p1) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i))))) (fun (auto:((((sameF_upto) ((bool.bool) )) ((nat.O) )) (p1)) (p2)) => (fun (auto':(((((sameF_p) (B)) ((nat.O) )) (p1)) (f)) (g)) => (((logic.refl) (B)) (((((((bigop) (B)) ((nat.O) )) (fun (i:(nat.nat) ) => (p1) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i))))))))))) (fun (n:(nat.nat) ) => ((((sym_eq_bigop_S) (B)) (n)) (fun (y:(((nat.nat) ) -> (bool.bool) ) -> (B) -> ((B) -> (B) -> B) -> (((nat.nat) ) -> B) -> B) => ((((((sameF_upto) ((bool.bool) )) (n)) (p1)) (p2)) -> ((((((sameF_p) (B)) (n)) (p1)) (f)) (g)) -> (((logic.eq) (B)) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p1) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i)))) -> (((((sameF_upto) ((bool.bool) )) (((nat.S) ) (n))) (p1)) (p2)) -> ((((((sameF_p) (B)) (((nat.S) ) (n))) (p1)) (f)) (g)) -> (((logic.eq) (B)) (((((((bigop) (B)) (((nat.S) ) (n))) (fun (i:(nat.nat) ) => (p1) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (((((y) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i))))) (((((sym_eq_bigop_S) (B)) (n)) (fun (y:(((nat.nat) ) -> (bool.bool) ) -> (B) -> ((B) -> (B) -> B) -> (((nat.nat) ) -> B) -> B) => ((((((sameF_upto) ((bool.bool) )) (n)) (p1)) (p2)) -> ((((((sameF_p) (B)) (n)) (p1)) (f)) (g)) -> (((logic.eq) (B)) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p1) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i)))) -> (((((sameF_upto) ((bool.bool) )) (((nat.S) ) (n))) (p1)) (p2)) -> ((((((sameF_p) (B)) (((nat.S) ) (n))) (p1)) (f)) (g)) -> (((logic.eq) (B)) (((((y) (fun (i:(nat.nat) ) => (p1) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (((((((bigop_body) (B)) (((nat.S) ) (n))) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i))))) (((((sym_eq_bigop_body_S) (B)) (n)) (fun (y:(((nat.nat) ) -> (bool.bool) ) -> (B) -> ((B) -> (B) -> B) -> (((nat.nat) ) -> B) -> B) => ((((((sameF_upto) ((bool.bool) )) (n)) (p1)) (p2)) -> ((((((sameF_p) (B)) (n)) (p1)) (f)) (g)) -> (((logic.eq) (B)) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p1) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i)))) -> (((((sameF_upto) ((bool.bool) )) (((nat.S) ) (n))) (p1)) (p2)) -> ((((((sameF_p) (B)) (((nat.S) ) (n))) (p1)) (f)) (g)) -> (((logic.eq) (B)) (((((y) (fun (i:(nat.nat) ) => (p1) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (((((((bigop_body) (B)) (((nat.S) ) (n))) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i))))) (((((sym_eq_bigop_body_S) (B)) (n)) (fun (y:(((nat.nat) ) -> (bool.bool) ) -> (B) -> ((B) -> (B) -> B) -> (((nat.nat) ) -> B) -> B) => ((((((sameF_upto) ((bool.bool) )) (n)) (p1)) (p2)) -> ((((((sameF_p) (B)) (n)) (p1)) (f)) (g)) -> (((logic.eq) (B)) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p1) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i)))) -> (((((sameF_upto) ((bool.bool) )) (((nat.S) ) (n))) (p1)) (p2)) -> ((((((sameF_p) (B)) (((nat.S) ) (n))) (p1)) (f)) (g)) -> (((logic.eq) (B)) (((((fun (p:((nat.nat) ) -> (bool.bool) ) => fun (nil0:B) => fun (op0:(B) -> (B) -> B) => fun (f0:((nat.nat) ) -> B) => ((((bool.match_bool_type) (B)) (((op0) ((f0) (n))) (((((((bigop) (B)) (n)) (p)) (nil0)) (op0)) (f0)))) (((((((bigop) (B)) (n)) (p)) (nil0)) (op0)) (f0))) ((p) (n))) (fun (i:(nat.nat) ) => (p1) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (((((y) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i))))) (fun (Hind:(((((sameF_upto) ((bool.bool) )) (n)) (p1)) (p2)) -> ((((((sameF_p) (B)) (n)) (p1)) (f)) (g)) -> (((logic.eq) (B)) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p1) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i)))) => (fun (samep:((((sameF_upto) ((bool.bool) )) (((nat.S) ) (n))) (p1)) (p2)) => (fun (samef:(((((sameF_p) (B)) (((nat.S) ) (n))) (p1)) (f)) (g)) => (((((((logic.eq_ind_r) (B)) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i)))) (fun (x:B) => (((logic.eq) (B)) (((((bool.match_bool_type) (B)) (((op) ((f) (n))) (x))) (x)) ((p1) (n)))) (((((bool.match_bool_type) (B)) (((op) ((g) (n))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i))))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i)))) ((p2) (n))))) (((((((logic.eq_ind) ((bool.bool) )) ((p1) (n))) (fun (x_1:(bool.bool) ) => (((logic.eq) (B)) (((((bool.match_bool_type) (B)) (((op) ((f) (n))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i))))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i)))) ((p1) (n)))) (((((bool.match_bool_type) (B)) (((op) ((g) (n))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i))))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i)))) (x_1)))) (((((((connectives.match_Or_prop) ((((logic.eq) ((bool.bool) )) ((p1) (n))) ((bool.true) ))) ((((logic.eq) ((bool.bool) )) ((p1) (n))) ((bool.false) ))) ((((logic.eq) (B)) (((((bool.match_bool_type) (B)) (((op) ((f) (n))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i))))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i)))) ((p1) (n)))) (((((bool.match_bool_type) (B)) (((op) ((g) (n))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i))))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i)))) ((p1) (n))))) (fun (H1:(((logic.eq) ((bool.bool) )) ((p1) (n))) ((bool.true) )) => (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.true) )) (fun (x:(bool.bool) ) => (((logic.eq) (B)) (((((bool.match_bool_type) (B)) (((op) ((f) (n))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i))))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i)))) (x))) (((((bool.match_bool_type) (B)) (((op) ((g) (n))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i))))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i)))) (x)))) ((((((bool.sym_eq_match_bool_type_true) (B)) (((op) ((f) (n))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i))))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i)))) (fun (y:B) => (((logic.eq) (B)) (y)) (((((bool.match_bool_type) (B)) (((op) ((g) (n))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i))))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i)))) ((bool.true) )))) ((((((bool.sym_eq_match_bool_type_true) (B)) (((op) ((g) (n))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i))))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i)))) (fun (y:B) => (((logic.eq) (B)) (((op) ((f) (n))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i))))) (y))) (((((((logic.eq_ind) (B)) ((f) (n))) (fun (x_1:B) => (((logic.eq) (B)) (((op) ((f) (n))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i))))) (((op) (x_1)) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i)))))) (((logic.refl) (B)) (((op) ((f) (n))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i)))))) ((g) (n))) ((((samef) (n)) ((nat.le_n) (((nat.S) ) (n)))) (H1)))))) ((p1) (n))) (H1)))) (fun (H1:(((logic.eq) ((bool.bool) )) ((p1) (n))) ((bool.false) )) => (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.false) )) (fun (x:(bool.bool) ) => (((logic.eq) (B)) (((((bool.match_bool_type) (B)) (((op) ((f) (n))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i))))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i)))) (x))) (((((bool.match_bool_type) (B)) (((op) ((g) (n))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i))))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i)))) (x)))) ((((((bool.sym_eq_match_bool_type_false) (B)) (((op) ((f) (n))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i))))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i)))) (fun (y:B) => (((logic.eq) (B)) (y)) (((((bool.match_bool_type) (B)) (((op) ((g) (n))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i))))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i)))) ((bool.false) )))) ((((((bool.sym_eq_match_bool_type_false) (B)) (((op) ((g) (n))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i))))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i)))) (fun (y:B) => (((logic.eq) (B)) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i)))) (y))) (((logic.refl) (B)) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p2) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (g) (i))))))) ((p1) (n))) (H1)))) ((bool.true_or_false) ((p1) (n))))) ((p2) (n))) (((samep) (n)) ((nat.le_n) (((nat.S) ) (n)))))) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (p1) (i))) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (((Hind) ((((((((sameF_upto_le) ((bool.bool) )) (p1)) (p2)) (n)) (((nat.S) ) (n))) (((((logic.eq_coerc) ((((nat.le) ) (((nat.pred) ) (((nat.S) ) (n)))) (((nat.S) ) (n)))) ((((nat.le) ) (n)) (((nat.S) ) (n)))) ((nat.le_pred_n) (((nat.S) ) (n)))) (((((((logic.rewrite_l) ((nat.nat) )) (n)) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) (__)) (((nat.S) ) (n)))) ((((nat.le) ) (n)) (((nat.S) ) (n))))) (((logic.refl) (Prop)) ((((nat.le) ) (n)) (((nat.S) ) (n))))) (((nat.pred) ) (((nat.S) ) (n)))) ((nat.pred_Sn) (n))))) (samep))) (((((((((sameF_p_le) (B)) (p1)) (f)) (g)) (n)) (((nat.S) ) (n))) (((((logic.eq_coerc) ((((nat.le) ) (((nat.pred) ) (((nat.S) ) (n)))) (((nat.S) ) (n)))) ((((nat.le) ) (n)) (((nat.S) ) (n)))) ((nat.le_pred_n) (((nat.S) ) (n)))) (((((((logic.rewrite_l) ((nat.nat) )) (n)) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) (__)) (((nat.S) ) (n)))) ((((nat.le) ) (n)) (((nat.S) ) (n))))) (((logic.refl) (Prop)) ((((nat.le) ) (n)) (((nat.S) ) (n))))) (((nat.pred) ) (((nat.S) ) (n)))) ((nat.pred_Sn) (n))))) (samef)))))))))))) (k).
Definition bigop_false : forall B, forall (n:(nat.nat) ), forall (nil:B), forall (op:(B) -> (B) -> B), forall (f:((nat.nat) ) -> B), (((logic.eq) (B)) (((((((bigop) (B)) (n)) (fun (i:(nat.nat) ) => (bool.false) )) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (nil) := fun (B:Type) => fun (n:(nat.nat) ) => fun (nil:B) => fun (op:(B) -> (B) -> B) => fun (f:((nat.nat) ) -> B) => ((((nat.nat_ind) (fun (_x_365:(nat.nat) ) => (((logic.eq) (B)) (((((((bigop) (B)) (_x_365)) (fun (i:(nat.nat) ) => (bool.false) )) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (nil))) ((((eq_bigop_body_O) (B)) (fun (y:(((nat.nat) ) -> (bool.bool) ) -> (B) -> ((B) -> (B) -> B) -> (((nat.nat) ) -> B) -> B) => (((logic.eq) (B)) (((((((bigop) (B)) ((nat.O) )) (fun (i:(nat.nat) ) => (bool.false) )) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (((((y) (fun (i:(nat.nat) ) => (bool.false) )) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i))))) ((((eq_bigop_O) (B)) (fun (y:(((nat.nat) ) -> (bool.bool) ) -> (B) -> ((B) -> (B) -> B) -> (((nat.nat) ) -> B) -> B) => (((logic.eq) (B)) (((((((bigop) (B)) ((nat.O) )) (fun (i:(nat.nat) ) => (bool.false) )) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (((((y) (fun (i:(nat.nat) ) => (bool.false) )) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i))))) (((logic.refl) (B)) (((((((bigop) (B)) ((nat.O) )) (fun (i:(nat.nat) ) => (bool.false) )) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i))))))) (fun (n1:(nat.nat) ) => fun (Hind:(((logic.eq) (B)) (((((((bigop) (B)) (n1)) (fun (i:(nat.nat) ) => (bool.false) )) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (nil)) => (((((((logic.eq_ind_r) (B)) (((((((bigop) (B)) (n1)) (fun (i:(nat.nat) ) => (bool.false) )) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (fun (x:B) => (((logic.eq) (B)) (x)) (nil))) (((((((logic.rewrite_r) (B)) (nil)) (fun (__:B) => (((logic.eq) (B)) (__)) (nil))) (((logic.refl) (B)) (nil))) (((((((bigop) (B)) (n1)) (fun (i:(nat.nat) ) => (bool.false) )) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) (Hind))) (((((((bigop) (B)) (((nat.S) ) (n1))) (fun (i:(nat.nat) ) => (bool.false) )) (nil)) (op)) (fun (i:(nat.nat) ) => (f) (i)))) ((((((((bigop_Sfalse) (B)) (n1)) (fun (__:(nat.nat) ) => (bool.false) )) (nil)) (op)) (f)) (((logic.refl) ((bool.bool) )) ((bool.false) )))))) (n).
Parameter Aop : forall (A:Type), (A) -> Prop.
Axiom mk_Aop : forall A, forall (nil:A), forall (op:(A) -> (A) -> A), (forall (a:A), (((logic.eq) (A)) (((op) (nil)) (a))) (a)) -> (forall (a:A), (((logic.eq) (A)) (((op) (a)) (nil))) (a)) -> (forall (a:A), forall (b:A), forall (c:A), (((logic.eq) (A)) (((op) (a)) (((op) (b)) (c)))) (((op) (((op) (a)) (b))) (c))) -> ((Aop) (A)) (nil).
Definition assoc : forall (a:(nat.nat) ), forall (b:(nat.nat) ), forall (c:(nat.nat) ), (((logic.eq) ((nat.nat) )) ((((nat.times) ) (a)) ((((nat.times) ) (b)) (c)))) ((((nat.times) ) ((((nat.times) ) (a)) (b))) (c)) := fun (a:(nat.nat) ) => fun (b:(nat.nat) ) => fun (c:(nat.nat) ) => ((((logic.sym_eq) ((nat.nat) )) ((((nat.times) ) ((((nat.times) ) (a)) (b))) (c))) ((((nat.times) ) (a)) ((((nat.times) ) (b)) (c)))) ((((nat.associative_times) (a)) (b)) (c)).
Definition timesA : ((Aop) ((nat.nat) )) (((nat.S) ) ((nat.O) )) := ((((((mk_Aop) ((nat.nat) )) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (a:(nat.nat) ) => (((nat.sym_eq_times) (((nat.S) ) ((nat.O) ))) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) ((y) (a))) (a))) ((((((nat.sym_eq_filter_nat_type_S) (((nat.nat) ) -> (nat.nat) )) ((nat.times_body) )) ((nat.O) )) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) ((y) (a))) (a))) ((((nat.sym_eq_times_body_S) ((nat.O) )) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) ((y) (a))) (a))) ((((nat.sym_eq_times) ((nat.O) )) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.plus) ) (a)) ((y) (a)))) (a))) (((((nat.sym_eq_filter_nat_type_O) (((nat.nat) ) -> (nat.nat) )) ((nat.times_body) )) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.plus) ) (a)) ((y) (a)))) (a))) (((nat.sym_eq_times_body_O) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.plus) ) (a)) ((y) (a)))) (a))) (((((logic.sym_eq) ((nat.nat) )) (a)) ((((nat.plus) ) (a)) ((nat.O) ))) ((nat.plus_n_O) (a)))))))))) (fun (n:(nat.nat) ) => ((((logic.sym_eq) ((nat.nat) )) (n)) ((((nat.times) ) (n)) (((nat.S) ) ((nat.O) )))) ((nat.times_n_1) (n)))) (fun (a:(nat.nat) ) => fun (b:(nat.nat) ) => fun (c:(nat.nat) ) => ((((logic.sym_eq) ((nat.nat) )) ((((nat.times) ) ((((nat.times) ) (a)) (b))) (c))) ((((nat.times) ) (a)) ((((nat.times) ) (b)) (c)))) ((((nat.associative_times) (a)) (b)) (c))).
Definition bigop_I_gen : forall (a:(nat.nat) ), forall (b:(nat.nat) ), forall (p:((nat.nat) ) -> (bool.bool) ), forall (f:((nat.nat) ) -> (nat.nat) ), ((((nat.le) ) (a)) (b)) -> (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((((nat.minus) ) (b)) (a))) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a))))) (((((((bigop) ((nat.nat) )) (b)) (fun (i:(nat.nat) ) => (((bool.andb) ) ((((nat.leb) ) (a)) (i))) ((p) (i)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) (i))) := fun (a:(nat.nat) ) => fun (b:(nat.nat) ) => ((((nat.nat_ind) (fun (_x_365:(nat.nat) ) => forall (p:((nat.nat) ) -> (bool.bool) ), forall (f:((nat.nat) ) -> (nat.nat) ), ((((nat.le) ) (a)) (_x_365)) -> (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((((nat.minus) ) (_x_365)) (a))) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a))))) (((((((bigop) ((nat.nat) )) (_x_365)) (fun (i:(nat.nat) ) => (((bool.andb) ) ((((nat.leb) ) (a)) (i))) ((p) (i)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) (i))))) (fun (p:((nat.nat) ) -> (bool.bool) ) => fun (f:((nat.nat) ) -> (nat.nat) ) => (((sym_eq_bigop_O) ((nat.nat) )) (fun (y:(((nat.nat) ) -> (bool.bool) ) -> ((nat.nat) ) -> (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) -> (((nat.nat) ) -> (nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) (a)) ((nat.O) )) -> (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((((nat.minus) ) ((nat.O) )) (a))) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a))))) (((((y) (fun (i:(nat.nat) ) => (((bool.andb) ) ((((nat.leb) ) (a)) (i))) ((p) (i)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) (i))))) ((((sym_eq_bigop_body_O) ((nat.nat) )) (fun (y:(((nat.nat) ) -> (bool.bool) ) -> ((nat.nat) ) -> (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) -> (((nat.nat) ) -> (nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) (a)) ((nat.O) )) -> (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((((nat.minus) ) ((nat.O) )) (a))) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a))))) (((((y) (fun (i:(nat.nat) ) => (((bool.andb) ) ((((nat.leb) ) (a)) (i))) ((p) (i)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) (i))))) ((((eq_bigop_body_O) ((nat.nat) )) (fun (y:(((nat.nat) ) -> (bool.bool) ) -> ((nat.nat) ) -> (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) -> (((nat.nat) ) -> (nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) (a)) ((nat.O) )) -> (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((((nat.minus) ) ((nat.O) )) (a))) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a))))) (((((y) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a)))))) ((((eq_bigop_O) ((nat.nat) )) (fun (y:(((nat.nat) ) -> (bool.bool) ) -> ((nat.nat) ) -> (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) -> (((nat.nat) ) -> (nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) (a)) ((nat.O) )) -> (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((((nat.minus) ) ((nat.O) )) (a))) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a))))) (((((y) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a)))))) (((nat.eq_minus_body_O) (fun (y:((nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) (a)) ((nat.O) )) -> (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((((nat.minus) ) ((nat.O) )) (a))) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a))))) (((((((bigop) ((nat.nat) )) ((y) (a))) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a)))))) (((((nat.eq_filter_nat_type_O) (((nat.nat) ) -> (nat.nat) )) ((nat.minus_body) )) (fun (y:((nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) (a)) ((nat.O) )) -> (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((((nat.minus) ) ((nat.O) )) (a))) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a))))) (((((((bigop) ((nat.nat) )) ((y) (a))) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a)))))) ((((nat.eq_minus) ((nat.O) )) (fun (y:((nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) (a)) ((nat.O) )) -> (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((((nat.minus) ) ((nat.O) )) (a))) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a))))) (((((((bigop) ((nat.nat) )) ((y) (a))) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a)))))) (fun (auto:(((nat.le) ) (a)) ((nat.O) )) => (((logic.refl) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((((nat.minus) ) ((nat.O) )) (a))) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a)))))))))))))) (fun (b0:(nat.nat) ) => fun (Hind:forall (p:((nat.nat) ) -> (bool.bool) ), forall (f:((nat.nat) ) -> (nat.nat) ), ((((nat.le) ) (a)) (b0)) -> (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((((nat.minus) ) (b0)) (a))) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a))))) (((((((bigop) ((nat.nat) )) (b0)) (fun (i:(nat.nat) ) => (((bool.andb) ) ((((nat.leb) ) (a)) (i))) ((p) (i)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) (i)))) => (fun (p:((nat.nat) ) -> (bool.bool) ) => fun (f:((nat.nat) ) -> (nat.nat) ) => fun (lea:(((nat.le) ) (a)) (((nat.S) ) (b0))) => (((((((connectives.match_Or_prop) ((((nat.lt) ) (a)) (((nat.S) ) (b0)))) ((((logic.eq) ((nat.nat) )) (a)) (((nat.S) ) (b0)))) ((((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((((nat.minus) ) (((nat.S) ) (b0))) (a))) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a))))) (((((((bigop) ((nat.nat) )) (((nat.S) ) (b0))) (fun (i:(nat.nat) ) => (((bool.andb) ) ((((nat.leb) ) (a)) (i))) ((p) (i)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) (i))))) (fun (Ha:(((nat.lt) ) (a)) (((nat.S) ) (b0))) => (((((((connectives.match_Or_prop) ((((logic.eq) ((bool.bool) )) ((p) (b0))) ((bool.true) ))) ((((logic.eq) ((bool.bool) )) ((p) (b0))) ((bool.false) ))) ((((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((((nat.minus) ) (((nat.S) ) (b0))) (a))) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a))))) (((((((bigop) ((nat.nat) )) (((nat.S) ) (b0))) (fun (i:(nat.nat) ) => (((bool.andb) ) ((((nat.leb) ) (a)) (i))) ((p) (i)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) (i))))) (fun (Hcase:(((logic.eq) ((bool.bool) )) ((p) (b0))) ((bool.true) )) => (((((((logic.eq_ind_r) ((nat.nat) )) ((((nat.times) ) ((f) (b0))) (((((((bigop) ((nat.nat) )) (b0)) (fun (i:(nat.nat) ) => (((bool.andb) ) ((((nat.leb) ) (a)) (i))) ((p) (i)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) (i))))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((((nat.minus) ) (((nat.S) ) (b0))) (a))) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a))))) (x))) (((((((logic.eq_ind_r) ((nat.nat) )) (((nat.S) ) ((((nat.minus) ) (b0)) (a)))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) (x)) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a))))) ((((nat.times) ) ((f) (b0))) (((((((bigop) ((nat.nat) )) (b0)) (fun (i:(nat.nat) ) => (((bool.andb) ) ((((nat.leb) ) (a)) (i))) ((p) (i)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) (i)))))) (((((((logic.eq_ind_r) ((nat.nat) )) ((((nat.times) ) ((f) ((((nat.plus) ) ((((nat.minus) ) (b0)) (a))) (a)))) (((((((bigop) ((nat.nat) )) ((((nat.minus) ) (b0)) (a))) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a)))))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (x)) ((((nat.times) ) ((f) (b0))) (((((((bigop) ((nat.nat) )) (b0)) (fun (i:(nat.nat) ) => (((bool.andb) ) ((((nat.leb) ) (a)) (i))) ((p) (i)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) (i)))))) (((((((((((logic.eq_f2) ((nat.nat) )) ((nat.nat) )) ((nat.nat) )) ((nat.times) )) ((f) ((((nat.plus) ) ((((nat.minus) ) (b0)) (a))) (a)))) ((f) (b0))) (((((((bigop) ((nat.nat) )) ((((nat.minus) ) (b0)) (a))) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a))))) (((((((bigop) ((nat.nat) )) (b0)) (fun (i:(nat.nat) ) => (((bool.andb) ) ((((nat.leb) ) (a)) (i))) ((p) (i)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) (i)))) (((((((logic.eq_f) ((nat.nat) )) ((nat.nat) )) (f)) ((((nat.plus) ) ((((nat.minus) ) (b0)) (a))) (a))) (b0)) (((((((logic.eq_ind) ((nat.nat) )) (b0)) (fun (x_1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (x_1)) (b0))) (((logic.refl) ((nat.nat) )) (b0))) ((((nat.plus) ) ((((nat.minus) ) (b0)) (a))) (a))) ((((nat.plus_minus_m_m) (b0)) (a)) ((((nat.le_S_S_to_le) (a)) (b0)) (Ha)))))) ((((Hind) (p)) (f)) ((((nat.le_S_S_to_le) (a)) (b0)) (Ha))))) (((((((bigop) ((nat.nat) )) (((nat.S) ) ((((nat.minus) ) (b0)) (a)))) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a))))) ((((((((bigop_Strue) ((nat.nat) )) ((((nat.minus) ) (b0)) (a))) (fun (__:(nat.nat) ) => (p) ((((nat.plus) ) (__)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (__:(nat.nat) ) => (f) ((((nat.plus) ) (__)) (a)))) (((((((logic.eq_ind) ((nat.nat) )) (b0)) (fun (x_1:(nat.nat) ) => (((logic.eq) ((bool.bool) )) ((p) (x_1))) ((bool.true) ))) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.true) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.true) ))) (((logic.refl) ((bool.bool) )) ((bool.true) ))) ((p) (b0))) (Hcase))) ((((nat.plus) ) ((((nat.minus) ) (b0)) (a))) (a))) ((((nat.plus_minus_m_m) (b0)) (a)) ((((nat.le_S_S_to_le) (a)) (b0)) (Ha))))))) ((((nat.minus) ) (((nat.S) ) (b0))) (a))) ((((((nat.match_nat_prop) (fun (__:(nat.nat) ) => ((((nat.le) ) (__)) (b0)) -> (((logic.eq) ((nat.nat) )) ((((nat.minus) ) (((nat.S) ) (b0))) (__))) (((nat.S) ) ((((nat.minus) ) (b0)) (__))))) (fun (auto:(((nat.le) ) ((nat.O) )) (b0)) => (((((((logic.rewrite_l) ((nat.nat) )) (((nat.S) ) (b0))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__)) (((nat.S) ) ((((nat.minus) ) (b0)) ((nat.O) ))))) (((((((logic.rewrite_l) ((nat.nat) )) (b0)) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((nat.S) ) (b0))) (((nat.S) ) (__)))) (((logic.refl) ((nat.nat) )) (((nat.S) ) (b0)))) ((((nat.minus) ) (b0)) ((nat.O) ))) ((nat.minus_n_O) (b0)))) ((((nat.minus) ) (((nat.S) ) (b0))) ((nat.O) ))) ((nat.minus_n_O) (((nat.S) ) (b0)))))) ((((nat.sym_eq_minus) (((nat.S) ) (b0))) (fun (y:((nat.nat) ) -> (nat.nat) ) => forall (n:(nat.nat) ), ((((nat.le) ) (((nat.S) ) (n))) (b0)) -> (((logic.eq) ((nat.nat) )) ((y) (((nat.S) ) (n)))) (((nat.S) ) ((((nat.minus) ) (b0)) (((nat.S) ) (n)))))) ((((((nat.sym_eq_filter_nat_type_S) (((nat.nat) ) -> (nat.nat) )) ((nat.minus_body) )) (b0)) (fun (y:((nat.nat) ) -> (nat.nat) ) => forall (n:(nat.nat) ), ((((nat.le) ) (((nat.S) ) (n))) (b0)) -> (((logic.eq) ((nat.nat) )) ((y) (((nat.S) ) (n)))) (((nat.S) ) ((((nat.minus) ) (b0)) (((nat.S) ) (n)))))) (fun (a1:(nat.nat) ) => (((nat.sym_eq_minus_body_S) (b0)) (fun (y:((nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) (((nat.S) ) (a1))) (b0)) -> (((logic.eq) ((nat.nat) )) ((y) (((nat.S) ) (a1)))) (((nat.S) ) ((((nat.minus) ) (b0)) (((nat.S) ) (a1)))))) (((((((nat.sym_eq_match_nat_type_S) ((nat.nat) )) (((nat.S) ) (b0))) (fun (q:(nat.nat) ) => (((nat.minus) ) (b0)) (q))) (a1)) (fun (y:(nat.nat) ) => ((((nat.le) ) (((nat.S) ) (a1))) (b0)) -> (((logic.eq) ((nat.nat) )) (y)) (((nat.S) ) ((((nat.minus) ) (b0)) (((nat.S) ) (a1)))))) (fun (lta1:(((nat.le) ) (((nat.S) ) (a1))) (b0)) => (((((((logic.eq_ind_r) ((nat.nat) )) (((nat.pred) ) ((((nat.minus) ) (b0)) (a1)))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.minus) ) (b0)) (a1))) (((nat.S) ) (x)))) (((((((logic.eq_ind_r) ((nat.nat) )) ((((nat.minus) ) (b0)) (a1))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.minus) ) (b0)) (a1))) (x))) (((logic.refl) ((nat.nat) )) ((((nat.minus) ) (b0)) (a1)))) (((nat.S) ) (((nat.pred) ) ((((nat.minus) ) (b0)) (a1))))) (((nat.S_pred) ((((nat.minus) ) (b0)) (a1))) (((((nat.lt_plus_to_minus_r) ((nat.O) )) (a1)) (b0)) ((((nat.sym_eq_plus) ((nat.O) )) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((nat.le) ) (((nat.S) ) ((y) (a1)))) (b0))) (((((nat.sym_eq_filter_nat_type_O) (((nat.nat) ) -> (nat.nat) )) ((nat.plus_body) )) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((nat.le) ) (((nat.S) ) ((y) (a1)))) (b0))) (((nat.sym_eq_plus_body_O) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((nat.le) ) (((nat.S) ) ((y) (a1)))) (b0))) (lta1)))))))) ((((nat.minus) ) (b0)) (((nat.S) ) (a1)))) (((nat.eq_minus_S_pred) (b0)) (a1))))))))) (a)) ((((nat.le_S_S_to_le) (a)) (b0)) (Ha))))) (((((((bigop) ((nat.nat) )) (((nat.S) ) (b0))) (fun (i:(nat.nat) ) => (((bool.andb) ) ((((nat.leb) ) (a)) (i))) ((p) (i)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) (i)))) ((((((((bigop_Strue) ((nat.nat) )) (b0)) (fun (__:(nat.nat) ) => (((bool.andb) ) ((((nat.leb) ) (a)) (__))) ((p) (__)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (f)) (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.true) )) (fun (x:(bool.bool) ) => (((logic.eq) ((bool.bool) )) ((((bool.andb) ) ((((nat.leb) ) (a)) (b0))) (x))) ((bool.true) ))) (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.true) )) (fun (x:(bool.bool) ) => (((logic.eq) ((bool.bool) )) ((((bool.andb) ) (x)) ((bool.true) ))) ((bool.true) ))) ((((((bool.eq_match_bool_type_true) ((bool.bool) )) ((bool.true) )) ((bool.false) )) (fun (y:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (((((bool.match_bool_type) ((bool.bool) )) ((bool.true) )) ((bool.false) )) ((bool.true) ))) (y))) (((logic.refl) ((bool.bool) )) ((((bool.andb) ) ((bool.true) )) ((bool.true) ))))) ((((nat.leb) ) (a)) (b0))) ((((nat.le_to_leb_true) (a)) (b0)) ((((nat.le_S_S_to_le) (a)) (b0)) (Ha))))) ((p) (b0))) (Hcase)))))) (fun (Hcase:(((logic.eq) ((bool.bool) )) ((p) (b0))) ((bool.false) )) => (((((((logic.eq_ind_r) ((nat.nat) )) (((((((bigop) ((nat.nat) )) (b0)) (fun (i:(nat.nat) ) => (((bool.andb) ) ((((nat.leb) ) (a)) (i))) ((p) (i)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) (i)))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((((nat.minus) ) (((nat.S) ) (b0))) (a))) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a))))) (x))) (((((((logic.eq_ind_r) ((nat.nat) )) (((nat.S) ) ((((nat.minus) ) (b0)) (a)))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) (x)) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a))))) (((((((bigop) ((nat.nat) )) (b0)) (fun (i:(nat.nat) ) => (((bool.andb) ) ((((nat.leb) ) (a)) (i))) ((p) (i)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) (i))))) (((((((logic.eq_ind_r) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((((nat.minus) ) (b0)) (a))) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a))))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (x)) (((((((bigop) ((nat.nat) )) (b0)) (fun (i:(nat.nat) ) => (((bool.andb) ) ((((nat.leb) ) (a)) (i))) ((p) (i)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) (i))))) ((((Hind) (p)) (f)) ((((nat.le_S_S_to_le) (a)) (b0)) (Ha)))) (((((((bigop) ((nat.nat) )) (((nat.S) ) ((((nat.minus) ) (b0)) (a)))) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a))))) ((((((((bigop_Sfalse) ((nat.nat) )) ((((nat.minus) ) (b0)) (a))) (fun (__:(nat.nat) ) => (p) ((((nat.plus) ) (__)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (__:(nat.nat) ) => (f) ((((nat.plus) ) (__)) (a)))) (((((((logic.eq_ind) ((nat.nat) )) (b0)) (fun (x_1:(nat.nat) ) => (((logic.eq) ((bool.bool) )) ((p) (x_1))) ((bool.false) ))) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.false) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.false) ))) (((logic.refl) ((bool.bool) )) ((bool.false) ))) ((p) (b0))) (Hcase))) ((((nat.plus) ) ((((nat.minus) ) (b0)) (a))) (a))) ((((nat.plus_minus_m_m) (b0)) (a)) ((((nat.le_S_S_to_le) (a)) (b0)) (Ha))))))) ((((nat.minus) ) (((nat.S) ) (b0))) (a))) ((((((nat.match_nat_prop) (fun (__:(nat.nat) ) => ((((nat.le) ) (__)) (b0)) -> (((logic.eq) ((nat.nat) )) ((((nat.minus) ) (((nat.S) ) (b0))) (__))) (((nat.S) ) ((((nat.minus) ) (b0)) (__))))) (fun (auto:(((nat.le) ) ((nat.O) )) (b0)) => (((((((logic.rewrite_l) ((nat.nat) )) (((nat.S) ) (b0))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__)) (((nat.S) ) ((((nat.minus) ) (b0)) ((nat.O) ))))) (((((((logic.rewrite_l) ((nat.nat) )) (b0)) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((nat.S) ) (b0))) (((nat.S) ) (__)))) (((logic.refl) ((nat.nat) )) (((nat.S) ) (b0)))) ((((nat.minus) ) (b0)) ((nat.O) ))) ((nat.minus_n_O) (b0)))) ((((nat.minus) ) (((nat.S) ) (b0))) ((nat.O) ))) ((nat.minus_n_O) (((nat.S) ) (b0)))))) ((((nat.sym_eq_minus) (((nat.S) ) (b0))) (fun (y:((nat.nat) ) -> (nat.nat) ) => forall (n:(nat.nat) ), ((((nat.le) ) (((nat.S) ) (n))) (b0)) -> (((logic.eq) ((nat.nat) )) ((y) (((nat.S) ) (n)))) (((nat.S) ) ((((nat.minus) ) (b0)) (((nat.S) ) (n)))))) ((((((nat.sym_eq_filter_nat_type_S) (((nat.nat) ) -> (nat.nat) )) ((nat.minus_body) )) (b0)) (fun (y:((nat.nat) ) -> (nat.nat) ) => forall (n:(nat.nat) ), ((((nat.le) ) (((nat.S) ) (n))) (b0)) -> (((logic.eq) ((nat.nat) )) ((y) (((nat.S) ) (n)))) (((nat.S) ) ((((nat.minus) ) (b0)) (((nat.S) ) (n)))))) (fun (a1:(nat.nat) ) => (((nat.sym_eq_minus_body_S) (b0)) (fun (y:((nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) (((nat.S) ) (a1))) (b0)) -> (((logic.eq) ((nat.nat) )) ((y) (((nat.S) ) (a1)))) (((nat.S) ) ((((nat.minus) ) (b0)) (((nat.S) ) (a1)))))) (((((((nat.sym_eq_match_nat_type_S) ((nat.nat) )) (((nat.S) ) (b0))) (fun (q:(nat.nat) ) => (((nat.minus) ) (b0)) (q))) (a1)) (fun (y:(nat.nat) ) => ((((nat.le) ) (((nat.S) ) (a1))) (b0)) -> (((logic.eq) ((nat.nat) )) (y)) (((nat.S) ) ((((nat.minus) ) (b0)) (((nat.S) ) (a1)))))) (fun (lta1:(((nat.le) ) (((nat.S) ) (a1))) (b0)) => (((((((logic.eq_ind_r) ((nat.nat) )) (((nat.pred) ) ((((nat.minus) ) (b0)) (a1)))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.minus) ) (b0)) (a1))) (((nat.S) ) (x)))) (((((((logic.eq_ind_r) ((nat.nat) )) ((((nat.minus) ) (b0)) (a1))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.minus) ) (b0)) (a1))) (x))) (((logic.refl) ((nat.nat) )) ((((nat.minus) ) (b0)) (a1)))) (((nat.S) ) (((nat.pred) ) ((((nat.minus) ) (b0)) (a1))))) (((nat.S_pred) ((((nat.minus) ) (b0)) (a1))) (((((nat.lt_plus_to_minus_r) ((nat.O) )) (a1)) (b0)) ((((nat.sym_eq_plus) ((nat.O) )) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((nat.le) ) (((nat.S) ) ((y) (a1)))) (b0))) (((((nat.sym_eq_filter_nat_type_O) (((nat.nat) ) -> (nat.nat) )) ((nat.plus_body) )) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((nat.le) ) (((nat.S) ) ((y) (a1)))) (b0))) (((nat.sym_eq_plus_body_O) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((nat.le) ) (((nat.S) ) ((y) (a1)))) (b0))) (lta1)))))))) ((((nat.minus) ) (b0)) (((nat.S) ) (a1)))) (((nat.eq_minus_S_pred) (b0)) (a1))))))))) (a)) ((((nat.le_S_S_to_le) (a)) (b0)) (Ha))))) (((((((bigop) ((nat.nat) )) (((nat.S) ) (b0))) (fun (i:(nat.nat) ) => (((bool.andb) ) ((((nat.leb) ) (a)) (i))) ((p) (i)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) (i)))) ((((((((bigop_Sfalse) ((nat.nat) )) (b0)) (fun (__:(nat.nat) ) => (((bool.andb) ) ((((nat.leb) ) (a)) (__))) ((p) (__)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (f)) (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.false) )) (fun (x:(bool.bool) ) => (((logic.eq) ((bool.bool) )) ((((bool.andb) ) ((((nat.leb) ) (a)) (b0))) (x))) ((bool.false) ))) (((((bool.match_bool_prop) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) ((((bool.andb) ) (__)) ((bool.false) ))) ((bool.false) ))) ((((((bool.eq_match_bool_type_true) ((bool.bool) )) ((bool.false) )) ((bool.false) )) (fun (y:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (((((bool.match_bool_type) ((bool.bool) )) ((bool.false) )) ((bool.false) )) ((bool.true) ))) (y))) (((logic.refl) ((bool.bool) )) ((((bool.andb) ) ((bool.true) )) ((bool.false) ))))) ((((((bool.eq_match_bool_type_false) ((bool.bool) )) ((bool.false) )) ((bool.false) )) (fun (y:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (((((bool.match_bool_type) ((bool.bool) )) ((bool.false) )) ((bool.false) )) ((bool.false) ))) (y))) (((logic.refl) ((bool.bool) )) ((((bool.andb) ) ((bool.false) )) ((bool.false) ))))) ((((nat.leb) ) (a)) (b0)))) ((p) (b0))) (Hcase)))))) ((bool.true_or_false) ((p) (b0)))))) (fun (Ha:(((logic.eq) ((nat.nat) )) (a)) (((nat.S) ) (b0))) => (((((((logic.eq_ind) ((nat.nat) )) (a)) (fun (x_1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((((nat.minus) ) (x_1)) (a))) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a))))) (((((((bigop) ((nat.nat) )) (x_1)) (fun (i:(nat.nat) ) => (((bool.andb) ) ((((nat.leb) ) (a)) (i))) ((p) (i)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) (i))))) (((((((logic.eq_ind) ((nat.nat) )) ((nat.O) )) (fun (x_1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) (x_1)) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a))))) (((((((bigop) ((nat.nat) )) (a)) (fun (i:(nat.nat) ) => (((bool.andb) ) ((((nat.leb) ) (a)) (i))) ((p) (i)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) (i))))) ((((sym_eq_bigop_O) ((nat.nat) )) (fun (y:(((nat.nat) ) -> (bool.bool) ) -> ((nat.nat) ) -> (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) -> (((nat.nat) ) -> (nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((y) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a))))) (((((((bigop) ((nat.nat) )) (a)) (fun (i:(nat.nat) ) => (((bool.andb) ) ((((nat.leb) ) (a)) (i))) ((p) (i)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) (i))))) ((((sym_eq_bigop_body_O) ((nat.nat) )) (fun (y:(((nat.nat) ) -> (bool.bool) ) -> ((nat.nat) ) -> (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) -> (((nat.nat) ) -> (nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((y) (fun (i:(nat.nat) ) => (p) ((((nat.plus) ) (i)) (a)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) ((((nat.plus) ) (i)) (a))))) (((((((bigop) ((nat.nat) )) (a)) (fun (i:(nat.nat) ) => (((bool.andb) ) ((((nat.leb) ) (a)) (i))) ((p) (i)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) (i))))) (((((((logic.eq_ind) ((nat.nat) )) (((((((bigop) ((nat.nat) )) (a)) (fun (i:(nat.nat) ) => (bool.false) )) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) (i)))) (fun (x_1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (x_1)) (((((((bigop) ((nat.nat) )) (a)) (fun (i:(nat.nat) ) => (((bool.andb) ) ((((nat.leb) ) (a)) (i))) ((p) (i)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f) (i))))) (((((((((((same_bigop) ((nat.nat) )) (a)) (fun (__:(nat.nat) ) => (bool.false) )) (fun (__:(nat.nat) ) => (((bool.andb) ) ((((nat.leb) ) (a)) (__))) ((p) (__)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (f)) (f)) (fun (i:(nat.nat) ) => fun (ltia:(((nat.lt) ) (i)) (a)) => (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.false) )) (fun (x:(bool.bool) ) => (((logic.eq) ((bool.bool) )) ((bool.false) )) ((((bool.andb) ) (x)) ((p) (i))))) ((((((bool.sym_eq_match_bool_type_false) ((bool.bool) )) ((p) (i))) ((bool.false) )) (fun (y:(bool.bool) ) => (((logic.eq) ((bool.bool) )) ((bool.false) )) (y))) (((logic.refl) ((bool.bool) )) ((bool.false) )))) ((((nat.leb) ) (a)) (i))) ((((nat.not_le_to_leb_false) (a)) (i)) ((((nat.lt_to_not_le) (i)) (a)) (ltia)))))) (fun (i:(nat.nat) ) => fun (auto:(((nat.lt) ) (i)) (a)) => (fun (auto':(((logic.eq) ((bool.bool) )) ((bool.false) )) ((bool.true) )) => (((logic.refl) ((nat.nat) )) ((f) (i))))))) (((nat.S) ) ((nat.O) ))) ((((((bigop_false) ((nat.nat) )) (a)) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (f)))))) ((((nat.minus) ) (a)) (a))) ((nat.minus_n_n) (a)))) (((nat.S) ) (b0))) (Ha)))) ((((nat.le_to_or_lt_eq) (a)) (((nat.S) ) (b0))) (lea)))))) (b).
Parameter ACop : forall (A:Type), (A) -> Prop.
Axiom mk_ACop : forall A, forall (nil:A), forall (op:(A) -> (A) -> A), (forall (a:A), (((logic.eq) (A)) (((op) (nil)) (a))) (a)) -> (forall (a:A), (((logic.eq) (A)) (((op) (a)) (nil))) (a)) -> (forall (a:A), forall (b:A), forall (c:A), (((logic.eq) (A)) (((op) (a)) (((op) (b)) (c)))) (((op) (((op) (a)) (b))) (c))) -> (forall (a:A), forall (b:A), (((logic.eq) (A)) (((op) (a)) (b))) (((op) (b)) (a))) -> ((ACop) (A)) (nil).
Definition timesAC : ((ACop) ((nat.nat) )) (((nat.S) ) ((nat.O) )) := (((((((mk_ACop) ((nat.nat) )) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (a:(nat.nat) ) => (((nat.sym_eq_times) (((nat.S) ) ((nat.O) ))) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) ((y) (a))) (a))) ((((((nat.sym_eq_filter_nat_type_S) (((nat.nat) ) -> (nat.nat) )) ((nat.times_body) )) ((nat.O) )) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) ((y) (a))) (a))) ((((nat.sym_eq_times_body_S) ((nat.O) )) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) ((y) (a))) (a))) ((((nat.sym_eq_times) ((nat.O) )) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.plus) ) (a)) ((y) (a)))) (a))) (((((nat.sym_eq_filter_nat_type_O) (((nat.nat) ) -> (nat.nat) )) ((nat.times_body) )) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.plus) ) (a)) ((y) (a)))) (a))) (((nat.sym_eq_times_body_O) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.plus) ) (a)) ((y) (a)))) (a))) (((((logic.sym_eq) ((nat.nat) )) (a)) ((((nat.plus) ) (a)) ((nat.O) ))) ((nat.plus_n_O) (a)))))))))) (fun (n:(nat.nat) ) => ((((logic.sym_eq) ((nat.nat) )) (n)) ((((nat.times) ) (n)) (((nat.S) ) ((nat.O) )))) ((nat.times_n_1) (n)))) (fun (a:(nat.nat) ) => fun (b:(nat.nat) ) => fun (c:(nat.nat) ) => ((((logic.sym_eq) ((nat.nat) )) ((((nat.times) ) ((((nat.times) ) (a)) (b))) (c))) ((((nat.times) ) (a)) ((((nat.times) ) (b)) (c)))) ((((nat.associative_times) (a)) (b)) (c)))) (nat.commutative_times).
Definition bigop_diff : forall (p:((nat.nat) ) -> (bool.bool) ), forall (f:((nat.nat) ) -> (nat.nat) ), forall (i:(nat.nat) ), forall (n:(nat.nat) ), ((((nat.lt) ) (i)) (n)) -> ((((logic.eq) ((bool.bool) )) ((p) (i))) ((bool.true) )) -> (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) (n)) (fun (x:(nat.nat) ) => (p) (x))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x:(nat.nat) ) => (f) (x)))) ((((nat.times) ) ((f) (i))) (((((((bigop) ((nat.nat) )) (n)) (fun (x:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (x)))) ((p) (x)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x:(nat.nat) ) => (f) (x)))) := fun (p:((nat.nat) ) -> (bool.bool) ) => fun (f:((nat.nat) ) -> (nat.nat) ) => fun (i:(nat.nat) ) => fun (n:(nat.nat) ) => ((((nat.nat_ind) (fun (_x_365:(nat.nat) ) => ((((nat.lt) ) (i)) (_x_365)) -> ((((logic.eq) ((bool.bool) )) ((p) (i))) ((bool.true) )) -> (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) (_x_365)) (fun (x:(nat.nat) ) => (p) (x))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x:(nat.nat) ) => (f) (x)))) ((((nat.times) ) ((f) (i))) (((((((bigop) ((nat.nat) )) (_x_365)) (fun (x:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (x)))) ((p) (x)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x:(nat.nat) ) => (f) (x)))))) (fun (ltO:(((nat.lt) ) (i)) ((nat.O) )) => (((connectives.falsity) (((((logic.eq) ((bool.bool) )) ((p) (i))) ((bool.true) )) -> (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((nat.O) )) (fun (x:(nat.nat) ) => (p) (x))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x:(nat.nat) ) => (f) (x)))) ((((nat.times) ) ((f) (i))) (((((((bigop) ((nat.nat) )) ((nat.O) )) (fun (x:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (x)))) ((p) (x)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x:(nat.nat) ) => (f) (x)))))) ((((logic.absurd) ((((nat.le) ) (((nat.S) ) (i))) ((nat.O) ))) (ltO)) ((nat.not_le_Sn_O) (i)))))) (fun (n0:(nat.nat) ) => fun (Hind:((((nat.lt) ) (i)) (n0)) -> ((((logic.eq) ((bool.bool) )) ((p) (i))) ((bool.true) )) -> (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) (n0)) (fun (x:(nat.nat) ) => (p) (x))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x:(nat.nat) ) => (f) (x)))) ((((nat.times) ) ((f) (i))) (((((((bigop) ((nat.nat) )) (n0)) (fun (x:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (x)))) ((p) (x)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x:(nat.nat) ) => (f) (x))))) => (fun (lein:(((nat.lt) ) (i)) (((nat.S) ) (n0))) => (fun (pi:(((logic.eq) ((bool.bool) )) ((p) (i))) ((bool.true) )) => (((((((connectives.match_Or_prop) ((((nat.lt) ) (i)) (n0))) ((((logic.eq) ((nat.nat) )) (i)) (n0))) ((((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) (((nat.S) ) (n0))) (fun (x:(nat.nat) ) => (p) (x))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x:(nat.nat) ) => (f) (x)))) ((((nat.times) ) ((f) (i))) (((((((bigop) ((nat.nat) )) (((nat.S) ) (n0))) (fun (x:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (x)))) ((p) (x)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x:(nat.nat) ) => (f) (x)))))) (fun (Hi:(((nat.lt) ) (i)) (n0)) => (((((((connectives.match_Or_prop) ((((logic.eq) ((bool.bool) )) ((p) (n0))) ((bool.true) ))) ((((logic.eq) ((bool.bool) )) ((p) (n0))) ((bool.false) ))) ((((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) (((nat.S) ) (n0))) (fun (x:(nat.nat) ) => (p) (x))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x:(nat.nat) ) => (f) (x)))) ((((nat.times) ) ((f) (i))) (((((((bigop) ((nat.nat) )) (((nat.S) ) (n0))) (fun (x:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (x)))) ((p) (x)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x:(nat.nat) ) => (f) (x)))))) (fun (pn:(((logic.eq) ((bool.bool) )) ((p) (n0))) ((bool.true) )) => (((((((logic.eq_ind_r) ((nat.nat) )) ((((nat.times) ) ((f) (n0))) (((((((bigop) ((nat.nat) )) (n0)) (fun (i0:(nat.nat) ) => (p) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0))))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (x)) ((((nat.times) ) ((f) (i))) (((((((bigop) ((nat.nat) )) (((nat.S) ) (n0))) (fun (x0:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (x0)))) ((p) (x0)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x0:(nat.nat) ) => (f) (x0)))))) (((((((logic.eq_ind_r) ((nat.nat) )) ((((nat.times) ) ((f) (n0))) (((((((bigop) ((nat.nat) )) (n0)) (fun (i0:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (i0)))) ((p) (i0)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0))))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.times) ) ((f) (n0))) (((((((bigop) ((nat.nat) )) (n0)) (fun (i0:(nat.nat) ) => (p) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0))))) ((((nat.times) ) ((f) (i))) (x)))) (((((((logic.eq_ind_r) ((nat.nat) )) ((((nat.times) ) ((((nat.times) ) ((f) (i))) ((f) (n0)))) (((((((bigop) ((nat.nat) )) (n0)) (fun (i0:(nat.nat) ) => ((((bool.match_bool_type) ((bool.bool) )) ((p) (i0))) ((bool.false) )) (((((bool.match_bool_type) ((bool.bool) )) ((bool.false) )) ((bool.true) )) ((((nat.eqb) ) (i)) (i0))))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0))))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.times) ) ((f) (n0))) (((((((bigop) ((nat.nat) )) (n0)) (fun (i0:(nat.nat) ) => (p) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0))))) (x))) (((((((logic.eq_ind_r) ((nat.nat) )) ((((nat.times) ) ((f) (n0))) ((f) (i)))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.times) ) ((f) (n0))) (((((((bigop) ((nat.nat) )) (n0)) (fun (i0:(nat.nat) ) => (p) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0))))) ((((nat.times) ) (x)) (((((((bigop) ((nat.nat) )) (n0)) (fun (i0:(nat.nat) ) => ((((bool.match_bool_type) ((bool.bool) )) ((p) (i0))) ((bool.false) )) (((((bool.match_bool_type) ((bool.bool) )) ((bool.false) )) ((bool.true) )) ((((nat.eqb) ) (i)) (i0))))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0)))))) (((((((logic.eq_ind) ((nat.nat) )) ((((nat.times) ) ((f) (n0))) ((((nat.times) ) ((f) (i))) (((((((bigop) ((nat.nat) )) (n0)) (fun (i0:(nat.nat) ) => ((((bool.match_bool_type) ((bool.bool) )) ((p) (i0))) ((bool.false) )) (((((bool.match_bool_type) ((bool.bool) )) ((bool.false) )) ((bool.true) )) ((((nat.eqb) ) (i)) (i0))))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0)))))) (fun (x_1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.times) ) ((f) (n0))) (((((((bigop) ((nat.nat) )) (n0)) (fun (i0:(nat.nat) ) => (p) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0))))) (x_1))) (((((((logic.eq_ind_r) ((nat.nat) )) ((((nat.times) ) ((f) (i))) (((((((bigop) ((nat.nat) )) (n0)) (fun (x:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (x)))) ((p) (x)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x:(nat.nat) ) => (f) (x))))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.times) ) ((f) (n0))) (x))) ((((nat.times) ) ((f) (n0))) ((((nat.times) ) ((f) (i))) (((((((bigop) ((nat.nat) )) (n0)) (fun (i0:(nat.nat) ) => ((((bool.match_bool_type) ((bool.bool) )) ((p) (i0))) ((bool.false) )) (((((bool.match_bool_type) ((bool.bool) )) ((bool.false) )) ((bool.true) )) ((((nat.eqb) ) (i)) (i0))))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0))))))) (((logic.refl) ((nat.nat) )) ((((nat.times) ) ((f) (n0))) ((((nat.times) ) ((f) (i))) (((((((bigop) ((nat.nat) )) (n0)) (fun (x:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (x)))) ((p) (x)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x:(nat.nat) ) => (f) (x))))))) (((((((bigop) ((nat.nat) )) (n0)) (fun (x:(nat.nat) ) => (p) (x))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x:(nat.nat) ) => (f) (x)))) (((Hind) (Hi)) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.true) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.true) ))) (((logic.refl) ((bool.bool) )) ((bool.true) ))) ((p) (i))) (pi))))) ((((nat.times) ) ((((nat.times) ) ((f) (n0))) ((f) (i)))) (((((((bigop) ((nat.nat) )) (n0)) (fun (i0:(nat.nat) ) => ((((bool.match_bool_type) ((bool.bool) )) ((p) (i0))) ((bool.false) )) (((((bool.match_bool_type) ((bool.bool) )) ((bool.false) )) ((bool.true) )) ((((nat.eqb) ) (i)) (i0))))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0))))) ((((assoc) ((f) (n0))) ((f) (i))) (((((((bigop) ((nat.nat) )) (n0)) (fun (i0:(nat.nat) ) => ((((bool.match_bool_type) ((bool.bool) )) ((p) (i0))) ((bool.false) )) (((((bool.match_bool_type) ((bool.bool) )) ((bool.false) )) ((bool.true) )) ((((nat.eqb) ) (i)) (i0))))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0)))))) ((((nat.times) ) ((f) (i))) ((f) (n0)))) (((nat.commutative_times) ((f) (i))) ((f) (n0))))) ((((nat.times) ) ((f) (i))) ((((nat.times) ) ((f) (n0))) (((((((bigop) ((nat.nat) )) (n0)) (fun (i0:(nat.nat) ) => ((((bool.match_bool_type) ((bool.bool) )) ((p) (i0))) ((bool.false) )) (((((bool.match_bool_type) ((bool.bool) )) ((bool.false) )) ((bool.true) )) ((((nat.eqb) ) (i)) (i0))))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0)))))) ((((assoc) ((f) (i))) ((f) (n0))) (((((((bigop) ((nat.nat) )) (n0)) (fun (i0:(nat.nat) ) => ((((bool.match_bool_type) ((bool.bool) )) ((p) (i0))) ((bool.false) )) (((((bool.match_bool_type) ((bool.bool) )) ((bool.false) )) ((bool.true) )) ((((nat.eqb) ) (i)) (i0))))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0)))))) (((((((bigop) ((nat.nat) )) (((nat.S) ) (n0))) (fun (i0:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (i0)))) ((p) (i0)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0)))) ((((((((bigop_Strue) ((nat.nat) )) (n0)) (fun (__:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (__)))) ((p) (__)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (f)) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.true) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) ((((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (n0)))) (__))) ((bool.true) ))) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.true) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.true) ))) (((logic.refl) ((bool.bool) )) ((bool.true) ))) ((((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (n0)))) ((bool.true) ))) (((((((logic.rewrite_l) ((bool.bool) )) ((p) (n0))) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) ((((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (n0)))) ((bool.true) ))) (__))) (((((((logic.rewrite_l) ((bool.bool) )) ((p) (n0))) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) ((((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (n0)))) (__))) ((p) (n0)))) (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.false) )) (fun (x:(bool.bool) ) => (((logic.eq) ((bool.bool) )) ((((bool.andb) ) (((bool.notb) ) (x))) ((p) (n0)))) ((p) (n0)))) ((((((bool.sym_eq_match_bool_type_false) ((bool.bool) )) ((bool.false) )) ((bool.true) )) (fun (y:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (((((bool.match_bool_type) ((bool.bool) )) ((p) (n0))) ((bool.false) )) (y))) ((p) (n0)))) ((((((bool.eq_match_bool_type_true) ((bool.bool) )) ((p) (n0))) ((bool.false) )) (fun (y:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (((((bool.match_bool_type) ((bool.bool) )) ((p) (n0))) ((bool.false) )) ((bool.true) ))) (y))) ((((((bool.eq_match_bool_type_false) ((bool.bool) )) ((bool.false) )) ((bool.true) )) (fun (y:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (((((bool.match_bool_type) ((bool.bool) )) ((p) (n0))) ((bool.false) )) ((bool.true) ))) (((((bool.match_bool_type) ((bool.bool) )) ((p) (n0))) ((bool.false) )) (y)))) ((((((bool.eq_match_bool_type_false) ((bool.bool) )) ((bool.false) )) ((bool.true) )) (fun (y:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (((((bool.match_bool_type) ((bool.bool) )) ((p) (n0))) ((bool.false) )) (y))) (((((bool.match_bool_type) ((bool.bool) )) ((p) (n0))) ((bool.false) )) (((((bool.match_bool_type) ((bool.bool) )) ((bool.false) )) ((bool.true) )) ((bool.false) ))))) (((logic.refl) ((bool.bool) )) ((((bool.andb) ) (((bool.notb) ) ((bool.false) ))) ((p) (n0))))))))) ((((nat.eqb) ) (i)) (n0))) ((((nat.not_eq_to_eqb_false) (i)) (n0)) ((((nat.lt_to_not_eq) (i)) (n0)) (Hi))))) ((bool.true) )) (pn))) ((bool.true) )) (pn)))) ((p) (n0))) (pn))))) (((((((bigop) ((nat.nat) )) (((nat.S) ) (n0))) (fun (i0:(nat.nat) ) => (p) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0)))) ((((((((bigop_Strue) ((nat.nat) )) (n0)) (p)) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (f)) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.true) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.true) ))) (((logic.refl) ((bool.bool) )) ((bool.true) ))) ((p) (n0))) (pn)))))) (fun (pn:(((logic.eq) ((bool.bool) )) ((p) (n0))) ((bool.false) )) => (((((((logic.eq_ind_r) ((nat.nat) )) (((((((bigop) ((nat.nat) )) (n0)) (fun (i0:(nat.nat) ) => (p) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0)))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (x)) ((((nat.times) ) ((f) (i))) (((((((bigop) ((nat.nat) )) (((nat.S) ) (n0))) (fun (x0:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (x0)))) ((p) (x0)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x0:(nat.nat) ) => (f) (x0)))))) (((((((logic.eq_ind_r) ((nat.nat) )) (((((((bigop) ((nat.nat) )) (n0)) (fun (i0:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (i0)))) ((p) (i0)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0)))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) (n0)) (fun (i0:(nat.nat) ) => (p) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0)))) ((((nat.times) ) ((f) (i))) (x)))) (((((((logic.eq_ind_r) ((nat.nat) )) ((((nat.times) ) ((f) (i))) (((((((bigop) ((nat.nat) )) (n0)) (fun (x:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (x)))) ((p) (x)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x:(nat.nat) ) => (f) (x))))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (x)) ((((nat.times) ) ((f) (i))) (((((((bigop) ((nat.nat) )) (n0)) (fun (i0:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (i0)))) ((p) (i0)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0)))))) (((logic.refl) ((nat.nat) )) ((((nat.times) ) ((f) (i))) (((((((bigop) ((nat.nat) )) (n0)) (fun (x:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (x)))) ((p) (x)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x:(nat.nat) ) => (f) (x)))))) (((((((bigop) ((nat.nat) )) (n0)) (fun (x:(nat.nat) ) => (p) (x))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x:(nat.nat) ) => (f) (x)))) (((Hind) (Hi)) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.true) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.true) ))) (((logic.refl) ((bool.bool) )) ((bool.true) ))) ((p) (i))) (pi))))) (((((((bigop) ((nat.nat) )) (((nat.S) ) (n0))) (fun (i0:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (i0)))) ((p) (i0)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0)))) ((((((((bigop_Sfalse) ((nat.nat) )) (n0)) (fun (__:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (__)))) ((p) (__)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (f)) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.false) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) ((((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (n0)))) (__))) ((bool.false) ))) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.false) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.false) ))) (((logic.refl) ((bool.bool) )) ((bool.false) ))) ((((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (n0)))) ((bool.false) ))) (((((((logic.rewrite_l) ((bool.bool) )) ((p) (n0))) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) ((((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (n0)))) ((bool.false) ))) (__))) (((((((logic.rewrite_l) ((bool.bool) )) ((p) (n0))) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) ((((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (n0)))) (__))) ((p) (n0)))) (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.false) )) (fun (x:(bool.bool) ) => (((logic.eq) ((bool.bool) )) ((((bool.andb) ) (((bool.notb) ) (x))) ((p) (n0)))) ((p) (n0)))) ((((((bool.sym_eq_match_bool_type_false) ((bool.bool) )) ((bool.false) )) ((bool.true) )) (fun (y:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (((((bool.match_bool_type) ((bool.bool) )) ((p) (n0))) ((bool.false) )) (y))) ((p) (n0)))) ((((((bool.eq_match_bool_type_true) ((bool.bool) )) ((p) (n0))) ((bool.false) )) (fun (y:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (((((bool.match_bool_type) ((bool.bool) )) ((p) (n0))) ((bool.false) )) ((bool.true) ))) (y))) ((((((bool.eq_match_bool_type_false) ((bool.bool) )) ((bool.false) )) ((bool.true) )) (fun (y:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (((((bool.match_bool_type) ((bool.bool) )) ((p) (n0))) ((bool.false) )) ((bool.true) ))) (((((bool.match_bool_type) ((bool.bool) )) ((p) (n0))) ((bool.false) )) (y)))) ((((((bool.eq_match_bool_type_false) ((bool.bool) )) ((bool.false) )) ((bool.true) )) (fun (y:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (((((bool.match_bool_type) ((bool.bool) )) ((p) (n0))) ((bool.false) )) (y))) (((((bool.match_bool_type) ((bool.bool) )) ((p) (n0))) ((bool.false) )) (((((bool.match_bool_type) ((bool.bool) )) ((bool.false) )) ((bool.true) )) ((bool.false) ))))) (((logic.refl) ((bool.bool) )) ((((bool.andb) ) (((bool.notb) ) ((bool.false) ))) ((p) (n0))))))))) ((((nat.eqb) ) (i)) (n0))) ((((nat.not_eq_to_eqb_false) (i)) (n0)) ((((nat.lt_to_not_eq) (i)) (n0)) (Hi))))) ((bool.false) )) (pn))) ((bool.false) )) (pn)))) ((p) (n0))) (pn))))) (((((((bigop) ((nat.nat) )) (((nat.S) ) (n0))) (fun (i0:(nat.nat) ) => (p) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0)))) ((((((((bigop_Sfalse) ((nat.nat) )) (n0)) (p)) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (f)) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.false) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.false) ))) (((logic.refl) ((bool.bool) )) ((bool.false) ))) ((p) (n0))) (pn)))))) ((bool.true_or_false) ((p) (n0)))))) (fun (Hi:(((logic.eq) ((nat.nat) )) (i)) (n0)) => (((((((logic.eq_ind) ((nat.nat) )) (i)) (fun (x_1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) (((nat.S) ) (x_1))) (fun (x:(nat.nat) ) => (p) (x))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x:(nat.nat) ) => (f) (x)))) ((((nat.times) ) ((f) (i))) (((((((bigop) ((nat.nat) )) (((nat.S) ) (x_1))) (fun (x:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (x)))) ((p) (x)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x:(nat.nat) ) => (f) (x)))))) (((((((logic.eq_ind_r) ((nat.nat) )) ((((nat.times) ) ((f) (i))) (((((((bigop) ((nat.nat) )) (i)) (fun (i0:(nat.nat) ) => (p) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0))))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (x)) ((((nat.times) ) ((f) (i))) (((((((bigop) ((nat.nat) )) (((nat.S) ) (i))) (fun (x0:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (x0)))) ((p) (x0)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x0:(nat.nat) ) => (f) (x0)))))) (((((((logic.eq_f) ((nat.nat) )) ((nat.nat) )) (((nat.times) ) ((f) (i)))) (((((((bigop) ((nat.nat) )) (i)) (fun (i0:(nat.nat) ) => (p) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0)))) (((((((bigop) ((nat.nat) )) (((nat.S) ) (i))) (fun (x:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (x)))) ((p) (x)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x:(nat.nat) ) => (f) (x)))) (((((((logic.eq_ind_r) ((nat.nat) )) (((((((bigop) ((nat.nat) )) (i)) (fun (i0:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (i0)))) ((p) (i0)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0)))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) (i)) (fun (i0:(nat.nat) ) => (p) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0)))) (x))) (((((((((((same_bigop) ((nat.nat) )) (i)) (p)) (fun (__:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (__)))) ((p) (__)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (f)) (f)) (fun (k:(nat.nat) ) => fun (ltki:(((nat.lt) ) (k)) (i)) => (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.false) )) (fun (x:(bool.bool) ) => (((logic.eq) ((bool.bool) )) ((p) (k))) ((((bool.andb) ) (((bool.notb) ) (x))) ((p) (k))))) ((((((bool.sym_eq_match_bool_type_false) ((bool.bool) )) ((bool.false) )) ((bool.true) )) (fun (y:(bool.bool) ) => (((logic.eq) ((bool.bool) )) ((p) (k))) (((((bool.match_bool_type) ((bool.bool) )) ((p) (k))) ((bool.false) )) (y)))) ((((((bool.sym_eq_match_bool_type_true) ((bool.bool) )) ((p) (k))) ((bool.false) )) (fun (y:(bool.bool) ) => (((logic.eq) ((bool.bool) )) ((p) (k))) (y))) (((logic.refl) ((bool.bool) )) ((p) (k)))))) ((((nat.eqb) ) (i)) (k))) ((((nat.not_eq_to_eqb_false) (i)) (k)) (((((logic.not_to_not) ((((logic.eq) ((nat.nat) )) (i)) (k))) ((((nat.le) ) (((nat.S) ) (i))) (i))) (fun (auto:(((logic.eq) ((nat.nat) )) (i)) (k)) => (((((logic.eq_coerc) ((((nat.le) ) (((nat.S) ) (k))) (i))) ((((nat.le) ) (((nat.S) ) (i))) (i))) (ltki)) (((((((logic.rewrite_l) ((nat.nat) )) (i)) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) (((nat.S) ) (__))) (i))) ((((nat.le) ) (((nat.S) ) (i))) (i)))) (((logic.refl) (Prop)) ((((nat.le) ) (((nat.S) ) (i))) (i)))) (k)) (auto))))) ((nat.not_le_Sn_n) (i))))))) (fun (i0:(nat.nat) ) => fun (auto:(((nat.lt) ) (i0)) (i)) => (fun (auto':(((logic.eq) ((bool.bool) )) ((p) (i0))) ((bool.true) )) => (((logic.refl) ((nat.nat) )) ((f) (i0))))))) (((((((bigop) ((nat.nat) )) (((nat.S) ) (i))) (fun (i0:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (i0)))) ((p) (i0)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0)))) ((((((((bigop_Sfalse) ((nat.nat) )) (i)) (fun (__:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) (i)) (__)))) ((p) (__)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (f)) (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.true) )) (fun (x:(bool.bool) ) => (((logic.eq) ((bool.bool) )) ((((bool.andb) ) (((bool.notb) ) (x))) ((p) (i)))) ((bool.false) ))) ((((((bool.eq_match_bool_type_false) ((bool.bool) )) ((p) (i))) ((bool.false) )) (fun (y:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (((((bool.match_bool_type) ((bool.bool) )) ((p) (i))) ((bool.false) )) (((((bool.match_bool_type) ((bool.bool) )) ((bool.false) )) ((bool.true) )) ((bool.true) )))) (y))) ((((((bool.eq_match_bool_type_true) ((bool.bool) )) ((bool.false) )) ((bool.true) )) (fun (y:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (((((bool.match_bool_type) ((bool.bool) )) ((p) (i))) ((bool.false) )) (((((bool.match_bool_type) ((bool.bool) )) ((bool.false) )) ((bool.true) )) ((bool.true) )))) (((((bool.match_bool_type) ((bool.bool) )) ((p) (i))) ((bool.false) )) (y)))) (((logic.refl) ((bool.bool) )) ((((bool.andb) ) (((bool.notb) ) ((bool.true) ))) ((p) (i))))))) ((((nat.eqb) ) (i)) (i))) ((((nat.eq_to_eqb_true) (i)) (i)) (((logic.refl) ((nat.nat) )) (i)))))))) (((((((bigop) ((nat.nat) )) (((nat.S) ) (i))) (fun (i0:(nat.nat) ) => (p) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f) (i0)))) ((((((((bigop_Strue) ((nat.nat) )) (i)) (p)) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (f)) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.true) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.true) ))) (((logic.refl) ((bool.bool) )) ((bool.true) ))) ((p) (i))) (pi))))) (n0)) (Hi)))) ((((nat.le_to_or_lt_eq) (i)) (n0)) ((((nat.le_S_S_to_le) (i)) (n0)) (lein)))))))) (n).
Definition sub_hk : (((nat.nat) ) -> (nat.nat) ) -> (((nat.nat) ) -> (nat.nat) ) -> ((nat.nat) ) -> ((nat.nat) ) -> (((nat.nat) ) -> (bool.bool) ) -> (((nat.nat) ) -> (bool.bool) ) -> (((nat.nat) ) -> (nat.nat) ) -> (((nat.nat) ) -> (nat.nat) ) -> Prop := fun (h:((nat.nat) ) -> (nat.nat) ) => fun (k:((nat.nat) ) -> (nat.nat) ) => fun (n1:(nat.nat) ) => fun (n2:(nat.nat) ) => fun (p1:((nat.nat) ) -> (bool.bool) ) => fun (p2:((nat.nat) ) -> (bool.bool) ) => fun (f1:((nat.nat) ) -> (nat.nat) ) => fun (f2:((nat.nat) ) -> (nat.nat) ) => forall (i:(nat.nat) ), ((((nat.lt) ) (i)) (n1)) -> ((((logic.eq) ((bool.bool) )) ((p1) (i))) ((bool.true) )) -> (((connectives.And) ) ((((connectives.And) ) ((((nat.lt) ) ((h) (i))) (n2))) ((((logic.eq) ((bool.bool) )) ((p2) ((h) (i)))) ((bool.true) )))) ((((logic.eq) ((nat.nat) )) ((k) ((h) (i)))) (i)).
Definition iso : ((nat.nat) ) -> ((nat.nat) ) -> (((nat.nat) ) -> (bool.bool) ) -> (((nat.nat) ) -> (bool.bool) ) -> (((nat.nat) ) -> (nat.nat) ) -> (((nat.nat) ) -> (nat.nat) ) -> Prop := fun (n1:(nat.nat) ) => fun (n2:(nat.nat) ) => fun (p1:((nat.nat) ) -> (bool.bool) ) => fun (p2:((nat.nat) ) -> (bool.bool) ) => fun (f1:((nat.nat) ) -> (nat.nat) ) => fun (f2:((nat.nat) ) -> (nat.nat) ) => ((connectives.ex) (((nat.nat) ) -> (nat.nat) )) (fun (h:((nat.nat) ) -> (nat.nat) ) => ((connectives.ex) (((nat.nat) ) -> (nat.nat) )) (fun (k:((nat.nat) ) -> (nat.nat) ) => (((connectives.And) ) ((((connectives.And) ) (forall (i:(nat.nat) ), ((((nat.lt) ) (i)) (n1)) -> ((((logic.eq) ((bool.bool) )) ((p1) (i))) ((bool.true) )) -> (((logic.eq) ((nat.nat) )) ((f1) (i))) ((f2) ((h) (i))))) ((((((((((sub_hk) ) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)))) ((((((((((sub_hk) ) (k)) (h)) (n2)) (n1)) (p2)) (p1)) (f2)) (f1)))).
Definition sub_hkO : forall (h:((nat.nat) ) -> (nat.nat) ), forall (k:((nat.nat) ) -> (nat.nat) ), forall (n1:(nat.nat) ), forall (n2:(nat.nat) ), forall (p1:((nat.nat) ) -> (bool.bool) ), forall (p2:((nat.nat) ) -> (bool.bool) ), forall (f1:((nat.nat) ) -> (nat.nat) ), forall (f2:((nat.nat) ) -> (nat.nat) ), ((((logic.eq) ((nat.nat) )) (n1)) ((nat.O) )) -> (((((((((sub_hk) ) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2) := fun (h:((nat.nat) ) -> (nat.nat) ) => fun (k:((nat.nat) ) -> (nat.nat) ) => fun (n1:(nat.nat) ) => fun (n2:(nat.nat) ) => fun (p1:((nat.nat) ) -> (bool.bool) ) => fun (p2:((nat.nat) ) -> (bool.bool) ) => fun (f1:((nat.nat) ) -> (nat.nat) ) => fun (f2:((nat.nat) ) -> (nat.nat) ) => fun (up0:(((logic.eq) ((nat.nat) )) (n1)) ((nat.O) )) => (fun (i:(nat.nat) ) => fun (lti:(((nat.lt) ) (i)) (n1)) => (((((((logic.eq_ind_r) ((nat.nat) )) ((nat.O) )) (fun (x:(nat.nat) ) => ((((logic.eq) ((bool.bool) )) ((p1) (i))) ((bool.true) )) -> (((connectives.And) ) ((((connectives.And) ) ((((nat.lt) ) ((h) (i))) (n2))) ((((logic.eq) ((bool.bool) )) ((p2) ((h) (i)))) ((bool.true) )))) ((((logic.eq) ((nat.nat) )) ((k) ((h) (i)))) (i)))) (((connectives.falsity) (((((logic.eq) ((bool.bool) )) ((p1) (i))) ((bool.true) )) -> (((connectives.And) ) ((((connectives.And) ) ((((nat.lt) ) ((h) (i))) (n2))) ((((logic.eq) ((bool.bool) )) ((p2) ((h) (i)))) ((bool.true) )))) ((((logic.eq) ((nat.nat) )) ((k) ((h) (i)))) (i)))) ((((logic.absurd) ((((nat.le) ) (((nat.S) ) (i))) ((nat.O) ))) (((((logic.eq_coerc) ((((nat.le) ) (((nat.S) ) (i))) (n1))) ((((nat.le) ) (((nat.S) ) (i))) ((nat.O) ))) (lti)) (((((((logic.rewrite_r) ((nat.nat) )) ((nat.O) )) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) (((nat.S) ) (i))) (__))) ((((nat.le) ) (((nat.S) ) (i))) ((nat.O) )))) (((logic.refl) (Prop)) ((((nat.le) ) (((nat.S) ) (i))) ((nat.O) )))) (n1)) (up0)))) ((nat.not_le_Sn_O) (i))))) (n1)) (up0))).
Definition sub0_to_false : forall (h:((nat.nat) ) -> (nat.nat) ), forall (k:((nat.nat) ) -> (nat.nat) ), forall (n1:(nat.nat) ), forall (n2:(nat.nat) ), forall (p1:((nat.nat) ) -> (bool.bool) ), forall (p2:((nat.nat) ) -> (bool.bool) ), forall (f1:((nat.nat) ) -> (nat.nat) ), forall (f2:((nat.nat) ) -> (nat.nat) ), ((((logic.eq) ((nat.nat) )) (n1)) ((nat.O) )) -> ((((((((((sub_hk) ) (h)) (k)) (n2)) (n1)) (p2)) (p1)) (f2)) (f1)) -> forall (i:(nat.nat) ), ((((nat.lt) ) (i)) (n2)) -> (((logic.eq) ((bool.bool) )) ((p2) (i))) ((bool.false) ) := fun (h:((nat.nat) ) -> (nat.nat) ) => fun (k:((nat.nat) ) -> (nat.nat) ) => fun (n1:(nat.nat) ) => fun (n2:(nat.nat) ) => fun (p1:((nat.nat) ) -> (bool.bool) ) => fun (p2:((nat.nat) ) -> (bool.bool) ) => fun (f1:((nat.nat) ) -> (nat.nat) ) => fun (f2:((nat.nat) ) -> (nat.nat) ) => fun (up0:(((logic.eq) ((nat.nat) )) (n1)) ((nat.O) )) => (fun (sub:(((((((((sub_hk) ) (h)) (k)) (n2)) (n1)) (p2)) (p1)) (f2)) (f1)) => (fun (i:(nat.nat) ) => fun (lti:(((nat.lt) ) (i)) (n2)) => (((((((connectives.match_Or_prop) ((((logic.eq) ((bool.bool) )) ((p2) (i))) ((bool.true) ))) ((((logic.eq) ((bool.bool) )) ((p2) (i))) ((bool.false) ))) ((((logic.eq) ((bool.bool) )) ((p2) (i))) ((bool.false) ))) (fun (ptrue:(((logic.eq) ((bool.bool) )) ((p2) (i))) ((bool.true) )) => ((((((connectives.match_And_prop) ((((connectives.And) ) ((((nat.lt) ) ((h) (i))) (n1))) ((((logic.eq) ((bool.bool) )) ((p1) ((h) (i)))) ((bool.true) )))) ((((logic.eq) ((nat.nat) )) ((k) ((h) (i)))) (i))) ((((logic.eq) ((bool.bool) )) ((p2) (i))) ((bool.false) ))) (fun (_clearme:(((connectives.And) ) ((((nat.lt) ) ((h) (i))) (n1))) ((((logic.eq) ((bool.bool) )) ((p1) ((h) (i)))) ((bool.true) ))) => ((((((connectives.match_And_prop) ((((nat.lt) ) ((h) (i))) (n1))) ((((logic.eq) ((bool.bool) )) ((p1) ((h) (i)))) ((bool.true) ))) (((((logic.eq) ((nat.nat) )) ((k) ((h) (i)))) (i)) -> (((logic.eq) ((bool.bool) )) ((p2) (i))) ((bool.false) ))) (fun (hi:(((nat.lt) ) ((h) (i))) (n1)) => (((connectives.falsity) (((((logic.eq) ((bool.bool) )) ((p1) ((h) (i)))) ((bool.true) )) -> ((((logic.eq) ((nat.nat) )) ((k) ((h) (i)))) (i)) -> (((logic.eq) ((bool.bool) )) ((p2) (i))) ((bool.false) ))) ((((logic.absurd) ((((nat.le) ) (((nat.S) ) ((h) (i)))) ((nat.O) ))) (((((logic.eq_coerc) ((((nat.le) ) (((nat.S) ) ((h) (i)))) (n1))) ((((nat.le) ) (((nat.S) ) ((h) (i)))) ((nat.O) ))) (hi)) (((((((logic.rewrite_r) ((nat.nat) )) ((nat.O) )) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) (((nat.S) ) ((h) (i)))) (__))) ((((nat.le) ) (((nat.S) ) ((h) (i)))) ((nat.O) )))) (((logic.refl) (Prop)) ((((nat.le) ) (((nat.S) ) ((h) (i)))) ((nat.O) )))) (n1)) (up0)))) ((nat.not_le_Sn_O) ((h) (i))))))) (_clearme)))) ((((sub) (i)) (lti)) (ptrue))))) (fun (auto:(((logic.eq) ((bool.bool) )) ((p2) (i))) ((bool.false) )) => (((((((logic.rewrite_r) ((bool.bool) )) ((bool.false) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.false) ))) (((logic.refl) ((bool.bool) )) ((bool.false) ))) ((p2) (i))) (auto)))) ((bool.true_or_false) ((p2) (i)))))).
Definition sub_lt : forall (e:((nat.nat) ) -> (nat.nat) ), forall (p:((nat.nat) ) -> (bool.bool) ), forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((((nat.le) ) (n)) (m)) -> (((((((((sub_hk) ) (fun (x:(nat.nat) ) => x)) (fun (x:(nat.nat) ) => x)) (n)) (m)) (p)) (p)) (e)) (e) := fun (e:((nat.nat) ) -> (nat.nat) ) => fun (f:((nat.nat) ) -> (bool.bool) ) => fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => fun (lenm:(((nat.le) ) (n)) (m)) => (fun (i:(nat.nat) ) => fun (lti:(((nat.lt) ) (i)) (n)) => (fun (fi:(((logic.eq) ((bool.bool) )) ((f) (i))) ((bool.true) )) => (((((connectives.conj) ((((connectives.And) ) ((((nat.lt) ) (i)) (m))) ((((logic.eq) ((bool.bool) )) ((f) (i))) ((bool.true) )))) ((((logic.eq) ((nat.nat) )) (i)) (i))) (((((connectives.conj) ((((nat.lt) ) (i)) (m))) ((((logic.eq) ((bool.bool) )) ((f) (i))) ((bool.true) ))) ((((((nat.lt_to_le_to_lt) (i)) (n)) (m)) (lti)) (lenm))) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.true) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.true) ))) (((logic.refl) ((bool.bool) )) ((bool.true) ))) ((f) (i))) (fi)))) (((logic.refl) ((nat.nat) )) (i))))).
Definition transitive_sub : forall (h1:((nat.nat) ) -> (nat.nat) ), forall (k1:((nat.nat) ) -> (nat.nat) ), forall (h2:((nat.nat) ) -> (nat.nat) ), forall (k2:((nat.nat) ) -> (nat.nat) ), forall (n1:(nat.nat) ), forall (n2:(nat.nat) ), forall (n3:(nat.nat) ), forall (p1:((nat.nat) ) -> (bool.bool) ), forall (p2:((nat.nat) ) -> (bool.bool) ), forall (p3:((nat.nat) ) -> (bool.bool) ), forall (f1:((nat.nat) ) -> (nat.nat) ), forall (f2:((nat.nat) ) -> (nat.nat) ), forall (f3:((nat.nat) ) -> (nat.nat) ), ((((((((((sub_hk) ) (h1)) (k1)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)) -> ((((((((((sub_hk) ) (h2)) (k2)) (n2)) (n3)) (p2)) (p3)) (f2)) (f3)) -> (((((((((sub_hk) ) (fun (x:(nat.nat) ) => (h2) ((h1) (x)))) (fun (x:(nat.nat) ) => (k1) ((k2) (x)))) (n1)) (n3)) (p1)) (p3)) (f1)) (f3) := fun (h1:((nat.nat) ) -> (nat.nat) ) => fun (k1:((nat.nat) ) -> (nat.nat) ) => fun (h2:((nat.nat) ) -> (nat.nat) ) => fun (k2:((nat.nat) ) -> (nat.nat) ) => fun (n1:(nat.nat) ) => fun (n2:(nat.nat) ) => fun (n3:(nat.nat) ) => fun (p1:((nat.nat) ) -> (bool.bool) ) => fun (p2:((nat.nat) ) -> (bool.bool) ) => fun (p3:((nat.nat) ) -> (bool.bool) ) => fun (f1:((nat.nat) ) -> (nat.nat) ) => fun (f2:((nat.nat) ) -> (nat.nat) ) => fun (f3:((nat.nat) ) -> (nat.nat) ) => fun (sub1:(((((((((sub_hk) ) (h1)) (k1)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)) => (fun (sub2:(((((((((sub_hk) ) (h2)) (k2)) (n2)) (n3)) (p2)) (p3)) (f2)) (f3)) => (fun (i:(nat.nat) ) => fun (lti:(((nat.lt) ) (i)) (n1)) => (fun (fi:(((logic.eq) ((bool.bool) )) ((p1) (i))) ((bool.true) )) => ((((((connectives.match_And_prop) ((((connectives.And) ) ((((nat.lt) ) ((h1) (i))) (n2))) ((((logic.eq) ((bool.bool) )) ((p2) ((h1) (i)))) ((bool.true) )))) ((((logic.eq) ((nat.nat) )) ((k1) ((h1) (i)))) (i))) ((((connectives.And) ) ((((connectives.And) ) ((((nat.lt) ) ((h2) ((h1) (i)))) (n3))) ((((logic.eq) ((bool.bool) )) ((p3) ((h2) ((h1) (i))))) ((bool.true) )))) ((((logic.eq) ((nat.nat) )) ((k1) ((k2) ((h2) ((h1) (i)))))) (i)))) (fun (_clearme:(((connectives.And) ) ((((nat.lt) ) ((h1) (i))) (n2))) ((((logic.eq) ((bool.bool) )) ((p2) ((h1) (i)))) ((bool.true) ))) => ((((((connectives.match_And_prop) ((((nat.lt) ) ((h1) (i))) (n2))) ((((logic.eq) ((bool.bool) )) ((p2) ((h1) (i)))) ((bool.true) ))) (((((logic.eq) ((nat.nat) )) ((k1) ((h1) (i)))) (i)) -> (((connectives.And) ) ((((connectives.And) ) ((((nat.lt) ) ((h2) ((h1) (i)))) (n3))) ((((logic.eq) ((bool.bool) )) ((p3) ((h2) ((h1) (i))))) ((bool.true) )))) ((((logic.eq) ((nat.nat) )) ((k1) ((k2) ((h2) ((h1) (i)))))) (i)))) (fun (lth1i:(((nat.lt) ) ((h1) (i))) (n2)) => (fun (fh1i:(((logic.eq) ((bool.bool) )) ((p2) ((h1) (i)))) ((bool.true) )) => (fun (ei:(((logic.eq) ((nat.nat) )) ((k1) ((h1) (i)))) (i)) => ((((((connectives.match_And_prop) ((((connectives.And) ) ((((nat.lt) ) ((h2) ((h1) (i)))) (n3))) ((((logic.eq) ((bool.bool) )) ((p3) ((h2) ((h1) (i))))) ((bool.true) )))) ((((logic.eq) ((nat.nat) )) ((k2) ((h2) ((h1) (i))))) ((h1) (i)))) ((((connectives.And) ) ((((connectives.And) ) ((((nat.lt) ) ((h2) ((h1) (i)))) (n3))) ((((logic.eq) ((bool.bool) )) ((p3) ((h2) ((h1) (i))))) ((bool.true) )))) ((((logic.eq) ((nat.nat) )) ((k1) ((k2) ((h2) ((h1) (i)))))) (i)))) (fun (_clearme0:(((connectives.And) ) ((((nat.lt) ) ((h2) ((h1) (i)))) (n3))) ((((logic.eq) ((bool.bool) )) ((p3) ((h2) ((h1) (i))))) ((bool.true) ))) => ((((((connectives.match_And_prop) ((((nat.lt) ) ((h2) ((h1) (i)))) (n3))) ((((logic.eq) ((bool.bool) )) ((p3) ((h2) ((h1) (i))))) ((bool.true) ))) (((((logic.eq) ((nat.nat) )) ((k2) ((h2) ((h1) (i))))) ((h1) (i))) -> (((connectives.And) ) ((((connectives.And) ) ((((nat.lt) ) ((h2) ((h1) (i)))) (n3))) ((((logic.eq) ((bool.bool) )) ((p3) ((h2) ((h1) (i))))) ((bool.true) )))) ((((logic.eq) ((nat.nat) )) ((k1) ((k2) ((h2) ((h1) (i)))))) (i)))) (fun (H1:(((nat.lt) ) ((h2) ((h1) (i)))) (n3)) => (fun (H2:(((logic.eq) ((bool.bool) )) ((p3) ((h2) ((h1) (i))))) ((bool.true) )) => (fun (H3:(((logic.eq) ((nat.nat) )) ((k2) ((h2) ((h1) (i))))) ((h1) (i))) => (((((connectives.conj) ((((connectives.And) ) ((((nat.lt) ) ((h2) ((h1) (i)))) (n3))) ((((logic.eq) ((bool.bool) )) ((p3) ((h2) ((h1) (i))))) ((bool.true) )))) ((((logic.eq) ((nat.nat) )) ((k1) ((k2) ((h2) ((h1) (i)))))) (i))) (((((connectives.conj) ((((nat.lt) ) ((h2) ((h1) (i)))) (n3))) ((((logic.eq) ((bool.bool) )) ((p3) ((h2) ((h1) (i))))) ((bool.true) ))) (H1)) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.true) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.true) ))) (((logic.refl) ((bool.bool) )) ((bool.true) ))) ((p3) ((h2) ((h1) (i))))) (H2)))) (((((((logic.rewrite_r) ((nat.nat) )) ((h1) (i))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((k1) (__))) (i))) (((((((logic.rewrite_r) ((nat.nat) )) (i)) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__)) (i))) (((logic.refl) ((nat.nat) )) (i))) ((k1) ((h1) (i)))) (ei))) ((k2) ((h2) ((h1) (i))))) (H3))))))) (_clearme0)))) ((((sub2) ((h1) (i))) (lth1i)) (fh1i))))))) (_clearme)))) ((((sub1) (i)) (lti)) (fi)))))).
Definition let_clause_10471 : forall (n1:(nat.nat) ), forall (n2:(nat.nat) ), forall (p1:((nat.nat) ) -> (bool.bool) ), forall (p2:((nat.nat) ) -> (bool.bool) ), forall (f1:((nat.nat) ) -> (nat.nat) ), forall (f2:((nat.nat) ) -> (nat.nat) ), ((((((((iso) ) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)) -> forall (h:((nat.nat) ) -> (nat.nat) ), (((connectives.ex) (((nat.nat) ) -> (nat.nat) )) (fun (k:((nat.nat) ) -> (nat.nat) ) => (((connectives.And) ) ((((connectives.And) ) (forall (i:(nat.nat) ), ((((nat.lt) ) (i)) (n1)) -> ((((logic.eq) ((bool.bool) )) ((p1) (i))) ((bool.true) )) -> (((logic.eq) ((nat.nat) )) ((f1) (i))) ((f2) ((h) (i))))) ((((((((((sub_hk) ) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)))) ((((((((((sub_hk) ) (k)) (h)) (n2)) (n1)) (p2)) (p1)) (f2)) (f1)))) -> forall (k:((nat.nat) ) -> (nat.nat) ), ((((connectives.And) ) ((((connectives.And) ) (forall (i:(nat.nat) ), ((((nat.lt) ) (i)) (n1)) -> ((((logic.eq) ((bool.bool) )) ((p1) (i))) ((bool.true) )) -> (((logic.eq) ((nat.nat) )) ((f1) (i))) ((f2) ((h) (i))))) ((((((((((sub_hk) ) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)))) ((((((((((sub_hk) ) (k)) (h)) (n2)) (n1)) (p2)) (p1)) (f2)) (f1))) -> ((((connectives.And) ) (forall (i:(nat.nat) ), ((((nat.lt) ) (i)) (n1)) -> ((((logic.eq) ((bool.bool) )) ((p1) (i))) ((bool.true) )) -> (((logic.eq) ((nat.nat) )) ((f1) (i))) ((f2) ((h) (i))))) ((((((((((sub_hk) ) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2))) -> (forall (i:(nat.nat) ), ((((nat.lt) ) (i)) (n1)) -> ((((logic.eq) ((bool.bool) )) ((p1) (i))) ((bool.true) )) -> (((logic.eq) ((nat.nat) )) ((f1) (i))) ((f2) ((h) (i)))) -> forall (i:(nat.nat) ), forall (m:(nat.nat) ), (forall (f:((nat.nat) ) -> (bool.bool) ), ((((nat.le) ) ((nat.O) )) (n1)) -> ((((((((((sub_hk) ) (h)) (k)) ((nat.O) )) (m)) (p1)) (f)) (f1)) (f2)) -> ((((((((((sub_hk) ) (k)) (h)) (m)) ((nat.O) )) (f)) (p1)) (f2)) (f1)) -> (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((nat.O) )) (fun (i0:(nat.nat) ) => (p1) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f1) (i0)))) (((((((bigop) ((nat.nat) )) (m)) (fun (i0:(nat.nat) ) => (f) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f2) (i0)))) -> forall (p20:((nat.nat) ) -> (bool.bool) ), ((((nat.le) ) ((nat.O) )) (n1)) -> ((((((((((sub_hk) ) (h)) (k)) ((nat.O) )) (((nat.S) ) (m))) (p1)) (p20)) (f1)) (f2)) -> ((((((((((sub_hk) ) (k)) (h)) (((nat.S) ) (m))) ((nat.O) )) (p20)) (p1)) (f2)) (f1)) -> forall (x2571:(nat.nat) ), forall (x2572:(nat.nat) ), (((logic.eq) ((nat.nat) )) (x2571)) ((((nat.plus) ) ((((nat.times) ) (x2572)) ((((div_mod.div) ) (x2571)) (x2572)))) ((((div_mod.mod) ) (x2571)) (x2572))) := fun (n1:(nat.nat) ) => fun (n2:(nat.nat) ) => fun (p1:((nat.nat) ) -> (bool.bool) ) => fun (p2:((nat.nat) ) -> (bool.bool) ) => fun (f1:((nat.nat) ) -> (nat.nat) ) => fun (f2:((nat.nat) ) -> (nat.nat) ) => fun (_clearme:(((((((iso) ) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)) => (fun (h:((nat.nat) ) -> (nat.nat) ) => fun (_clearme0:((connectives.ex) (((nat.nat) ) -> (nat.nat) )) (fun (k:((nat.nat) ) -> (nat.nat) ) => (((connectives.And) ) ((((connectives.And) ) (forall (i:(nat.nat) ), ((((nat.lt) ) (i)) (n1)) -> ((((logic.eq) ((bool.bool) )) ((p1) (i))) ((bool.true) )) -> (((logic.eq) ((nat.nat) )) ((f1) (i))) ((f2) ((h) (i))))) ((((((((((sub_hk) ) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)))) ((((((((((sub_hk) ) (k)) (h)) (n2)) (n1)) (p2)) (p1)) (f2)) (f1)))) => (fun (k:((nat.nat) ) -> (nat.nat) ) => fun (_clearme1:(((connectives.And) ) ((((connectives.And) ) (forall (i:(nat.nat) ), ((((nat.lt) ) (i)) (n1)) -> ((((logic.eq) ((bool.bool) )) ((p1) (i))) ((bool.true) )) -> (((logic.eq) ((nat.nat) )) ((f1) (i))) ((f2) ((h) (i))))) ((((((((((sub_hk) ) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)))) ((((((((((sub_hk) ) (k)) (h)) (n2)) (n1)) (p2)) (p1)) (f2)) (f1))) => (fun (_clearme2:(((connectives.And) ) (forall (i:(nat.nat) ), ((((nat.lt) ) (i)) (n1)) -> ((((logic.eq) ((bool.bool) )) ((p1) (i))) ((bool.true) )) -> (((logic.eq) ((nat.nat) )) ((f1) (i))) ((f2) ((h) (i))))) ((((((((((sub_hk) ) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2))) => (fun (same:forall (i:(nat.nat) ), ((((nat.lt) ) (i)) (n1)) -> ((((logic.eq) ((bool.bool) )) ((p1) (i))) ((bool.true) )) -> (((logic.eq) ((nat.nat) )) ((f1) (i))) ((f2) ((h) (i)))) => (fun (i:(nat.nat) ) => fun (m:(nat.nat) ) => fun (Hind:forall (f:((nat.nat) ) -> (bool.bool) ), ((((nat.le) ) ((nat.O) )) (n1)) -> ((((((((((sub_hk) ) (h)) (k)) ((nat.O) )) (m)) (p1)) (f)) (f1)) (f2)) -> ((((((((((sub_hk) ) (k)) (h)) (m)) ((nat.O) )) (f)) (p1)) (f2)) (f1)) -> (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((nat.O) )) (fun (i0:(nat.nat) ) => (p1) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f1) (i0)))) (((((((bigop) ((nat.nat) )) (m)) (fun (i0:(nat.nat) ) => (f) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f2) (i0)))) => (fun (p20:((nat.nat) ) -> (bool.bool) ) => fun (__:(((nat.le) ) ((nat.O) )) (n1)) => (fun (sub1:(((((((((sub_hk) ) (h)) (k)) ((nat.O) )) (((nat.S) ) (m))) (p1)) (p20)) (f1)) (f2)) => (fun (sub2:(((((((((sub_hk) ) (k)) (h)) (((nat.S) ) (m))) ((nat.O) )) (p20)) (p1)) (f2)) (f1)) => (fun (x2571:(nat.nat) ) => fun (x2572:(nat.nat) ) => ((((((logic.rewrite_l) ((nat.nat) )) ((((nat.times) ) ((((div_mod.div) ) (x2571)) (x2572))) (x2572))) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (x2571)) ((((nat.plus) ) (__1)) ((((div_mod.mod) ) (x2571)) (x2572))))) (((div_mod.div_mod) (x2571)) (x2572))) ((((nat.times) ) (x2572)) ((((div_mod.div) ) (x2571)) (x2572)))) (((nat.commutative_times) ((((div_mod.div) ) (x2571)) (x2572))) (x2572))))))))))).
Definition bigop_iso : forall (n1:(nat.nat) ), forall (n2:(nat.nat) ), forall (p1:((nat.nat) ) -> (bool.bool) ), forall (p2:((nat.nat) ) -> (bool.bool) ), forall (f1:((nat.nat) ) -> (nat.nat) ), forall (f2:((nat.nat) ) -> (nat.nat) ), ((((((((iso) ) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)) -> (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) (n1)) (fun (i:(nat.nat) ) => (p1) (i))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f1) (i)))) (((((((bigop) ((nat.nat) )) (n2)) (fun (i:(nat.nat) ) => (p2) (i))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f2) (i))) := fun (n1:(nat.nat) ) => fun (n2:(nat.nat) ) => fun (p1:((nat.nat) ) -> (bool.bool) ) => fun (p2:((nat.nat) ) -> (bool.bool) ) => fun (f1:((nat.nat) ) -> (nat.nat) ) => fun (f2:((nat.nat) ) -> (nat.nat) ) => fun (_clearme:(((((((iso) ) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)) => ((((((connectives.match_ex_prop) (((nat.nat) ) -> (nat.nat) )) (fun (h:((nat.nat) ) -> (nat.nat) ) => ((connectives.ex) (((nat.nat) ) -> (nat.nat) )) (fun (k:((nat.nat) ) -> (nat.nat) ) => (((connectives.And) ) ((((connectives.And) ) (forall (i:(nat.nat) ), ((((nat.lt) ) (i)) (n1)) -> ((((logic.eq) ((bool.bool) )) ((p1) (i))) ((bool.true) )) -> (((logic.eq) ((nat.nat) )) ((f1) (i))) ((f2) ((h) (i))))) ((((((((((sub_hk) ) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)))) ((((((((((sub_hk) ) (k)) (h)) (n2)) (n1)) (p2)) (p1)) (f2)) (f1))))) ((((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) (n1)) (fun (i:(nat.nat) ) => (p1) (i))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f1) (i)))) (((((((bigop) ((nat.nat) )) (n2)) (fun (i:(nat.nat) ) => (p2) (i))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f2) (i))))) (fun (h:((nat.nat) ) -> (nat.nat) ) => fun (_clearme0:((connectives.ex) (((nat.nat) ) -> (nat.nat) )) (fun (k:((nat.nat) ) -> (nat.nat) ) => (((connectives.And) ) ((((connectives.And) ) (forall (i:(nat.nat) ), ((((nat.lt) ) (i)) (n1)) -> ((((logic.eq) ((bool.bool) )) ((p1) (i))) ((bool.true) )) -> (((logic.eq) ((nat.nat) )) ((f1) (i))) ((f2) ((h) (i))))) ((((((((((sub_hk) ) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)))) ((((((((((sub_hk) ) (k)) (h)) (n2)) (n1)) (p2)) (p1)) (f2)) (f1)))) => ((((((connectives.match_ex_prop) (((nat.nat) ) -> (nat.nat) )) (fun (k:((nat.nat) ) -> (nat.nat) ) => (((connectives.And) ) ((((connectives.And) ) (forall (i:(nat.nat) ), ((((nat.lt) ) (i)) (n1)) -> ((((logic.eq) ((bool.bool) )) ((p1) (i))) ((bool.true) )) -> (((logic.eq) ((nat.nat) )) ((f1) (i))) ((f2) ((h) (i))))) ((((((((((sub_hk) ) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)))) ((((((((((sub_hk) ) (k)) (h)) (n2)) (n1)) (p2)) (p1)) (f2)) (f1)))) ((((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) (n1)) (fun (i:(nat.nat) ) => (p1) (i))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f1) (i)))) (((((((bigop) ((nat.nat) )) (n2)) (fun (i:(nat.nat) ) => (p2) (i))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f2) (i))))) (fun (k:((nat.nat) ) -> (nat.nat) ) => fun (_clearme1:(((connectives.And) ) ((((connectives.And) ) (forall (i:(nat.nat) ), ((((nat.lt) ) (i)) (n1)) -> ((((logic.eq) ((bool.bool) )) ((p1) (i))) ((bool.true) )) -> (((logic.eq) ((nat.nat) )) ((f1) (i))) ((f2) ((h) (i))))) ((((((((((sub_hk) ) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)))) ((((((((((sub_hk) ) (k)) (h)) (n2)) (n1)) (p2)) (p1)) (f2)) (f1))) => ((((((connectives.match_And_prop) ((((connectives.And) ) (forall (i:(nat.nat) ), ((((nat.lt) ) (i)) (n1)) -> ((((logic.eq) ((bool.bool) )) ((p1) (i))) ((bool.true) )) -> (((logic.eq) ((nat.nat) )) ((f1) (i))) ((f2) ((h) (i))))) ((((((((((sub_hk) ) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)))) ((((((((((sub_hk) ) (k)) (h)) (n2)) (n1)) (p2)) (p1)) (f2)) (f1))) ((((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) (n1)) (fun (i:(nat.nat) ) => (p1) (i))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f1) (i)))) (((((((bigop) ((nat.nat) )) (n2)) (fun (i:(nat.nat) ) => (p2) (i))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f2) (i))))) (fun (_clearme2:(((connectives.And) ) (forall (i:(nat.nat) ), ((((nat.lt) ) (i)) (n1)) -> ((((logic.eq) ((bool.bool) )) ((p1) (i))) ((bool.true) )) -> (((logic.eq) ((nat.nat) )) ((f1) (i))) ((f2) ((h) (i))))) ((((((((((sub_hk) ) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2))) => ((((((connectives.match_And_prop) (forall (i:(nat.nat) ), ((((nat.lt) ) (i)) (n1)) -> ((((logic.eq) ((bool.bool) )) ((p1) (i))) ((bool.true) )) -> (((logic.eq) ((nat.nat) )) ((f1) (i))) ((f2) ((h) (i))))) ((((((((((sub_hk) ) (h)) (k)) (n1)) (n2)) (p1)) (p2)) (f1)) (f2))) (((((((((((sub_hk) ) (k)) (h)) (n2)) (n1)) (p2)) (p1)) (f2)) (f1)) -> (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) (n1)) (fun (i:(nat.nat) ) => (p1) (i))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f1) (i)))) (((((((bigop) ((nat.nat) )) (n2)) (fun (i:(nat.nat) ) => (p2) (i))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f2) (i))))) (fun (same:forall (i:(nat.nat) ), ((((nat.lt) ) (i)) (n1)) -> ((((logic.eq) ((bool.bool) )) ((p1) (i))) ((bool.true) )) -> (((logic.eq) ((nat.nat) )) ((f1) (i))) ((f2) ((h) (i)))) => ((((nat.le_gen) (fun (__:(nat.nat) ) => ((((((((((sub_hk) ) (h)) (k)) (__)) (n2)) (p1)) (p2)) (f1)) (f2)) -> ((((((((((sub_hk) ) (k)) (h)) (n2)) (__)) (p2)) (p1)) (f2)) (f1)) -> (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) (__)) (fun (i:(nat.nat) ) => (p1) (i))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f1) (i)))) (((((((bigop) ((nat.nat) )) (n2)) (fun (i:(nat.nat) ) => (p2) (i))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i:(nat.nat) ) => (f2) (i))))) (n1)) (fun (i:(nat.nat) ) => (((((nat.nat_ind) (fun (_x_365:(nat.nat) ) => forall (f:((nat.nat) ) -> (bool.bool) ), ((((nat.le) ) (_x_365)) (n1)) -> ((((((((((sub_hk) ) (h)) (k)) (_x_365)) (n2)) (p1)) (f)) (f1)) (f2)) -> ((((((((((sub_hk) ) (k)) (h)) (n2)) (_x_365)) (f)) (p1)) (f2)) (f1)) -> (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) (_x_365)) (fun (i0:(nat.nat) ) => (p1) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f1) (i0)))) (((((((bigop) ((nat.nat) )) (n2)) (fun (i0:(nat.nat) ) => (f) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f2) (i0))))) (((((nat.nat_ind) (fun (_x_365:(nat.nat) ) => forall (f:((nat.nat) ) -> (bool.bool) ), ((((nat.le) ) ((nat.O) )) (n1)) -> ((((((((((sub_hk) ) (h)) (k)) ((nat.O) )) (_x_365)) (p1)) (f)) (f1)) (f2)) -> ((((((((((sub_hk) ) (k)) (h)) (_x_365)) ((nat.O) )) (f)) (p1)) (f2)) (f1)) -> (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((nat.O) )) (fun (i0:(nat.nat) ) => (p1) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f1) (i0)))) (((((((bigop) ((nat.nat) )) (_x_365)) (fun (i0:(nat.nat) ) => (f) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f2) (i0))))) (fun (f:((nat.nat) ) -> (bool.bool) ) => (((sym_eq_bigop_O) ((nat.nat) )) (fun (y:(((nat.nat) ) -> (bool.bool) ) -> ((nat.nat) ) -> (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) -> (((nat.nat) ) -> (nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) ((nat.O) )) (n1)) -> ((((((((((sub_hk) ) (h)) (k)) ((nat.O) )) ((nat.O) )) (p1)) (f)) (f1)) (f2)) -> ((((((((((sub_hk) ) (k)) (h)) ((nat.O) )) ((nat.O) )) (f)) (p1)) (f2)) (f1)) -> (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((nat.O) )) (fun (iO:(nat.nat) ) => (p1) (iO))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (iO:(nat.nat) ) => (f1) (iO)))) (((((y) (fun (iO:(nat.nat) ) => (f) (iO))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (iO:(nat.nat) ) => (f2) (iO))))) ((((sym_eq_bigop_body_O) ((nat.nat) )) (fun (y:(((nat.nat) ) -> (bool.bool) ) -> ((nat.nat) ) -> (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) -> (((nat.nat) ) -> (nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) ((nat.O) )) (n1)) -> ((((((((((sub_hk) ) (h)) (k)) ((nat.O) )) ((nat.O) )) (p1)) (f)) (f1)) (f2)) -> ((((((((((sub_hk) ) (k)) (h)) ((nat.O) )) ((nat.O) )) (f)) (p1)) (f2)) (f1)) -> (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((nat.O) )) (fun (iO:(nat.nat) ) => (p1) (iO))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (iO:(nat.nat) ) => (f1) (iO)))) (((((y) (fun (iO:(nat.nat) ) => (f) (iO))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (iO:(nat.nat) ) => (f2) (iO))))) ((((eq_bigop_body_O) ((nat.nat) )) (fun (y:(((nat.nat) ) -> (bool.bool) ) -> ((nat.nat) ) -> (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) -> (((nat.nat) ) -> (nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) ((nat.O) )) (n1)) -> ((((((((((sub_hk) ) (h)) (k)) ((nat.O) )) ((nat.O) )) (p1)) (f)) (f1)) (f2)) -> ((((((((((sub_hk) ) (k)) (h)) ((nat.O) )) ((nat.O) )) (f)) (p1)) (f2)) (f1)) -> (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((nat.O) )) (fun (iO:(nat.nat) ) => (p1) (iO))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (iO:(nat.nat) ) => (f1) (iO)))) (((((y) (fun (iO:(nat.nat) ) => (p1) (iO))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (iO:(nat.nat) ) => (f1) (iO))))) ((((eq_bigop_O) ((nat.nat) )) (fun (y:(((nat.nat) ) -> (bool.bool) ) -> ((nat.nat) ) -> (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) -> (((nat.nat) ) -> (nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) ((nat.O) )) (n1)) -> ((((((((((sub_hk) ) (h)) (k)) ((nat.O) )) ((nat.O) )) (p1)) (f)) (f1)) (f2)) -> ((((((((((sub_hk) ) (k)) (h)) ((nat.O) )) ((nat.O) )) (f)) (p1)) (f2)) (f1)) -> (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((nat.O) )) (fun (iO:(nat.nat) ) => (p1) (iO))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (iO:(nat.nat) ) => (f1) (iO)))) (((((y) (fun (iO:(nat.nat) ) => (p1) (iO))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (iO:(nat.nat) ) => (f1) (iO))))) (fun (auto:(((nat.le) ) ((nat.O) )) (n1)) => (fun (auto':(((((((((sub_hk) ) (h)) (k)) ((nat.O) )) ((nat.O) )) (p1)) (f)) (f1)) (f2)) => (fun (auto'':(((((((((sub_hk) ) (k)) (h)) ((nat.O) )) ((nat.O) )) (f)) (p1)) (f2)) (f1)) => (((logic.refl) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((nat.O) )) (fun (i0:(nat.nat) ) => (p1) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f1) (i0)))))))))))) (fun (m:(nat.nat) ) => fun (Hind:forall (f:((nat.nat) ) -> (bool.bool) ), ((((nat.le) ) ((nat.O) )) (n1)) -> ((((((((((sub_hk) ) (h)) (k)) ((nat.O) )) (m)) (p1)) (f)) (f1)) (f2)) -> ((((((((((sub_hk) ) (k)) (h)) (m)) ((nat.O) )) (f)) (p1)) (f2)) (f1)) -> (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((nat.O) )) (fun (i0:(nat.nat) ) => (p1) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f1) (i0)))) (((((((bigop) ((nat.nat) )) (m)) (fun (i0:(nat.nat) ) => (f) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f2) (i0)))) => (fun (p20:((nat.nat) ) -> (bool.bool) ) => fun (__:(((nat.le) ) ((nat.O) )) (n1)) => (fun (sub1:(((((((((sub_hk) ) (h)) (k)) ((nat.O) )) (((nat.S) ) (m))) (p1)) (p20)) (f1)) (f2)) => (fun (sub2:(((((((((sub_hk) ) (k)) (h)) (((nat.S) ) (m))) ((nat.O) )) (p20)) (p1)) (f2)) (f1)) => (((((((logic.eq_ind_r) ((nat.nat) )) (((((((bigop) ((nat.nat) )) (m)) (fun (i0:(nat.nat) ) => (p20) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f2) (i0)))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) ((nat.O) )) (fun (i0:(nat.nat) ) => (p1) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f1) (i0)))) (x))) (((((Hind) (p20)) ((nat.le_O_n) (n1))) ((((((((((sub_hkO) (h)) (k)) ((nat.O) )) (m)) (p1)) (p20)) (f1)) (f2)) (((logic.refl) ((nat.nat) )) ((nat.O) )))) ((((((((((((((((transitive_sub) (fun (x:(nat.nat) ) => x)) (fun (x:(nat.nat) ) => x)) (k)) (h)) (m)) (((nat.S) ) (m))) ((nat.O) )) (p20)) (p20)) (p1)) (f2)) (f2)) (f1)) ((((((sub_lt) (f2)) (p20)) (m)) (((nat.S) ) (m))) ((nat.le_n_Sn) (m)))) (sub2)))) (((((((bigop) ((nat.nat) )) (((nat.S) ) (m))) (fun (i0:(nat.nat) ) => (p20) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f2) (i0)))) ((((((((bigop_Sfalse) ((nat.nat) )) (m)) (p20)) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (f2)) (((((((((((((sub0_to_false) (k)) (h)) ((nat.O) )) (((nat.S) ) (m))) (p1)) (p20)) (f1)) (f2)) (((logic.refl) ((nat.nat) )) ((nat.O) ))) (sub2)) (m)) (((((logic.eq_coerc) ((((nat.lt) ) ((((div_mod.mod) ) (m)) ((nat.O) ))) ((((nat.plus) ) ((((nat.plus) ) ((((div_mod.mod) ) (m)) ((nat.O) ))) ((((nat.times) ) ((nat.O) )) ((((div_mod.div) ) (m)) ((nat.O) ))))) (((nat.S) ) ((nat.O) ))))) ((((nat.lt) ) (m)) (((nat.S) ) (m)))) ((((nat.lt_plus_Sn_r) ((((div_mod.mod) ) (m)) ((nat.O) ))) ((((nat.times) ) ((nat.O) )) ((((div_mod.div) ) (m)) ((nat.O) )))) ((nat.O) ))) (((((((logic.rewrite_l) ((nat.nat) )) (m)) (fun (__1:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.lt) ) ((((div_mod.mod) ) (m)) ((nat.O) ))) ((((nat.plus) ) (__1)) (((nat.S) ) ((nat.O) ))))) ((((nat.lt) ) (m)) (((nat.S) ) (m))))) (((((((logic.rewrite_l) ((nat.nat) )) (m)) (fun (__1:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.lt) ) (__1)) ((((nat.plus) ) (m)) (((nat.S) ) ((nat.O) ))))) ((((nat.lt) ) (m)) (((nat.S) ) (m))))) (((((((logic.rewrite_l) ((nat.nat) )) (((nat.S) ) (m))) (fun (__1:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.lt) ) (m)) (__1))) ((((nat.lt) ) (m)) (((nat.S) ) (m))))) (((logic.refl) (Prop)) ((((nat.lt) ) (m)) (((nat.S) ) (m))))) ((((nat.plus) ) (m)) (((nat.S) ) ((nat.O) )))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.plus) ) (m)) ((nat.O) ))) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((nat.S) ) (__1))) ((((nat.plus) ) (m)) (((nat.S) ) ((nat.O) ))))) (((nat.plus_n_Sm) (m)) ((nat.O) ))) (m)) ((nat.plus_n_O) (m))))) ((((div_mod.mod) ) (m)) ((nat.O) ))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.plus) ) ((nat.O) )) ((((div_mod.mod) ) (m)) ((nat.O) )))) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (m)) (__1))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.plus) ) ((((div_mod.mod) ) (m)) ((nat.O) ))) ((nat.O) ))) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (m)) (__1))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) ((nat.O) )) ((((div_mod.div) ) (m)) ((nat.O) )))) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (m)) ((((nat.plus) ) ((((div_mod.mod) ) (m)) ((nat.O) ))) (__1)))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.plus) ) ((((nat.times) ) ((nat.O) )) ((((div_mod.div) ) (m)) ((nat.O) )))) ((((div_mod.mod) ) (m)) ((nat.O) )))) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (m)) (__1))) (((((((((((((((((((((((let_clause_10471) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)) (_clearme)) (h)) (_clearme0)) (k)) (_clearme1)) (_clearme2)) (same)) (i)) (m)) (Hind)) (p20)) (__)) (sub1)) (sub2)) (m)) ((nat.O) ))) ((((nat.plus) ) ((((div_mod.mod) ) (m)) ((nat.O) ))) ((((nat.times) ) ((nat.O) )) ((((div_mod.div) ) (m)) ((nat.O) ))))) (((nat.commutative_plus) ((((nat.times) ) ((nat.O) )) ((((div_mod.div) ) (m)) ((nat.O) )))) ((((div_mod.mod) ) (m)) ((nat.O) ))))) ((nat.O) )) ((nat.times_O_n) ((((div_mod.div) ) (m)) ((nat.O) ))))) ((((nat.plus) ) ((nat.O) )) ((((div_mod.mod) ) (m)) ((nat.O) )))) (((nat.commutative_plus) ((((div_mod.mod) ) (m)) ((nat.O) ))) ((nat.O) )))) ((((div_mod.mod) ) (m)) ((nat.O) ))) ((nat.plus_O_n) ((((div_mod.mod) ) (m)) ((nat.O) )))))) ((((nat.plus) ) ((((div_mod.mod) ) (m)) ((nat.O) ))) ((((nat.times) ) ((nat.O) )) ((((div_mod.div) ) (m)) ((nat.O) ))))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.plus) ) ((((nat.times) ) ((nat.O) )) ((((div_mod.div) ) (m)) ((nat.O) )))) ((((div_mod.mod) ) (m)) ((nat.O) )))) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (m)) (__1))) (((((((((((((((((((((((let_clause_10471) (n1)) (n2)) (p1)) (p2)) (f1)) (f2)) (_clearme)) (h)) (_clearme0)) (k)) (_clearme1)) (_clearme2)) (same)) (i)) (m)) (Hind)) (p20)) (__)) (sub1)) (sub2)) (m)) ((nat.O) ))) ((((nat.plus) ) ((((div_mod.mod) ) (m)) ((nat.O) ))) ((((nat.times) ) ((nat.O) )) ((((div_mod.div) ) (m)) ((nat.O) ))))) (((nat.commutative_plus) ((((nat.times) ) ((nat.O) )) ((((div_mod.div) ) (m)) ((nat.O) )))) ((((div_mod.mod) ) (m)) ((nat.O) )))))))))))))) (n2))) (fun (n:(nat.nat) ) => fun (Hind:forall (f:((nat.nat) ) -> (bool.bool) ), ((((nat.le) ) (n)) (n1)) -> ((((((((((sub_hk) ) (h)) (k)) (n)) (n2)) (p1)) (f)) (f1)) (f2)) -> ((((((((((sub_hk) ) (k)) (h)) (n2)) (n)) (f)) (p1)) (f2)) (f1)) -> (((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) (n)) (fun (i0:(nat.nat) ) => (p1) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f1) (i0)))) (((((((bigop) ((nat.nat) )) (n2)) (fun (i0:(nat.nat) ) => (f) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f2) (i0)))) => (fun (p20:((nat.nat) ) -> (bool.bool) ) => fun (ltn:(((nat.le) ) (((nat.S) ) (n))) (n1)) => (fun (sub1:(((((((((sub_hk) ) (h)) (k)) (((nat.S) ) (n))) (n2)) (p1)) (p20)) (f1)) (f2)) => (fun (sub2:(((((((((sub_hk) ) (k)) (h)) (n2)) (((nat.S) ) (n))) (p20)) (p1)) (f2)) (f1)) => (((((((connectives.match_Or_prop) ((((logic.eq) ((bool.bool) )) ((p1) (n))) ((bool.true) ))) ((((logic.eq) ((bool.bool) )) ((p1) (n))) ((bool.false) ))) ((((logic.eq) ((nat.nat) )) (((((((bigop) ((nat.nat) )) (((nat.S) ) (n))) (fun (i0:(nat.nat) ) => (p1) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f1) (i0)))) (((((((bigop) ((nat.nat) )) (n2)) (fun (i0:(nat.nat) ) => (p20) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f2) (i0))))) (fun (p1n:(((logic.eq) ((bool.bool) )) ((p1) (n))) ((bool.true) )) => (((((((logic.eq_ind_r) ((nat.nat) )) ((((nat.times) ) ((f1) (n))) (((((((bigop) ((nat.nat) )) (n)) (fun (i0:(nat.nat) ) => (p1) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f1) (i0))))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (x)) (((((((bigop) ((nat.nat) )) (n2)) (fun (i0:(nat.nat) ) => (p20) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f2) (i0))))) ((((((connectives.match_And_prop) ((((connectives.And) ) ((((nat.lt) ) ((h) (n))) (n2))) ((((logic.eq) ((bool.bool) )) ((p20) ((h) (n)))) ((bool.true) )))) ((((logic.eq) ((nat.nat) )) ((k) ((h) (n)))) (n))) ((((logic.eq) ((nat.nat) )) ((((nat.times) ) ((f1) (n))) (((((((bigop) ((nat.nat) )) (n)) (fun (i0:(nat.nat) ) => (p1) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f1) (i0))))) (((((((bigop) ((nat.nat) )) (n2)) (fun (i0:(nat.nat) ) => (p20) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f2) (i0))))) (fun (_clearme3:(((connectives.And) ) ((((nat.lt) ) ((h) (n))) (n2))) ((((logic.eq) ((bool.bool) )) ((p20) ((h) (n)))) ((bool.true) ))) => ((((((connectives.match_And_prop) ((((nat.lt) ) ((h) (n))) (n2))) ((((logic.eq) ((bool.bool) )) ((p20) ((h) (n)))) ((bool.true) ))) (((((logic.eq) ((nat.nat) )) ((k) ((h) (n)))) (n)) -> (((logic.eq) ((nat.nat) )) ((((nat.times) ) ((f1) (n))) (((((((bigop) ((nat.nat) )) (n)) (fun (i0:(nat.nat) ) => (p1) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f1) (i0))))) (((((((bigop) ((nat.nat) )) (n2)) (fun (i0:(nat.nat) ) => (p20) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f2) (i0))))) (fun (hn:(((nat.lt) ) ((h) (n))) (n2)) => (fun (p2hn:(((logic.eq) ((bool.bool) )) ((p20) ((h) (n)))) ((bool.true) )) => (fun (eqn:(((logic.eq) ((nat.nat) )) ((k) ((h) (n)))) (n)) => (((((((logic.eq_ind_r) ((nat.nat) )) ((((nat.times) ) ((f2) ((h) (n)))) (((((((bigop) ((nat.nat) )) (n2)) (fun (x:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) ((h) (n))) (x)))) ((p20) (x)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x:(nat.nat) ) => (f2) (x))))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.times) ) ((f1) (n))) (((((((bigop) ((nat.nat) )) (n)) (fun (i0:(nat.nat) ) => (p1) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f1) (i0))))) (x))) (((((((logic.eq_ind_r) ((nat.nat) )) ((f2) ((h) (n)))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.times) ) (x)) (((((((bigop) ((nat.nat) )) (n)) (fun (i0:(nat.nat) ) => (p1) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f1) (i0))))) ((((nat.times) ) ((f2) ((h) (n)))) (((((((bigop) ((nat.nat) )) (n2)) (fun (x0:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) ((h) (n))) (x0)))) ((p20) (x0)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x0:(nat.nat) ) => (f2) (x0)))))) (((((((logic.eq_f) ((nat.nat) )) ((nat.nat) )) (((nat.times) ) ((f2) ((h) (n))))) (((((((bigop) ((nat.nat) )) (n)) (fun (i0:(nat.nat) ) => (p1) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f1) (i0)))) (((((((bigop) ((nat.nat) )) (n2)) (fun (x:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) ((h) (n))) (x)))) ((p20) (x)))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x:(nat.nat) ) => (f2) (x)))) (((((Hind) (fun (__:(nat.nat) ) => (((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) ((h) (n))) (__)))) ((p20) (__)))) ((((nat.lt_to_le) (n)) (n1)) (ltn))) (fun (i0:(nat.nat) ) => fun (ltin:(((nat.lt) ) (i0)) (n)) => (fun (p1i:(((logic.eq) ((bool.bool) )) ((p1) (i0))) ((bool.true) )) => ((((((connectives.match_And_prop) ((((connectives.And) ) ((((nat.lt) ) ((h) (i0))) (n2))) ((((logic.eq) ((bool.bool) )) ((p20) ((h) (i0)))) ((bool.true) )))) ((((logic.eq) ((nat.nat) )) ((k) ((h) (i0)))) (i0))) ((((connectives.And) ) ((((connectives.And) ) ((((nat.lt) ) ((h) (i0))) (n2))) ((((logic.eq) ((bool.bool) )) ((((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) ((h) (n))) ((h) (i0))))) ((p20) ((h) (i0))))) ((bool.true) )))) ((((logic.eq) ((nat.nat) )) ((k) ((h) (i0)))) (i0)))) (fun (_clearme4:(((connectives.And) ) ((((nat.lt) ) ((h) (i0))) (n2))) ((((logic.eq) ((bool.bool) )) ((p20) ((h) (i0)))) ((bool.true) ))) => ((((((connectives.match_And_prop) ((((nat.lt) ) ((h) (i0))) (n2))) ((((logic.eq) ((bool.bool) )) ((p20) ((h) (i0)))) ((bool.true) ))) (((((logic.eq) ((nat.nat) )) ((k) ((h) (i0)))) (i0)) -> (((connectives.And) ) ((((connectives.And) ) ((((nat.lt) ) ((h) (i0))) (n2))) ((((logic.eq) ((bool.bool) )) ((((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) ((h) (n))) ((h) (i0))))) ((p20) ((h) (i0))))) ((bool.true) )))) ((((logic.eq) ((nat.nat) )) ((k) ((h) (i0)))) (i0)))) (fun (h1i:(((nat.lt) ) ((h) (i0))) (n2)) => (fun (p2h1i:(((logic.eq) ((bool.bool) )) ((p20) ((h) (i0)))) ((bool.true) )) => (fun (eqi:(((logic.eq) ((nat.nat) )) ((k) ((h) (i0)))) (i0)) => (((((connectives.conj) ((((connectives.And) ) ((((nat.lt) ) ((h) (i0))) (n2))) ((((logic.eq) ((bool.bool) )) ((((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) ((h) (n))) ((h) (i0))))) ((p20) ((h) (i0))))) ((bool.true) )))) ((((logic.eq) ((nat.nat) )) ((k) ((h) (i0)))) (i0))) (((((connectives.conj) ((((nat.lt) ) ((h) (i0))) (n2))) ((((logic.eq) ((bool.bool) )) ((((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) ((h) (n))) ((h) (i0))))) ((p20) ((h) (i0))))) ((bool.true) ))) (h1i)) (((((((logic.eq_ind_r) ((bool.bool) )) ((bool.false) )) (fun (x:(bool.bool) ) => (((logic.eq) ((bool.bool) )) ((((bool.andb) ) (((bool.notb) ) (x))) ((p20) ((h) (i0))))) ((bool.true) ))) ((((((bool.sym_eq_match_bool_type_false) ((bool.bool) )) ((bool.false) )) ((bool.true) )) (fun (y:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (((((bool.match_bool_type) ((bool.bool) )) ((p20) ((h) (i0)))) ((bool.false) )) (y))) ((bool.true) ))) ((((((bool.sym_eq_match_bool_type_true) ((bool.bool) )) ((p20) ((h) (i0)))) ((bool.false) )) (fun (y:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (y)) ((bool.true) ))) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.true) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.true) ))) (((logic.refl) ((bool.bool) )) ((bool.true) ))) ((p20) ((h) (i0)))) (p2h1i))))) ((((nat.eqb) ) ((h) (n))) ((h) (i0)))) ((((nat.not_eq_to_eqb_false) ((h) (n))) ((h) (i0))) (((((logic.not_to_not) ((((logic.eq) ((nat.nat) )) ((h) (n))) ((h) (i0)))) ((((logic.eq) ((nat.nat) )) (i0)) (n))) (fun (auto:(((logic.eq) ((nat.nat) )) ((h) (n))) ((h) (i0))) => (((((((logic.rewrite_r) ((nat.nat) )) (n)) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__)) (n))) (((logic.refl) ((nat.nat) )) (n))) (i0)) (((((((logic.rewrite_l) ((nat.nat) )) ((k) ((h) (n)))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__)) (n))) (eqn)) (i0)) (((((((logic.rewrite_r) ((nat.nat) )) ((h) (i0))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((k) (__))) (i0))) (eqi)) ((h) (n))) (auto)))))) ((((nat.lt_to_not_eq) (i0)) (n)) (ltin))))))) (((((((logic.rewrite_r) ((nat.nat) )) (i0)) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__)) (i0))) (((logic.refl) ((nat.nat) )) (i0))) ((k) ((h) (i0)))) (eqi))))))) (_clearme4)))) ((((sub1) (i0)) ((((nat.le_S) (((nat.S) ) (i0))) (n)) (ltin))) (p1i)))))) (fun (j:(nat.nat) ) => fun (ltj:(((nat.lt) ) (j)) (n2)) => (fun (p2j:(((logic.eq) ((bool.bool) )) ((((bool.andb) ) (((bool.notb) ) ((((nat.eqb) ) ((h) (n))) (j)))) ((p20) (j)))) ((bool.true) )) => ((((((connectives.match_And_prop) ((((connectives.And) ) ((((nat.lt) ) ((k) (j))) (((nat.S) ) (n)))) ((((logic.eq) ((bool.bool) )) ((p1) ((k) (j)))) ((bool.true) )))) ((((logic.eq) ((nat.nat) )) ((h) ((k) (j)))) (j))) ((((connectives.And) ) ((((connectives.And) ) ((((nat.lt) ) ((k) (j))) (n))) ((((logic.eq) ((bool.bool) )) ((p1) ((k) (j)))) ((bool.true) )))) ((((logic.eq) ((nat.nat) )) ((h) ((k) (j)))) (j)))) (fun (_clearme4:(((connectives.And) ) ((((nat.lt) ) ((k) (j))) (((nat.S) ) (n)))) ((((logic.eq) ((bool.bool) )) ((p1) ((k) (j)))) ((bool.true) ))) => ((((((connectives.match_And_prop) ((((nat.lt) ) ((k) (j))) (((nat.S) ) (n)))) ((((logic.eq) ((bool.bool) )) ((p1) ((k) (j)))) ((bool.true) ))) (((((logic.eq) ((nat.nat) )) ((h) ((k) (j)))) (j)) -> (((connectives.And) ) ((((connectives.And) ) ((((nat.lt) ) ((k) (j))) (n))) ((((logic.eq) ((bool.bool) )) ((p1) ((k) (j)))) ((bool.true) )))) ((((logic.eq) ((nat.nat) )) ((h) ((k) (j)))) (j)))) (fun (ltkj:(((nat.lt) ) ((k) (j))) (((nat.S) ) (n))) => (fun (p1kj:(((logic.eq) ((bool.bool) )) ((p1) ((k) (j)))) ((bool.true) )) => (fun (eqj:(((logic.eq) ((nat.nat) )) ((h) ((k) (j)))) (j)) => (((((connectives.conj) ((((connectives.And) ) ((((nat.lt) ) ((k) (j))) (n))) ((((logic.eq) ((bool.bool) )) ((p1) ((k) (j)))) ((bool.true) )))) ((((logic.eq) ((nat.nat) )) ((h) ((k) (j)))) (j))) (((((connectives.conj) ((((nat.lt) ) ((k) (j))) (n))) ((((logic.eq) ((bool.bool) )) ((p1) ((k) (j)))) ((bool.true) ))) (((((((connectives.match_Or_prop) ((((nat.lt) ) ((k) (j))) (n))) ((((logic.eq) ((nat.nat) )) ((k) (j))) (n))) ((((nat.lt) ) ((k) (j))) (n))) (fun (auto:(((nat.lt) ) ((k) (j))) (n)) => (auto))) (fun (eqkj:(((logic.eq) ((nat.nat) )) ((k) (j))) (n)) => (((connectives.falsity) ((((nat.lt) ) ((k) (j))) (n))) (((((((nat.eqb_elim) ((h) (n))) (j)) (fun (__:(bool.bool) ) => ((((logic.eq) ((bool.bool) )) ((((bool.andb) ) (((bool.notb) ) (__))) ((p20) (j)))) ((bool.true) )) -> (connectives.False) )) ((((((bool.sym_eq_match_bool_type_true) ((bool.bool) )) ((bool.false) )) ((bool.true) )) (fun (y:(bool.bool) ) => ((((logic.eq) ((nat.nat) )) ((h) (n))) (j)) -> ((((logic.eq) ((bool.bool) )) (((((bool.match_bool_type) ((bool.bool) )) ((p20) (j))) ((bool.false) )) (y))) ((bool.true) )) -> (connectives.False) )) ((((((bool.sym_eq_match_bool_type_false) ((bool.bool) )) ((p20) (j))) ((bool.false) )) (fun (y:(bool.bool) ) => ((((logic.eq) ((nat.nat) )) ((h) (n))) (j)) -> ((((logic.eq) ((bool.bool) )) (y)) ((bool.true) )) -> (connectives.False) )) (fun (auto:(((logic.eq) ((nat.nat) )) ((h) (n))) (j)) => (fun (auto':(((logic.eq) ((bool.bool) )) ((bool.false) )) ((bool.true) )) => ((((logic.absurd) ((((logic.eq) ((bool.bool) )) ((bool.true) )) ((bool.false) ))) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.true) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) ((bool.true) )) (__))) (((logic.refl) ((bool.bool) )) ((bool.true) ))) ((bool.false) )) (auto'))) (bool.not_eq_true_false))))))) ((((((bool.sym_eq_match_bool_type_false) ((bool.bool) )) ((bool.false) )) ((bool.true) )) (fun (y:(bool.bool) ) => (((connectives.Not) ) ((((logic.eq) ((nat.nat) )) ((h) (n))) (j))) -> ((((logic.eq) ((bool.bool) )) (((((bool.match_bool_type) ((bool.bool) )) ((p20) (j))) ((bool.false) )) (y))) ((bool.true) )) -> (connectives.False) )) ((((((bool.sym_eq_match_bool_type_true) ((bool.bool) )) ((p20) (j))) ((bool.false) )) (fun (y:(bool.bool) ) => (((connectives.Not) ) ((((logic.eq) ((nat.nat) )) ((h) (n))) (j))) -> ((((logic.eq) ((bool.bool) )) (y)) ((bool.true) )) -> (connectives.False) )) (fun (auto:((connectives.Not) ) ((((logic.eq) ((nat.nat) )) ((h) (n))) (j))) => (fun (auto':(((logic.eq) ((bool.bool) )) ((p20) (j))) ((bool.true) )) => ((((logic.absurd) ((((logic.eq) ((nat.nat) )) ((h) (n))) (j))) (((((((logic.rewrite_r) ((nat.nat) )) (j)) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__)) (j))) (((logic.refl) ((nat.nat) )) (j))) ((h) (n))) (((((((logic.rewrite_l) ((nat.nat) )) ((k) (j))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((h) (__))) (j))) (eqj)) (n)) (eqkj)))) (auto))))))) (p2j))))) ((((nat.le_to_or_lt_eq) ((k) (j))) (n)) ((((nat.le_S_S_to_le) ((k) (j))) (n)) (ltkj))))) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.true) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.true) ))) (((logic.refl) ((bool.bool) )) ((bool.true) ))) ((p1) ((k) (j)))) (p1kj)))) (((((((logic.rewrite_r) ((nat.nat) )) (j)) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__)) (j))) (((logic.refl) ((nat.nat) )) (j))) ((h) ((k) (j)))) (eqj))))))) (_clearme4)))) ((((sub2) (j)) (ltj)) ((((bool.andb_true_r) (((bool.notb) ) ((((nat.eqb) ) ((h) (n))) (j)))) ((p20) (j))) (p2j))))))))) ((f1) (n))) ((((same) (n)) (ltn)) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.true) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.true) ))) (((logic.refl) ((bool.bool) )) ((bool.true) ))) ((p1) (n))) (p1n))))) (((((((bigop) ((nat.nat) )) (n2)) (fun (x:(nat.nat) ) => (p20) (x))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (x:(nat.nat) ) => (f2) (x)))) (((((((bigop_diff) (p20)) (f2)) ((h) (n))) (n2)) (hn)) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.true) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.true) ))) (((logic.refl) ((bool.bool) )) ((bool.true) ))) ((p20) ((h) (n)))) (p2hn)))))))) (_clearme3)))) ((((sub1) (n)) ((nat.le_n) (((nat.S) ) (n)))) (p1n)))) (((((((bigop) ((nat.nat) )) (((nat.S) ) (n))) (fun (i0:(nat.nat) ) => (p1) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f1) (i0)))) ((((((((bigop_Strue) ((nat.nat) )) (n)) (p1)) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (f1)) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.true) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.true) ))) (((logic.refl) ((bool.bool) )) ((bool.true) ))) ((p1) (n))) (p1n)))))) (fun (p1n:(((logic.eq) ((bool.bool) )) ((p1) (n))) ((bool.false) )) => (((((((logic.eq_ind_r) ((nat.nat) )) (((((((bigop) ((nat.nat) )) (n)) (fun (i0:(nat.nat) ) => (p1) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f1) (i0)))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (x)) (((((((bigop) ((nat.nat) )) (n2)) (fun (i0:(nat.nat) ) => (p20) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f2) (i0))))) (((((Hind) (p20)) ((((nat.lt_to_le) (n)) (n1)) (ltn))) ((((((((((((((((transitive_sub) (fun (x:(nat.nat) ) => x)) (fun (x:(nat.nat) ) => x)) (h)) (k)) (n)) (((nat.S) ) (n))) (n2)) (p1)) (p1)) (p20)) (f1)) (f1)) (f2)) ((((((sub_lt) (f1)) (p1)) (n)) (((nat.S) ) (n))) ((nat.le_n_Sn) (n)))) (sub1))) (fun (i0:(nat.nat) ) => fun (lti:(((nat.lt) ) (i0)) (n2)) => (fun (p2i:(((logic.eq) ((bool.bool) )) ((p20) (i0))) ((bool.true) )) => ((((((connectives.match_And_prop) ((((connectives.And) ) ((((nat.lt) ) ((k) (i0))) (((nat.S) ) (n)))) ((((logic.eq) ((bool.bool) )) ((p1) ((k) (i0)))) ((bool.true) )))) ((((logic.eq) ((nat.nat) )) ((h) ((k) (i0)))) (i0))) ((((connectives.And) ) ((((connectives.And) ) ((((nat.lt) ) ((k) (i0))) (n))) ((((logic.eq) ((bool.bool) )) ((p1) ((k) (i0)))) ((bool.true) )))) ((((logic.eq) ((nat.nat) )) ((h) ((k) (i0)))) (i0)))) (fun (_clearme3:(((connectives.And) ) ((((nat.lt) ) ((k) (i0))) (((nat.S) ) (n)))) ((((logic.eq) ((bool.bool) )) ((p1) ((k) (i0)))) ((bool.true) ))) => ((((((connectives.match_And_prop) ((((nat.lt) ) ((k) (i0))) (((nat.S) ) (n)))) ((((logic.eq) ((bool.bool) )) ((p1) ((k) (i0)))) ((bool.true) ))) (((((logic.eq) ((nat.nat) )) ((h) ((k) (i0)))) (i0)) -> (((connectives.And) ) ((((connectives.And) ) ((((nat.lt) ) ((k) (i0))) (n))) ((((logic.eq) ((bool.bool) )) ((p1) ((k) (i0)))) ((bool.true) )))) ((((logic.eq) ((nat.nat) )) ((h) ((k) (i0)))) (i0)))) (fun (ltki:(((nat.lt) ) ((k) (i0))) (((nat.S) ) (n))) => (fun (p1ki:(((logic.eq) ((bool.bool) )) ((p1) ((k) (i0)))) ((bool.true) )) => (fun (eqi:(((logic.eq) ((nat.nat) )) ((h) ((k) (i0)))) (i0)) => (((((connectives.conj) ((((connectives.And) ) ((((nat.lt) ) ((k) (i0))) (n))) ((((logic.eq) ((bool.bool) )) ((p1) ((k) (i0)))) ((bool.true) )))) ((((logic.eq) ((nat.nat) )) ((h) ((k) (i0)))) (i0))) (((((connectives.conj) ((((nat.lt) ) ((k) (i0))) (n))) ((((logic.eq) ((bool.bool) )) ((p1) ((k) (i0)))) ((bool.true) ))) (((((((connectives.match_Or_prop) ((((nat.lt) ) ((k) (i0))) (n))) ((((logic.eq) ((nat.nat) )) ((k) (i0))) (n))) ((((nat.lt) ) ((k) (i0))) (n))) (fun (auto:(((nat.lt) ) ((k) (i0))) (n)) => (auto))) (fun (eqki:(((logic.eq) ((nat.nat) )) ((k) (i0))) (n)) => (((connectives.falsity) ((((nat.lt) ) ((k) (i0))) (n))) ((((logic.absurd) ((((logic.eq) ((bool.bool) )) ((bool.true) )) ((bool.false) ))) (((((((logic.rewrite_l) ((bool.bool) )) ((bool.true) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) ((bool.true) )) (__))) (((logic.refl) ((bool.bool) )) ((bool.true) ))) ((bool.false) )) (((((((logic.rewrite_l) ((bool.bool) )) ((p1) (n))) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.false) ))) (p1n)) ((bool.true) )) (((((((logic.rewrite_l) ((nat.nat) )) ((k) (i0))) (fun (__:(nat.nat) ) => (((logic.eq) ((bool.bool) )) ((p1) (__))) ((bool.true) ))) (p1ki)) (n)) (eqki))))) (bool.not_eq_true_false))))) ((((nat.le_to_or_lt_eq) ((k) (i0))) (n)) ((((nat.le_S_S_to_le) ((k) (i0))) (n)) (ltki))))) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.true) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.true) ))) (((logic.refl) ((bool.bool) )) ((bool.true) ))) ((p1) ((k) (i0)))) (p1ki)))) (((((((logic.rewrite_r) ((nat.nat) )) (i0)) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__)) (i0))) (((logic.refl) ((nat.nat) )) (i0))) ((h) ((k) (i0)))) (eqi))))))) (_clearme3)))) ((((sub2) (i0)) (lti)) (p2i))))))) (((((((bigop) ((nat.nat) )) (((nat.S) ) (n))) (fun (i0:(nat.nat) ) => (p1) (i0))) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (fun (i0:(nat.nat) ) => (f1) (i0)))) ((((((((bigop_Sfalse) ((nat.nat) )) (n)) (p1)) (((nat.S) ) ((nat.O) ))) ((nat.times) )) (f1)) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.false) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.false) ))) (((logic.refl) ((bool.bool) )) ((bool.false) ))) ((p1) (n))) (p1n)))))) ((bool.true_or_false) ((p1) (n))))))))) (i)) (p2))))) (_clearme2)))) (_clearme1)))) (_clearme0)))) (_clearme)).
