include "basics/pts.ma".
include "bool.ma".
include "connectives.ma".
include "div_mod.ma".
include "logic.ma".
include "nat.ma".
include "relations.ma".
axiom divides : ((nat) ) -> ((nat) ) -> Prop.
axiom quotient : \forall (n:(nat) ). \forall (m:(nat) ). \forall (q:(nat) ). ((((eq) ((nat) )) (m)) ((((times) ) (n)) (q))) -> (((divides) ) (n)) (m).
axiom match_divides_prop : \forall (n:(nat) ). \forall (m:(nat) ). \forall (return_type:Prop). (\forall (q:(nat) ). ((((eq) ((nat) )) (m)) ((((times) ) (n)) (q))) -> return_type) -> ((((divides) ) (n)) (m)) -> return_type.
definition reflexive_divides : ((reflexive) ((nat) )) ((divides) ) := \lambda x : (nat) . ((((quotient) (x)) (x)) (((S) ) ((O) ))) (((((((rewrite_r) ((nat) )) ((((times) ) (x)) (((S) ) ((O) )))) (\lambda j__ : (nat) . (((eq) ((nat) )) (j__)) ((((times) ) (x)) (((S) ) ((O) ))))) (((refl) ((nat) )) ((((times) ) (x)) (((S) ) ((O) ))))) (x)) ((times_n_1) (x))).
definition divides_to_div_mod_spec : \forall (n:(nat) ). \forall (m:(nat) ). ((((lt) ) ((O) )) (n)) -> ((((divides) ) (n)) (m)) -> (((((div_mod_spec) ) (m)) (n)) ((((div) ) (m)) (n))) ((O) ) := \lambda n : (nat) . \lambda m : (nat) . \lambda posn : (((lt) ) ((O) )) (n). (\lambda j_clearme : (((divides) ) (n)) (m). ((((((match_divides_prop) (n)) (m)) ((((((div_mod_spec) ) (m)) (n)) ((((div) ) (m)) (n))) ((O) ))) (\lambda q : (nat) . \lambda eqm : (((eq) ((nat) )) (m)) ((((times) ) (n)) (q)). (((((((div_mod_spec_intro) (m)) (n)) ((((div) ) (m)) (n))) ((O) )) (posn)) (((((((eq_ind_r) ((nat) )) ((((times) ) (n)) (q))) (\lambda x : (nat) . (((eq) ((nat) )) (x)) ((((plus) ) ((((times) ) ((((div) ) (x)) (n))) (n))) ((O) )))) (((((((eq_ind_r) ((nat) )) ((((times) ) (q)) (n))) (\lambda x : (nat) . (((eq) ((nat) )) (x)) ((((plus) ) ((((times) ) ((((div) ) (x)) (n))) (n))) ((O) )))) (((((((eq_ind_r) ((nat) )) (q)) (\lambda x : (nat) . (((eq) ((nat) )) ((((times) ) (q)) (n))) ((((plus) ) ((((times) ) (x)) (n))) ((O) )))) (((((((rewrite_r) ((nat) )) ((((times) ) (n)) (q))) (\lambda j__ : (nat) . (((eq) ((nat) )) (j__)) ((((plus) ) ((((times) ) (q)) (n))) ((O) )))) (((((((rewrite_l) ((nat) )) (m)) (\lambda j__ : (nat) . (((eq) ((nat) )) (j__)) ((((plus) ) ((((times) ) (q)) (n))) ((O) )))) (((((((rewrite_r) ((nat) )) ((((times) ) (n)) (q))) (\lambda j__ : (nat) . (((eq) ((nat) )) (m)) ((((plus) ) (j__)) ((O) )))) (((((((rewrite_l) ((nat) )) (m)) (\lambda j__ : (nat) . (((eq) ((nat) )) (m)) ((((plus) ) (j__)) ((O) )))) (((((((rewrite_l) ((nat) )) (m)) (\lambda j__ : (nat) . (((eq) ((nat) )) (m)) (j__))) (((refl) ((nat) )) (m))) ((((plus) ) (m)) ((O) ))) ((plus_n_O) (m)))) ((((times) ) (n)) (q))) (eqm))) ((((times) ) (q)) (n))) (((commutative_times) (q)) (n)))) ((((times) ) (n)) (q))) (eqm))) ((((times) ) (q)) (n))) (((commutative_times) (q)) (n)))) ((((div) ) ((((times) ) (q)) (n))) (n))) ((((div_times) (q)) (n)) (posn)))) ((((times) ) (n)) (q))) (((commutative_times) (n)) (q)))) (m)) (eqm))))) (j_clearme))).
definition divides_to_mod_O : \forall (n:(nat) ). \forall (m:(nat) ). ((((lt) ) ((O) )) (n)) -> ((((divides) ) (n)) (m)) -> (((eq) ((nat) )) ((((mod) ) (m)) (n))) ((O) ) := \lambda n : (nat) . \lambda m : (nat) . \lambda posn : (((lt) ) ((O) )) (n). (\lambda divnm : (((divides) ) (n)) (m). (((((((((div_mod_spec_to_eq2) (m)) (n)) ((((div) ) (m)) (n))) ((((mod) ) (m)) (n))) ((((div) ) (m)) (n))) ((O) )) ((((div_mod_spec_div_mod) (m)) (n)) (posn))) (((((divides_to_div_mod_spec) (n)) (m)) (posn)) (divnm)))).
definition mod_O_to_divides : \forall (n:(nat) ). \forall (m:(nat) ). ((((lt) ) ((O) )) (n)) -> ((((eq) ((nat) )) ((((mod) ) (m)) (n))) ((O) )) -> (((divides) ) (n)) (m) := \lambda n : (nat) . \lambda m : (nat) . \lambda auto : (((lt) ) ((O) )) (n). (\lambda auto' : (((eq) ((nat) )) ((((mod) ) (m)) (n))) ((O) ). (((((quotient) (n)) (m)) ((((div) ) (m)) (n))) (((((((rewrite_l) ((nat) )) ((((times) ) (n)) ((((div) ) (m)) (n)))) (\lambda j__ : (nat) . (((eq) ((nat) )) (j__)) ((((times) ) (n)) ((((div) ) (m)) (n))))) (((refl) ((nat) )) ((((times) ) (n)) ((((div) ) (m)) (n))))) (m)) (((((((rewrite_r) ((nat) )) ((((minus) ) (m)) ((O) ))) (\lambda j__ : (nat) . (((eq) ((nat) )) ((((times) ) (n)) ((((div) ) (m)) (n)))) (j__))) (((((((rewrite_l) ((nat) )) ((((mod) ) (m)) (n))) (\lambda j__ : (nat) . (((eq) ((nat) )) ((((times) ) (n)) ((((div) ) (m)) (n)))) ((((minus) ) (m)) (j__)))) (((((((rewrite_l) ((nat) )) ((((times) ) ((((div) ) (m)) (n))) (n))) (\lambda j__ : (nat) . (((eq) ((nat) )) (j__)) ((((minus) ) (m)) ((((mod) ) (m)) (n))))) (((eq_times_div_minus_mod) (m)) (n))) ((((times) ) (n)) ((((div) ) (m)) (n)))) (((commutative_times) ((((div) ) (m)) (n))) (n)))) ((O) )) (auto'))) (m)) ((minus_n_O) (m)))))).
definition divides_n_O : \forall (n:(nat) ). (((divides) ) (n)) ((O) ) := \lambda n : (nat) . ((((quotient) (n)) ((O) )) ((O) )) (((((((rewrite_r) ((nat) )) ((((times) ) (n)) ((O) ))) (\lambda j__ : (nat) . (((eq) ((nat) )) (j__)) ((((times) ) (n)) ((O) )))) (((refl) ((nat) )) ((((times) ) (n)) ((O) )))) ((O) )) ((times_n_O) (n))).
definition divides_n_n : \forall (n:(nat) ). (((divides) ) (n)) (n) := \lambda n : (nat) . (reflexive_divides) (n).
definition eq_mod_to_divides : \forall (n:(nat) ). \forall (m:(nat) ). \forall (q:(nat) ). ((((lt) ) ((O) )) (q)) -> ((((eq) ((nat) )) ((((mod) ) (n)) (q))) ((((mod) ) (m)) (q))) -> (((divides) ) (q)) ((((minus) ) (n)) (m)) := \lambda n : (nat) . \lambda m : (nat) . \lambda q : (nat) . \lambda posq : (((lt) ) ((O) )) (q). (\lambda eqmod : (((eq) ((nat) )) ((((mod) ) (n)) (q))) ((((mod) ) (m)) (q)). ((((((leb_elim) (n)) (m)) (\lambda j__ : (bool) . (((divides) ) (q)) ((((minus) ) (n)) (m)))) (\lambda nm : (((le) ) (n)) (m). (((((eq_coerc) ((((divides) ) (q)) ((O) ))) ((((divides) ) (q)) ((((minus) ) (n)) (m)))) ((divides_n_O) (q))) (((((((rewrite_r) ((nat) )) ((O) )) (\lambda j__ : (nat) . (((eq) (Prop)) ((((divides) ) (q)) ((O) ))) ((((divides) ) (q)) (j__)))) (((refl) (Prop)) ((((divides) ) (q)) ((O) )))) ((((minus) ) (n)) (m))) (((((sym_eq) ((nat) )) ((O) )) ((((minus) ) (n)) (m))) (((((eq_coerc) ((((eq) ((nat) )) ((((minus) ) ((O) )) ((((minus) ) (m)) (n)))) ((((minus) ) ((((plus) ) ((O) )) (n))) (m)))) ((((eq) ((nat) )) ((O) )) ((((minus) ) (n)) (m)))) (((((minus_le_minus_minus_comm) (m)) (n)) ((O) )) (nm))) (((((((rewrite_l) ((nat) )) ((O) )) (\lambda j__ : (nat) . (((eq) (Prop)) ((((eq) ((nat) )) (j__)) ((((minus) ) ((((plus) ) ((O) )) (n))) (m)))) ((((eq) ((nat) )) ((O) )) ((((minus) ) (n)) (m))))) (((((((rewrite_l) ((nat) )) (n)) (\lambda j__ : (nat) . (((eq) (Prop)) ((((eq) ((nat) )) ((O) )) ((((minus) ) (j__)) (m)))) ((((eq) ((nat) )) ((O) )) ((((minus) ) (n)) (m))))) (((refl) (Prop)) ((((eq) ((nat) )) ((O) )) ((((minus) ) (n)) (m))))) ((((plus) ) ((O) )) (n))) ((plus_O_n) (n)))) ((((minus) ) ((O) )) ((((minus) ) (m)) (n)))) ((minus_O_n) ((((minus) ) (m)) (n)))))))))) (\lambda nm : ((Not) ) ((((le) ) (n)) (m)). (((((quotient) (q)) ((((minus) ) (n)) (m))) ((((minus) ) ((((div) ) (n)) (q))) ((((div) ) (m)) (q)))) (((((((eq_ind_r) ((nat) )) ((((minus) ) ((((times) ) (q)) ((((div) ) (n)) (q)))) ((((times) ) (q)) ((((div) ) (m)) (q))))) (\lambda x : (nat) . (((eq) ((nat) )) ((((minus) ) (n)) (m))) (x))) (((((((eq_ind_r) ((nat) )) ((((times) ) ((((div) ) (n)) (q))) (q))) (\lambda x : (nat) . (((eq) ((nat) )) ((((minus) ) (n)) (m))) ((((minus) ) (x)) ((((times) ) (q)) ((((div) ) (m)) (q)))))) (((((((eq_ind_r) ((nat) )) ((((times) ) ((((div) ) (m)) (q))) (q))) (\lambda x : (nat) . (((eq) ((nat) )) ((((minus) ) (n)) (m))) ((((minus) ) ((((times) ) ((((div) ) (n)) (q))) (q))) (x)))) (((((((eq_ind_r) ((nat) )) ((((minus) ) (n)) ((((mod) ) (n)) (q)))) (\lambda x : (nat) . (((eq) ((nat) )) ((((minus) ) (n)) (m))) ((((minus) ) (x)) ((((times) ) ((((div) ) (m)) (q))) (q))))) (((((((eq_ind_r) ((nat) )) ((((minus) ) (n)) ((((plus) ) ((((mod) ) (n)) (q))) ((((times) ) ((((div) ) (m)) (q))) (q))))) (\lambda x : (nat) . (((eq) ((nat) )) ((((minus) ) (n)) (m))) (x))) (((((((eq_ind_r) ((nat) )) ((((mod) ) (m)) (q))) (\lambda x : (nat) . (((eq) ((nat) )) ((((minus) ) (n)) (m))) ((((minus) ) (n)) ((((plus) ) (x)) ((((times) ) ((((div) ) (m)) (q))) (q)))))) (((((((eq_ind_r) ((nat) )) ((((plus) ) ((((times) ) ((((div) ) (m)) (q))) (q))) ((((mod) ) (m)) (q)))) (\lambda x : (nat) . (((eq) ((nat) )) ((((minus) ) (n)) (m))) ((((minus) ) (n)) (x)))) (((((((eq_ind) ((nat) )) (m)) (\lambda x_1 : (nat) . (((eq) ((nat) )) ((((minus) ) (n)) (m))) ((((minus) ) (n)) (x_1)))) (((refl) ((nat) )) ((((minus) ) (n)) (m)))) ((((plus) ) ((((times) ) ((((div) ) (m)) (q))) (q))) ((((mod) ) (m)) (q)))) (((div_mod) (m)) (q)))) ((((plus) ) ((((mod) ) (m)) (q))) ((((times) ) ((((div) ) (m)) (q))) (q)))) (((commutative_plus) ((((mod) ) (m)) (q))) ((((times) ) ((((div) ) (m)) (q))) (q))))) ((((mod) ) (n)) (q))) (eqmod))) ((((minus) ) ((((minus) ) (n)) ((((mod) ) (n)) (q)))) ((((times) ) ((((div) ) (m)) (q))) (q)))) ((((minus_plus) (n)) ((((mod) ) (n)) (q))) ((((times) ) ((((div) ) (m)) (q))) (q))))) ((((times) ) ((((div) ) (n)) (q))) (q))) (((((((rewrite_r) ((nat) )) ((((times) ) (q)) ((((div) ) (n)) (q)))) (\lambda j__ : (nat) . (((eq) ((nat) )) (j__)) ((((minus) ) (n)) ((((mod) ) (n)) (q))))) (((((((rewrite_l) ((nat) )) ((((times) ) (q)) ((((div) ) (n)) (q)))) (\lambda j__ : (nat) . (((eq) ((nat) )) ((((times) ) (q)) ((((div) ) (n)) (q)))) (j__))) (((refl) ((nat) )) ((((times) ) (q)) ((((div) ) (n)) (q))))) ((((minus) ) (n)) ((((mod) ) (n)) (q)))) (((((((rewrite_l) ((nat) )) ((((times) ) ((((div) ) (n)) (q))) (q))) (\lambda j__ : (nat) . (((eq) ((nat) )) (j__)) ((((minus) ) (n)) ((((mod) ) (n)) (q))))) (((eq_times_div_minus_mod) (n)) (q))) ((((times) ) (q)) ((((div) ) (n)) (q)))) (((commutative_times) ((((div) ) (n)) (q))) (q))))) ((((times) ) ((((div) ) (n)) (q))) (q))) (((commutative_times) ((((div) ) (n)) (q))) (q))))) ((((times) ) (q)) ((((div) ) (m)) (q)))) (((commutative_times) (q)) ((((div) ) (m)) (q))))) ((((times) ) (q)) ((((div) ) (n)) (q)))) (((commutative_times) (q)) ((((div) ) (n)) (q))))) ((((times) ) (q)) ((((minus) ) ((((div) ) (n)) (q))) ((((div) ) (m)) (q))))) ((((distributive_times_minus) (q)) ((((div) ) (n)) (q))) ((((div) ) (m)) (q)))))))).
definition let_clause_1531 : \forall (n:(nat) ). \forall (m:(nat) ). ((((lt) ) ((O) )) (m)) -> ((((divides) ) (n)) (m)) -> \forall (d:(nat) ). ((((eq) ((nat) )) (m)) ((((times) ) (n)) ((O) ))) -> (((eq) ((nat) )) (m)) ((O) ) := \lambda n : (nat) . \lambda m : (nat) . \lambda posm : (((lt) ) ((O) )) (m). (\lambda j_clearme : (((divides) ) (n)) (m). (\lambda d : (nat) . \lambda eqm : (((eq) ((nat) )) (m)) ((((times) ) (n)) ((O) )). (((((((rewrite_r) ((nat) )) ((((times) ) (n)) ((O) ))) (\lambda j__ : (nat) . (((eq) ((nat) )) (m)) (j__))) (eqm)) ((O) )) ((times_n_O) (n))))).
definition let_clause_15311 : \forall (n:(nat) ). \forall (m:(nat) ). ((((lt) ) ((O) )) (m)) -> ((((divides) ) (n)) (m)) -> \forall (d:(nat) ). \forall (p:(nat) ). ((((eq) ((nat) )) (m)) ((((times) ) (n)) (((S) ) (p)))) -> (((eq) ((nat) )) (m)) ((((plus) ) (n)) ((((times) ) (n)) (p))) := \lambda n : (nat) . \lambda m : (nat) . \lambda posm : (((lt) ) ((O) )) (m). (\lambda j_clearme : (((divides) ) (n)) (m). (\lambda d : (nat) . \lambda p : (nat) . \lambda eqm : (((eq) ((nat) )) (m)) ((((times) ) (n)) (((S) ) (p))). (((((((rewrite_r) ((nat) )) ((((times) ) (n)) (((S) ) (p)))) (\lambda j__ : (nat) . (((eq) ((nat) )) (m)) (j__))) (eqm)) ((((plus) ) (n)) ((((times) ) (n)) (p)))) (((times_n_Sm) (n)) (p))))).
definition divides_to_le : \forall (n:(nat) ). \forall (m:(nat) ). ((((lt) ) ((O) )) (m)) -> ((((divides) ) (n)) (m)) -> (((le) ) (n)) (m) := \lambda n : (nat) . \lambda m : (nat) . \lambda posm : (((lt) ) ((O) )) (m). (\lambda j_clearme : (((divides) ) (n)) (m). ((((((match_divides_prop) (n)) (m)) ((((le) ) (n)) (m))) (\lambda d : (nat) . ((((match_nat_prop) (\lambda j__ : (nat) . ((((eq) ((nat) )) (m)) ((((times) ) (n)) (j__))) -> (((le) ) (n)) (m))) (\lambda eqm : (((eq) ((nat) )) (m)) ((((times) ) (n)) ((O) )). (((falsity) ((((le) ) (n)) (m))) ((((absurd) ((((le) ) (((S) ) (m))) ((O) ))) (((((eq_coerc) ((((le) ) (((S) ) ((O) ))) (m))) ((((le) ) (((S) ) (m))) ((O) ))) (posm)) (((((((rewrite_l) ((nat) )) (m)) (\lambda j__ : (nat) . (((eq) (Prop)) ((((le) ) (((S) ) (j__))) (m))) ((((le) ) (((S) ) (m))) ((O) )))) (((((((rewrite_l) ((nat) )) (m)) (\lambda j__ : (nat) . (((eq) (Prop)) ((((le) ) (((S) ) (m))) (m))) ((((le) ) (((S) ) (m))) (j__)))) (((refl) (Prop)) ((((le) ) (((S) ) (m))) (m)))) ((O) )) (((((((let_clause_1531) (n)) (m)) (posm)) (j_clearme)) (d)) (eqm)))) ((O) )) (((((((let_clause_1531) (n)) (m)) (posm)) (j_clearme)) (d)) (eqm))))) ((not_le_Sn_O) (m)))))) (\lambda p : (nat) . \lambda eqm : (((eq) ((nat) )) (m)) ((((times) ) (n)) (((S) ) (p))). (((((((eq_ind_r) ((nat) )) ((((times) ) (n)) (((S) ) (p)))) (\lambda x : (nat) . (((le) ) (n)) (x))) (((((eq_coerc) ((((le) ) (n)) ((((plus) ) (n)) ((((times) ) (n)) (p))))) ((((le) ) (n)) ((((times) ) (n)) (((S) ) (p))))) (((le_plus_n_r) ((((times) ) (n)) (p))) (n))) (((((((rewrite_l) ((nat) )) ((((plus) ) (n)) ((((times) ) (n)) (p)))) (\lambda j__ : (nat) . (((eq) (Prop)) ((((le) ) (n)) ((((plus) ) (n)) ((((times) ) (n)) (p))))) ((((le) ) (n)) (j__)))) (((((((rewrite_l) ((nat) )) (m)) (\lambda j__ : (nat) . (((eq) (Prop)) ((((le) ) (n)) ((((plus) ) (n)) ((((times) ) (n)) (p))))) ((((le) ) (n)) (j__)))) (((((((rewrite_l) ((nat) )) (m)) (\lambda j__ : (nat) . (((eq) (Prop)) ((((le) ) (n)) (j__))) ((((le) ) (n)) (m)))) (((refl) (Prop)) ((((le) ) (n)) (m)))) ((((plus) ) (n)) ((((times) ) (n)) (p)))) ((((((((let_clause_15311) (n)) (m)) (posm)) (j_clearme)) (d)) (p)) (eqm)))) ((((plus) ) (n)) ((((times) ) (n)) (p)))) ((((((((let_clause_15311) (n)) (m)) (posm)) (j_clearme)) (d)) (p)) (eqm)))) ((((times) ) (n)) (((S) ) (p)))) (((times_n_Sm) (n)) (p))))) (m)) (eqm)))) (d))) (j_clearme))).
definition dividesb : ((nat) ) -> ((nat) ) -> (bool)  := \lambda n : (nat) . \lambda m : (nat) . (((eqb) ) ((((mod) ) (m)) (n))) ((O) ).
definition dividesb_true_to_divides : \forall (n:(nat) ). \forall (m:(nat) ). ((((eq) ((bool) )) ((((dividesb) ) (n)) (m))) ((true) )) -> (((divides) ) (n)) (m) := \lambda n : (nat) . \lambda m : (nat) . ((((((match_Or_prop) ((((lt) ) ((O) )) (n))) ((((eq) ((nat) )) ((O) )) (n))) (((((eq) ((bool) )) ((((dividesb) ) (n)) (m))) ((true) )) -> (((divides) ) (n)) (m))) (\lambda posn : (((lt) ) ((O) )) (n). (\lambda divbnm : (((eq) ((bool) )) ((((dividesb) ) (n)) (m))) ((true) ). (((((mod_O_to_divides) (n)) (m)) (posn)) ((((eqb_true_to_eq) ((((mod) ) (m)) (n))) ((O) )) (divbnm)))))) (\lambda eqnO : (((eq) ((nat) )) ((O) )) (n). (((((((eq_ind) ((nat) )) ((O) )) (\lambda x_1 : (nat) . ((((eq) ((bool) )) ((((dividesb) ) (x_1)) (m))) ((true) )) -> (((divides) ) (x_1)) (m))) ((((((sym_eq_match_nat_type_O) ((nat) )) (m)) (\lambda p : (nat) . ((((mod_aux) ) (m)) (m)) (p))) (\lambda y : (nat) . ((((eq) ((bool) )) ((((eqb) ) (y)) ((O) ))) ((true) )) -> (((divides) ) ((O) )) (m))) (\lambda eqbmO : (((eq) ((bool) )) ((((eqb) ) (m)) ((O) ))) ((true) ). (((((((eq_ind_r) ((nat) )) ((O) )) (\lambda x : (nat) . (((divides) ) ((O) )) (x))) ((divides_n_n) ((O) ))) (m)) ((((eqb_true_to_eq) (m)) ((O) )) (eqbmO)))))) (n)) (eqnO)))) ((((le_to_or_lt_eq) ((O) )) (n)) ((le_O_n) (n))).
definition dividesb_false_to_not_divides : \forall (n:(nat) ). \forall (m:(nat) ). ((((eq) ((bool) )) ((((dividesb) ) (n)) (m))) ((false) )) -> ((Not) ) ((((divides) ) (n)) (m)) := \lambda n : (nat) . \lambda m : (nat) . ((((((match_Or_prop) ((((lt) ) ((O) )) (n))) ((((eq) ((nat) )) ((O) )) (n))) (((((eq) ((bool) )) ((((dividesb) ) (n)) (m))) ((false) )) -> ((Not) ) ((((divides) ) (n)) (m)))) (\lambda posn : (((lt) ) ((O) )) (n). (\lambda ndivbnm : (((eq) ((bool) )) ((((dividesb) ) (n)) (m))) ((false) ). (((((not_to_not) ((((divides) ) (n)) (m))) ((((eq) ((nat) )) ((((mod) ) (m)) (n))) ((O) ))) ((((divides_to_mod_O) (n)) (m)) (posn))) ((((eqb_false_to_not_eq) ((((mod) ) (m)) (n))) ((O) )) (ndivbnm)))))) (\lambda eqnO : (((eq) ((nat) )) ((O) )) (n). (((((((eq_ind) ((nat) )) ((O) )) (\lambda x_1 : (nat) . ((((eq) ((bool) )) ((((dividesb) ) (x_1)) (m))) ((false) )) -> ((Not) ) ((((divides) ) (x_1)) (m)))) ((((((sym_eq_match_nat_type_O) ((nat) )) (m)) (\lambda p : (nat) . ((((mod_aux) ) (m)) (m)) (p))) (\lambda y : (nat) . ((((eq) ((bool) )) ((((eqb) ) (y)) ((O) ))) ((false) )) -> ((Not) ) ((((divides) ) ((O) )) (m)))) (((((nat_case) (m)) (\lambda j__ : (nat) . ((((eq) ((bool) )) ((((eqb) ) (j__)) ((O) ))) ((false) )) -> ((Not) ) ((((divides) ) ((O) )) (j__)))) ((((sym_eq_eqb) ((O) )) (\lambda y : ((nat) ) -> (bool) . ((((eq) ((nat) )) (m)) ((O) )) -> ((((eq) ((bool) )) ((y) ((O) ))) ((false) )) -> ((Not) ) ((((divides) ) ((O) )) ((O) )))) (((((sym_eq_filter_nat_type_O) (((nat) ) -> (bool) )) ((eqb_body) )) (\lambda y : ((nat) ) -> (bool) . ((((eq) ((nat) )) (m)) ((O) )) -> ((((eq) ((bool) )) ((y) ((O) ))) ((false) )) -> ((Not) ) ((((divides) ) ((O) )) ((O) )))) (((sym_eq_eqb_body_O) (\lambda y : ((nat) ) -> (bool) . ((((eq) ((nat) )) (m)) ((O) )) -> ((((eq) ((bool) )) ((y) ((O) ))) ((false) )) -> ((Not) ) ((((divides) ) ((O) )) ((O) )))) ((((((sym_eq_match_nat_type_O) ((bool) )) ((true) )) (\lambda q : (nat) . (false) )) (\lambda y : (bool) . ((((eq) ((nat) )) (m)) ((O) )) -> ((((eq) ((bool) )) (y)) ((false) )) -> ((Not) ) ((((divides) ) ((O) )) ((O) )))) (\lambda auto : (((eq) ((nat) )) (m)) ((O) ). (\lambda auto' : (((eq) ((bool) )) ((true) )) ((false) ). (((((not_to_not) ((((divides) ) ((O) )) ((O) ))) ((((eq) ((bool) )) ((true) )) ((false) ))) (\lambda auto'' : (((divides) ) ((O) )) ((O) ). (((((((rewrite_l) ((bool) )) ((true) )) (\lambda j__ : (bool) . (((eq) ((bool) )) ((true) )) (j__))) (((refl) ((bool) )) ((true) ))) ((false) )) (auto')))) (not_eq_true_false))))))))) (\lambda a : (nat) . \lambda j__ : (((eq) ((nat) )) (m)) (((S) ) (a)). (\lambda j_0 : (((eq) ((bool) )) ((((eqb) ) (((S) ) (a))) ((O) ))) ((false) ). (((nmk) ((((divides) ) ((O) )) (((S) ) (a)))) (\lambda j_clearme : (((divides) ) ((O) )) (((S) ) (a)). ((((((match_divides_prop) ((O) )) (((S) ) (a))) ((False) )) (\lambda q : (nat) . \lambda auto : (((eq) ((nat) )) (((S) ) (a))) ((((times) ) ((O) )) (q)). ((((absurd) ((((eq) ((nat) )) ((O) )) (((S) ) (a)))) (((((((rewrite_r) ((nat) )) (n)) (\lambda j__1 : (nat) . (((eq) ((nat) )) (j__1)) (((S) ) (a)))) (((((((rewrite_l) ((nat) )) (((S) ) (a))) (\lambda j__1 : (nat) . (((eq) ((nat) )) (j__1)) (((S) ) (a)))) (((refl) ((nat) )) (((S) ) (a)))) (n)) (((((((rewrite_l) ((nat) )) ((O) )) (\lambda j__1 : (nat) . (((eq) ((nat) )) (((S) ) (a))) (j__1))) (((((((rewrite_r) ((nat) )) ((((times) ) (q)) ((O) ))) (\lambda j__1 : (nat) . (((eq) ((nat) )) (((S) ) (a))) (j__1))) (((((((rewrite_l) ((nat) )) ((((times) ) ((O) )) (q))) (\lambda j__1 : (nat) . (((eq) ((nat) )) (((S) ) (a))) (j__1))) (auto)) ((((times) ) (q)) ((O) ))) (((commutative_times) ((O) )) (q)))) ((O) )) ((times_n_O) (q)))) (n)) (eqnO)))) ((O) )) (eqnO))) ((not_eq_O_S) (a))))) (j_clearme))))))))) (n)) (eqnO)))) ((((le_to_or_lt_eq) ((O) )) (n)) ((le_O_n) (n))).
definition decidable_divides : \forall (n:(nat) ). \forall (m:(nat) ). ((decidable) ) ((((divides) ) (n)) (m)) := \lambda n : (nat) . \lambda m : (nat) . ((((((match_Or_prop) ((((eq) ((bool) )) ((((dividesb) ) (n)) (m))) ((true) ))) ((((eq) ((bool) )) ((((dividesb) ) (n)) (m))) ((false) ))) (((decidable) ) ((((divides) ) (n)) (m)))) (\lambda auto : (((eq) ((bool) )) ((((dividesb) ) (n)) (m))) ((true) ). ((((or_introl) ((((divides) ) (n)) (m))) (((Not) ) ((((divides) ) (n)) (m)))) ((((dividesb_true_to_divides) (n)) (m)) (((((((rewrite_r) ((bool) )) ((true) )) (\lambda j__ : (bool) . (((eq) ((bool) )) (j__)) ((true) ))) (((refl) ((bool) )) ((true) ))) ((((dividesb) ) (n)) (m))) (auto)))))) (\lambda auto : (((eq) ((bool) )) ((((dividesb) ) (n)) (m))) ((false) ). ((((or_intror) ((((divides) ) (n)) (m))) (((Not) ) ((((divides) ) (n)) (m)))) ((((dividesb_false_to_not_divides) (n)) (m)) (((((((rewrite_r) ((bool) )) ((false) )) (\lambda j__ : (bool) . (((eq) ((bool) )) (j__)) ((false) ))) (((refl) ((bool) )) ((false) ))) ((((dividesb) ) (n)) (m))) (auto)))))) ((true_or_false) ((((dividesb) ) (n)) (m))).
definition divides_to_dividesb_true : \forall (n:(nat) ). \forall (m:(nat) ). ((((lt) ) ((O) )) (n)) -> ((((divides) ) (n)) (m)) -> (((eq) ((bool) )) ((((dividesb) ) (n)) (m))) ((true) ) := \lambda n : (nat) . \lambda m : (nat) . \lambda posn : (((lt) ) ((O) )) (n). (\lambda divnm : (((divides) ) (n)) (m). (((((((match_Or_prop) ((((eq) ((bool) )) ((((dividesb) ) (n)) (m))) ((true) ))) ((((eq) ((bool) )) ((((dividesb) ) (n)) (m))) ((false) ))) ((((eq) ((bool) )) ((((dividesb) ) (n)) (m))) ((true) ))) (\lambda auto : (((eq) ((bool) )) ((((dividesb) ) (n)) (m))) ((true) ). (((((((rewrite_r) ((bool) )) ((true) )) (\lambda j__ : (bool) . (((eq) ((bool) )) (j__)) ((true) ))) (((refl) ((bool) )) ((true) ))) ((((dividesb) ) (n)) (m))) (auto)))) (\lambda ndivbnm : (((eq) ((bool) )) ((((dividesb) ) (n)) (m))) ((false) ). (((falsity) ((((eq) ((bool) )) ((((dividesb) ) (n)) (m))) ((true) ))) ((((absurd) ((((divides) ) (n)) (m))) (divnm)) ((((dividesb_false_to_not_divides) (n)) (m)) (((((((rewrite_r) ((bool) )) ((false) )) (\lambda j__ : (bool) . (((eq) ((bool) )) (j__)) ((false) ))) (((refl) ((bool) )) ((false) ))) ((((dividesb) ) (n)) (m))) (ndivbnm))))))) ((true_or_false) ((((dividesb) ) (n)) (m))))).
definition not_divides_to_dividesb_false : \forall (n:(nat) ). \forall (m:(nat) ). ((((lt) ) ((O) )) (n)) -> (((Not) ) ((((divides) ) (n)) (m))) -> (((eq) ((bool) )) ((((dividesb) ) (n)) (m))) ((false) ) := \lambda n : (nat) . \lambda m : (nat) . \lambda posn : (((lt) ) ((O) )) (n). (((((((match_Or_prop) ((((eq) ((bool) )) ((((dividesb) ) (n)) (m))) ((true) ))) ((((eq) ((bool) )) ((((dividesb) ) (n)) (m))) ((false) ))) ((((Not) ) ((((divides) ) (n)) (m))) -> (((eq) ((bool) )) ((((dividesb) ) (n)) (m))) ((false) ))) (\lambda divbnm : (((eq) ((bool) )) ((((dividesb) ) (n)) (m))) ((true) ). (\lambda ndivnm : ((Not) ) ((((divides) ) (n)) (m)). (((falsity) ((((eq) ((bool) )) ((((dividesb) ) (n)) (m))) ((false) ))) ((((absurd) ((((divides) ) (n)) (m))) ((((dividesb_true_to_divides) (n)) (m)) (((((((rewrite_r) ((bool) )) ((true) )) (\lambda j__ : (bool) . (((eq) ((bool) )) (j__)) ((true) ))) (((refl) ((bool) )) ((true) ))) ((((dividesb) ) (n)) (m))) (divbnm)))) (ndivnm)))))) (\lambda auto : (((eq) ((bool) )) ((((dividesb) ) (n)) (m))) ((false) ). (\lambda auto' : ((Not) ) ((((divides) ) (n)) (m)). (((((((rewrite_r) ((bool) )) ((false) )) (\lambda j__ : (bool) . (((eq) ((bool) )) (j__)) ((false) ))) (((refl) ((bool) )) ((false) ))) ((((dividesb) ) (n)) (m))) (auto))))) ((true_or_false) ((((dividesb) ) (n)) (m)))).
definition prime : ((nat) ) -> Prop := \lambda n : (nat) . (((And) ) ((((lt) ) (((S) ) ((O) ))) (n))) (\forall (m:(nat) ). ((((divides) ) (m)) (n)) -> ((((lt) ) (((S) ) ((O) ))) (m)) -> (((eq) ((nat) )) (m)) (n)).
definition prime_to_lt_O : \forall (p:(nat) ). (((prime) ) (p)) -> (((lt) ) ((O) )) (p) := \lambda p : (nat) . \lambda j_clearme : ((prime) ) (p). ((((((match_And_prop) ((((lt) ) (((S) ) ((O) ))) (p))) (\forall (m:(nat) ). ((((divides) ) (m)) (p)) -> ((((lt) ) (((S) ) ((O) ))) (m)) -> (((eq) ((nat) )) (m)) (p))) ((((lt) ) ((O) )) (p))) (\lambda lt1p : (((lt) ) (((S) ) ((O) ))) (p). (\lambda auto : \forall (m:(nat) ). ((((divides) ) (m)) (p)) -> ((((lt) ) (((S) ) ((O) ))) (m)) -> (((eq) ((nat) )) (m)) (p). ((((lt_S_to_lt) ((O) )) (p)) (lt1p))))) (j_clearme)).
definition prime_to_lt_SO : \forall (p:(nat) ). (((prime) ) (p)) -> (((lt) ) (((S) ) ((O) ))) (p) := \lambda p : (nat) . \lambda j_clearme : ((prime) ) (p). ((((((match_And_prop) ((((lt) ) (((S) ) ((O) ))) (p))) (\forall (m:(nat) ). ((((divides) ) (m)) (p)) -> ((((lt) ) (((S) ) ((O) ))) (m)) -> (((eq) ((nat) )) (m)) (p))) ((((lt) ) (((S) ) ((O) ))) (p))) (\lambda lt1p : (((lt) ) (((S) ) ((O) ))) (p). (\lambda auto : \forall (m:(nat) ). ((((divides) ) (m)) (p)) -> ((((lt) ) (((S) ) ((O) ))) (m)) -> (((eq) ((nat) )) (m)) (p). (lt1p)))) (j_clearme)).
