#NAME gcd.

gcd_aux :
  sttfa.etap 
    (sttfa.p 
       (sttfa.arrow nat.nat 
          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))).

gcd_aux_body :
  sttfa.etap 
    (sttfa.p 
       (sttfa.arrow nat.nat 
          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))).

eq_gcd_aux :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
          (gcd.gcd_aux p) 
          (nat.filter_nat_type 
             (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
             gcd.gcd_aux_body p))).

def sym_eq_gcd_aux :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
          (nat.filter_nat_type 
             (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
             gcd.gcd_aux_body p) (gcd.gcd_aux p)))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  sttfa.sym_leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
    (gcd.gcd_aux p) 
    (nat.filter_nat_type (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
       gcd.gcd_aux_body p) (gcd.eq_gcd_aux p).

eq_gcd_aux_body_O :
  sttfa.eps 
    (sttfa.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
       (gcd.gcd_aux_body nat.O) 
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        n:(sttfa.etap (sttfa.p nat.nat)) => m)).

def sym_eq_gcd_aux_body_O :
  sttfa.eps 
    (sttfa.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        n:(sttfa.etap (sttfa.p nat.nat)) => m) (gcd.gcd_aux_body nat.O))
  :=
  sttfa.sym_leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
    (gcd.gcd_aux_body nat.O) 
    (m:(sttfa.etap (sttfa.p nat.nat)) =>
     n:(sttfa.etap (sttfa.p nat.nat)) => m) gcd.eq_gcd_aux_body_O.

eq_gcd_aux_body_S :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
          (gcd.gcd_aux_body (nat.S p)) 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           n:(sttfa.etap (sttfa.p nat.nat)) =>
           bool.match_bool_type nat.nat n 
             (gcd.gcd_aux p n (div_mod.mod m n)) (primes.dividesb n m)))).

def sym_eq_gcd_aux_body_S :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           n:(sttfa.etap (sttfa.p nat.nat)) =>
           bool.match_bool_type nat.nat n 
             (gcd.gcd_aux p n (div_mod.mod m n)) (primes.dividesb n m)) 
          (gcd.gcd_aux_body (nat.S p))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  sttfa.sym_leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
    (gcd.gcd_aux_body (nat.S p)) 
    (m:(sttfa.etap (sttfa.p nat.nat)) =>
     n:(sttfa.etap (sttfa.p nat.nat)) =>
     bool.match_bool_type nat.nat n (gcd.gcd_aux p n (div_mod.mod m n)) 
       (primes.dividesb n m)) (gcd.eq_gcd_aux_body_S p).

def gcd :
  sttfa.etap (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  bool.match_bool_type nat.nat (gcd.gcd_aux n m n) (gcd.gcd_aux m n m) 
    (nat.leb n m).

def commutative_gcd :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat (gcd.gcd n m) (gcd.gcd m n))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.leb_elim n m 
    (__:(sttfa.etap (sttfa.p bool.bool)) =>
     logic.eq nat.nat 
       (bool.match_bool_type nat.nat (gcd.gcd_aux n m n) (gcd.gcd_aux m n m) 
          __) 
       (bool.match_bool_type nat.nat (gcd.gcd_aux m n m) (gcd.gcd_aux n m n) 
          (nat.leb m n))) 
    (lenm:(sttfa.eps (nat.le n m)) =>
     logic.match_Or_prop (nat.lt n m) (logic.eq nat.nat n m) 
       (logic.eq nat.nat 
          (bool.match_bool_type nat.nat (gcd.gcd_aux n m n) 
             (gcd.gcd_aux m n m) bool.true) 
          (bool.match_bool_type nat.nat (gcd.gcd_aux m n m) 
             (gcd.gcd_aux n m n) (nat.leb m n))) 
       (ltnm:(sttfa.eps (nat.lt n m)) =>
        logic.eq_ind_r bool.bool bool.false 
          (x:(sttfa.etap (sttfa.p bool.bool)) =>
           logic.eq nat.nat 
             (bool.match_bool_type nat.nat (gcd.gcd_aux n m n) 
                (gcd.gcd_aux m n m) bool.true) 
             (bool.match_bool_type nat.nat (gcd.gcd_aux m n m) 
                (gcd.gcd_aux n m n) x)) 
          (bool.sym_eq_match_bool_type_false nat.nat (gcd.gcd_aux m n m) 
             (gcd.gcd_aux n m n) 
             (y:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat 
                (bool.match_bool_type nat.nat (gcd.gcd_aux n m n) 
                   (gcd.gcd_aux m n m) bool.true) y) 
             (bool.eq_match_bool_type_true nat.nat (gcd.gcd_aux n m n) 
                (gcd.gcd_aux m n m) 
                (y:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat 
                   (bool.match_bool_type nat.nat (gcd.gcd_aux n m n) 
                      (gcd.gcd_aux m n m) bool.true) y) 
                (logic.refl nat.nat 
                   (bool.match_bool_type nat.nat (gcd.gcd_aux n m n) 
                      (gcd.gcd_aux m n m) bool.true)))) (nat.leb m n) 
          (nat.not_le_to_leb_false m n (nat.lt_to_not_le n m ltnm))) 
       (eqnm:(sttfa.eps (logic.eq nat.nat n m)) =>
        logic.eq_ind_r nat.nat m 
          (x:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat 
             (bool.match_bool_type nat.nat (gcd.gcd_aux x m x) 
                (gcd.gcd_aux m x m) bool.true) 
             (bool.match_bool_type nat.nat (gcd.gcd_aux m x m) 
                (gcd.gcd_aux x m x) (nat.leb m x))) 
          (bool.match_bool_prop 
             (__:(sttfa.etap (sttfa.p bool.bool)) =>
              logic.eq nat.nat 
                (bool.match_bool_type nat.nat (gcd.gcd_aux m m m) 
                   (gcd.gcd_aux m m m) bool.true) 
                (bool.match_bool_type nat.nat (gcd.gcd_aux m m m) 
                   (gcd.gcd_aux m m m) __)) 
             (logic.refl nat.nat 
                (bool.match_bool_type nat.nat (gcd.gcd_aux m m m) 
                   (gcd.gcd_aux m m m) bool.true)) 
             (bool.sym_eq_match_bool_type_false nat.nat (gcd.gcd_aux m m m) 
                (gcd.gcd_aux m m m) 
                (y:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat 
                   (bool.match_bool_type nat.nat (gcd.gcd_aux m m m) 
                      (gcd.gcd_aux m m m) bool.true) y) 
                (bool.eq_match_bool_type_true nat.nat (gcd.gcd_aux m m m) 
                   (gcd.gcd_aux m m m) 
                   (y:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat 
                      (bool.match_bool_type nat.nat (gcd.gcd_aux m m m) 
                         (gcd.gcd_aux m m m) bool.true) y) 
                   (logic.refl nat.nat 
                      (bool.match_bool_type nat.nat (gcd.gcd_aux m m m) 
                         (gcd.gcd_aux m m m) bool.true)))) (nat.leb m m)) n 
          eqnm) (nat.le_to_or_lt_eq n m lenm)) 
    (notlenm:(sttfa.eps (connectives.Not (nat.le n m))) =>
     logic.eq_ind_r bool.bool bool.true 
       (x:(sttfa.etap (sttfa.p bool.bool)) =>
        logic.eq nat.nat 
          (bool.match_bool_type nat.nat (gcd.gcd_aux n m n) 
             (gcd.gcd_aux m n m) bool.false) 
          (bool.match_bool_type nat.nat (gcd.gcd_aux m n m) 
             (gcd.gcd_aux n m n) x)) 
       (bool.sym_eq_match_bool_type_false nat.nat (gcd.gcd_aux n m n) 
          (gcd.gcd_aux m n m) 
          (y:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat y 
             (bool.match_bool_type nat.nat (gcd.gcd_aux m n m) 
                (gcd.gcd_aux n m n) bool.true)) 
          (bool.sym_eq_match_bool_type_true nat.nat (gcd.gcd_aux m n m) 
             (gcd.gcd_aux n m n) 
             (y:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat (gcd.gcd_aux m n m) y) 
             (bool.eq_match_bool_type_false nat.nat (gcd.gcd_aux n m n) 
                (gcd.gcd_aux m n m) 
                (y:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat (gcd.gcd_aux m n m) y) 
                (bool.eq_match_bool_type_false nat.nat (gcd.gcd_aux n m n) 
                   (gcd.gcd_aux m n m) 
                   (y:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat y 
                      (bool.match_bool_type nat.nat (gcd.gcd_aux n m n) 
                         (gcd.gcd_aux m n m) bool.false)) 
                   (logic.refl nat.nat 
                      (bool.match_bool_type nat.nat (gcd.gcd_aux n m n) 
                         (gcd.gcd_aux m n m) bool.false)))))) (nat.leb m n) 
       (nat.le_to_leb_true m n 
          (nat.transitive_le m (nat.S m) n (nat.le_n_Sn m) 
             (nat.not_le_to_lt n m notlenm)))).

def gcd_O_l :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat (gcd.gcd nat.O m) m))
  :=
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  bool.eq_match_bool_type_true nat.nat m (gcd.gcd_aux m nat.O m) 
    (y:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat (gcd.gcd nat.O m) y) 
    (nat.eq_leb_body_O 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
        logic.eq nat.nat (gcd.gcd nat.O m) 
          (bool.match_bool_type nat.nat m (gcd.gcd_aux m nat.O m) (y m))) 
       (nat.eq_filter_nat_type_O (sttfa.arrow nat.nat bool.bool) 
          nat.leb_body 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
           logic.eq nat.nat (gcd.gcd nat.O m) 
             (bool.match_bool_type nat.nat m (gcd.gcd_aux m nat.O m) (y m))) 
          (nat.eq_leb nat.O 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
              logic.eq nat.nat (gcd.gcd nat.O m) 
                (bool.match_bool_type nat.nat m (gcd.gcd_aux m nat.O m) (y m))) 
             (gcd.eq_gcd_aux_body_O 
                (y:
                 (sttfa.etap 
                    (sttfa.p 
                       (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
                 logic.eq nat.nat (gcd.gcd nat.O m) 
                   (bool.match_bool_type nat.nat (y m nat.O) 
                      (gcd.gcd_aux m nat.O m) (nat.leb nat.O m))) 
                (nat.eq_filter_nat_type_O 
                   (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
                   gcd.gcd_aux_body 
                   (y:
                    (sttfa.etap 
                       (sttfa.p 
                          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
                    logic.eq nat.nat (gcd.gcd nat.O m) 
                      (bool.match_bool_type nat.nat (y m nat.O) 
                         (gcd.gcd_aux m nat.O m) (nat.leb nat.O m))) 
                   (gcd.eq_gcd_aux nat.O 
                      (y:
                       (sttfa.etap 
                          (sttfa.p 
                             (sttfa.arrow nat.nat 
                                (sttfa.arrow nat.nat nat.nat)))) =>
                       logic.eq nat.nat (gcd.gcd nat.O m) 
                         (bool.match_bool_type nat.nat (y m nat.O) 
                            (gcd.gcd_aux m nat.O m) (nat.leb nat.O m))) 
                      (logic.refl nat.nat (gcd.gcd nat.O m)))))))).

def divides_mod_to_divides :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (n:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.lt nat.O n) 
                (sttfa.impl (primes.divides p (div_mod.mod m n)) 
                   (sttfa.impl (primes.divides p n) (primes.divides p m)))))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  posn:(sttfa.eps (nat.lt nat.O n)) =>
  _clearme:(sttfa.eps (primes.divides p (div_mod.mod m n))) =>
  primes.match_divides_prop p (div_mod.mod m n) 
    (sttfa.impl (primes.divides p n) (primes.divides p m)) 
    (q1:(sttfa.etap (sttfa.p nat.nat)) =>
     eq1:(sttfa.eps (logic.eq nat.nat (div_mod.mod m n) (nat.times p q1))) =>
     _clearme0:(sttfa.eps (primes.divides p n)) =>
     primes.match_divides_prop p n (primes.divides p m) 
       (q2:(sttfa.etap (sttfa.p nat.nat)) =>
        eq2:(sttfa.eps (logic.eq nat.nat n (nat.times p q2))) =>
        primes.quotient p m (nat.plus (nat.times q2 (div_mod.div m n)) q1) 
          (logic.eq_ind_r nat.nat 
             (nat.plus (nat.times p (nat.times q2 (div_mod.div m n))) 
                (nat.times p q1)) 
             (x:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat m x) 
             (logic.eq_ind nat.nat (div_mod.mod m n) 
                (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat m 
                   (nat.plus (nat.times p (nat.times q2 (div_mod.div m n))) 
                      x_1)) 
                (logic.eq_ind nat.nat 
                   (nat.times (nat.times p q2) (div_mod.div m n)) 
                   (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat m (nat.plus x_1 (div_mod.mod m n))) 
                   (logic.eq_ind nat.nat n 
                      (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat m 
                         (nat.plus (nat.times x_1 (div_mod.div m n)) 
                            (div_mod.mod m n))) 
                      (logic.rewrite_r nat.nat 
                         (nat.plus (div_mod.mod m n) 
                            (nat.times n (div_mod.div m n))) 
                         (__:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat m __) 
                         (logic.rewrite_l nat.nat m 
                            (__:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq nat.nat m __) (logic.refl nat.nat m) 
                            (nat.plus (div_mod.mod m n) 
                               (nat.times n (div_mod.div m n))) 
                            (logic.rewrite_l nat.nat 
                               (nat.plus (nat.times n (div_mod.div m n)) 
                                  (div_mod.mod m n)) 
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq nat.nat m __) 
                               (logic.rewrite_l nat.nat 
                                  (nat.times (div_mod.div m n) n) 
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq nat.nat m 
                                     (nat.plus __ (div_mod.mod m n))) 
                                  (div_mod.div_mod m n) 
                                  (nat.times n (div_mod.div m n)) 
                                  (nat.commutative_times (div_mod.div m n) n)) 
                               (nat.plus (div_mod.mod m n) 
                                  (nat.times n (div_mod.div m n))) 
                               (nat.commutative_plus 
                                  (nat.times n (div_mod.div m n)) 
                                  (div_mod.mod m n)))) 
                         (nat.plus (nat.times n (div_mod.div m n)) 
                            (div_mod.mod m n)) 
                         (nat.commutative_plus 
                            (nat.times n (div_mod.div m n)) (div_mod.mod m n))) 
                      (nat.times p q2) eq2) 
                   (nat.times p (nat.times q2 (div_mod.div m n))) 
                   (nat.associative_times p q2 (div_mod.div m n))) 
                (nat.times p q1) eq1) 
             (nat.times p (nat.plus (nat.times q2 (div_mod.div m n)) q1)) 
             (nat.distributive_times_plus p (nat.times q2 (div_mod.div m n)) 
                q1))) _clearme0) _clearme.

def divides_to_gcd_aux :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (n:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.lt nat.O p) 
                (sttfa.impl (nat.lt nat.O n) 
                   (sttfa.impl (primes.divides n m) 
                      (logic.eq nat.nat (gcd.gcd_aux p m n) n)))))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  posp:(sttfa.eps (nat.lt nat.O p)) =>
  nat.lt_O_n_elim p posp 
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.impl (nat.lt nat.O n) 
       (sttfa.impl (primes.divides n m) 
          (logic.eq nat.nat (gcd.gcd_aux __ m n) n))) 
    (l:(sttfa.etap (sttfa.p nat.nat)) =>
     gcd.sym_eq_gcd_aux (nat.S l) 
       (y:
        (sttfa.etap 
           (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
        sttfa.impl (nat.lt nat.O n) 
          (sttfa.impl (primes.divides n m) (logic.eq nat.nat (y m n) n))) 
       (nat.sym_eq_filter_nat_type_S 
          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
          gcd.gcd_aux_body l 
          (y:
           (sttfa.etap 
              (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
           sttfa.impl (nat.lt nat.O n) 
             (sttfa.impl (primes.divides n m) (logic.eq nat.nat (y m n) n))) 
          (gcd.sym_eq_gcd_aux_body_S l 
             (y:
              (sttfa.etap 
                 (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
              sttfa.impl (nat.lt nat.O n) 
                (sttfa.impl (primes.divides n m) (logic.eq nat.nat (y m n) n))) 
             (posn:(sttfa.eps (nat.lt nat.O n)) =>
              divnm:(sttfa.eps (primes.divides n m)) =>
              logic.eq_ind_r bool.bool bool.true 
                (x:(sttfa.etap (sttfa.p bool.bool)) =>
                 logic.eq nat.nat 
                   (bool.match_bool_type nat.nat n 
                      (gcd.gcd_aux l n (div_mod.mod m n)) x) n) 
                (bool.sym_eq_match_bool_type_true nat.nat n 
                   (gcd.gcd_aux l n 
                      (nat.match_nat_type nat.nat m 
                         (p0:(sttfa.etap (sttfa.p nat.nat)) =>
                          div_mod.mod_aux m m p0) n)) 
                   (y:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat y n) 
                   (logic.refl nat.nat n)) (primes.dividesb n m) 
                (primes.divides_to_dividesb_true n m posn divnm))))).

def not_divides_to_gcd_aux :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (n:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.lt nat.O n) 
                (sttfa.impl (connectives.Not (primes.divides n m)) 
                   (logic.eq nat.nat (gcd.gcd_aux (nat.S p) m n) 
                      (gcd.gcd_aux p n (div_mod.mod m n))))))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  gcd.sym_eq_gcd_aux (nat.S p) 
    (y:
     (sttfa.etap 
        (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
     sttfa.impl (nat.lt nat.O n) 
       (sttfa.impl (connectives.Not (primes.divides n m)) 
          (logic.eq nat.nat (y m n) (gcd.gcd_aux p n (div_mod.mod m n))))) 
    (nat.sym_eq_filter_nat_type_S 
       (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) gcd.gcd_aux_body 
       p 
       (y:
        (sttfa.etap 
           (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
        sttfa.impl (nat.lt nat.O n) 
          (sttfa.impl (connectives.Not (primes.divides n m)) 
             (logic.eq nat.nat (y m n) (gcd.gcd_aux p n (div_mod.mod m n))))) 
       (gcd.sym_eq_gcd_aux_body_S p 
          (y:
           (sttfa.etap 
              (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
           sttfa.impl (nat.lt nat.O n) 
             (sttfa.impl (connectives.Not (primes.divides n m)) 
                (logic.eq nat.nat (y m n) (gcd.gcd_aux p n (div_mod.mod m n))))) 
          (lenm:(sttfa.eps (nat.lt nat.O n)) =>
           divnm:(sttfa.eps (connectives.Not (primes.divides n m))) =>
           logic.eq_ind_r bool.bool bool.false 
             (x:(sttfa.etap (sttfa.p bool.bool)) =>
              logic.eq nat.nat 
                (bool.match_bool_type nat.nat n 
                   (gcd.gcd_aux p n (div_mod.mod m n)) x) 
                (gcd.gcd_aux p n (div_mod.mod m n))) 
             (bool.sym_eq_match_bool_type_false nat.nat n 
                (gcd.gcd_aux p n 
                   (nat.match_nat_type nat.nat m 
                      (p0:(sttfa.etap (sttfa.p nat.nat)) =>
                       div_mod.mod_aux m m p0) n)) 
                (y:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat y 
                   (gcd.gcd_aux p n 
                      (nat.match_nat_type nat.nat m 
                         (p0:(sttfa.etap (sttfa.p nat.nat)) =>
                          div_mod.mod_aux m m p0) n))) 
                (logic.refl nat.nat 
                   (gcd.gcd_aux p n 
                      (nat.match_nat_type nat.nat m 
                         (p0:(sttfa.etap (sttfa.p nat.nat)) =>
                          div_mod.mod_aux m m p0) n)))) 
             (primes.dividesb n m) 
             (primes.not_divides_to_dividesb_false n m lenm divnm)))).

def divides_gcd_aux_mn :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (n:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.lt nat.O n) 
                (sttfa.impl (nat.le n m) 
                   (sttfa.impl (nat.le n p) 
                      (connectives.And 
                         (primes.divides (gcd.gcd_aux p m n) m) 
                         (primes.divides (gcd.gcd_aux p m n) n))))))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind 
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.forall nat.nat 
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.lt nat.O n) 
             (sttfa.impl (nat.le n m) 
                (sttfa.impl (nat.le n _x_365) 
                   (connectives.And 
                      (primes.divides (gcd.gcd_aux _x_365 m n) m) 
                      (primes.divides (gcd.gcd_aux _x_365 m n) n))))))) 
    (m:(sttfa.etap (sttfa.p nat.nat)) =>
     n:(sttfa.etap (sttfa.p nat.nat)) =>
     posn:(sttfa.eps (nat.lt nat.O n)) =>
     lenm:(sttfa.eps (nat.le n m)) =>
     lenO:(sttfa.eps (nat.le n nat.O)) =>
     logic.falsity 
       (connectives.And (primes.divides (gcd.gcd_aux nat.O m n) m) 
          (primes.divides (gcd.gcd_aux nat.O m n) n)) 
       (logic.absurd (nat.lt nat.O n) posn (nat.le_to_not_lt n nat.O lenO))) 
    (q:(sttfa.etap (sttfa.p nat.nat)) =>
     Hind:
     (sttfa.eps 
        (sttfa.forall nat.nat 
           (m:(sttfa.etap (sttfa.p nat.nat)) =>
            sttfa.forall nat.nat 
              (n:(sttfa.etap (sttfa.p nat.nat)) =>
               sttfa.impl (nat.lt nat.O n) 
                 (sttfa.impl (nat.le n m) 
                    (sttfa.impl (nat.le n q) 
                       (connectives.And 
                          (primes.divides (gcd.gcd_aux q m n) m) 
                          (primes.divides (gcd.gcd_aux q m n) n)))))))) =>
     m:(sttfa.etap (sttfa.p nat.nat)) =>
     n:(sttfa.etap (sttfa.p nat.nat)) =>
     posn:(sttfa.eps (nat.lt nat.O n)) =>
     lenm:(sttfa.eps (nat.le n m)) =>
     lenS:(sttfa.eps (nat.le n (nat.S q))) =>
     logic.match_Or_prop (primes.divides n m) 
       (connectives.Not (primes.divides n m)) 
       (connectives.And (primes.divides (gcd.gcd_aux (nat.S q) m n) m) 
          (primes.divides (gcd.gcd_aux (nat.S q) m n) n)) 
       (divnm:(sttfa.eps (primes.divides n m)) =>
        logic.eq_ind_r nat.nat n 
          (x:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.And (primes.divides x m) (primes.divides x n)) 
          (z:(sttfa.etap (sttfa.p sttfa.bool)) =>
           f:
           (sttfa.eps 
              (sttfa.impl (primes.divides n m) 
                 (sttfa.impl (primes.divides n n) z))) =>
           f divnm (primes.divides_n_n n)) (gcd.gcd_aux (nat.S q) m n) 
          (gcd.divides_to_gcd_aux (nat.S q) m n (nat.lt_O_S q) posn divnm)) 
       (ndivnm:(sttfa.eps (connectives.Not (primes.divides n m))) =>
        logic.eq_ind_r nat.nat (gcd.gcd_aux q n (div_mod.mod m n)) 
          (x:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.And (primes.divides x m) (primes.divides x n)) 
          (logic.match_And_prop 
             (primes.divides (gcd.gcd_aux q n (div_mod.mod m n)) n) 
             (primes.divides (gcd.gcd_aux q n (div_mod.mod m n)) 
                (div_mod.mod m n)) 
             (connectives.And 
                (primes.divides (gcd.gcd_aux q n (div_mod.mod m n)) m) 
                (primes.divides (gcd.gcd_aux q n (div_mod.mod m n)) n)) 
             (H:
              (sttfa.eps 
                 (primes.divides (gcd.gcd_aux q n (div_mod.mod m n)) n)) =>
              H1:
              (sttfa.eps 
                 (primes.divides (gcd.gcd_aux q n (div_mod.mod m n)) 
                    (div_mod.mod m n))) =>
              z:(sttfa.etap (sttfa.p sttfa.bool)) =>
              f:
              (sttfa.eps 
                 (sttfa.impl 
                    (primes.divides (gcd.gcd_aux q n (div_mod.mod m n)) m) 
                    (sttfa.impl 
                       (primes.divides (gcd.gcd_aux q n (div_mod.mod m n)) n) 
                       z))) =>
              f 
                (gcd.divides_mod_to_divides 
                   (gcd.gcd_aux q n (div_mod.mod m n)) m n posn H1 H) H) 
             (Hind n (div_mod.mod m n) 
                (logic.match_Or_prop (nat.lt nat.O (div_mod.mod m n)) 
                   (logic.eq nat.nat nat.O (div_mod.mod m n)) 
                   (nat.lt nat.O (div_mod.mod m n)) 
                   (auto:(sttfa.eps (nat.lt nat.O (div_mod.mod m n))) => auto) 
                   (modO:
                    (sttfa.eps (logic.eq nat.nat nat.O (div_mod.mod m n))) =>
                    logic.falsity (nat.lt nat.O (div_mod.mod m n)) 
                      (logic.absurd (primes.divides n m) 
                         (primes.mod_O_to_divides n m posn 
                            (logic.rewrite_l nat.nat nat.O 
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq nat.nat __ nat.O) 
                               (logic.refl nat.nat nat.O) (div_mod.mod m n) 
                               modO)) ndivnm)) 
                   (nat.le_to_or_lt_eq nat.O (div_mod.mod m n) 
                      (nat.le_O_n (div_mod.mod m n)))) 
                (nat.lt_to_le (div_mod.mod m n) n 
                   (div_mod.lt_mod_m_m m n posn)) 
                (nat.le_S_S_to_le (div_mod.mod m n) q 
                   (nat.transitive_le (nat.S (div_mod.mod m n)) n (nat.S q) 
                      (div_mod.lt_mod_m_m m n posn) lenS)))) 
          (gcd.gcd_aux (nat.S q) m n) 
          (gcd.not_divides_to_gcd_aux q m n posn ndivnm)) 
       (primes.decidable_divides n m)) p.

def divides_gcd_nm :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.And (primes.divides (gcd.gcd n m) m) 
             (primes.divides (gcd.gcd n m) n))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.match_Or_prop (nat.lt nat.O n) (logic.eq nat.nat nat.O n) 
    (connectives.And (primes.divides (gcd.gcd n m) m) 
       (primes.divides (gcd.gcd n m) n)) 
    (posn:(sttfa.eps (nat.lt nat.O n)) =>
     logic.match_Or_prop (nat.lt nat.O m) (logic.eq nat.nat nat.O m) 
       (connectives.And (primes.divides (gcd.gcd n m) m) 
          (primes.divides (gcd.gcd n m) n)) 
       (posm:(sttfa.eps (nat.lt nat.O m)) =>
        nat.leb_elim n m 
          (__:(sttfa.etap (sttfa.p bool.bool)) =>
           connectives.And 
             (primes.divides 
                (bool.match_bool_type nat.nat (gcd.gcd_aux n m n) 
                   (gcd.gcd_aux m n m) __) m) 
             (primes.divides 
                (bool.match_bool_type nat.nat (gcd.gcd_aux n m n) 
                   (gcd.gcd_aux m n m) __) n)) 
          (bool.sym_eq_match_bool_type_true nat.nat (gcd.gcd_aux n m n) 
             (gcd.gcd_aux m n m) 
             (y:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.le n m) 
                (connectives.And 
                   (primes.divides 
                      (bool.match_bool_type nat.nat (gcd.gcd_aux n m n) 
                         (gcd.gcd_aux m n m) bool.true) m) 
                   (primes.divides y n))) 
             (bool.sym_eq_match_bool_type_true nat.nat (gcd.gcd_aux n m n) 
                (gcd.gcd_aux m n m) 
                (y:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (nat.le n m) 
                   (connectives.And (primes.divides y m) 
                      (primes.divides (gcd.gcd_aux n m n) n))) 
                (lenm:(sttfa.eps (nat.le n m)) =>
                 gcd.divides_gcd_aux_mn n m n posn lenm (nat.le_n n)))) 
          (bool.sym_eq_match_bool_type_false nat.nat (gcd.gcd_aux n m n) 
             (gcd.gcd_aux m n m) 
             (y:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (connectives.Not (nat.le n m)) 
                (connectives.And 
                   (primes.divides 
                      (bool.match_bool_type nat.nat (gcd.gcd_aux n m n) 
                         (gcd.gcd_aux m n m) bool.false) m) 
                   (primes.divides y n))) 
             (bool.sym_eq_match_bool_type_false nat.nat (gcd.gcd_aux n m n) 
                (gcd.gcd_aux m n m) 
                (y:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (connectives.Not (nat.le n m)) 
                   (connectives.And (primes.divides y m) 
                      (primes.divides (gcd.gcd_aux m n m) n))) 
                (notlt:(sttfa.eps (connectives.Not (nat.le n m))) =>
                 logic.match_And_prop (primes.divides (gcd.gcd_aux m n m) n) 
                   (primes.divides (gcd.gcd_aux m n m) m) 
                   (connectives.And (primes.divides (gcd.gcd_aux m n m) m) 
                      (primes.divides (gcd.gcd_aux m n m) n)) 
                   (auto:
                    (sttfa.eps (primes.divides (gcd.gcd_aux m n m) n)) =>
                    auto':
                    (sttfa.eps (primes.divides (gcd.gcd_aux m n m) m)) =>
                    z:(sttfa.etap (sttfa.p sttfa.bool)) =>
                    f:
                    (sttfa.eps 
                       (sttfa.impl (primes.divides (gcd.gcd_aux m n m) m) 
                          (sttfa.impl (primes.divides (gcd.gcd_aux m n m) n) 
                             z))) =>
                    f auto' auto) 
                   (gcd.divides_gcd_aux_mn m n m posm 
                      (nat.transitive_le m (nat.S m) n (nat.le_n_Sn m) 
                         (nat.not_le_to_lt n m notlt)) (nat.le_n m)))))) 
       (eqmO:(sttfa.eps (logic.eq nat.nat nat.O m)) =>
        logic.eq_ind nat.nat nat.O 
          (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.And (primes.divides (gcd.gcd n x_1) x_1) 
             (primes.divides (gcd.gcd n x_1) n)) 
          (z:(sttfa.etap (sttfa.p sttfa.bool)) =>
           f:
           (sttfa.eps 
              (sttfa.impl (primes.divides (gcd.gcd n nat.O) nat.O) 
                 (sttfa.impl (primes.divides (gcd.gcd n nat.O) n) z))) =>
           f (primes.divides_n_O (gcd.gcd n nat.O)) 
             (logic.eq_coerc 
                (primes.divides (gcd.gcd n nat.O) (gcd.gcd n nat.O)) 
                (primes.divides (gcd.gcd n nat.O) n) 
                (primes.divides_n_n (gcd.gcd n nat.O)) 
                (logic.rewrite_r nat.nat n 
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq sttfa.bool 
                      (primes.divides (gcd.gcd n nat.O) __) 
                      (primes.divides (gcd.gcd n nat.O) n)) 
                   (logic.refl sttfa.bool 
                      (primes.divides (gcd.gcd n nat.O) n)) 
                   (gcd.gcd n nat.O) 
                   (logic.rewrite_l nat.nat (gcd.gcd nat.O n) 
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat (gcd.gcd n nat.O) __) 
                      (gcd.commutative_gcd n nat.O) n (gcd.gcd_O_l n))))) m 
          eqmO) (nat.le_to_or_lt_eq nat.O m (nat.le_O_n m))) 
    (eqnO:(sttfa.eps (logic.eq nat.nat nat.O n)) =>
     logic.eq_ind nat.nat nat.O 
       (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
        connectives.And (primes.divides (gcd.gcd x_1 m) m) 
          (primes.divides (gcd.gcd x_1 m) x_1)) 
       (z:(sttfa.etap (sttfa.p sttfa.bool)) =>
        f:
        (sttfa.eps 
           (sttfa.impl (primes.divides (gcd.gcd nat.O m) m) 
              (sttfa.impl (primes.divides (gcd.gcd nat.O m) nat.O) z))) =>
        f 
          (bool.eq_match_bool_type_true nat.nat m (gcd.gcd_aux m nat.O m) 
             (y:(sttfa.etap (sttfa.p nat.nat)) =>
              primes.divides 
                (bool.match_bool_type nat.nat (gcd.gcd_aux nat.O m nat.O) 
                   (gcd.gcd_aux m nat.O m) (nat.leb nat.O m)) y) 
             (nat.eq_leb_body_O 
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
                 primes.divides 
                   (bool.match_bool_type nat.nat (gcd.gcd_aux nat.O m nat.O) 
                      (gcd.gcd_aux m nat.O m) (nat.leb nat.O m)) 
                   (bool.match_bool_type nat.nat m (gcd.gcd_aux m nat.O m) 
                      (y m))) 
                (nat.eq_filter_nat_type_O (sttfa.arrow nat.nat bool.bool) 
                   nat.leb_body 
                   (y:
                    (sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
                    primes.divides 
                      (bool.match_bool_type nat.nat 
                         (gcd.gcd_aux nat.O m nat.O) (gcd.gcd_aux m nat.O m) 
                         (nat.leb nat.O m)) 
                      (bool.match_bool_type nat.nat m 
                         (gcd.gcd_aux m nat.O m) (y m))) 
                   (nat.eq_leb nat.O 
                      (y:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
                       primes.divides 
                         (bool.match_bool_type nat.nat 
                            (gcd.gcd_aux nat.O m nat.O) 
                            (gcd.gcd_aux m nat.O m) (nat.leb nat.O m)) 
                         (bool.match_bool_type nat.nat m 
                            (gcd.gcd_aux m nat.O m) (y m))) 
                      (gcd.eq_gcd_aux_body_O 
                         (y:
                          (sttfa.etap 
                             (sttfa.p 
                                (sttfa.arrow nat.nat 
                                   (sttfa.arrow nat.nat nat.nat)))) =>
                          primes.divides (gcd.gcd nat.O m) 
                            (bool.match_bool_type nat.nat (y m nat.O) 
                               (gcd.gcd_aux m nat.O m) (nat.leb nat.O m))) 
                         (nat.eq_filter_nat_type_O 
                            (sttfa.arrow nat.nat 
                               (sttfa.arrow nat.nat nat.nat)) 
                            gcd.gcd_aux_body 
                            (y:
                             (sttfa.etap 
                                (sttfa.p 
                                   (sttfa.arrow nat.nat 
                                      (sttfa.arrow nat.nat nat.nat)))) =>
                             primes.divides (gcd.gcd nat.O m) 
                               (bool.match_bool_type nat.nat (y m nat.O) 
                                  (gcd.gcd_aux m nat.O m) (nat.leb nat.O m))) 
                            (gcd.eq_gcd_aux nat.O 
                               (y:
                                (sttfa.etap 
                                   (sttfa.p 
                                      (sttfa.arrow nat.nat 
                                         (sttfa.arrow nat.nat nat.nat)))) =>
                                primes.divides (gcd.gcd nat.O m) 
                                  (bool.match_bool_type nat.nat (y m nat.O) 
                                     (gcd.gcd_aux m nat.O m) 
                                     (nat.leb nat.O m))) 
                               (primes.divides_n_n (gcd.gcd nat.O m))))))))) 
          (primes.divides_n_O (gcd.gcd nat.O m))) n eqnO) 
    (nat.le_to_or_lt_eq nat.O n (nat.le_O_n n)).

def divides_gcd_l :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) => primes.divides (gcd.gcd n m) n)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.proj2 (primes.divides (gcd.gcd n m) m) 
    (primes.divides (gcd.gcd n m) n) (gcd.divides_gcd_nm n m).

def divides_gcd_r :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) => primes.divides (gcd.gcd n m) m)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.proj1 (primes.divides (gcd.gcd n m) m) 
    (primes.divides (gcd.gcd n m) n) (gcd.divides_gcd_nm n m).

def let_clause_1544 :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (q:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl 
             (sttfa.forall nat.nat 
                (m:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall nat.nat 
                   (n:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (nat.lt nat.O n) 
                      (sttfa.impl (nat.le n m) 
                         (sttfa.impl (nat.le n q) 
                            (connectives.Ex nat.nat 
                               (a:(sttfa.etap (sttfa.p nat.nat)) =>
                                connectives.Ex nat.nat 
                                  (b:(sttfa.etap (sttfa.p nat.nat)) =>
                                   connectives.Or 
                                     (logic.eq nat.nat 
                                        (nat.minus (nat.times a n) 
                                           (nat.times b m)) 
                                        (gcd.gcd_aux q m n)) 
                                     (logic.eq nat.nat 
                                        (nat.minus (nat.times b m) 
                                           (nat.times a n)) 
                                        (gcd.gcd_aux q m n)))))))))) 
             (sttfa.forall nat.nat 
                (m:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall nat.nat 
                   (n:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (nat.lt nat.O n) 
                      (sttfa.impl (nat.le n m) 
                         (sttfa.impl (nat.le n (nat.S q)) 
                            (sttfa.impl 
                               (connectives.Not (primes.divides n m)) 
                               (sttfa.forall nat.nat 
                                  (a:(sttfa.etap (sttfa.p nat.nat)) =>
                                   sttfa.impl 
                                     (connectives.Ex nat.nat 
                                        (b:(sttfa.etap (sttfa.p nat.nat)) =>
                                         connectives.Or 
                                           (logic.eq nat.nat 
                                              (nat.minus 
                                                 (nat.times a 
                                                    (div_mod.mod m n)) 
                                                 (nat.times b n)) 
                                              (gcd.gcd_aux q n 
                                                 (div_mod.mod m n))) 
                                           (logic.eq nat.nat 
                                              (nat.minus (nat.times b n) 
                                                 (nat.times a 
                                                    (div_mod.mod m n))) 
                                              (gcd.gcd_aux q n 
                                                 (div_mod.mod m n))))) 
                                     (sttfa.forall nat.nat 
                                        (b:(sttfa.etap (sttfa.p nat.nat)) =>
                                         sttfa.impl 
                                           (connectives.Or 
                                              (logic.eq nat.nat 
                                                 (nat.minus 
                                                    (nat.times a 
                                                       (div_mod.mod m n)) 
                                                    (nat.times b n)) 
                                                 (gcd.gcd_aux q n 
                                                    (div_mod.mod m n))) 
                                              (logic.eq nat.nat 
                                                 (nat.minus (nat.times b n) 
                                                    (nat.times a 
                                                       (div_mod.mod m n))) 
                                                 (gcd.gcd_aux q n 
                                                    (div_mod.mod m n)))) 
                                           (sttfa.impl 
                                              (logic.eq nat.nat 
                                                 (nat.minus 
                                                    (nat.times a 
                                                       (div_mod.mod m n)) 
                                                    (nat.times b n)) 
                                                 (gcd.gcd_aux q n 
                                                    (div_mod.mod m n))) 
                                              (logic.eq nat.nat 
                                                 (nat.minus 
                                                    (nat.times a 
                                                       (div_mod.mod m n)) 
                                                    (nat.times n b)) 
                                                 (gcd.gcd_aux q n 
                                                    (div_mod.mod m n)))))))))))))))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  q:(sttfa.etap (sttfa.p nat.nat)) =>
  Hind:
  (sttfa.eps 
     (sttfa.forall nat.nat 
        (m:(sttfa.etap (sttfa.p nat.nat)) =>
         sttfa.forall nat.nat 
           (n:(sttfa.etap (sttfa.p nat.nat)) =>
            sttfa.impl (nat.lt nat.O n) 
              (sttfa.impl (nat.le n m) 
                 (sttfa.impl (nat.le n q) 
                    (connectives.Ex nat.nat 
                       (a:(sttfa.etap (sttfa.p nat.nat)) =>
                        connectives.Ex nat.nat 
                          (b:(sttfa.etap (sttfa.p nat.nat)) =>
                           connectives.Or 
                             (logic.eq nat.nat 
                                (nat.minus (nat.times a n) (nat.times b m)) 
                                (gcd.gcd_aux q m n)) 
                             (logic.eq nat.nat 
                                (nat.minus (nat.times b m) (nat.times a n)) 
                                (gcd.gcd_aux q m n))))))))))) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  posn:(sttfa.eps (nat.lt nat.O n)) =>
  lenm:(sttfa.eps (nat.le n m)) =>
  lenS:(sttfa.eps (nat.le n (nat.S q))) =>
  ndivnm:(sttfa.eps (connectives.Not (primes.divides n m))) =>
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  _clearme:
  (sttfa.eps 
     (connectives.Ex nat.nat 
        (b:(sttfa.etap (sttfa.p nat.nat)) =>
         connectives.Or 
           (logic.eq nat.nat 
              (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)) 
              (gcd.gcd_aux q n (div_mod.mod m n))) 
           (logic.eq nat.nat 
              (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))) 
              (gcd.gcd_aux q n (div_mod.mod m n)))))) =>
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  _clearme0:
  (sttfa.eps 
     (connectives.Or 
        (logic.eq nat.nat 
           (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)) 
           (gcd.gcd_aux q n (div_mod.mod m n))) 
        (logic.eq nat.nat 
           (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))) 
           (gcd.gcd_aux q n (div_mod.mod m n))))) =>
  H:
  (sttfa.eps 
     (logic.eq nat.nat 
        (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)) 
        (gcd.gcd_aux q n (div_mod.mod m n)))) =>
  logic.rewrite_l nat.nat (nat.times b n) 
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq nat.nat (nat.minus (nat.times a (div_mod.mod m n)) __) 
       (gcd.gcd_aux q n (div_mod.mod m n))) H (nat.times n b) 
    (nat.commutative_times b n).

def let_clause_15441 :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (q:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl 
             (sttfa.forall nat.nat 
                (m:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall nat.nat 
                   (n:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (nat.lt nat.O n) 
                      (sttfa.impl (nat.le n m) 
                         (sttfa.impl (nat.le n q) 
                            (connectives.Ex nat.nat 
                               (a:(sttfa.etap (sttfa.p nat.nat)) =>
                                connectives.Ex nat.nat 
                                  (b:(sttfa.etap (sttfa.p nat.nat)) =>
                                   connectives.Or 
                                     (logic.eq nat.nat 
                                        (nat.minus (nat.times a n) 
                                           (nat.times b m)) 
                                        (gcd.gcd_aux q m n)) 
                                     (logic.eq nat.nat 
                                        (nat.minus (nat.times b m) 
                                           (nat.times a n)) 
                                        (gcd.gcd_aux q m n)))))))))) 
             (sttfa.forall nat.nat 
                (m:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall nat.nat 
                   (n:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (nat.lt nat.O n) 
                      (sttfa.impl (nat.le n m) 
                         (sttfa.impl (nat.le n (nat.S q)) 
                            (sttfa.impl 
                               (connectives.Not (primes.divides n m)) 
                               (sttfa.forall nat.nat 
                                  (a:(sttfa.etap (sttfa.p nat.nat)) =>
                                   sttfa.impl 
                                     (connectives.Ex nat.nat 
                                        (b:(sttfa.etap (sttfa.p nat.nat)) =>
                                         connectives.Or 
                                           (logic.eq nat.nat 
                                              (nat.minus 
                                                 (nat.times a 
                                                    (div_mod.mod m n)) 
                                                 (nat.times b n)) 
                                              (gcd.gcd_aux q n 
                                                 (div_mod.mod m n))) 
                                           (logic.eq nat.nat 
                                              (nat.minus (nat.times b n) 
                                                 (nat.times a 
                                                    (div_mod.mod m n))) 
                                              (gcd.gcd_aux q n 
                                                 (div_mod.mod m n))))) 
                                     (sttfa.forall nat.nat 
                                        (b:(sttfa.etap (sttfa.p nat.nat)) =>
                                         sttfa.impl 
                                           (connectives.Or 
                                              (logic.eq nat.nat 
                                                 (nat.minus 
                                                    (nat.times a 
                                                       (div_mod.mod m n)) 
                                                    (nat.times b n)) 
                                                 (gcd.gcd_aux q n 
                                                    (div_mod.mod m n))) 
                                              (logic.eq nat.nat 
                                                 (nat.minus (nat.times b n) 
                                                    (nat.times a 
                                                       (div_mod.mod m n))) 
                                                 (gcd.gcd_aux q n 
                                                    (div_mod.mod m n)))) 
                                           (sttfa.impl 
                                              (logic.eq nat.nat 
                                                 (nat.minus (nat.times b n) 
                                                    (nat.times a 
                                                       (div_mod.mod m n))) 
                                                 (gcd.gcd_aux q n 
                                                    (div_mod.mod m n))) 
                                              (logic.eq nat.nat 
                                                 (nat.minus (nat.times n b) 
                                                    (nat.times a 
                                                       (div_mod.mod m n))) 
                                                 (gcd.gcd_aux q n 
                                                    (div_mod.mod m n)))))))))))))))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  q:(sttfa.etap (sttfa.p nat.nat)) =>
  Hind:
  (sttfa.eps 
     (sttfa.forall nat.nat 
        (m:(sttfa.etap (sttfa.p nat.nat)) =>
         sttfa.forall nat.nat 
           (n:(sttfa.etap (sttfa.p nat.nat)) =>
            sttfa.impl (nat.lt nat.O n) 
              (sttfa.impl (nat.le n m) 
                 (sttfa.impl (nat.le n q) 
                    (connectives.Ex nat.nat 
                       (a:(sttfa.etap (sttfa.p nat.nat)) =>
                        connectives.Ex nat.nat 
                          (b:(sttfa.etap (sttfa.p nat.nat)) =>
                           connectives.Or 
                             (logic.eq nat.nat 
                                (nat.minus (nat.times a n) (nat.times b m)) 
                                (gcd.gcd_aux q m n)) 
                             (logic.eq nat.nat 
                                (nat.minus (nat.times b m) (nat.times a n)) 
                                (gcd.gcd_aux q m n))))))))))) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  posn:(sttfa.eps (nat.lt nat.O n)) =>
  lenm:(sttfa.eps (nat.le n m)) =>
  lenS:(sttfa.eps (nat.le n (nat.S q))) =>
  ndivnm:(sttfa.eps (connectives.Not (primes.divides n m))) =>
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  _clearme:
  (sttfa.eps 
     (connectives.Ex nat.nat 
        (b:(sttfa.etap (sttfa.p nat.nat)) =>
         connectives.Or 
           (logic.eq nat.nat 
              (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)) 
              (gcd.gcd_aux q n (div_mod.mod m n))) 
           (logic.eq nat.nat 
              (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))) 
              (gcd.gcd_aux q n (div_mod.mod m n)))))) =>
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  _clearme0:
  (sttfa.eps 
     (connectives.Or 
        (logic.eq nat.nat 
           (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n)) 
           (gcd.gcd_aux q n (div_mod.mod m n))) 
        (logic.eq nat.nat 
           (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))) 
           (gcd.gcd_aux q n (div_mod.mod m n))))) =>
  H:
  (sttfa.eps 
     (logic.eq nat.nat 
        (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n))) 
        (gcd.gcd_aux q n (div_mod.mod m n)))) =>
  logic.rewrite_l nat.nat (nat.times b n) 
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq nat.nat (nat.minus __ (nat.times a (div_mod.mod m n))) 
       (gcd.gcd_aux q n (div_mod.mod m n))) H (nat.times n b) 
    (nat.commutative_times b n).

def eq_minus_gcd_aux :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (n:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.lt nat.O n) 
                (sttfa.impl (nat.le n m) 
                   (sttfa.impl (nat.le n p) 
                      (connectives.Ex nat.nat 
                         (a:(sttfa.etap (sttfa.p nat.nat)) =>
                          connectives.Ex nat.nat 
                            (b:(sttfa.etap (sttfa.p nat.nat)) =>
                             connectives.Or 
                               (logic.eq nat.nat 
                                  (nat.minus (nat.times a n) (nat.times b m)) 
                                  (gcd.gcd_aux p m n)) 
                               (logic.eq nat.nat 
                                  (nat.minus (nat.times b m) (nat.times a n)) 
                                  (gcd.gcd_aux p m n)))))))))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind 
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.forall nat.nat 
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.lt nat.O n) 
             (sttfa.impl (nat.le n m) 
                (sttfa.impl (nat.le n _x_365) 
                   (connectives.Ex nat.nat 
                      (a:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.Ex nat.nat 
                         (b:(sttfa.etap (sttfa.p nat.nat)) =>
                          connectives.Or 
                            (logic.eq nat.nat 
                               (nat.minus (nat.times a n) (nat.times b m)) 
                               (gcd.gcd_aux _x_365 m n)) 
                            (logic.eq nat.nat 
                               (nat.minus (nat.times b m) (nat.times a n)) 
                               (gcd.gcd_aux _x_365 m n)))))))))) 
    (m:(sttfa.etap (sttfa.p nat.nat)) =>
     n:(sttfa.etap (sttfa.p nat.nat)) =>
     posn:(sttfa.eps (nat.lt nat.O n)) =>
     lenm:(sttfa.eps (nat.le n m)) =>
     lenO:(sttfa.eps (nat.le n nat.O)) =>
     logic.falsity 
       (connectives.Ex nat.nat 
          (a:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.Ex nat.nat 
             (b:(sttfa.etap (sttfa.p nat.nat)) =>
              connectives.Or 
                (logic.eq nat.nat 
                   (nat.minus (nat.times a n) (nat.times b m)) 
                   (gcd.gcd_aux nat.O m n)) 
                (logic.eq nat.nat 
                   (nat.minus (nat.times b m) (nat.times a n)) 
                   (gcd.gcd_aux nat.O m n))))) 
       (logic.absurd (nat.lt nat.O n) posn (nat.le_to_not_lt n nat.O lenO))) 
    (q:(sttfa.etap (sttfa.p nat.nat)) =>
     Hind:
     (sttfa.eps 
        (sttfa.forall nat.nat 
           (m:(sttfa.etap (sttfa.p nat.nat)) =>
            sttfa.forall nat.nat 
              (n:(sttfa.etap (sttfa.p nat.nat)) =>
               sttfa.impl (nat.lt nat.O n) 
                 (sttfa.impl (nat.le n m) 
                    (sttfa.impl (nat.le n q) 
                       (connectives.Ex nat.nat 
                          (a:(sttfa.etap (sttfa.p nat.nat)) =>
                           connectives.Ex nat.nat 
                             (b:(sttfa.etap (sttfa.p nat.nat)) =>
                              connectives.Or 
                                (logic.eq nat.nat 
                                   (nat.minus (nat.times a n) (nat.times b m)) 
                                   (gcd.gcd_aux q m n)) 
                                (logic.eq nat.nat 
                                   (nat.minus (nat.times b m) (nat.times a n)) 
                                   (gcd.gcd_aux q m n))))))))))) =>
     m:(sttfa.etap (sttfa.p nat.nat)) =>
     n:(sttfa.etap (sttfa.p nat.nat)) =>
     posn:(sttfa.eps (nat.lt nat.O n)) =>
     lenm:(sttfa.eps (nat.le n m)) =>
     lenS:(sttfa.eps (nat.le n (nat.S q))) =>
     logic.match_Or_prop (primes.divides n m) 
       (connectives.Not (primes.divides n m)) 
       (connectives.Ex nat.nat 
          (a:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.Ex nat.nat 
             (b:(sttfa.etap (sttfa.p nat.nat)) =>
              connectives.Or 
                (logic.eq nat.nat 
                   (nat.minus (nat.times a n) (nat.times b m)) 
                   (gcd.gcd_aux (nat.S q) m n)) 
                (logic.eq nat.nat 
                   (nat.minus (nat.times b m) (nat.times a n)) 
                   (gcd.gcd_aux (nat.S q) m n))))) 
       (divnm:(sttfa.eps (primes.divides n m)) =>
        logic.eq_ind_r nat.nat n 
          (x:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.Ex nat.nat 
             (a:(sttfa.etap (sttfa.p nat.nat)) =>
              connectives.Ex nat.nat 
                (b:(sttfa.etap (sttfa.p nat.nat)) =>
                 connectives.Or 
                   (logic.eq nat.nat 
                      (nat.minus (nat.times a n) (nat.times b m)) x) 
                   (logic.eq nat.nat 
                      (nat.minus (nat.times b m) (nat.times a n)) x)))) 
          (z:(sttfa.etap (sttfa.p sttfa.bool)) =>
           f:
           (sttfa.eps 
              (sttfa.forall nat.nat 
                 (x:(sttfa.etap (sttfa.p nat.nat)) =>
                  sttfa.impl 
                    (connectives.Ex nat.nat 
                       (b:(sttfa.etap (sttfa.p nat.nat)) =>
                        connectives.Or 
                          (logic.eq nat.nat 
                             (nat.minus (nat.times x n) (nat.times b m)) n) 
                          (logic.eq nat.nat 
                             (nat.minus (nat.times b m) (nat.times x n)) n))) 
                    z))) =>
           f (nat.S nat.O) 
             (z0:(sttfa.etap (sttfa.p sttfa.bool)) =>
              f2:
              (sttfa.eps 
                 (sttfa.forall nat.nat 
                    (x:(sttfa.etap (sttfa.p nat.nat)) =>
                     sttfa.impl 
                       (connectives.Or 
                          (logic.eq nat.nat 
                             (nat.minus (nat.times (nat.S nat.O) n) 
                                (nat.times x m)) n) 
                          (logic.eq nat.nat 
                             (nat.minus (nat.times x m) 
                                (nat.times (nat.S nat.O) n)) n)) z0))) =>
              f2 nat.O 
                (z1:(sttfa.etap (sttfa.p sttfa.bool)) =>
                 l:
                 (sttfa.eps 
                    (sttfa.impl 
                       (logic.eq nat.nat 
                          (nat.minus (nat.times (nat.S nat.O) n) 
                             (nat.times nat.O m)) n) z1)) =>
                 r:
                 (sttfa.eps 
                    (sttfa.impl 
                       (logic.eq nat.nat 
                          (nat.minus (nat.times nat.O m) 
                             (nat.times (nat.S nat.O) n)) n) z1)) =>
                 l 
                   (logic.rewrite_r nat.nat (nat.times n (nat.S nat.O)) 
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat (nat.minus __ (nat.times nat.O m)) n) 
                      (logic.rewrite_l nat.nat 
                         (nat.plus n (nat.times n nat.O)) 
                         (__:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat 
                            (nat.minus __ (nat.times nat.O m)) n) 
                         (logic.rewrite_l nat.nat nat.O 
                            (__:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq nat.nat 
                               (nat.minus (nat.plus n __) (nat.times nat.O m)) 
                               n) 
                            (logic.rewrite_l nat.nat n 
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq nat.nat 
                                  (nat.minus __ (nat.times nat.O m)) n) 
                               (logic.rewrite_r nat.nat (nat.times m nat.O) 
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq nat.nat (nat.minus n __) n) 
                                  (logic.rewrite_l nat.nat nat.O 
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq nat.nat (nat.minus n __) n) 
                                     (logic.rewrite_l nat.nat n 
                                        (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq nat.nat __ n) 
                                        (logic.refl nat.nat n) 
                                        (nat.minus n nat.O) (nat.minus_n_O n)) 
                                     (nat.times m nat.O) (nat.times_n_O m)) 
                                  (nat.times nat.O m) 
                                  (nat.commutative_times nat.O m)) 
                               (nat.plus n nat.O) (nat.plus_n_O n)) 
                            (nat.times n nat.O) (nat.times_n_O n)) 
                         (nat.times n (nat.S nat.O)) (nat.times_n_Sm n nat.O)) 
                      (nat.times (nat.S nat.O) n) 
                      (nat.commutative_times (nat.S nat.O) n))))) 
          (gcd.gcd_aux (nat.S q) m n) 
          (gcd.divides_to_gcd_aux (nat.S q) m n (nat.lt_O_S q) posn divnm)) 
       (ndivnm:(sttfa.eps (connectives.Not (primes.divides n m))) =>
        logic.eq_ind_r nat.nat (gcd.gcd_aux q n (div_mod.mod m n)) 
          (x:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.Ex nat.nat 
             (a:(sttfa.etap (sttfa.p nat.nat)) =>
              connectives.Ex nat.nat 
                (b:(sttfa.etap (sttfa.p nat.nat)) =>
                 connectives.Or 
                   (logic.eq nat.nat 
                      (nat.minus (nat.times a n) (nat.times b m)) x) 
                   (logic.eq nat.nat 
                      (nat.minus (nat.times b m) (nat.times a n)) x)))) 
          (logic.match_ex_prop nat.nat 
             (a:(sttfa.etap (sttfa.p nat.nat)) =>
              connectives.Ex nat.nat 
                (b:(sttfa.etap (sttfa.p nat.nat)) =>
                 connectives.Or 
                   (logic.eq nat.nat 
                      (nat.minus (nat.times a (div_mod.mod m n)) 
                         (nat.times b n)) (gcd.gcd_aux q n (div_mod.mod m n))) 
                   (logic.eq nat.nat 
                      (nat.minus (nat.times b n) 
                         (nat.times a (div_mod.mod m n))) 
                      (gcd.gcd_aux q n (div_mod.mod m n))))) 
             (connectives.Ex nat.nat 
                (a:(sttfa.etap (sttfa.p nat.nat)) =>
                 connectives.Ex nat.nat 
                   (b:(sttfa.etap (sttfa.p nat.nat)) =>
                    connectives.Or 
                      (logic.eq nat.nat 
                         (nat.minus (nat.times a n) (nat.times b m)) 
                         (gcd.gcd_aux q n (div_mod.mod m n))) 
                      (logic.eq nat.nat 
                         (nat.minus (nat.times b m) (nat.times a n)) 
                         (gcd.gcd_aux q n (div_mod.mod m n)))))) 
             (a:(sttfa.etap (sttfa.p nat.nat)) =>
              _clearme:
              (sttfa.eps 
                 (connectives.Ex nat.nat 
                    (b:(sttfa.etap (sttfa.p nat.nat)) =>
                     connectives.Or 
                       (logic.eq nat.nat 
                          (nat.minus (nat.times a (div_mod.mod m n)) 
                             (nat.times b n)) 
                          (gcd.gcd_aux q n (div_mod.mod m n))) 
                       (logic.eq nat.nat 
                          (nat.minus (nat.times b n) 
                             (nat.times a (div_mod.mod m n))) 
                          (gcd.gcd_aux q n (div_mod.mod m n)))))) =>
              logic.match_ex_prop nat.nat 
                (b:(sttfa.etap (sttfa.p nat.nat)) =>
                 connectives.Or 
                   (logic.eq nat.nat 
                      (nat.minus (nat.times a (div_mod.mod m n)) 
                         (nat.times b n)) (gcd.gcd_aux q n (div_mod.mod m n))) 
                   (logic.eq nat.nat 
                      (nat.minus (nat.times b n) 
                         (nat.times a (div_mod.mod m n))) 
                      (gcd.gcd_aux q n (div_mod.mod m n)))) 
                (connectives.Ex nat.nat 
                   (a0:(sttfa.etap (sttfa.p nat.nat)) =>
                    connectives.Ex nat.nat 
                      (b:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.Or 
                         (logic.eq nat.nat 
                            (nat.minus (nat.times a0 n) (nat.times b m)) 
                            (gcd.gcd_aux q n (div_mod.mod m n))) 
                         (logic.eq nat.nat 
                            (nat.minus (nat.times b m) (nat.times a0 n)) 
                            (gcd.gcd_aux q n (div_mod.mod m n)))))) 
                (b:(sttfa.etap (sttfa.p nat.nat)) =>
                 _clearme0:
                 (sttfa.eps 
                    (connectives.Or 
                       (logic.eq nat.nat 
                          (nat.minus (nat.times a (div_mod.mod m n)) 
                             (nat.times b n)) 
                          (gcd.gcd_aux q n (div_mod.mod m n))) 
                       (logic.eq nat.nat 
                          (nat.minus (nat.times b n) 
                             (nat.times a (div_mod.mod m n))) 
                          (gcd.gcd_aux q n (div_mod.mod m n))))) =>
                 logic.match_Or_prop 
                   (logic.eq nat.nat 
                      (nat.minus (nat.times a (div_mod.mod m n)) 
                         (nat.times b n)) (gcd.gcd_aux q n (div_mod.mod m n))) 
                   (logic.eq nat.nat 
                      (nat.minus (nat.times b n) 
                         (nat.times a (div_mod.mod m n))) 
                      (gcd.gcd_aux q n (div_mod.mod m n))) 
                   (connectives.Ex nat.nat 
                      (a0:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.Ex nat.nat 
                         (b0:(sttfa.etap (sttfa.p nat.nat)) =>
                          connectives.Or 
                            (logic.eq nat.nat 
                               (nat.minus (nat.times a0 n) (nat.times b0 m)) 
                               (gcd.gcd_aux q n (div_mod.mod m n))) 
                            (logic.eq nat.nat 
                               (nat.minus (nat.times b0 m) (nat.times a0 n)) 
                               (gcd.gcd_aux q n (div_mod.mod m n)))))) 
                   (H:
                    (sttfa.eps 
                       (logic.eq nat.nat 
                          (nat.minus (nat.times a (div_mod.mod m n)) 
                             (nat.times b n)) 
                          (gcd.gcd_aux q n (div_mod.mod m n)))) =>
                    logic.eq_ind nat.nat 
                      (nat.minus (nat.times a (div_mod.mod m n)) 
                         (nat.times b n)) 
                      (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.Ex nat.nat 
                         (a0:(sttfa.etap (sttfa.p nat.nat)) =>
                          connectives.Ex nat.nat 
                            (b0:(sttfa.etap (sttfa.p nat.nat)) =>
                             connectives.Or 
                               (logic.eq nat.nat 
                                  (nat.minus (nat.times a0 n) 
                                     (nat.times b0 m)) x_1) 
                               (logic.eq nat.nat 
                                  (nat.minus (nat.times b0 m) 
                                     (nat.times a0 n)) x_1)))) 
                      (z:(sttfa.etap (sttfa.p sttfa.bool)) =>
                       f:
                       (sttfa.eps 
                          (sttfa.forall nat.nat 
                             (x:(sttfa.etap (sttfa.p nat.nat)) =>
                              sttfa.impl 
                                (connectives.Ex nat.nat 
                                   (b0:(sttfa.etap (sttfa.p nat.nat)) =>
                                    connectives.Or 
                                      (logic.eq nat.nat 
                                         (nat.minus (nat.times x n) 
                                            (nat.times b0 m)) 
                                         (nat.minus 
                                            (nat.times a (div_mod.mod m n)) 
                                            (nat.times b n))) 
                                      (logic.eq nat.nat 
                                         (nat.minus (nat.times b0 m) 
                                            (nat.times x n)) 
                                         (nat.minus 
                                            (nat.times a (div_mod.mod m n)) 
                                            (nat.times b n))))) z))) =>
                       f (nat.plus b (nat.times a (div_mod.div m n))) 
                         (z0:(sttfa.etap (sttfa.p sttfa.bool)) =>
                          f0:
                          (sttfa.eps 
                             (sttfa.forall nat.nat 
                                (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                 sttfa.impl 
                                   (connectives.Or 
                                      (logic.eq nat.nat 
                                         (nat.minus 
                                            (nat.times 
                                               (nat.plus b 
                                                  (nat.times a 
                                                     (div_mod.div m n))) n) 
                                            (nat.times x m)) 
                                         (nat.minus 
                                            (nat.times a (div_mod.mod m n)) 
                                            (nat.times b n))) 
                                      (logic.eq nat.nat 
                                         (nat.minus (nat.times x m) 
                                            (nat.times 
                                               (nat.plus b 
                                                  (nat.times a 
                                                     (div_mod.div m n))) n)) 
                                         (nat.minus 
                                            (nat.times a (div_mod.mod m n)) 
                                            (nat.times b n)))) z0))) =>
                          f0 a 
                            (z1:(sttfa.etap (sttfa.p sttfa.bool)) =>
                             l:
                             (sttfa.eps 
                                (sttfa.impl 
                                   (logic.eq nat.nat 
                                      (nat.minus 
                                         (nat.times 
                                            (nat.plus b 
                                               (nat.times a (div_mod.div m n))) 
                                            n) (nat.times a m)) 
                                      (nat.minus 
                                         (nat.times a (div_mod.mod m n)) 
                                         (nat.times b n))) z1)) =>
                             r:
                             (sttfa.eps 
                                (sttfa.impl 
                                   (logic.eq nat.nat 
                                      (nat.minus (nat.times a m) 
                                         (nat.times 
                                            (nat.plus b 
                                               (nat.times a (div_mod.div m n))) 
                                            n)) 
                                      (nat.minus 
                                         (nat.times a (div_mod.mod m n)) 
                                         (nat.times b n))) z1)) =>
                             r 
                               (logic.eq_ind nat.nat 
                                  (nat.plus (nat.times a (div_mod.div m n)) b) 
                                  (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq nat.nat 
                                     (nat.minus (nat.times a m) 
                                        (nat.times x_1 n)) 
                                     (nat.minus 
                                        (nat.times a (div_mod.mod m n)) 
                                        (nat.times b n))) 
                                  (logic.eq_ind_r nat.nat 
                                     (nat.plus 
                                        (nat.times 
                                           (nat.times a (div_mod.div m n)) n) 
                                        (nat.times b n)) 
                                     (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq nat.nat 
                                        (nat.minus (nat.times a m) x) 
                                        (nat.minus 
                                           (nat.times a (div_mod.mod m n)) 
                                           (nat.times b n))) 
                                     (logic.eq_ind_r nat.nat 
                                        (nat.plus 
                                           (nat.times (div_mod.div m n) n) 
                                           (div_mod.mod m n)) 
                                        (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq nat.nat 
                                           (nat.minus (nat.times a x) 
                                              (nat.plus 
                                                 (nat.times 
                                                    (nat.times a 
                                                       (div_mod.div m n)) n) 
                                                 (nat.times b n))) 
                                           (nat.minus 
                                              (nat.times a (div_mod.mod m n)) 
                                              (nat.times b n))) 
                                        (logic.eq_ind_r nat.nat 
                                           (nat.times a 
                                              (nat.times (div_mod.div m n) n)) 
                                           (x:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq nat.nat 
                                              (nat.minus 
                                                 (nat.times a 
                                                    (nat.plus 
                                                       (nat.times 
                                                          (div_mod.div m n) n) 
                                                       (div_mod.mod m n))) 
                                                 (nat.plus x (nat.times b n))) 
                                              (nat.minus 
                                                 (nat.times a 
                                                    (div_mod.mod m n)) 
                                                 (nat.times b n))) 
                                           (logic.eq_ind nat.nat 
                                              (nat.plus (div_mod.mod m n) 
                                                 (nat.times 
                                                    (div_mod.div m n) n)) 
                                              (x_1:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq nat.nat 
                                                 (nat.minus 
                                                    (nat.times a x_1) 
                                                    (nat.plus 
                                                       (nat.times a 
                                                          (nat.times 
                                                             (div_mod.div m n) 
                                                             n)) 
                                                       (nat.times b n))) 
                                                 (nat.minus 
                                                    (nat.times a 
                                                       (div_mod.mod m n)) 
                                                    (nat.times b n))) 
                                              (logic.eq_ind_r nat.nat 
                                                 (nat.plus 
                                                    (nat.times a 
                                                       (div_mod.mod m n)) 
                                                    (nat.times a 
                                                       (nat.times 
                                                          (div_mod.div m n) n))) 
                                                 (x:
                                                  (sttfa.etap 
                                                     (sttfa.p nat.nat)) =>
                                                  logic.eq nat.nat 
                                                    (nat.minus x 
                                                       (nat.plus 
                                                          (nat.times a 
                                                             (nat.times 
                                                                (div_mod.div 
                                                                   m n) n)) 
                                                          (nat.times b n))) 
                                                    (nat.minus 
                                                       (nat.times a 
                                                          (div_mod.mod m n)) 
                                                       (nat.times b n))) 
                                                 (logic.eq_ind nat.nat 
                                                    (nat.minus 
                                                       (nat.minus 
                                                          (nat.plus 
                                                             (nat.times a 
                                                                (div_mod.mod 
                                                                   m n)) 
                                                             (nat.times a 
                                                                (nat.times 
                                                                   (div_mod.div 
                                                                    m n) n))) 
                                                          (nat.times a 
                                                             (nat.times 
                                                                (div_mod.div 
                                                                   m n) n))) 
                                                       (nat.times b n)) 
                                                    (x_1:
                                                     (sttfa.etap 
                                                        (sttfa.p nat.nat)) =>
                                                     logic.eq nat.nat x_1 
                                                       (nat.minus 
                                                          (nat.times a 
                                                             (div_mod.mod m n)) 
                                                          (nat.times b n))) 
                                                    (logic.eq_ind nat.nat 
                                                       (nat.plus 
                                                          (nat.times a 
                                                             (nat.times 
                                                                (div_mod.div 
                                                                   m n) n)) 
                                                          (nat.times a 
                                                             (div_mod.mod m n))) 
                                                       (x_1:
                                                        (sttfa.etap 
                                                           (sttfa.p nat.nat)) =>
                                                        logic.eq nat.nat 
                                                          (nat.minus 
                                                             (nat.minus x_1 
                                                                (nat.times a 
                                                                   (nat.times 
                                                                    (div_mod.div 
                                                                    m n) n))) 
                                                             (nat.times b n)) 
                                                          (nat.minus 
                                                             (nat.times a 
                                                                (div_mod.mod 
                                                                   m n)) 
                                                             (nat.times b n))) 
                                                       (logic.eq_ind nat.nat 
                                                          (nat.plus 
                                                             (nat.minus 
                                                                (nat.times a 
                                                                   (nat.times 
                                                                    (div_mod.div 
                                                                    m n) n)) 
                                                                (nat.times a 
                                                                   (nat.times 
                                                                    (div_mod.div 
                                                                    m n) n))) 
                                                             (nat.times a 
                                                                (div_mod.mod 
                                                                   m n))) 
                                                          (x_1:
                                                           (sttfa.etap 
                                                              (sttfa.p 
                                                                 nat.nat)) =>
                                                           logic.eq nat.nat 
                                                             (nat.minus x_1 
                                                                (nat.times b 
                                                                   n)) 
                                                             (nat.minus 
                                                                (nat.times a 
                                                                   (div_mod.mod 
                                                                    m n)) 
                                                                (nat.times b 
                                                                   n))) 
                                                          (logic.rewrite_r 
                                                             nat.nat 
                                                             (nat.times n 
                                                                (div_mod.div 
                                                                   m n)) 
                                                             (__:
                                                              (sttfa.etap 
                                                                 (sttfa.p 
                                                                    nat.nat)) =>
                                                              logic.eq 
                                                                nat.nat 
                                                                (nat.minus 
                                                                   (nat.plus 
                                                                    (nat.minus 
                                                                    (nat.times 
                                                                    a __) 
                                                                    (nat.times 
                                                                    a 
                                                                    (nat.times 
                                                                    (div_mod.div 
                                                                    m n) n))) 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n))) 
                                                                   (nat.times 
                                                                    b n)) 
                                                                (nat.minus 
                                                                   (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n)) 
                                                                   (nat.times 
                                                                    b n))) 
                                                             (logic.rewrite_r 
                                                                nat.nat 
                                                                (nat.times n 
                                                                   (nat.times 
                                                                    a 
                                                                    (div_mod.div 
                                                                    m n))) 
                                                                (__:
                                                                 (sttfa.etap 
                                                                    (
                                                                    sttfa.p 
                                                                    nat.nat)) =>
                                                                 logic.eq 
                                                                   nat.nat 
                                                                   (nat.minus 
                                                                    (nat.plus 
                                                                    (nat.minus 
                                                                    __ 
                                                                    (nat.times 
                                                                    a 
                                                                    (nat.times 
                                                                    (div_mod.div 
                                                                    m n) n))) 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n))) 
                                                                    (nat.times 
                                                                    b n)) 
                                                                   (nat.minus 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n)) 
                                                                    (nat.times 
                                                                    b n))) 
                                                                (logic.rewrite_r 
                                                                   nat.nat 
                                                                   (nat.times 
                                                                    n 
                                                                    (div_mod.div 
                                                                    m n)) 
                                                                   (__:
                                                                    (
                                                                    sttfa.etap 
                                                                    (sttfa.p 
                                                                    nat.nat)) =>
                                                                    logic.eq 
                                                                    nat.nat 
                                                                    (nat.minus 
                                                                    (nat.plus 
                                                                    (nat.minus 
                                                                    (nat.times 
                                                                    n 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.div 
                                                                    m n))) 
                                                                    (nat.times 
                                                                    a __)) 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n))) 
                                                                    (nat.times 
                                                                    b n)) 
                                                                    (nat.minus 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n)) 
                                                                    (nat.times 
                                                                    b n))) 
                                                                   (logic.rewrite_r 
                                                                    nat.nat 
                                                                    (nat.times 
                                                                    n 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.div 
                                                                    m n))) 
                                                                    (__:
                                                                    (sttfa.etap 
                                                                    (sttfa.p 
                                                                    nat.nat)) =>
                                                                    logic.eq 
                                                                    nat.nat 
                                                                    (nat.minus 
                                                                    (nat.plus 
                                                                    (nat.minus 
                                                                    (nat.times 
                                                                    n 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.div 
                                                                    m n))) __) 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n))) 
                                                                    (nat.times 
                                                                    b n)) 
                                                                    (nat.minus 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n)) 
                                                                    (nat.times 
                                                                    b n))) 
                                                                    (logic.rewrite_l 
                                                                    nat.nat 
                                                                    nat.O 
                                                                    (__:
                                                                    (sttfa.etap 
                                                                    (sttfa.p 
                                                                    nat.nat)) =>
                                                                    logic.eq 
                                                                    nat.nat 
                                                                    (nat.minus 
                                                                    (nat.plus 
                                                                    __ 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n))) 
                                                                    (nat.times 
                                                                    b n)) 
                                                                    (nat.minus 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n)) 
                                                                    (nat.times 
                                                                    b n))) 
                                                                    (logic.rewrite_l 
                                                                    nat.nat 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n)) 
                                                                    (__:
                                                                    (sttfa.etap 
                                                                    (sttfa.p 
                                                                    nat.nat)) =>
                                                                    logic.eq 
                                                                    nat.nat 
                                                                    (nat.minus 
                                                                    __ 
                                                                    (nat.times 
                                                                    b n)) 
                                                                    (nat.minus 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n)) 
                                                                    (nat.times 
                                                                    b n))) 
                                                                    (logic.rewrite_r 
                                                                    nat.nat 
                                                                    (nat.times 
                                                                    n b) 
                                                                    (__:
                                                                    (sttfa.etap 
                                                                    (sttfa.p 
                                                                    nat.nat)) =>
                                                                    logic.eq 
                                                                    nat.nat 
                                                                    (nat.minus 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n)) __) 
                                                                    (nat.minus 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n)) 
                                                                    (nat.times 
                                                                    b n))) 
                                                                    (logic.rewrite_r 
                                                                    nat.nat 
                                                                    (gcd.gcd_aux 
                                                                    q n 
                                                                    (div_mod.mod 
                                                                    m n)) 
                                                                    (__:
                                                                    (sttfa.etap 
                                                                    (sttfa.p 
                                                                    nat.nat)) =>
                                                                    logic.eq 
                                                                    nat.nat 
                                                                    __ 
                                                                    (nat.minus 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n)) 
                                                                    (nat.times 
                                                                    b n))) 
                                                                    (logic.rewrite_r 
                                                                    nat.nat 
                                                                    (nat.times 
                                                                    n b) 
                                                                    (__:
                                                                    (sttfa.etap 
                                                                    (sttfa.p 
                                                                    nat.nat)) =>
                                                                    logic.eq 
                                                                    nat.nat 
                                                                    (gcd.gcd_aux 
                                                                    q n 
                                                                    (div_mod.mod 
                                                                    m n)) 
                                                                    (nat.minus 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n)) __)) 
                                                                    (logic.rewrite_r 
                                                                    nat.nat 
                                                                    (gcd.gcd_aux 
                                                                    q n 
                                                                    (div_mod.mod 
                                                                    m n)) 
                                                                    (__:
                                                                    (sttfa.etap 
                                                                    (sttfa.p 
                                                                    nat.nat)) =>
                                                                    logic.eq 
                                                                    nat.nat 
                                                                    (gcd.gcd_aux 
                                                                    q n 
                                                                    (div_mod.mod 
                                                                    m n)) __) 
                                                                    (logic.refl 
                                                                    nat.nat 
                                                                    (gcd.gcd_aux 
                                                                    q n 
                                                                    (div_mod.mod 
                                                                    m n))) 
                                                                    (nat.minus 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n)) 
                                                                    (nat.times 
                                                                    n b)) 
                                                                    (gcd.let_clause_1544 
                                                                    p q Hind 
                                                                    m n posn 
                                                                    lenm 
                                                                    lenS 
                                                                    ndivnm a 
                                                                    _clearme 
                                                                    b 
                                                                    _clearme0 
                                                                    H)) 
                                                                    (nat.times 
                                                                    b n) 
                                                                    (nat.commutative_times 
                                                                    b n)) 
                                                                    (nat.minus 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n)) 
                                                                    (nat.times 
                                                                    n b)) 
                                                                    (gcd.let_clause_1544 
                                                                    p q Hind 
                                                                    m n posn 
                                                                    lenm 
                                                                    lenS 
                                                                    ndivnm a 
                                                                    _clearme 
                                                                    b 
                                                                    _clearme0 
                                                                    H)) 
                                                                    (nat.times 
                                                                    b n) 
                                                                    (nat.commutative_times 
                                                                    b n)) 
                                                                    (nat.plus 
                                                                    nat.O 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n))) 
                                                                    (nat.plus_O_n 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n)))) 
                                                                    (nat.minus 
                                                                    (nat.times 
                                                                    n 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.div 
                                                                    m n))) 
                                                                    (nat.times 
                                                                    n 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.div 
                                                                    m n)))) 
                                                                    (nat.minus_n_n 
                                                                    (nat.times 
                                                                    n 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.div 
                                                                    m n))))) 
                                                                    (nat.times 
                                                                    a 
                                                                    (nat.times 
                                                                    n 
                                                                    (div_mod.div 
                                                                    m n))) 
                                                                    (nat.times_times 
                                                                    a n 
                                                                    (div_mod.div 
                                                                    m n))) 
                                                                   (nat.times 
                                                                    (div_mod.div 
                                                                    m n) n) 
                                                                   (nat.commutative_times 
                                                                    (div_mod.div 
                                                                    m n) n)) 
                                                                (nat.times a 
                                                                   (nat.times 
                                                                    n 
                                                                    (div_mod.div 
                                                                    m n))) 
                                                                (nat.times_times 
                                                                   a n 
                                                                   (div_mod.div 
                                                                    m n))) 
                                                             (nat.times 
                                                                (div_mod.div 
                                                                   m n) n) 
                                                             (nat.commutative_times 
                                                                (div_mod.div 
                                                                   m n) n)) 
                                                          (nat.minus 
                                                             (nat.plus 
                                                                (nat.times a 
                                                                   (nat.times 
                                                                    (div_mod.div 
                                                                    m n) n)) 
                                                                (nat.times a 
                                                                   (div_mod.mod 
                                                                    m n))) 
                                                             (nat.times a 
                                                                (nat.times 
                                                                   (div_mod.div 
                                                                    m n) n))) 
                                                          (nat.plus_minus 
                                                             (nat.times a 
                                                                (nat.times 
                                                                   (div_mod.div 
                                                                    m n) n)) 
                                                             (nat.times a 
                                                                (nat.times 
                                                                   (div_mod.div 
                                                                    m n) n)) 
                                                             (nat.times a 
                                                                (div_mod.mod 
                                                                   m n)) 
                                                             (nat.le_n 
                                                                (nat.times a 
                                                                   (nat.times 
                                                                    (div_mod.div 
                                                                    m n) n))))) 
                                                       (nat.plus 
                                                          (nat.times a 
                                                             (div_mod.mod m n)) 
                                                          (nat.times a 
                                                             (nat.times 
                                                                (div_mod.div 
                                                                   m n) n))) 
                                                       (nat.commutative_plus 
                                                          (nat.times a 
                                                             (nat.times 
                                                                (div_mod.div 
                                                                   m n) n)) 
                                                          (nat.times a 
                                                             (div_mod.mod m n)))) 
                                                    (nat.minus 
                                                       (nat.plus 
                                                          (nat.times a 
                                                             (div_mod.mod m n)) 
                                                          (nat.times a 
                                                             (nat.times 
                                                                (div_mod.div 
                                                                   m n) n))) 
                                                       (nat.plus 
                                                          (nat.times a 
                                                             (nat.times 
                                                                (div_mod.div 
                                                                   m n) n)) 
                                                          (nat.times b n))) 
                                                    (nat.minus_plus 
                                                       (nat.plus 
                                                          (nat.times a 
                                                             (div_mod.mod m n)) 
                                                          (nat.times a 
                                                             (nat.times 
                                                                (div_mod.div 
                                                                   m n) n))) 
                                                       (nat.times a 
                                                          (nat.times 
                                                             (div_mod.div m n) 
                                                             n)) 
                                                       (nat.times b n))) 
                                                 (nat.times a 
                                                    (nat.plus 
                                                       (div_mod.mod m n) 
                                                       (nat.times 
                                                          (div_mod.div m n) n))) 
                                                 (nat.distributive_times_plus 
                                                    a (div_mod.mod m n) 
                                                    (nat.times 
                                                       (div_mod.div m n) n))) 
                                              (nat.plus 
                                                 (nat.times 
                                                    (div_mod.div m n) n) 
                                                 (div_mod.mod m n)) 
                                              (nat.commutative_plus 
                                                 (div_mod.mod m n) 
                                                 (nat.times 
                                                    (div_mod.div m n) n))) 
                                           (nat.times 
                                              (nat.times a (div_mod.div m n)) 
                                              n) 
                                           (nat.associative_times a 
                                              (div_mod.div m n) n)) m 
                                        (div_mod.div_mod m n)) 
                                     (nat.times 
                                        (nat.plus 
                                           (nat.times a (div_mod.div m n)) b) 
                                        n) 
                                     (nat.distributive_times_plus_r n 
                                        (nat.times a (div_mod.div m n)) b)) 
                                  (nat.plus b (nat.times a (div_mod.div m n))) 
                                  (nat.commutative_plus 
                                     (nat.times a (div_mod.div m n)) b))))) 
                      (gcd.gcd_aux q n (div_mod.mod m n)) H) 
                   (H:
                    (sttfa.eps 
                       (logic.eq nat.nat 
                          (nat.minus (nat.times b n) 
                             (nat.times a (div_mod.mod m n))) 
                          (gcd.gcd_aux q n (div_mod.mod m n)))) =>
                    logic.eq_ind nat.nat 
                      (nat.minus (nat.times b n) 
                         (nat.times a (div_mod.mod m n))) 
                      (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.Ex nat.nat 
                         (a0:(sttfa.etap (sttfa.p nat.nat)) =>
                          connectives.Ex nat.nat 
                            (b0:(sttfa.etap (sttfa.p nat.nat)) =>
                             connectives.Or 
                               (logic.eq nat.nat 
                                  (nat.minus (nat.times a0 n) 
                                     (nat.times b0 m)) x_1) 
                               (logic.eq nat.nat 
                                  (nat.minus (nat.times b0 m) 
                                     (nat.times a0 n)) x_1)))) 
                      (z:(sttfa.etap (sttfa.p sttfa.bool)) =>
                       f:
                       (sttfa.eps 
                          (sttfa.forall nat.nat 
                             (x:(sttfa.etap (sttfa.p nat.nat)) =>
                              sttfa.impl 
                                (connectives.Ex nat.nat 
                                   (b0:(sttfa.etap (sttfa.p nat.nat)) =>
                                    connectives.Or 
                                      (logic.eq nat.nat 
                                         (nat.minus (nat.times x n) 
                                            (nat.times b0 m)) 
                                         (nat.minus (nat.times b n) 
                                            (nat.times a (div_mod.mod m n)))) 
                                      (logic.eq nat.nat 
                                         (nat.minus (nat.times b0 m) 
                                            (nat.times x n)) 
                                         (nat.minus (nat.times b n) 
                                            (nat.times a (div_mod.mod m n)))))) 
                                z))) =>
                       f (nat.plus b (nat.times a (div_mod.div m n))) 
                         (z0:(sttfa.etap (sttfa.p sttfa.bool)) =>
                          f0:
                          (sttfa.eps 
                             (sttfa.forall nat.nat 
                                (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                 sttfa.impl 
                                   (connectives.Or 
                                      (logic.eq nat.nat 
                                         (nat.minus 
                                            (nat.times 
                                               (nat.plus b 
                                                  (nat.times a 
                                                     (div_mod.div m n))) n) 
                                            (nat.times x m)) 
                                         (nat.minus (nat.times b n) 
                                            (nat.times a (div_mod.mod m n)))) 
                                      (logic.eq nat.nat 
                                         (nat.minus (nat.times x m) 
                                            (nat.times 
                                               (nat.plus b 
                                                  (nat.times a 
                                                     (div_mod.div m n))) n)) 
                                         (nat.minus (nat.times b n) 
                                            (nat.times a (div_mod.mod m n))))) 
                                   z0))) =>
                          f0 a 
                            (z1:(sttfa.etap (sttfa.p sttfa.bool)) =>
                             l:
                             (sttfa.eps 
                                (sttfa.impl 
                                   (logic.eq nat.nat 
                                      (nat.minus 
                                         (nat.times 
                                            (nat.plus b 
                                               (nat.times a (div_mod.div m n))) 
                                            n) (nat.times a m)) 
                                      (nat.minus (nat.times b n) 
                                         (nat.times a (div_mod.mod m n)))) z1)) =>
                             r:
                             (sttfa.eps 
                                (sttfa.impl 
                                   (logic.eq nat.nat 
                                      (nat.minus (nat.times a m) 
                                         (nat.times 
                                            (nat.plus b 
                                               (nat.times a (div_mod.div m n))) 
                                            n)) 
                                      (nat.minus (nat.times b n) 
                                         (nat.times a (div_mod.mod m n)))) z1)) =>
                             l 
                               (logic.eq_ind_r nat.nat 
                                  (nat.plus (nat.times b n) 
                                     (nat.times 
                                        (nat.times a (div_mod.div m n)) n)) 
                                  (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq nat.nat 
                                     (nat.minus x (nat.times a m)) 
                                     (nat.minus (nat.times b n) 
                                        (nat.times a (div_mod.mod m n)))) 
                                  (logic.eq_ind_r nat.nat 
                                     (nat.plus 
                                        (nat.times (div_mod.div m n) n) 
                                        (div_mod.mod m n)) 
                                     (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq nat.nat 
                                        (nat.minus 
                                           (nat.plus (nat.times b n) 
                                              (nat.times 
                                                 (nat.times a 
                                                    (div_mod.div m n)) n)) 
                                           (nat.times a x)) 
                                        (nat.minus (nat.times b n) 
                                           (nat.times a (div_mod.mod m n)))) 
                                     (logic.eq_ind_r nat.nat 
                                        (nat.plus 
                                           (nat.times a 
                                              (nat.times (div_mod.div m n) n)) 
                                           (nat.times a (div_mod.mod m n))) 
                                        (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq nat.nat 
                                           (nat.minus 
                                              (nat.plus (nat.times b n) 
                                                 (nat.times 
                                                    (nat.times a 
                                                       (div_mod.div m n)) n)) 
                                              x) 
                                           (nat.minus (nat.times b n) 
                                              (nat.times a (div_mod.mod m n)))) 
                                        (logic.eq_ind_r nat.nat 
                                           (nat.times a 
                                              (nat.times (div_mod.div m n) n)) 
                                           (x:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq nat.nat 
                                              (nat.minus 
                                                 (nat.plus (nat.times b n) x) 
                                                 (nat.plus 
                                                    (nat.times a 
                                                       (nat.times 
                                                          (div_mod.div m n) n)) 
                                                    (nat.times a 
                                                       (div_mod.mod m n)))) 
                                              (nat.minus (nat.times b n) 
                                                 (nat.times a 
                                                    (div_mod.mod m n)))) 
                                           (logic.eq_ind nat.nat 
                                              (nat.minus 
                                                 (nat.minus 
                                                    (nat.plus 
                                                       (nat.times b n) 
                                                       (nat.times a 
                                                          (nat.times 
                                                             (div_mod.div m n) 
                                                             n))) 
                                                    (nat.times a 
                                                       (nat.times 
                                                          (div_mod.div m n) n))) 
                                                 (nat.times a 
                                                    (div_mod.mod m n))) 
                                              (x_1:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq nat.nat x_1 
                                                 (nat.minus (nat.times b n) 
                                                    (nat.times a 
                                                       (div_mod.mod m n)))) 
                                              (logic.eq_ind nat.nat 
                                                 (nat.plus 
                                                    (nat.times a 
                                                       (nat.times 
                                                          (div_mod.div m n) n)) 
                                                    (nat.times b n)) 
                                                 (x_1:
                                                  (sttfa.etap 
                                                     (sttfa.p nat.nat)) =>
                                                  logic.eq nat.nat 
                                                    (nat.minus 
                                                       (nat.minus x_1 
                                                          (nat.times a 
                                                             (nat.times 
                                                                (div_mod.div 
                                                                   m n) n))) 
                                                       (nat.times a 
                                                          (div_mod.mod m n))) 
                                                    (nat.minus 
                                                       (nat.times b n) 
                                                       (nat.times a 
                                                          (div_mod.mod m n)))) 
                                                 (logic.eq_ind nat.nat 
                                                    (nat.plus 
                                                       (nat.minus 
                                                          (nat.times a 
                                                             (nat.times 
                                                                (div_mod.div 
                                                                   m n) n)) 
                                                          (nat.times a 
                                                             (nat.times 
                                                                (div_mod.div 
                                                                   m n) n))) 
                                                       (nat.times b n)) 
                                                    (x_1:
                                                     (sttfa.etap 
                                                        (sttfa.p nat.nat)) =>
                                                     logic.eq nat.nat 
                                                       (nat.minus x_1 
                                                          (nat.times a 
                                                             (div_mod.mod m n))) 
                                                       (nat.minus 
                                                          (nat.times b n) 
                                                          (nat.times a 
                                                             (div_mod.mod m n)))) 
                                                    (logic.rewrite_r nat.nat 
                                                       (nat.times n 
                                                          (div_mod.div m n)) 
                                                       (__:
                                                        (sttfa.etap 
                                                           (sttfa.p nat.nat)) =>
                                                        logic.eq nat.nat 
                                                          (nat.minus 
                                                             (nat.plus 
                                                                (nat.minus 
                                                                   (nat.times 
                                                                    a __) 
                                                                   (nat.times 
                                                                    a 
                                                                    (nat.times 
                                                                    (div_mod.div 
                                                                    m n) n))) 
                                                                (nat.times b 
                                                                   n)) 
                                                             (nat.times a 
                                                                (div_mod.mod 
                                                                   m n))) 
                                                          (nat.minus 
                                                             (nat.times b n) 
                                                             (nat.times a 
                                                                (div_mod.mod 
                                                                   m n)))) 
                                                       (logic.rewrite_r 
                                                          nat.nat 
                                                          (nat.times n 
                                                             (nat.times a 
                                                                (div_mod.div 
                                                                   m n))) 
                                                          (__:
                                                           (sttfa.etap 
                                                              (sttfa.p 
                                                                 nat.nat)) =>
                                                           logic.eq nat.nat 
                                                             (nat.minus 
                                                                (nat.plus 
                                                                   (nat.minus 
                                                                    __ 
                                                                    (nat.times 
                                                                    a 
                                                                    (nat.times 
                                                                    (div_mod.div 
                                                                    m n) n))) 
                                                                   (nat.times 
                                                                    b n)) 
                                                                (nat.times a 
                                                                   (div_mod.mod 
                                                                    m n))) 
                                                             (nat.minus 
                                                                (nat.times b 
                                                                   n) 
                                                                (nat.times a 
                                                                   (div_mod.mod 
                                                                    m n)))) 
                                                          (logic.rewrite_r 
                                                             nat.nat 
                                                             (nat.times n 
                                                                (div_mod.div 
                                                                   m n)) 
                                                             (__:
                                                              (sttfa.etap 
                                                                 (sttfa.p 
                                                                    nat.nat)) =>
                                                              logic.eq 
                                                                nat.nat 
                                                                (nat.minus 
                                                                   (nat.plus 
                                                                    (nat.minus 
                                                                    (nat.times 
                                                                    n 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.div 
                                                                    m n))) 
                                                                    (nat.times 
                                                                    a __)) 
                                                                    (nat.times 
                                                                    b n)) 
                                                                   (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n))) 
                                                                (nat.minus 
                                                                   (nat.times 
                                                                    b n) 
                                                                   (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n)))) 
                                                             (logic.rewrite_r 
                                                                nat.nat 
                                                                (nat.times n 
                                                                   (nat.times 
                                                                    a 
                                                                    (div_mod.div 
                                                                    m n))) 
                                                                (__:
                                                                 (sttfa.etap 
                                                                    (
                                                                    sttfa.p 
                                                                    nat.nat)) =>
                                                                 logic.eq 
                                                                   nat.nat 
                                                                   (nat.minus 
                                                                    (nat.plus 
                                                                    (nat.minus 
                                                                    (nat.times 
                                                                    n 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.div 
                                                                    m n))) __) 
                                                                    (nat.times 
                                                                    b n)) 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n))) 
                                                                   (nat.minus 
                                                                    (nat.times 
                                                                    b n) 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n)))) 
                                                                (logic.rewrite_l 
                                                                   nat.nat 
                                                                   nat.O 
                                                                   (__:
                                                                    (
                                                                    sttfa.etap 
                                                                    (sttfa.p 
                                                                    nat.nat)) =>
                                                                    logic.eq 
                                                                    nat.nat 
                                                                    (nat.minus 
                                                                    (nat.plus 
                                                                    __ 
                                                                    (nat.times 
                                                                    b n)) 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n))) 
                                                                    (nat.minus 
                                                                    (nat.times 
                                                                    b n) 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n)))) 
                                                                   (logic.rewrite_r 
                                                                    nat.nat 
                                                                    (nat.times 
                                                                    n b) 
                                                                    (__:
                                                                    (sttfa.etap 
                                                                    (sttfa.p 
                                                                    nat.nat)) =>
                                                                    logic.eq 
                                                                    nat.nat 
                                                                    (nat.minus 
                                                                    (nat.plus 
                                                                    nat.O __) 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n))) 
                                                                    (nat.minus 
                                                                    (nat.times 
                                                                    b n) 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n)))) 
                                                                    (logic.rewrite_l 
                                                                    nat.nat 
                                                                    (nat.times 
                                                                    n b) 
                                                                    (__:
                                                                    (sttfa.etap 
                                                                    (sttfa.p 
                                                                    nat.nat)) =>
                                                                    logic.eq 
                                                                    nat.nat 
                                                                    (nat.minus 
                                                                    __ 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n))) 
                                                                    (nat.minus 
                                                                    (nat.times 
                                                                    b n) 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n)))) 
                                                                    (logic.rewrite_r 
                                                                    nat.nat 
                                                                    (gcd.gcd_aux 
                                                                    q n 
                                                                    (div_mod.mod 
                                                                    m n)) 
                                                                    (__:
                                                                    (sttfa.etap 
                                                                    (sttfa.p 
                                                                    nat.nat)) =>
                                                                    logic.eq 
                                                                    nat.nat 
                                                                    __ 
                                                                    (nat.minus 
                                                                    (nat.times 
                                                                    b n) 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n)))) 
                                                                    (logic.rewrite_r 
                                                                    nat.nat 
                                                                    (nat.times 
                                                                    n b) 
                                                                    (__:
                                                                    (sttfa.etap 
                                                                    (sttfa.p 
                                                                    nat.nat)) =>
                                                                    logic.eq 
                                                                    nat.nat 
                                                                    (gcd.gcd_aux 
                                                                    q n 
                                                                    (div_mod.mod 
                                                                    m n)) 
                                                                    (nat.minus 
                                                                    __ 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n)))) 
                                                                    (logic.rewrite_r 
                                                                    nat.nat 
                                                                    (gcd.gcd_aux 
                                                                    q n 
                                                                    (div_mod.mod 
                                                                    m n)) 
                                                                    (__:
                                                                    (sttfa.etap 
                                                                    (sttfa.p 
                                                                    nat.nat)) =>
                                                                    logic.eq 
                                                                    nat.nat 
                                                                    (gcd.gcd_aux 
                                                                    q n 
                                                                    (div_mod.mod 
                                                                    m n)) __) 
                                                                    (logic.refl 
                                                                    nat.nat 
                                                                    (gcd.gcd_aux 
                                                                    q n 
                                                                    (div_mod.mod 
                                                                    m n))) 
                                                                    (nat.minus 
                                                                    (nat.times 
                                                                    n b) 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n))) 
                                                                    (gcd.let_clause_15441 
                                                                    p q Hind 
                                                                    m n posn 
                                                                    lenm 
                                                                    lenS 
                                                                    ndivnm a 
                                                                    _clearme 
                                                                    b 
                                                                    _clearme0 
                                                                    H)) 
                                                                    (nat.times 
                                                                    b n) 
                                                                    (nat.commutative_times 
                                                                    b n)) 
                                                                    (nat.minus 
                                                                    (nat.times 
                                                                    n b) 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.mod 
                                                                    m n))) 
                                                                    (gcd.let_clause_15441 
                                                                    p q Hind 
                                                                    m n posn 
                                                                    lenm 
                                                                    lenS 
                                                                    ndivnm a 
                                                                    _clearme 
                                                                    b 
                                                                    _clearme0 
                                                                    H)) 
                                                                    (nat.plus 
                                                                    nat.O 
                                                                    (nat.times 
                                                                    n b)) 
                                                                    (nat.plus_O_n 
                                                                    (nat.times 
                                                                    n b))) 
                                                                    (nat.times 
                                                                    b n) 
                                                                    (nat.commutative_times 
                                                                    b n)) 
                                                                   (nat.minus 
                                                                    (nat.times 
                                                                    n 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.div 
                                                                    m n))) 
                                                                    (nat.times 
                                                                    n 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.div 
                                                                    m n)))) 
                                                                   (nat.minus_n_n 
                                                                    (nat.times 
                                                                    n 
                                                                    (nat.times 
                                                                    a 
                                                                    (div_mod.div 
                                                                    m n))))) 
                                                                (nat.times a 
                                                                   (nat.times 
                                                                    n 
                                                                    (div_mod.div 
                                                                    m n))) 
                                                                (nat.times_times 
                                                                   a n 
                                                                   (div_mod.div 
                                                                    m n))) 
                                                             (nat.times 
                                                                (div_mod.div 
                                                                   m n) n) 
                                                             (nat.commutative_times 
                                                                (div_mod.div 
                                                                   m n) n)) 
                                                          (nat.times a 
                                                             (nat.times n 
                                                                (div_mod.div 
                                                                   m n))) 
                                                          (nat.times_times a 
                                                             n 
                                                             (div_mod.div m n))) 
                                                       (nat.times 
                                                          (div_mod.div m n) n) 
                                                       (nat.commutative_times 
                                                          (div_mod.div m n) n)) 
                                                    (nat.minus 
                                                       (nat.plus 
                                                          (nat.times a 
                                                             (nat.times 
                                                                (div_mod.div 
                                                                   m n) n)) 
                                                          (nat.times b n)) 
                                                       (nat.times a 
                                                          (nat.times 
                                                             (div_mod.div m n) 
                                                             n))) 
                                                    (nat.plus_minus 
                                                       (nat.times a 
                                                          (nat.times 
                                                             (div_mod.div m n) 
                                                             n)) 
                                                       (nat.times a 
                                                          (nat.times 
                                                             (div_mod.div m n) 
                                                             n)) 
                                                       (nat.times b n) 
                                                       (nat.le_n 
                                                          (nat.times a 
                                                             (nat.times 
                                                                (div_mod.div 
                                                                   m n) n))))) 
                                                 (nat.plus (nat.times b n) 
                                                    (nat.times a 
                                                       (nat.times 
                                                          (div_mod.div m n) n))) 
                                                 (nat.commutative_plus 
                                                    (nat.times a 
                                                       (nat.times 
                                                          (div_mod.div m n) n)) 
                                                    (nat.times b n))) 
                                              (nat.minus 
                                                 (nat.plus (nat.times b n) 
                                                    (nat.times a 
                                                       (nat.times 
                                                          (div_mod.div m n) n))) 
                                                 (nat.plus 
                                                    (nat.times a 
                                                       (nat.times 
                                                          (div_mod.div m n) n)) 
                                                    (nat.times a 
                                                       (div_mod.mod m n)))) 
                                              (nat.minus_plus 
                                                 (nat.plus (nat.times b n) 
                                                    (nat.times a 
                                                       (nat.times 
                                                          (div_mod.div m n) n))) 
                                                 (nat.times a 
                                                    (nat.times 
                                                       (div_mod.div m n) n)) 
                                                 (nat.times a 
                                                    (div_mod.mod m n)))) 
                                           (nat.times 
                                              (nat.times a (div_mod.div m n)) 
                                              n) 
                                           (nat.associative_times a 
                                              (div_mod.div m n) n)) 
                                        (nat.times a 
                                           (nat.plus 
                                              (nat.times (div_mod.div m n) n) 
                                              (div_mod.mod m n))) 
                                        (nat.distributive_times_plus a 
                                           (nat.times (div_mod.div m n) n) 
                                           (div_mod.mod m n))) m 
                                     (div_mod.div_mod m n)) 
                                  (nat.times 
                                     (nat.plus b 
                                        (nat.times a (div_mod.div m n))) n) 
                                  (nat.distributive_times_plus_r n b 
                                     (nat.times a (div_mod.div m n))))))) 
                      (gcd.gcd_aux q n (div_mod.mod m n)) H) _clearme0) 
                _clearme) 
             (Hind n (div_mod.mod m n) 
                (logic.match_Or_prop (nat.lt nat.O (div_mod.mod m n)) 
                   (logic.eq nat.nat nat.O (div_mod.mod m n)) 
                   (nat.lt nat.O (div_mod.mod m n)) 
                   (auto:(sttfa.eps (nat.lt nat.O (div_mod.mod m n))) => auto) 
                   (modO:
                    (sttfa.eps (logic.eq nat.nat nat.O (div_mod.mod m n))) =>
                    logic.falsity (nat.lt nat.O (div_mod.mod m n)) 
                      (logic.absurd (primes.divides n m) 
                         (primes.mod_O_to_divides n m posn 
                            (logic.rewrite_l nat.nat nat.O 
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq nat.nat __ nat.O) 
                               (logic.refl nat.nat nat.O) (div_mod.mod m n) 
                               modO)) ndivnm)) 
                   (nat.le_to_or_lt_eq nat.O (div_mod.mod m n) 
                      (nat.le_O_n (div_mod.mod m n)))) 
                (nat.lt_to_le (div_mod.mod m n) n 
                   (div_mod.lt_mod_m_m m n posn)) 
                (nat.le_S_S_to_le (div_mod.mod m n) q 
                   (nat.transitive_le (nat.S (div_mod.mod m n)) n (nat.S q) 
                      (div_mod.lt_mod_m_m m n posn) lenS)))) 
          (gcd.gcd_aux (nat.S q) m n) 
          (gcd.not_divides_to_gcd_aux q m n posn ndivnm)) 
       (primes.decidable_divides n m)) p.

def let_clause_1549 :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.lt nat.O n) 
             (sttfa.impl (logic.eq nat.nat nat.O m) 
                (sttfa.forall nat.nat 
                   (x1106:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat x1106 (nat.minus x1106 m)))))))
  :=
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  posn:(sttfa.eps (nat.lt nat.O n)) =>
  eqm0:(sttfa.eps (logic.eq nat.nat nat.O m)) =>
  x1106:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.rewrite_l nat.nat nat.O 
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq nat.nat x1106 (nat.minus x1106 __)) (nat.minus_n_O x1106) m 
    eqm0.

def let_clause_15491 :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (logic.eq nat.nat nat.O n) 
             (sttfa.forall nat.nat 
                (x1106:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat x1106 (nat.minus x1106 n))))))
  :=
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  eqn0:(sttfa.eps (logic.eq nat.nat nat.O n)) =>
  x1106:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.rewrite_l nat.nat nat.O 
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq nat.nat x1106 (nat.minus x1106 __)) (nat.minus_n_O x1106) n 
    eqn0.

def let_clause_1551 :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (logic.eq nat.nat nat.O n) 
             (sttfa.forall nat.nat 
                (x347:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat n (nat.times x347 n))))))
  :=
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  eqn0:(sttfa.eps (logic.eq nat.nat nat.O n)) =>
  x347:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.rewrite_l nat.nat nat.O 
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq nat.nat n (nat.times x347 __)) 
    (logic.rewrite_l nat.nat nat.O 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat __ (nat.times x347 nat.O)) (nat.times_n_O x347) n 
       eqn0) n eqn0.

def eq_minus_gcd :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.Ex nat.nat 
             (a:(sttfa.etap (sttfa.p nat.nat)) =>
              connectives.Ex nat.nat 
                (b:(sttfa.etap (sttfa.p nat.nat)) =>
                 connectives.Or 
                   (logic.eq nat.nat 
                      (nat.minus (nat.times a n) (nat.times b m)) 
                      (gcd.gcd n m)) 
                   (logic.eq nat.nat 
                      (nat.minus (nat.times b m) (nat.times a n)) 
                      (gcd.gcd n m)))))))
  :=
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.match_Or_prop (nat.lt nat.O n) (logic.eq nat.nat nat.O n) 
    (connectives.Ex nat.nat 
       (a:(sttfa.etap (sttfa.p nat.nat)) =>
        connectives.Ex nat.nat 
          (b:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.Or 
             (logic.eq nat.nat (nat.minus (nat.times a n) (nat.times b m)) 
                (gcd.gcd n m)) 
             (logic.eq nat.nat (nat.minus (nat.times b m) (nat.times a n)) 
                (gcd.gcd n m))))) 
    (posn:(sttfa.eps (nat.lt nat.O n)) =>
     logic.match_Or_prop (nat.lt nat.O m) (logic.eq nat.nat nat.O m) 
       (connectives.Ex nat.nat 
          (a:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.Ex nat.nat 
             (b:(sttfa.etap (sttfa.p nat.nat)) =>
              connectives.Or 
                (logic.eq nat.nat 
                   (nat.minus (nat.times a n) (nat.times b m)) (gcd.gcd n m)) 
                (logic.eq nat.nat 
                   (nat.minus (nat.times b m) (nat.times a n)) (gcd.gcd n m))))) 
       (posm:(sttfa.eps (nat.lt nat.O m)) =>
        nat.leb_elim n m 
          (__:(sttfa.etap (sttfa.p bool.bool)) =>
           connectives.Ex nat.nat 
             (a:(sttfa.etap (sttfa.p nat.nat)) =>
              connectives.Ex nat.nat 
                (b:(sttfa.etap (sttfa.p nat.nat)) =>
                 connectives.Or 
                   (logic.eq nat.nat 
                      (nat.minus (nat.times a n) (nat.times b m)) 
                      (bool.match_bool_type nat.nat (gcd.gcd_aux n m n) 
                         (gcd.gcd_aux m n m) __)) 
                   (logic.eq nat.nat 
                      (nat.minus (nat.times b m) (nat.times a n)) 
                      (bool.match_bool_type nat.nat (gcd.gcd_aux n m n) 
                         (gcd.gcd_aux m n m) __))))) 
          (bool.sym_eq_match_bool_type_true nat.nat (gcd.gcd_aux n m n) 
             (gcd.gcd_aux m n m) 
             (y:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.le n m) 
                (connectives.Ex nat.nat 
                   (a:(sttfa.etap (sttfa.p nat.nat)) =>
                    connectives.Ex nat.nat 
                      (b:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.Or 
                         (logic.eq nat.nat 
                            (nat.minus (nat.times a n) (nat.times b m)) 
                            (bool.match_bool_type nat.nat 
                               (gcd.gcd_aux n m n) (gcd.gcd_aux m n m) 
                               bool.true)) 
                         (logic.eq nat.nat 
                            (nat.minus (nat.times b m) (nat.times a n)) y))))) 
             (bool.sym_eq_match_bool_type_true nat.nat (gcd.gcd_aux n m n) 
                (gcd.gcd_aux m n m) 
                (y:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (nat.le n m) 
                   (connectives.Ex nat.nat 
                      (a:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.Ex nat.nat 
                         (b:(sttfa.etap (sttfa.p nat.nat)) =>
                          connectives.Or 
                            (logic.eq nat.nat 
                               (nat.minus (nat.times a n) (nat.times b m)) y) 
                            (logic.eq nat.nat 
                               (nat.minus (nat.times b m) (nat.times a n)) 
                               (gcd.gcd_aux n m n)))))) 
                (lenm:(sttfa.eps (nat.le n m)) =>
                 gcd.eq_minus_gcd_aux n m n posn lenm (nat.le_n n)))) 
          (bool.sym_eq_match_bool_type_false nat.nat (gcd.gcd_aux n m n) 
             (gcd.gcd_aux m n m) 
             (y:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (connectives.Not (nat.le n m)) 
                (connectives.Ex nat.nat 
                   (a:(sttfa.etap (sttfa.p nat.nat)) =>
                    connectives.Ex nat.nat 
                      (b:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.Or 
                         (logic.eq nat.nat 
                            (nat.minus (nat.times a n) (nat.times b m)) 
                            (bool.match_bool_type nat.nat 
                               (gcd.gcd_aux n m n) (gcd.gcd_aux m n m) 
                               bool.false)) 
                         (logic.eq nat.nat 
                            (nat.minus (nat.times b m) (nat.times a n)) y))))) 
             (bool.sym_eq_match_bool_type_false nat.nat (gcd.gcd_aux n m n) 
                (gcd.gcd_aux m n m) 
                (y:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (connectives.Not (nat.le n m)) 
                   (connectives.Ex nat.nat 
                      (a:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.Ex nat.nat 
                         (b:(sttfa.etap (sttfa.p nat.nat)) =>
                          connectives.Or 
                            (logic.eq nat.nat 
                               (nat.minus (nat.times a n) (nat.times b m)) y) 
                            (logic.eq nat.nat 
                               (nat.minus (nat.times b m) (nat.times a n)) 
                               (gcd.gcd_aux m n m)))))) 
                (nlenm:(sttfa.eps (connectives.Not (nat.le n m))) =>
                 logic.match_ex_prop nat.nat 
                   (a:(sttfa.etap (sttfa.p nat.nat)) =>
                    connectives.Ex nat.nat 
                      (b:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.Or 
                         (logic.eq nat.nat 
                            (nat.minus (nat.times a m) (nat.times b n)) 
                            (gcd.gcd_aux m n m)) 
                         (logic.eq nat.nat 
                            (nat.minus (nat.times b n) (nat.times a m)) 
                            (gcd.gcd_aux m n m)))) 
                   (connectives.Ex nat.nat 
                      (a:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.Ex nat.nat 
                         (b:(sttfa.etap (sttfa.p nat.nat)) =>
                          connectives.Or 
                            (logic.eq nat.nat 
                               (nat.minus (nat.times a n) (nat.times b m)) 
                               (gcd.gcd_aux m n m)) 
                            (logic.eq nat.nat 
                               (nat.minus (nat.times b m) (nat.times a n)) 
                               (gcd.gcd_aux m n m))))) 
                   (a:(sttfa.etap (sttfa.p nat.nat)) =>
                    _clearme:
                    (sttfa.eps 
                       (connectives.Ex nat.nat 
                          (b:(sttfa.etap (sttfa.p nat.nat)) =>
                           connectives.Or 
                             (logic.eq nat.nat 
                                (nat.minus (nat.times a m) (nat.times b n)) 
                                (gcd.gcd_aux m n m)) 
                             (logic.eq nat.nat 
                                (nat.minus (nat.times b n) (nat.times a m)) 
                                (gcd.gcd_aux m n m))))) =>
                    logic.match_ex_prop nat.nat 
                      (b:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.Or 
                         (logic.eq nat.nat 
                            (nat.minus (nat.times a m) (nat.times b n)) 
                            (gcd.gcd_aux m n m)) 
                         (logic.eq nat.nat 
                            (nat.minus (nat.times b n) (nat.times a m)) 
                            (gcd.gcd_aux m n m))) 
                      (connectives.Ex nat.nat 
                         (a0:(sttfa.etap (sttfa.p nat.nat)) =>
                          connectives.Ex nat.nat 
                            (b:(sttfa.etap (sttfa.p nat.nat)) =>
                             connectives.Or 
                               (logic.eq nat.nat 
                                  (nat.minus (nat.times a0 n) (nat.times b m)) 
                                  (gcd.gcd_aux m n m)) 
                               (logic.eq nat.nat 
                                  (nat.minus (nat.times b m) (nat.times a0 n)) 
                                  (gcd.gcd_aux m n m))))) 
                      (b:(sttfa.etap (sttfa.p nat.nat)) =>
                       _clearme0:
                       (sttfa.eps 
                          (connectives.Or 
                             (logic.eq nat.nat 
                                (nat.minus (nat.times a m) (nat.times b n)) 
                                (gcd.gcd_aux m n m)) 
                             (logic.eq nat.nat 
                                (nat.minus (nat.times b n) (nat.times a m)) 
                                (gcd.gcd_aux m n m)))) =>
                       logic.match_Or_prop 
                         (logic.eq nat.nat 
                            (nat.minus (nat.times a m) (nat.times b n)) 
                            (gcd.gcd_aux m n m)) 
                         (logic.eq nat.nat 
                            (nat.minus (nat.times b n) (nat.times a m)) 
                            (gcd.gcd_aux m n m)) 
                         (connectives.Ex nat.nat 
                            (a0:(sttfa.etap (sttfa.p nat.nat)) =>
                             connectives.Ex nat.nat 
                               (b0:(sttfa.etap (sttfa.p nat.nat)) =>
                                connectives.Or 
                                  (logic.eq nat.nat 
                                     (nat.minus (nat.times a0 n) 
                                        (nat.times b0 m)) (gcd.gcd_aux m n m)) 
                                  (logic.eq nat.nat 
                                     (nat.minus (nat.times b0 m) 
                                        (nat.times a0 n)) (gcd.gcd_aux m n m))))) 
                         (H:
                          (sttfa.eps 
                             (logic.eq nat.nat 
                                (nat.minus (nat.times a m) (nat.times b n)) 
                                (gcd.gcd_aux m n m))) =>
                          z:(sttfa.etap (sttfa.p sttfa.bool)) =>
                          f:
                          (sttfa.eps 
                             (sttfa.forall nat.nat 
                                (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                 sttfa.impl 
                                   (connectives.Ex nat.nat 
                                      (b0:(sttfa.etap (sttfa.p nat.nat)) =>
                                       connectives.Or 
                                         (logic.eq nat.nat 
                                            (nat.minus (nat.times x n) 
                                               (nat.times b0 m)) 
                                            (gcd.gcd_aux m n m)) 
                                         (logic.eq nat.nat 
                                            (nat.minus (nat.times b0 m) 
                                               (nat.times x n)) 
                                            (gcd.gcd_aux m n m)))) z))) =>
                          f b 
                            (z0:(sttfa.etap (sttfa.p sttfa.bool)) =>
                             f2:
                             (sttfa.eps 
                                (sttfa.forall nat.nat 
                                   (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                    sttfa.impl 
                                      (connectives.Or 
                                         (logic.eq nat.nat 
                                            (nat.minus (nat.times b n) 
                                               (nat.times x m)) 
                                            (gcd.gcd_aux m n m)) 
                                         (logic.eq nat.nat 
                                            (nat.minus (nat.times x m) 
                                               (nat.times b n)) 
                                            (gcd.gcd_aux m n m))) z0))) =>
                             f2 a 
                               (z1:(sttfa.etap (sttfa.p sttfa.bool)) =>
                                l:
                                (sttfa.eps 
                                   (sttfa.impl 
                                      (logic.eq nat.nat 
                                         (nat.minus (nat.times b n) 
                                            (nat.times a m)) 
                                         (gcd.gcd_aux m n m)) z1)) =>
                                r:
                                (sttfa.eps 
                                   (sttfa.impl 
                                      (logic.eq nat.nat 
                                         (nat.minus (nat.times a m) 
                                            (nat.times b n)) 
                                         (gcd.gcd_aux m n m)) z1)) =>
                                r 
                                  (logic.rewrite_r nat.nat (nat.times m a) 
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq nat.nat 
                                        (nat.minus __ (nat.times b n)) 
                                        (gcd.gcd_aux m n m)) 
                                     (logic.rewrite_r nat.nat 
                                        (nat.times n b) 
                                        (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq nat.nat 
                                           (nat.minus (nat.times m a) __) 
                                           (gcd.gcd_aux m n m)) 
                                        (logic.rewrite_r nat.nat 
                                           (gcd.gcd_aux m n m) 
                                           (__:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq nat.nat __ 
                                              (gcd.gcd_aux m n m)) 
                                           (logic.refl nat.nat 
                                              (gcd.gcd_aux m n m)) 
                                           (nat.minus (nat.times m a) 
                                              (nat.times n b)) 
                                           (logic.rewrite_l nat.nat 
                                              (nat.times b n) 
                                              (__:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq nat.nat 
                                                 (nat.minus (nat.times m a) 
                                                    __) (gcd.gcd_aux m n m)) 
                                              (logic.rewrite_l nat.nat 
                                                 (nat.times a m) 
                                                 (__:
                                                  (sttfa.etap 
                                                     (sttfa.p nat.nat)) =>
                                                  logic.eq nat.nat 
                                                    (nat.minus __ 
                                                       (nat.times b n)) 
                                                    (gcd.gcd_aux m n m)) H 
                                                 (nat.times m a) 
                                                 (nat.commutative_times a m)) 
                                              (nat.times n b) 
                                              (nat.commutative_times b n))) 
                                        (nat.times b n) 
                                        (nat.commutative_times b n)) 
                                     (nat.times a m) 
                                     (nat.commutative_times a m))))) 
                         (H:
                          (sttfa.eps 
                             (logic.eq nat.nat 
                                (nat.minus (nat.times b n) (nat.times a m)) 
                                (gcd.gcd_aux m n m))) =>
                          z:(sttfa.etap (sttfa.p sttfa.bool)) =>
                          f:
                          (sttfa.eps 
                             (sttfa.forall nat.nat 
                                (y:(sttfa.etap (sttfa.p nat.nat)) =>
                                 sttfa.impl 
                                   (connectives.Ex nat.nat 
                                      (b0:(sttfa.etap (sttfa.p nat.nat)) =>
                                       connectives.Or 
                                         (logic.eq nat.nat 
                                            (nat.minus (nat.times y n) 
                                               (nat.times b0 m)) 
                                            (gcd.gcd_aux m n m)) 
                                         (logic.eq nat.nat 
                                            (nat.minus (nat.times b0 m) 
                                               (nat.times y n)) 
                                            (gcd.gcd_aux m n m)))) z))) =>
                          f b 
                            (z0:(sttfa.etap (sttfa.p sttfa.bool)) =>
                             f2:
                             (sttfa.eps 
                                (sttfa.forall nat.nat 
                                   (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                    sttfa.impl 
                                      (connectives.Or 
                                         (logic.eq nat.nat 
                                            (nat.minus (nat.times b n) 
                                               (nat.times x m)) 
                                            (gcd.gcd_aux m n m)) 
                                         (logic.eq nat.nat 
                                            (nat.minus (nat.times x m) 
                                               (nat.times b n)) 
                                            (gcd.gcd_aux m n m))) z0))) =>
                             f2 a 
                               (z1:(sttfa.etap (sttfa.p sttfa.bool)) =>
                                l:
                                (sttfa.eps 
                                   (sttfa.impl 
                                      (logic.eq nat.nat 
                                         (nat.minus (nat.times b n) 
                                            (nat.times a m)) 
                                         (gcd.gcd_aux m n m)) z1)) =>
                                r:
                                (sttfa.eps 
                                   (sttfa.impl 
                                      (logic.eq nat.nat 
                                         (nat.minus (nat.times a m) 
                                            (nat.times b n)) 
                                         (gcd.gcd_aux m n m)) z1)) =>
                                l 
                                  (logic.rewrite_r nat.nat (nat.times n b) 
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq nat.nat 
                                        (nat.minus __ (nat.times a m)) 
                                        (gcd.gcd_aux m n m)) 
                                     (logic.rewrite_r nat.nat 
                                        (nat.times m a) 
                                        (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq nat.nat 
                                           (nat.minus (nat.times n b) __) 
                                           (gcd.gcd_aux m n m)) 
                                        (logic.rewrite_r nat.nat 
                                           (gcd.gcd_aux m n m) 
                                           (__:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq nat.nat __ 
                                              (gcd.gcd_aux m n m)) 
                                           (logic.refl nat.nat 
                                              (gcd.gcd_aux m n m)) 
                                           (nat.minus (nat.times n b) 
                                              (nat.times m a)) 
                                           (logic.rewrite_l nat.nat 
                                              (nat.times a m) 
                                              (__:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq nat.nat 
                                                 (nat.minus (nat.times n b) 
                                                    __) (gcd.gcd_aux m n m)) 
                                              (logic.rewrite_l nat.nat 
                                                 (nat.times b n) 
                                                 (__:
                                                  (sttfa.etap 
                                                     (sttfa.p nat.nat)) =>
                                                  logic.eq nat.nat 
                                                    (nat.minus __ 
                                                       (nat.times a m)) 
                                                    (gcd.gcd_aux m n m)) H 
                                                 (nat.times n b) 
                                                 (nat.commutative_times b n)) 
                                              (nat.times m a) 
                                              (nat.commutative_times a m))) 
                                        (nat.times a m) 
                                        (nat.commutative_times a m)) 
                                     (nat.times b n) 
                                     (nat.commutative_times b n))))) 
                         _clearme0) _clearme) 
                   (gcd.eq_minus_gcd_aux m n m posm 
                      (nat.transitive_le m (nat.S m) n (nat.le_n_Sn m) 
                         (nat.not_le_to_lt n m nlenm)) (nat.le_n m)))))) 
       (eqm0:(sttfa.eps (logic.eq nat.nat nat.O m)) =>
        logic.eq_ind_r nat.nat m 
          (x:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.Ex nat.nat 
             (a:(sttfa.etap (sttfa.p nat.nat)) =>
              connectives.Ex nat.nat 
                (b:(sttfa.etap (sttfa.p nat.nat)) =>
                 connectives.Or 
                   (logic.eq nat.nat 
                      (nat.minus (nat.times a n) (nat.times b m)) 
                      (gcd.gcd n m)) 
                   (logic.eq nat.nat 
                      (nat.minus (nat.times b m) (nat.times a n)) 
                      (gcd.gcd n m))))) 
          (z:(sttfa.etap (sttfa.p sttfa.bool)) =>
           f:
           (sttfa.eps 
              (sttfa.forall nat.nat 
                 (x:(sttfa.etap (sttfa.p nat.nat)) =>
                  sttfa.impl 
                    (connectives.Ex nat.nat 
                       (b:(sttfa.etap (sttfa.p nat.nat)) =>
                        connectives.Or 
                          (logic.eq nat.nat 
                             (nat.minus (nat.times x n) (nat.times b m)) 
                             (gcd.gcd n m)) 
                          (logic.eq nat.nat 
                             (nat.minus (nat.times b m) (nat.times x n)) 
                             (gcd.gcd n m)))) z))) =>
           f (nat.S nat.O) 
             (z0:(sttfa.etap (sttfa.p sttfa.bool)) =>
              f2:
              (sttfa.eps 
                 (sttfa.forall nat.nat 
                    (y:(sttfa.etap (sttfa.p nat.nat)) =>
                     sttfa.impl 
                       (connectives.Or 
                          (logic.eq nat.nat 
                             (nat.minus (nat.times (nat.S nat.O) n) 
                                (nat.times y m)) (gcd.gcd n m)) 
                          (logic.eq nat.nat 
                             (nat.minus (nat.times y m) 
                                (nat.times (nat.S nat.O) n)) (gcd.gcd n m))) 
                       z0))) =>
              f2 nat.O 
                (z1:(sttfa.etap (sttfa.p sttfa.bool)) =>
                 l:
                 (sttfa.eps 
                    (sttfa.impl 
                       (logic.eq nat.nat 
                          (nat.minus (nat.times (nat.S nat.O) n) 
                             (nat.times nat.O m)) (gcd.gcd n m)) z1)) =>
                 r:
                 (sttfa.eps 
                    (sttfa.impl 
                       (logic.eq nat.nat 
                          (nat.minus (nat.times nat.O m) 
                             (nat.times (nat.S nat.O) n)) (gcd.gcd n m)) z1)) =>
                 l 
                   (logic.eq_coerc (logic.eq nat.nat n (nat.minus n nat.O)) 
                      (logic.eq nat.nat 
                         (nat.minus (nat.times (nat.S nat.O) n) 
                            (nat.times nat.O m)) (gcd.gcd n m)) 
                      (nat.minus_n_O n) 
                      (logic.rewrite_r nat.nat m 
                         (__:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq sttfa.bool 
                            (logic.eq nat.nat n (nat.minus n __)) 
                            (logic.eq nat.nat 
                               (nat.minus (nat.times (nat.S nat.O) n) 
                                  (nat.times nat.O m)) (gcd.gcd n m))) 
                         (logic.rewrite_l nat.nat n 
                            (__:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq sttfa.bool (logic.eq nat.nat n __) 
                               (logic.eq nat.nat 
                                  (nat.minus (nat.times (nat.S nat.O) n) 
                                     (nat.times nat.O m)) (gcd.gcd n m))) 
                            (logic.rewrite_r nat.nat m 
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq sttfa.bool (logic.eq nat.nat n n) 
                                  (logic.eq nat.nat 
                                     (nat.minus (nat.times (nat.S __) n) 
                                        (nat.times nat.O m)) (gcd.gcd n m))) 
                               (logic.rewrite_r nat.nat 
                                  (nat.times n (nat.S m)) 
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq sttfa.bool 
                                     (logic.eq nat.nat n n) 
                                     (logic.eq nat.nat 
                                        (nat.minus __ (nat.times nat.O m)) 
                                        (gcd.gcd n m))) 
                                  (logic.rewrite_l nat.nat 
                                     (nat.plus n (nat.times n m)) 
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq sttfa.bool 
                                        (logic.eq nat.nat n n) 
                                        (logic.eq nat.nat 
                                           (nat.minus __ (nat.times nat.O m)) 
                                           (gcd.gcd n m))) 
                                     (logic.rewrite_r nat.nat 
                                        (nat.times m n) 
                                        (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq sttfa.bool 
                                           (logic.eq nat.nat n n) 
                                           (logic.eq nat.nat 
                                              (nat.minus (nat.plus n __) 
                                                 (nat.times nat.O m)) 
                                              (gcd.gcd n m))) 
                                        (logic.rewrite_l nat.nat m 
                                           (__:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq sttfa.bool 
                                              (logic.eq nat.nat n n) 
                                              (logic.eq nat.nat 
                                                 (nat.minus (nat.plus n __) 
                                                    (nat.times nat.O m)) 
                                                 (gcd.gcd n m))) 
                                           (logic.rewrite_r nat.nat 
                                              (nat.plus m n) 
                                              (__:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq sttfa.bool 
                                                 (logic.eq nat.nat n n) 
                                                 (logic.eq nat.nat 
                                                    (nat.minus __ 
                                                       (nat.times nat.O m)) 
                                                    (gcd.gcd n m))) 
                                              (logic.rewrite_l nat.nat n 
                                                 (__:
                                                  (sttfa.etap 
                                                     (sttfa.p nat.nat)) =>
                                                  logic.eq sttfa.bool 
                                                    (logic.eq nat.nat n n) 
                                                    (logic.eq nat.nat 
                                                       (nat.minus __ 
                                                          (nat.times nat.O m)) 
                                                       (gcd.gcd n m))) 
                                                 (logic.rewrite_r nat.nat m 
                                                    (__:
                                                     (sttfa.etap 
                                                        (sttfa.p nat.nat)) =>
                                                     logic.eq sttfa.bool 
                                                       (logic.eq nat.nat n n) 
                                                       (logic.eq nat.nat 
                                                          (nat.minus n 
                                                             (nat.times __ m)) 
                                                          (gcd.gcd n m))) 
                                                    (logic.rewrite_l nat.nat 
                                                       m 
                                                       (__:
                                                        (sttfa.etap 
                                                           (sttfa.p nat.nat)) =>
                                                        logic.eq sttfa.bool 
                                                          (logic.eq nat.nat 
                                                             n n) 
                                                          (logic.eq nat.nat 
                                                             (nat.minus n __) 
                                                             (gcd.gcd n m))) 
                                                       (logic.rewrite_l 
                                                          nat.nat n 
                                                          (__:
                                                           (sttfa.etap 
                                                              (sttfa.p 
                                                                 nat.nat)) =>
                                                           logic.eq 
                                                             sttfa.bool 
                                                             (logic.eq 
                                                                nat.nat n n) 
                                                             (logic.eq 
                                                                nat.nat __ 
                                                                (gcd.gcd n m))) 
                                                          (logic.rewrite_r 
                                                             nat.nat 
                                                             (gcd.gcd m n) 
                                                             (__:
                                                              (sttfa.etap 
                                                                 (sttfa.p 
                                                                    nat.nat)) =>
                                                              logic.eq 
                                                                sttfa.bool 
                                                                (logic.eq 
                                                                   nat.nat n 
                                                                   n) 
                                                                (logic.eq 
                                                                   nat.nat n 
                                                                   __)) 
                                                             (logic.rewrite_r 
                                                                nat.nat n 
                                                                (__:
                                                                 (sttfa.etap 
                                                                    (
                                                                    sttfa.p 
                                                                    nat.nat)) =>
                                                                 logic.eq 
                                                                   sttfa.bool 
                                                                   (logic.eq 
                                                                    nat.nat 
                                                                    n n) 
                                                                   (logic.eq 
                                                                    nat.nat 
                                                                    n __)) 
                                                                (logic.refl 
                                                                   sttfa.bool 
                                                                   (logic.eq 
                                                                    nat.nat 
                                                                    n n)) 
                                                                (gcd.gcd m n) 
                                                                (logic.rewrite_l 
                                                                   nat.nat 
                                                                   nat.O 
                                                                   (__:
                                                                    (
                                                                    sttfa.etap 
                                                                    (sttfa.p 
                                                                    nat.nat)) =>
                                                                    logic.eq 
                                                                    nat.nat 
                                                                    (gcd.gcd 
                                                                    __ n) n) 
                                                                   (gcd.gcd_O_l 
                                                                    n) m eqm0)) 
                                                             (gcd.gcd n m) 
                                                             (gcd.commutative_gcd 
                                                                n m)) 
                                                          (nat.minus n m) 
                                                          (gcd.let_clause_1549 
                                                             m n posn eqm0 n)) 
                                                       (nat.times m m) 
                                                       (logic.rewrite_l 
                                                          nat.nat nat.O 
                                                          (__:
                                                           (sttfa.etap 
                                                              (sttfa.p 
                                                                 nat.nat)) =>
                                                           logic.eq nat.nat 
                                                             m 
                                                             (nat.times m __)) 
                                                          (logic.rewrite_l 
                                                             nat.nat nat.O 
                                                             (__:
                                                              (sttfa.etap 
                                                                 (sttfa.p 
                                                                    nat.nat)) =>
                                                              logic.eq 
                                                                nat.nat __ 
                                                                (nat.times m 
                                                                   nat.O)) 
                                                             (nat.times_n_O m) 
                                                             m eqm0) m eqm0)) 
                                                    nat.O eqm0) 
                                                 (nat.plus m n) 
                                                 (logic.rewrite_l nat.nat 
                                                    nat.O 
                                                    (__:
                                                     (sttfa.etap 
                                                        (sttfa.p nat.nat)) =>
                                                     logic.eq nat.nat n 
                                                       (nat.plus __ n)) 
                                                    (nat.plus_O_n n) m eqm0)) 
                                              (nat.plus n m) 
                                              (nat.commutative_plus n m)) 
                                           (nat.times m n) 
                                           (logic.rewrite_l nat.nat nat.O 
                                              (__:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq nat.nat m 
                                                 (nat.times __ n)) 
                                              (logic.rewrite_l nat.nat nat.O 
                                                 (__:
                                                  (sttfa.etap 
                                                     (sttfa.p nat.nat)) =>
                                                  logic.eq nat.nat __ 
                                                    (nat.times nat.O n)) 
                                                 (nat.times_O_n n) m eqm0) m 
                                              eqm0)) (nat.times n m) 
                                        (nat.commutative_times n m)) 
                                     (nat.times n (nat.S m)) 
                                     (nat.times_n_Sm n m)) 
                                  (nat.times (nat.S m) n) 
                                  (nat.commutative_times (nat.S m) n)) nat.O 
                               eqm0) (nat.minus n m) 
                            (gcd.let_clause_1549 m n posn eqm0 n)) nat.O eqm0))))) 
          nat.O eqm0) (nat.le_to_or_lt_eq nat.O m (nat.le_O_n m))) 
    (eqn0:(sttfa.eps (logic.eq nat.nat nat.O n)) =>
     logic.eq_ind_r nat.nat n 
       (x:(sttfa.etap (sttfa.p nat.nat)) =>
        connectives.Ex nat.nat 
          (a:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.Ex nat.nat 
             (b:(sttfa.etap (sttfa.p nat.nat)) =>
              connectives.Or 
                (logic.eq nat.nat 
                   (nat.minus (nat.times a n) (nat.times b m)) (gcd.gcd n m)) 
                (logic.eq nat.nat 
                   (nat.minus (nat.times b m) (nat.times a n)) (gcd.gcd n m))))) 
       (z:(sttfa.etap (sttfa.p sttfa.bool)) =>
        f:
        (sttfa.eps 
           (sttfa.forall nat.nat 
              (x:(sttfa.etap (sttfa.p nat.nat)) =>
               sttfa.impl 
                 (connectives.Ex nat.nat 
                    (b:(sttfa.etap (sttfa.p nat.nat)) =>
                     connectives.Or 
                       (logic.eq nat.nat 
                          (nat.minus (nat.times x n) (nat.times b m)) 
                          (gcd.gcd n m)) 
                       (logic.eq nat.nat 
                          (nat.minus (nat.times b m) (nat.times x n)) 
                          (gcd.gcd n m)))) z))) =>
        f nat.O 
          (z0:(sttfa.etap (sttfa.p sttfa.bool)) =>
           f0:
           (sttfa.eps 
              (sttfa.forall nat.nat 
                 (x:(sttfa.etap (sttfa.p nat.nat)) =>
                  sttfa.impl 
                    (connectives.Or 
                       (logic.eq nat.nat 
                          (nat.minus (nat.times nat.O n) (nat.times x m)) 
                          (gcd.gcd n m)) 
                       (logic.eq nat.nat 
                          (nat.minus (nat.times x m) (nat.times nat.O n)) 
                          (gcd.gcd n m))) z0))) =>
           f0 (nat.S nat.O) 
             (z1:(sttfa.etap (sttfa.p sttfa.bool)) =>
              l:
              (sttfa.eps 
                 (sttfa.impl 
                    (logic.eq nat.nat 
                       (nat.minus (nat.times nat.O n) 
                          (nat.times (nat.S nat.O) m)) (gcd.gcd n m)) z1)) =>
              r:
              (sttfa.eps 
                 (sttfa.impl 
                    (logic.eq nat.nat 
                       (nat.minus (nat.times (nat.S nat.O) m) 
                          (nat.times nat.O n)) (gcd.gcd n m)) z1)) =>
              r 
                (logic.eq_coerc (logic.eq nat.nat m (nat.minus m nat.O)) 
                   (logic.eq nat.nat 
                      (nat.minus (nat.times (nat.S nat.O) m) 
                         (nat.times nat.O n)) (gcd.gcd n m)) 
                   (nat.minus_n_O m) 
                   (logic.rewrite_r nat.nat m 
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq sttfa.bool 
                         (logic.eq nat.nat m (nat.minus m nat.O)) 
                         (logic.eq nat.nat 
                            (nat.minus (nat.times (nat.S nat.O) m) 
                               (nat.times nat.O n)) __)) 
                      (logic.rewrite_r nat.nat n 
                         (__:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq sttfa.bool 
                            (logic.eq nat.nat m (nat.minus m __)) 
                            (logic.eq nat.nat 
                               (nat.minus (nat.times (nat.S nat.O) m) 
                                  (nat.times nat.O n)) m)) 
                         (logic.rewrite_l nat.nat m 
                            (__:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq sttfa.bool (logic.eq nat.nat m __) 
                               (logic.eq nat.nat 
                                  (nat.minus (nat.times (nat.S nat.O) m) 
                                     (nat.times nat.O n)) m)) 
                            (logic.rewrite_r nat.nat n 
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq sttfa.bool (logic.eq nat.nat m m) 
                                  (logic.eq nat.nat 
                                     (nat.minus (nat.times (nat.S __) m) 
                                        (nat.times nat.O n)) m)) 
                               (logic.rewrite_r nat.nat 
                                  (nat.times m (nat.S n)) 
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq sttfa.bool 
                                     (logic.eq nat.nat m m) 
                                     (logic.eq nat.nat 
                                        (nat.minus __ (nat.times nat.O n)) m)) 
                                  (logic.rewrite_l nat.nat 
                                     (nat.plus m (nat.times m n)) 
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq sttfa.bool 
                                        (logic.eq nat.nat m m) 
                                        (logic.eq nat.nat 
                                           (nat.minus __ (nat.times nat.O n)) 
                                           m)) 
                                     (logic.rewrite_l nat.nat n 
                                        (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq sttfa.bool 
                                           (logic.eq nat.nat m m) 
                                           (logic.eq nat.nat 
                                              (nat.minus (nat.plus m __) 
                                                 (nat.times nat.O n)) m)) 
                                        (logic.rewrite_l nat.nat m 
                                           (__:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq sttfa.bool 
                                              (logic.eq nat.nat m m) 
                                              (logic.eq nat.nat 
                                                 (nat.minus __ 
                                                    (nat.times nat.O n)) m)) 
                                           (logic.rewrite_r nat.nat n 
                                              (__:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq sttfa.bool 
                                                 (logic.eq nat.nat m m) 
                                                 (logic.eq nat.nat 
                                                    (nat.minus m 
                                                       (nat.times __ n)) m)) 
                                              (logic.rewrite_l nat.nat n 
                                                 (__:
                                                  (sttfa.etap 
                                                     (sttfa.p nat.nat)) =>
                                                  logic.eq sttfa.bool 
                                                    (logic.eq nat.nat m m) 
                                                    (logic.eq nat.nat 
                                                       (nat.minus m __) m)) 
                                                 (logic.rewrite_l nat.nat m 
                                                    (__:
                                                     (sttfa.etap 
                                                        (sttfa.p nat.nat)) =>
                                                     logic.eq sttfa.bool 
                                                       (logic.eq nat.nat m m) 
                                                       (logic.eq nat.nat __ m)) 
                                                    (logic.refl sttfa.bool 
                                                       (logic.eq nat.nat m m)) 
                                                    (nat.minus m n) 
                                                    (gcd.let_clause_15491 m 
                                                       n eqn0 m)) 
                                                 (nat.times n n) 
                                                 (gcd.let_clause_1551 m n 
                                                    eqn0 n)) nat.O eqn0) 
                                           (nat.plus m n) 
                                           (logic.rewrite_l nat.nat nat.O 
                                              (__:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq nat.nat m 
                                                 (nat.plus m __)) 
                                              (nat.plus_n_O m) n eqn0)) 
                                        (nat.times m n) 
                                        (gcd.let_clause_1551 m n eqn0 m)) 
                                     (nat.times m (nat.S n)) 
                                     (nat.times_n_Sm m n)) 
                                  (nat.times (nat.S n) m) 
                                  (nat.commutative_times (nat.S n) m)) nat.O 
                               eqn0) (nat.minus m n) 
                            (gcd.let_clause_15491 m n eqn0 m)) nat.O eqn0) 
                      (gcd.gcd n m) 
                      (logic.rewrite_l nat.nat nat.O 
                         (__:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat (gcd.gcd __ m) m) (gcd.gcd_O_l m) 
                         n eqn0)))))) nat.O eqn0) 
    (nat.le_to_or_lt_eq nat.O n (nat.le_O_n n)).

def let_clause_1545 :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (logic.eq nat.nat (gcd.gcd m n) nat.O) 
             (sttfa.impl (primes.divides nat.O n) 
                (sttfa.forall nat.nat 
                   (q1:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (logic.eq nat.nat n (nat.times nat.O q1)) 
                      (sttfa.impl (primes.divides nat.O m) 
                         (sttfa.forall nat.nat 
                            (q2:(sttfa.etap (sttfa.p nat.nat)) =>
                             sttfa.impl 
                               (logic.eq nat.nat m (nat.times nat.O q2)) 
                               (logic.eq nat.nat m nat.O))))))))))
  :=
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  H:(sttfa.eps (logic.eq nat.nat (gcd.gcd m n) nat.O)) =>
  _clearme:(sttfa.eps (primes.divides nat.O n)) =>
  q1:(sttfa.etap (sttfa.p nat.nat)) =>
  H1:(sttfa.eps (logic.eq nat.nat n (nat.times nat.O q1))) =>
  _clearme0:(sttfa.eps (primes.divides nat.O m)) =>
  q2:(sttfa.etap (sttfa.p nat.nat)) =>
  H2:(sttfa.eps (logic.eq nat.nat m (nat.times nat.O q2))) =>
  logic.rewrite_r nat.nat (nat.times q2 nat.O) 
    (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat m __) 
    (logic.rewrite_l nat.nat (nat.times nat.O q2) 
       (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat m __) H2 
       (nat.times q2 nat.O) (nat.commutative_times nat.O q2)) nat.O 
    (nat.times_n_O q2).

def gcd_O_to_eq_O :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (logic.eq nat.nat (gcd.gcd m n) nat.O) 
             (connectives.And (logic.eq nat.nat m nat.O) 
                (logic.eq nat.nat n nat.O)))))
  :=
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  H:(sttfa.eps (logic.eq nat.nat (gcd.gcd m n) nat.O)) =>
  logic.match_And_prop (primes.divides nat.O n) (primes.divides nat.O m) 
    (connectives.And (logic.eq nat.nat m nat.O) (logic.eq nat.nat n nat.O)) 
    (_clearme:(sttfa.eps (primes.divides nat.O n)) =>
     primes.match_divides_prop nat.O n 
       (sttfa.impl (primes.divides nat.O m) 
          (connectives.And (logic.eq nat.nat m nat.O) 
             (logic.eq nat.nat n nat.O))) 
       (q1:(sttfa.etap (sttfa.p nat.nat)) =>
        H1:(sttfa.eps (logic.eq nat.nat n (nat.times nat.O q1))) =>
        _clearme0:(sttfa.eps (primes.divides nat.O m)) =>
        primes.match_divides_prop nat.O m 
          (connectives.And (logic.eq nat.nat m nat.O) 
             (logic.eq nat.nat n nat.O)) 
          (q2:(sttfa.etap (sttfa.p nat.nat)) =>
           H2:(sttfa.eps (logic.eq nat.nat m (nat.times nat.O q2))) =>
           z:(sttfa.etap (sttfa.p sttfa.bool)) =>
           f:
           (sttfa.eps 
              (sttfa.impl (logic.eq nat.nat m nat.O) 
                 (sttfa.impl (logic.eq nat.nat n nat.O) z))) =>
           f 
             (logic.rewrite_l nat.nat m 
                (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat m __) 
                (logic.refl nat.nat m) nat.O 
                (logic.rewrite_r nat.nat (nat.times q2 nat.O) 
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat m __) 
                   (logic.rewrite_l nat.nat (nat.times nat.O q2) 
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat m __) H2 (nat.times q2 nat.O) 
                      (nat.commutative_times nat.O q2)) nat.O 
                   (nat.times_n_O q2))) 
             (logic.rewrite_r nat.nat m 
                (__:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat __ nat.O) 
                (logic.rewrite_l nat.nat m 
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat m __) (logic.refl nat.nat m) nat.O 
                   (gcd.let_clause_1545 m n H _clearme q1 H1 _clearme0 q2 H2)) 
                n 
                (logic.rewrite_r nat.nat (nat.times m q1) 
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat n __) 
                   (logic.rewrite_r nat.nat nat.O 
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat n (nat.times __ q1)) H1 m 
                      (gcd.let_clause_1545 m n H _clearme q1 H1 _clearme0 q2 
                         H2)) m 
                   (logic.rewrite_r nat.nat nat.O 
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat m (nat.times __ q1)) 
                      (logic.rewrite_r nat.nat nat.O 
                         (__:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat __ (nat.times nat.O q1)) 
                         (nat.times_O_n q1) m 
                         (gcd.let_clause_1545 m n H _clearme q1 H1 _clearme0 
                            q2 H2)) m 
                      (gcd.let_clause_1545 m n H _clearme q1 H1 _clearme0 q2 
                         H2))))) _clearme0) _clearme) 
    (logic.eq_ind nat.nat (gcd.gcd m n) 
       (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
        connectives.And (primes.divides x_1 n) (primes.divides x_1 m)) 
       (gcd.divides_gcd_nm m n) nat.O H).

def let_clause_1571 :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.lt nat.O n) 
             (sttfa.impl (logic.eq nat.nat (gcd.gcd m n) nat.O) 
                (sttfa.impl (logic.eq nat.nat m nat.O) 
                   (sttfa.impl (logic.eq nat.nat n nat.O) 
                      (logic.eq nat.nat m n)))))))
  :=
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  posn:(sttfa.eps (nat.lt nat.O n)) =>
  H:(sttfa.eps (logic.eq nat.nat (gcd.gcd m n) nat.O)) =>
  auto:(sttfa.eps (logic.eq nat.nat m nat.O)) =>
  auto':(sttfa.eps (logic.eq nat.nat n nat.O)) =>
  logic.rewrite_r nat.nat nat.O 
    (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat m __) auto n auto'.

def let_clause_1572 :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.lt nat.O n) 
             (sttfa.impl (logic.eq nat.nat (gcd.gcd m n) nat.O) 
                (sttfa.impl (logic.eq nat.nat m nat.O) 
                   (sttfa.impl (logic.eq nat.nat n nat.O) 
                      (logic.eq nat.nat m nat.O)))))))
  :=
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  posn:(sttfa.eps (nat.lt nat.O n)) =>
  H:(sttfa.eps (logic.eq nat.nat (gcd.gcd m n) nat.O)) =>
  auto:(sttfa.eps (logic.eq nat.nat m nat.O)) =>
  auto':(sttfa.eps (logic.eq nat.nat n nat.O)) =>
  logic.rewrite_r nat.nat n 
    (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat __ nat.O) auto' m 
    (gcd.let_clause_1571 m n posn H auto auto').

def lt_O_gcd :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.lt nat.O n) (nat.lt nat.O (gcd.gcd m n)))))
  :=
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  posn:(sttfa.eps (nat.lt nat.O n)) =>
  nat.nat_case (gcd.gcd m n) (nat.lt nat.O) 
    (H:(sttfa.eps (logic.eq nat.nat (gcd.gcd m n) nat.O)) =>
     logic.match_And_prop (logic.eq nat.nat m nat.O) 
       (logic.eq nat.nat n nat.O) (nat.lt nat.O nat.O) 
       (auto:(sttfa.eps (logic.eq nat.nat m nat.O)) =>
        auto':(sttfa.eps (logic.eq nat.nat n nat.O)) =>
        logic.eq_coerc (nat.lt nat.O n) (nat.lt nat.O nat.O) posn 
          (logic.rewrite_l nat.nat m 
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq sttfa.bool (nat.lt __ n) (nat.lt nat.O nat.O)) 
             (logic.rewrite_l nat.nat m 
                (__:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq sttfa.bool (nat.lt m __) (nat.lt nat.O nat.O)) 
                (logic.rewrite_l nat.nat m 
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq sttfa.bool (nat.lt m m) (nat.lt __ nat.O)) 
                   (logic.rewrite_l nat.nat m 
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq sttfa.bool (nat.lt m m) (nat.lt m __)) 
                      (logic.refl sttfa.bool (nat.lt m m)) nat.O 
                      (gcd.let_clause_1572 m n posn H auto auto')) nat.O 
                   (gcd.let_clause_1572 m n posn H auto auto')) n 
                (gcd.let_clause_1571 m n posn H auto auto')) nat.O 
             (gcd.let_clause_1572 m n posn H auto auto'))) 
       (gcd.gcd_O_to_eq_O m n H)) 
    (m0:(sttfa.etap (sttfa.p nat.nat)) =>
     auto:(sttfa.eps (logic.eq nat.nat (gcd.gcd m n) (nat.S m0))) =>
     nat.lt_O_S m0).

def prime_to_gcd_1 :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (primes.prime n) 
             (sttfa.impl (connectives.Not (primes.divides n m)) 
                (logic.eq nat.nat (gcd.gcd n m) (nat.S nat.O))))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  _clearme:(sttfa.eps (primes.prime n)) =>
  logic.match_And_prop (nat.lt (nat.S nat.O) n) 
    (sttfa.forall nat.nat 
       (m1:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.impl (primes.divides m1 n) 
          (sttfa.impl (nat.lt (nat.S nat.O) m1) (logic.eq nat.nat m1 n)))) 
    (sttfa.impl (connectives.Not (primes.divides n m)) 
       (logic.eq nat.nat (gcd.gcd n m) (nat.S nat.O))) 
    (lt1n:(sttfa.eps (nat.lt (nat.S nat.O) n)) =>
     primen:
     (sttfa.eps 
        (sttfa.forall nat.nat 
           (m0:(sttfa.etap (sttfa.p nat.nat)) =>
            sttfa.impl (primes.divides m0 n) 
              (sttfa.impl (nat.lt (nat.S nat.O) m0) (logic.eq nat.nat m0 n))))) =>
     ndivnm:(sttfa.eps (connectives.Not (primes.divides n m))) =>
     nat.le_to_le_to_eq (gcd.gcd n m) (nat.S nat.O) 
       (nat.not_lt_to_le (nat.S nat.O) (gcd.gcd n m) 
          (logic.not_to_not (nat.lt (nat.S nat.O) (gcd.gcd n m)) 
             (logic.eq nat.nat (gcd.gcd n m) n) 
             (primen (gcd.gcd n m) (gcd.divides_gcd_l n m)) 
             (logic.not_to_not (logic.eq nat.nat (gcd.gcd n m) n) 
                (primes.divides n m) 
                (auto:(sttfa.eps (logic.eq nat.nat (gcd.gcd n m) n)) =>
                 logic.eq_coerc (primes.divides (gcd.gcd n m) m) 
                   (primes.divides n m) (gcd.divides_gcd_r n m) 
                   (logic.rewrite_r nat.nat n 
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq sttfa.bool (primes.divides __ m) 
                         (primes.divides n m)) 
                      (logic.refl sttfa.bool (primes.divides n m)) 
                      (gcd.gcd n m) auto)) ndivnm))) 
       (gcd.lt_O_gcd n m 
          (nat.not_eq_to_le_to_lt nat.O m 
             (logic.not_to_not (logic.eq nat.nat nat.O m) 
                (primes.divides n m) 
                (auto:(sttfa.eps (logic.eq nat.nat nat.O m)) =>
                 logic.eq_coerc (primes.divides n nat.O) 
                   (primes.divides n m) (primes.divides_n_O n) 
                   (logic.rewrite_r nat.nat m 
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq sttfa.bool (primes.divides n __) 
                         (primes.divides n m)) 
                      (logic.refl sttfa.bool (primes.divides n m)) nat.O auto)) 
                ndivnm) (nat.le_O_n m)))) _clearme.

def divides_times_to_divides :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (m:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (primes.prime p) 
                (sttfa.impl (primes.divides p (nat.times n m)) 
                   (connectives.Or (primes.divides p n) (primes.divides p m)))))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  primp:(sttfa.eps (primes.prime p)) =>
  _clearme:(sttfa.eps (primes.divides p (nat.times n m))) =>
  primes.match_divides_prop p (nat.times n m) 
    (connectives.Or (primes.divides p n) (primes.divides p m)) 
    (c:(sttfa.etap (sttfa.p nat.nat)) =>
     nm:(sttfa.eps (logic.eq nat.nat (nat.times n m) (nat.times p c))) =>
     logic.match_Or_prop (primes.divides p n) 
       (connectives.Not (primes.divides p n)) 
       (connectives.Or (primes.divides p n) (primes.divides p m)) 
       (auto:(sttfa.eps (primes.divides p n)) =>
        z:(sttfa.etap (sttfa.p sttfa.bool)) =>
        l:(sttfa.eps (sttfa.impl (primes.divides p n) z)) =>
        r:(sttfa.eps (sttfa.impl (primes.divides p m) z)) => l auto) 
       (ndivpn:(sttfa.eps (connectives.Not (primes.divides p n))) =>
        z:(sttfa.etap (sttfa.p sttfa.bool)) =>
        l:(sttfa.eps (sttfa.impl (primes.divides p n) z)) =>
        r:(sttfa.eps (sttfa.impl (primes.divides p m) z)) =>
        r 
          (logic.match_ex_prop nat.nat 
             (a:(sttfa.etap (sttfa.p nat.nat)) =>
              connectives.Ex nat.nat 
                (b:(sttfa.etap (sttfa.p nat.nat)) =>
                 connectives.Or 
                   (logic.eq nat.nat 
                      (nat.minus (nat.times a n) (nat.times b p)) 
                      (nat.S nat.O)) 
                   (logic.eq nat.nat 
                      (nat.minus (nat.times b p) (nat.times a n)) 
                      (nat.S nat.O)))) (primes.divides p m) 
             (a:(sttfa.etap (sttfa.p nat.nat)) =>
              _clearme0:
              (sttfa.eps 
                 (connectives.Ex nat.nat 
                    (b:(sttfa.etap (sttfa.p nat.nat)) =>
                     connectives.Or 
                       (logic.eq nat.nat 
                          (nat.minus (nat.times a n) (nat.times b p)) 
                          (nat.S nat.O)) 
                       (logic.eq nat.nat 
                          (nat.minus (nat.times b p) (nat.times a n)) 
                          (nat.S nat.O))))) =>
              logic.match_ex_prop nat.nat 
                (b:(sttfa.etap (sttfa.p nat.nat)) =>
                 connectives.Or 
                   (logic.eq nat.nat 
                      (nat.minus (nat.times a n) (nat.times b p)) 
                      (nat.S nat.O)) 
                   (logic.eq nat.nat 
                      (nat.minus (nat.times b p) (nat.times a n)) 
                      (nat.S nat.O))) (primes.divides p m) 
                (b:(sttfa.etap (sttfa.p nat.nat)) =>
                 _clearme1:
                 (sttfa.eps 
                    (connectives.Or 
                       (logic.eq nat.nat 
                          (nat.minus (nat.times a n) (nat.times b p)) 
                          (nat.S nat.O)) 
                       (logic.eq nat.nat 
                          (nat.minus (nat.times b p) (nat.times a n)) 
                          (nat.S nat.O)))) =>
                 logic.match_Or_prop 
                   (logic.eq nat.nat 
                      (nat.minus (nat.times a n) (nat.times b p)) 
                      (nat.S nat.O)) 
                   (logic.eq nat.nat 
                      (nat.minus (nat.times b p) (nat.times a n)) 
                      (nat.S nat.O)) (primes.divides p m) 
                   (H:
                    (sttfa.eps 
                       (logic.eq nat.nat 
                          (nat.minus (nat.times a n) (nat.times b p)) 
                          (nat.S nat.O))) =>
                    primes.quotient p m 
                      (nat.minus (nat.times a c) (nat.times b m)) 
                      (logic.eq_ind_r nat.nat 
                         (nat.minus (nat.times p (nat.times a c)) 
                            (nat.times p (nat.times b m))) 
                         (x:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat m x) 
                         (logic.eq_ind nat.nat (nat.times (nat.times p a) c) 
                            (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq nat.nat m 
                               (nat.minus x_1 (nat.times p (nat.times b m)))) 
                            (logic.eq_ind_r nat.nat (nat.times a p) 
                               (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq nat.nat m 
                                  (nat.minus (nat.times x c) 
                                     (nat.times p (nat.times b m)))) 
                               (logic.eq_ind_r nat.nat 
                                  (nat.times a (nat.times p c)) 
                                  (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq nat.nat m 
                                     (nat.minus x 
                                        (nat.times p (nat.times b m)))) 
                                  (logic.eq_ind nat.nat (nat.times n m) 
                                     (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq nat.nat m 
                                        (nat.minus (nat.times a x_1) 
                                           (nat.times p (nat.times b m)))) 
                                     (logic.eq_ind nat.nat 
                                        (nat.times (nat.times a n) m) 
                                        (x_1:
                                         (sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq nat.nat m 
                                           (nat.minus x_1 
                                              (nat.times p (nat.times b m)))) 
                                        (logic.eq_ind nat.nat 
                                           (nat.times (nat.times p b) m) 
                                           (x_1:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq nat.nat m 
                                              (nat.minus 
                                                 (nat.times (nat.times a n) m) 
                                                 x_1)) 
                                           (logic.eq_ind nat.nat 
                                              (nat.times m (nat.times a n)) 
                                              (x_1:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq nat.nat m 
                                                 (nat.minus x_1 
                                                    (nat.times 
                                                       (nat.times p b) m))) 
                                              (logic.eq_ind_r nat.nat 
                                                 (nat.times m (nat.times p b)) 
                                                 (x:
                                                  (sttfa.etap 
                                                     (sttfa.p nat.nat)) =>
                                                  logic.eq nat.nat m 
                                                    (nat.minus 
                                                       (nat.times m 
                                                          (nat.times a n)) x)) 
                                                 (logic.eq_ind nat.nat 
                                                    (nat.times m 
                                                       (nat.minus 
                                                          (nat.times a n) 
                                                          (nat.times p b))) 
                                                    (x_1:
                                                     (sttfa.etap 
                                                        (sttfa.p nat.nat)) =>
                                                     logic.eq nat.nat m x_1) 
                                                    (logic.rewrite_r nat.nat 
                                                       (nat.times n a) 
                                                       (__:
                                                        (sttfa.etap 
                                                           (sttfa.p nat.nat)) =>
                                                        logic.eq nat.nat m 
                                                          (nat.times m 
                                                             (nat.minus __ 
                                                                (nat.times p 
                                                                   b)))) 
                                                       (logic.rewrite_l 
                                                          nat.nat m 
                                                          (__:
                                                           (sttfa.etap 
                                                              (sttfa.p 
                                                                 nat.nat)) =>
                                                           logic.eq nat.nat 
                                                             m __) 
                                                          (logic.refl 
                                                             nat.nat m) 
                                                          (nat.times m 
                                                             (nat.minus 
                                                                (nat.times n 
                                                                   a) 
                                                                (nat.times p 
                                                                   b))) 
                                                          (logic.rewrite_r 
                                                             nat.nat 
                                                             (nat.S nat.O) 
                                                             (__:
                                                              (sttfa.etap 
                                                                 (sttfa.p 
                                                                    nat.nat)) =>
                                                              logic.eq 
                                                                nat.nat m 
                                                                (nat.times m 
                                                                   __)) 
                                                             (nat.times_n_1 m) 
                                                             (nat.minus 
                                                                (nat.times n 
                                                                   a) 
                                                                (nat.times p 
                                                                   b)) 
                                                             (logic.rewrite_l 
                                                                nat.nat 
                                                                (nat.times b 
                                                                   p) 
                                                                (__:
                                                                 (sttfa.etap 
                                                                    (
                                                                    sttfa.p 
                                                                    nat.nat)) =>
                                                                 logic.eq 
                                                                   nat.nat 
                                                                   (nat.minus 
                                                                    (nat.times 
                                                                    n a) __) 
                                                                   (nat.S 
                                                                    nat.O)) 
                                                                (logic.rewrite_l 
                                                                   nat.nat 
                                                                   (nat.times 
                                                                    a n) 
                                                                   (__:
                                                                    (
                                                                    sttfa.etap 
                                                                    (sttfa.p 
                                                                    nat.nat)) =>
                                                                    logic.eq 
                                                                    nat.nat 
                                                                    (nat.minus 
                                                                    __ 
                                                                    (nat.times 
                                                                    b p)) 
                                                                    (nat.S 
                                                                    nat.O)) 
                                                                   H 
                                                                   (nat.times 
                                                                    n a) 
                                                                   (nat.commutative_times 
                                                                    a n)) 
                                                                (nat.times p 
                                                                   b) 
                                                                (nat.commutative_times 
                                                                   b p)))) 
                                                       (nat.times a n) 
                                                       (nat.commutative_times 
                                                          a n)) 
                                                    (nat.minus 
                                                       (nat.times m 
                                                          (nat.times a n)) 
                                                       (nat.times m 
                                                          (nat.times p b))) 
                                                    (nat.distributive_times_minus 
                                                       m (nat.times a n) 
                                                       (nat.times p b))) 
                                                 (nat.times (nat.times p b) m) 
                                                 (nat.commutative_times 
                                                    (nat.times p b) m)) 
                                              (nat.times (nat.times a n) m) 
                                              (nat.commutative_times m 
                                                 (nat.times a n))) 
                                           (nat.times p (nat.times b m)) 
                                           (nat.associative_times p b m)) 
                                        (nat.times a (nat.times n m)) 
                                        (nat.associative_times a n m)) 
                                     (nat.times p c) nm) 
                                  (nat.times (nat.times a p) c) 
                                  (nat.associative_times a p c)) 
                               (nat.times p a) (nat.commutative_times p a)) 
                            (nat.times p (nat.times a c)) 
                            (nat.associative_times p a c)) 
                         (nat.times p 
                            (nat.minus (nat.times a c) (nat.times b m))) 
                         (nat.distributive_times_minus p (nat.times a c) 
                            (nat.times b m)))) 
                   (H:
                    (sttfa.eps 
                       (logic.eq nat.nat 
                          (nat.minus (nat.times b p) (nat.times a n)) 
                          (nat.S nat.O))) =>
                    primes.quotient p m 
                      (nat.minus (nat.times b m) (nat.times a c)) 
                      (logic.eq_ind_r nat.nat 
                         (nat.minus (nat.times p (nat.times b m)) 
                            (nat.times p (nat.times a c))) 
                         (x:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat m x) 
                         (logic.eq_ind nat.nat (nat.times (nat.times p b) m) 
                            (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq nat.nat m 
                               (nat.minus x_1 (nat.times p (nat.times a c)))) 
                            (logic.eq_ind nat.nat 
                               (nat.times (nat.times p a) c) 
                               (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq nat.nat m 
                                  (nat.minus (nat.times (nat.times p b) m) 
                                     x_1)) 
                               (logic.eq_ind nat.nat (nat.times a p) 
                                  (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq nat.nat m 
                                     (nat.minus 
                                        (nat.times (nat.times p b) m) 
                                        (nat.times x_1 c))) 
                                  (logic.eq_ind_r nat.nat 
                                     (nat.times a (nat.times p c)) 
                                     (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq nat.nat m 
                                        (nat.minus 
                                           (nat.times (nat.times p b) m) x)) 
                                     (logic.eq_ind nat.nat (nat.times n m) 
                                        (x_1:
                                         (sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq nat.nat m 
                                           (nat.minus 
                                              (nat.times (nat.times p b) m) 
                                              (nat.times a x_1))) 
                                        (logic.eq_ind nat.nat 
                                           (nat.times (nat.times a n) m) 
                                           (x_1:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq nat.nat m 
                                              (nat.minus 
                                                 (nat.times (nat.times p b) m) 
                                                 x_1)) 
                                           (logic.eq_ind nat.nat 
                                              (nat.times m (nat.times p b)) 
                                              (x_1:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq nat.nat m 
                                                 (nat.minus x_1 
                                                    (nat.times 
                                                       (nat.times a n) m))) 
                                              (logic.eq_ind_r nat.nat 
                                                 (nat.times m (nat.times a n)) 
                                                 (x:
                                                  (sttfa.etap 
                                                     (sttfa.p nat.nat)) =>
                                                  logic.eq nat.nat m 
                                                    (nat.minus 
                                                       (nat.times m 
                                                          (nat.times p b)) x)) 
                                                 (logic.eq_ind nat.nat 
                                                    (nat.times m 
                                                       (nat.minus 
                                                          (nat.times p b) 
                                                          (nat.times a n))) 
                                                    (x_1:
                                                     (sttfa.etap 
                                                        (sttfa.p nat.nat)) =>
                                                     logic.eq nat.nat m x_1) 
                                                    (logic.rewrite_r nat.nat 
                                                       (nat.times n a) 
                                                       (__:
                                                        (sttfa.etap 
                                                           (sttfa.p nat.nat)) =>
                                                        logic.eq nat.nat m 
                                                          (nat.times m 
                                                             (nat.minus 
                                                                (nat.times p 
                                                                   b) __))) 
                                                       (logic.rewrite_l 
                                                          nat.nat m 
                                                          (__:
                                                           (sttfa.etap 
                                                              (sttfa.p 
                                                                 nat.nat)) =>
                                                           logic.eq nat.nat 
                                                             m __) 
                                                          (logic.refl 
                                                             nat.nat m) 
                                                          (nat.times m 
                                                             (nat.minus 
                                                                (nat.times p 
                                                                   b) 
                                                                (nat.times n 
                                                                   a))) 
                                                          (logic.rewrite_r 
                                                             nat.nat 
                                                             (nat.S nat.O) 
                                                             (__:
                                                              (sttfa.etap 
                                                                 (sttfa.p 
                                                                    nat.nat)) =>
                                                              logic.eq 
                                                                nat.nat m 
                                                                (nat.times m 
                                                                   __)) 
                                                             (nat.times_n_1 m) 
                                                             (nat.minus 
                                                                (nat.times p 
                                                                   b) 
                                                                (nat.times n 
                                                                   a)) 
                                                             (logic.rewrite_l 
                                                                nat.nat 
                                                                (nat.times a 
                                                                   n) 
                                                                (__:
                                                                 (sttfa.etap 
                                                                    (
                                                                    sttfa.p 
                                                                    nat.nat)) =>
                                                                 logic.eq 
                                                                   nat.nat 
                                                                   (nat.minus 
                                                                    (nat.times 
                                                                    p b) __) 
                                                                   (nat.S 
                                                                    nat.O)) 
                                                                (logic.rewrite_l 
                                                                   nat.nat 
                                                                   (nat.times 
                                                                    b p) 
                                                                   (__:
                                                                    (
                                                                    sttfa.etap 
                                                                    (sttfa.p 
                                                                    nat.nat)) =>
                                                                    logic.eq 
                                                                    nat.nat 
                                                                    (nat.minus 
                                                                    __ 
                                                                    (nat.times 
                                                                    a n)) 
                                                                    (nat.S 
                                                                    nat.O)) 
                                                                   H 
                                                                   (nat.times 
                                                                    p b) 
                                                                   (nat.commutative_times 
                                                                    b p)) 
                                                                (nat.times n 
                                                                   a) 
                                                                (nat.commutative_times 
                                                                   a n)))) 
                                                       (nat.times a n) 
                                                       (nat.commutative_times 
                                                          a n)) 
                                                    (nat.minus 
                                                       (nat.times m 
                                                          (nat.times p b)) 
                                                       (nat.times m 
                                                          (nat.times a n))) 
                                                    (nat.distributive_times_minus 
                                                       m (nat.times p b) 
                                                       (nat.times a n))) 
                                                 (nat.times (nat.times a n) m) 
                                                 (nat.commutative_times 
                                                    (nat.times a n) m)) 
                                              (nat.times (nat.times p b) m) 
                                              (nat.commutative_times m 
                                                 (nat.times p b))) 
                                           (nat.times a (nat.times n m)) 
                                           (nat.associative_times a n m)) 
                                        (nat.times p c) nm) 
                                     (nat.times (nat.times a p) c) 
                                     (nat.associative_times a p c)) 
                                  (nat.times p a) (nat.commutative_times a p)) 
                               (nat.times p (nat.times a c)) 
                               (nat.associative_times p a c)) 
                            (nat.times p (nat.times b m)) 
                            (nat.associative_times p b m)) 
                         (nat.times p 
                            (nat.minus (nat.times b m) (nat.times a c))) 
                         (nat.distributive_times_minus p (nat.times b m) 
                            (nat.times a c)))) _clearme1) _clearme0) 
             (logic.eq_ind nat.nat (gcd.gcd p n) 
                (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                 connectives.Ex nat.nat 
                   (a:(sttfa.etap (sttfa.p nat.nat)) =>
                    connectives.Ex nat.nat 
                      (b:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.Or 
                         (logic.eq nat.nat 
                            (nat.minus (nat.times a n) (nat.times b p)) x_1) 
                         (logic.eq nat.nat 
                            (nat.minus (nat.times b p) (nat.times a n)) x_1)))) 
                (logic.eq_ind_r nat.nat (gcd.gcd n p) 
                   (x:(sttfa.etap (sttfa.p nat.nat)) =>
                    connectives.Ex nat.nat 
                      (a:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.Ex nat.nat 
                         (b:(sttfa.etap (sttfa.p nat.nat)) =>
                          connectives.Or 
                            (logic.eq nat.nat 
                               (nat.minus (nat.times a n) (nat.times b p)) x) 
                            (logic.eq nat.nat 
                               (nat.minus (nat.times b p) (nat.times a n)) x)))) 
                   (gcd.eq_minus_gcd p n) (gcd.gcd p n) 
                   (gcd.commutative_gcd p n)) (nat.S nat.O) 
                (gcd.prime_to_gcd_1 p n primp ndivpn)))) 
       (primes.decidable_divides p n)) _clearme.

