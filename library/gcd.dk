gcd_aux :
  sttfa.etap
    (sttfa.p
       (sttfa.arrow nat.nat
          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))).

gcd_aux_body :
  sttfa.etap
    (sttfa.p
       (sttfa.arrow nat.nat
          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))).

axiom_gcd_aux :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        connectives.equal (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          (gcd.gcd_aux p)
          (nat.filter_nat_type
             (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
             gcd.gcd_aux_body p))).

def eq_gcd_aux :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        leibniz.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          (gcd.gcd_aux p)
          (nat.filter_nat_type
             (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
             gcd.gcd_aux_body p))) :=
p:(sttfa.etap (sttfa.p nat.nat)) =>
        connectives.equal_leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          (gcd.gcd_aux p)
          (nat.filter_nat_type
             (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
             gcd.gcd_aux_body p) (axiom_gcd_aux p).

def sym_eq_gcd_aux :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        leibniz.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          (nat.filter_nat_type
             (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
             gcd.gcd_aux_body p) (gcd.gcd_aux p)))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  leibniz.sym_leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
    (gcd.gcd_aux p)
    (nat.filter_nat_type (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
       gcd.gcd_aux_body p) (gcd.eq_gcd_aux p).

axiom_gcd_aux_body_O :
  sttfa.eps
    (connectives.equal (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
       (gcd.gcd_aux_body nat.O)
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        n:(sttfa.etap (sttfa.p nat.nat)) => m)).

def eq_gcd_aux_body_O :
  sttfa.eps
    (leibniz.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
       (gcd.gcd_aux_body nat.O)
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        n:(sttfa.etap (sttfa.p nat.nat)) => m)) :=
connectives.equal_leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
       (gcd.gcd_aux_body nat.O)
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        n:(sttfa.etap (sttfa.p nat.nat)) => m) axiom_gcd_aux_body_O.

def sym_eq_gcd_aux_body_O :
  sttfa.eps
    (leibniz.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        n:(sttfa.etap (sttfa.p nat.nat)) => m) (gcd.gcd_aux_body nat.O))
  :=
  leibniz.sym_leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
    (gcd.gcd_aux_body nat.O)
    (m:(sttfa.etap (sttfa.p nat.nat)) =>
     n:(sttfa.etap (sttfa.p nat.nat)) => m) gcd.eq_gcd_aux_body_O.

axiom_gcd_aux_body_S :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        connectives.equal (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          (gcd.gcd_aux_body (nat.S p))
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           n:(sttfa.etap (sttfa.p nat.nat)) =>
           bool.match_bool_type nat.nat n
             (gcd.gcd_aux p n (div_mod.mod m n)) (primes.dividesb n m)))).

def eq_gcd_aux_body_S :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        leibniz.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          (gcd.gcd_aux_body (nat.S p))
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           n:(sttfa.etap (sttfa.p nat.nat)) =>
           bool.match_bool_type nat.nat n
             (gcd.gcd_aux p n (div_mod.mod m n)) (primes.dividesb n m)))) :=
p:(sttfa.etap (sttfa.p nat.nat)) =>
        connectives.equal_leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          (gcd.gcd_aux_body (nat.S p))
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           n:(sttfa.etap (sttfa.p nat.nat)) =>
           bool.match_bool_type nat.nat n
             (gcd.gcd_aux p n (div_mod.mod m n)) (primes.dividesb n m)) (axiom_gcd_aux_body_S p).


def sym_eq_gcd_aux_body_S :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        leibniz.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           n:(sttfa.etap (sttfa.p nat.nat)) =>
           bool.match_bool_type nat.nat n
             (gcd.gcd_aux p n (div_mod.mod m n)) (primes.dividesb n m))
          (gcd.gcd_aux_body (nat.S p))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  leibniz.sym_leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
    (gcd.gcd_aux_body (nat.S p))
    (m:(sttfa.etap (sttfa.p nat.nat)) =>
     n:(sttfa.etap (sttfa.p nat.nat)) =>
     bool.match_bool_type nat.nat n (gcd.gcd_aux p n (div_mod.mod m n))
       (primes.dividesb n m)) (gcd.eq_gcd_aux_body_S p).

def gcd :
  sttfa.etap (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  bool.match_bool_type nat.nat (gcd.gcd_aux n m n) (gcd.gcd_aux m n m)
    (nat.leb n m).

def commutative_gcd :
  sttfa.eps
    (sttfa.forall nat.nat
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat (gcd.gcd n m) (gcd.gcd m n))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.leb_elim n m
    (__:(sttfa.etap (sttfa.p bool.bool)) =>
     logic.eq nat.nat
       (bool.match_bool_type nat.nat (gcd.gcd_aux n m n) (gcd.gcd_aux m n m)
          __)
       (bool.match_bool_type nat.nat (gcd.gcd_aux m n m) (gcd.gcd_aux n m n)
          (nat.leb m n)))
    (lenm:(sttfa.eps (nat.le n m)) =>
     connectives.match_Or_prop (nat.lt n m) (logic.eq nat.nat n m)
       (logic.eq nat.nat
          (bool.match_bool_type nat.nat (gcd.gcd_aux n m n)
             (gcd.gcd_aux m n m) bool.true)
          (bool.match_bool_type nat.nat (gcd.gcd_aux m n m)
             (gcd.gcd_aux n m n) (nat.leb m n)))
       (ltnm:(sttfa.eps (nat.lt n m)) =>
        logic.eq_ind_r bool.bool bool.false
          (x:(sttfa.etap (sttfa.p bool.bool)) =>
           logic.eq nat.nat
             (bool.match_bool_type nat.nat (gcd.gcd_aux n m n)
                (gcd.gcd_aux m n m) bool.true)
             (bool.match_bool_type nat.nat (gcd.gcd_aux m n m)
                (gcd.gcd_aux n m n) x))
          (bool.sym_eq_match_bool_type_false nat.nat (gcd.gcd_aux m n m)
             (gcd.gcd_aux n m n)
             (y:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat
                (bool.match_bool_type nat.nat (gcd.gcd_aux n m n)
                   (gcd.gcd_aux m n m) bool.true) y)
             (bool.eq_match_bool_type_true nat.nat (gcd.gcd_aux n m n)
                (gcd.gcd_aux m n m)
                (y:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat
                   (bool.match_bool_type nat.nat (gcd.gcd_aux n m n)
                      (gcd.gcd_aux m n m) bool.true) y)
                (logic.refl nat.nat
                   (bool.match_bool_type nat.nat (gcd.gcd_aux n m n)
                      (gcd.gcd_aux m n m) bool.true)))) (nat.leb m n)
          (nat.not_le_to_leb_false m n (nat.lt_to_not_le n m ltnm)))
       (eqnm:(sttfa.eps (logic.eq nat.nat n m)) =>
        logic.eq_ind_r nat.nat m
          (x:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat
             (bool.match_bool_type nat.nat (gcd.gcd_aux x m x)
                (gcd.gcd_aux m x m) bool.true)
             (bool.match_bool_type nat.nat (gcd.gcd_aux m x m)
                (gcd.gcd_aux x m x) (nat.leb m x)))
          (bool.match_bool_prop
             (__:(sttfa.etap (sttfa.p bool.bool)) =>
              logic.eq nat.nat
                (bool.match_bool_type nat.nat (gcd.gcd_aux m m m)
                   (gcd.gcd_aux m m m) bool.true)
                (bool.match_bool_type nat.nat (gcd.gcd_aux m m m)
                   (gcd.gcd_aux m m m) __))
             (logic.refl nat.nat
                (bool.match_bool_type nat.nat (gcd.gcd_aux m m m)
                   (gcd.gcd_aux m m m) bool.true))
             (bool.sym_eq_match_bool_type_false nat.nat (gcd.gcd_aux m m m)
                (gcd.gcd_aux m m m)
                (y:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat
                   (bool.match_bool_type nat.nat (gcd.gcd_aux m m m)
                      (gcd.gcd_aux m m m) bool.true) y)
                (bool.eq_match_bool_type_true nat.nat (gcd.gcd_aux m m m)
                   (gcd.gcd_aux m m m)
                   (y:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat
                      (bool.match_bool_type nat.nat (gcd.gcd_aux m m m)
                         (gcd.gcd_aux m m m) bool.true) y)
                   (logic.refl nat.nat
                      (bool.match_bool_type nat.nat (gcd.gcd_aux m m m)
                         (gcd.gcd_aux m m m) bool.true)))) (nat.leb m m)) n
          eqnm) (nat.le_to_or_lt_eq n m lenm))
    (notlenm:(sttfa.eps (connectives.Not (nat.le n m))) =>
     logic.eq_ind_r bool.bool bool.true
       (x:(sttfa.etap (sttfa.p bool.bool)) =>
        logic.eq nat.nat
          (bool.match_bool_type nat.nat (gcd.gcd_aux n m n)
             (gcd.gcd_aux m n m) bool.false)
          (bool.match_bool_type nat.nat (gcd.gcd_aux m n m)
             (gcd.gcd_aux n m n) x))
       (bool.sym_eq_match_bool_type_false nat.nat (gcd.gcd_aux n m n)
          (gcd.gcd_aux m n m)
          (y:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat y
             (bool.match_bool_type nat.nat (gcd.gcd_aux m n m)
                (gcd.gcd_aux n m n) bool.true))
          (bool.sym_eq_match_bool_type_true nat.nat (gcd.gcd_aux m n m)
             (gcd.gcd_aux n m n)
             (y:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat (gcd.gcd_aux m n m) y)
             (bool.eq_match_bool_type_false nat.nat (gcd.gcd_aux n m n)
                (gcd.gcd_aux m n m)
                (y:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat (gcd.gcd_aux m n m) y)
                (bool.eq_match_bool_type_false nat.nat (gcd.gcd_aux n m n)
                   (gcd.gcd_aux m n m)
                   (y:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat y
                      (bool.match_bool_type nat.nat (gcd.gcd_aux n m n)
                         (gcd.gcd_aux m n m) bool.false))
                   (logic.refl nat.nat
                      (bool.match_bool_type nat.nat (gcd.gcd_aux n m n)
                         (gcd.gcd_aux m n m) bool.false)))))) (nat.leb m n)
       (nat.le_to_leb_true m n
          (nat.transitive_le m (nat.S m) n (nat.le_n_Sn m)
             (nat.not_le_to_lt n m notlenm)))).

def gcd_O_l :
  sttfa.eps
    (sttfa.forall nat.nat
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat (gcd.gcd nat.O m) m))
  :=
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  bool.eq_match_bool_type_true nat.nat m (gcd.gcd_aux m nat.O m)
    (y:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat (gcd.gcd nat.O m) y)
    (nat.eq_leb_body_O
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
        logic.eq nat.nat (gcd.gcd nat.O m)
          (bool.match_bool_type nat.nat m (gcd.gcd_aux m nat.O m) (y m)))
       (nat.eq_filter_nat_type_O (sttfa.arrow nat.nat bool.bool)
          nat.leb_body
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
           logic.eq nat.nat (gcd.gcd nat.O m)
             (bool.match_bool_type nat.nat m (gcd.gcd_aux m nat.O m) (y m)))
          (nat.eq_leb nat.O
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
              logic.eq nat.nat (gcd.gcd nat.O m)
                (bool.match_bool_type nat.nat m (gcd.gcd_aux m nat.O m) (y m)))
             (gcd.eq_gcd_aux_body_O
                (y:
                 (sttfa.etap
                    (sttfa.p
                       (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
                 logic.eq nat.nat (gcd.gcd nat.O m)
                   (bool.match_bool_type nat.nat (y m nat.O)
                      (gcd.gcd_aux m nat.O m) (nat.leb nat.O m)))
                (nat.eq_filter_nat_type_O
                   (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
                   gcd.gcd_aux_body
                   (y:
                    (sttfa.etap
                       (sttfa.p
                          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
                    logic.eq nat.nat (gcd.gcd nat.O m)
                      (bool.match_bool_type nat.nat (y m nat.O)
                         (gcd.gcd_aux m nat.O m) (nat.leb nat.O m)))
                   (gcd.eq_gcd_aux nat.O
                      (y:
                       (sttfa.etap
                          (sttfa.p
                             (sttfa.arrow nat.nat
                                (sttfa.arrow nat.nat nat.nat)))) =>
                       logic.eq nat.nat (gcd.gcd nat.O m)
                         (bool.match_bool_type nat.nat (y m nat.O)
                            (gcd.gcd_aux m nat.O m) (nat.leb nat.O m)))
                      (logic.refl nat.nat (gcd.gcd nat.O m)))))))).

def divides_mod_to_divides :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat
             (n:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.lt nat.O n)
                (sttfa.impl (primes.divides p (div_mod.mod m n))
                   (sttfa.impl (primes.divides p n) (primes.divides p m)))))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  posn:(sttfa.eps (nat.lt nat.O n)) =>
  _clearme:(sttfa.eps (primes.divides p (div_mod.mod m n))) =>
  primes.match_divides_prop p (div_mod.mod m n)
    (sttfa.impl (primes.divides p n) (primes.divides p m))
    (q1:(sttfa.etap (sttfa.p nat.nat)) =>
     eq1:(sttfa.eps (logic.eq nat.nat (div_mod.mod m n) (nat.times p q1))) =>
     _clearme0:(sttfa.eps (primes.divides p n)) =>
     primes.match_divides_prop p n (primes.divides p m)
       (q2:(sttfa.etap (sttfa.p nat.nat)) =>
        eq2:(sttfa.eps (logic.eq nat.nat n (nat.times p q2))) =>
        primes.quotient p m (nat.plus (nat.times q2 (div_mod.div m n)) q1)
          (logic.eq_ind_r nat.nat
             (nat.plus (nat.times p (nat.times q2 (div_mod.div m n)))
                (nat.times p q1))
             (x:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat m x)
             (logic.eq_ind nat.nat (div_mod.mod m n)
                (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat m
                   (nat.plus (nat.times p (nat.times q2 (div_mod.div m n)))
                      x_1))
                (logic.eq_ind nat.nat
                   (nat.times (nat.times p q2) (div_mod.div m n))
                   (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat m (nat.plus x_1 (div_mod.mod m n)))
                   (logic.eq_ind nat.nat n
                      (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat m
                         (nat.plus (nat.times x_1 (div_mod.div m n))
                            (div_mod.mod m n)))
                      (logic.rewrite_r nat.nat
                         (nat.plus (div_mod.mod m n)
                            (nat.times n (div_mod.div m n)))
                         (__:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat m __)
                         (logic.rewrite_l nat.nat m
                            (__:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq nat.nat m __) (logic.refl nat.nat m)
                            (nat.plus (div_mod.mod m n)
                               (nat.times n (div_mod.div m n)))
                            (logic.rewrite_l nat.nat
                               (nat.plus (nat.times n (div_mod.div m n))
                                  (div_mod.mod m n))
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq nat.nat m __)
                               (logic.rewrite_l nat.nat
                                  (nat.times (div_mod.div m n) n)
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq nat.nat m
                                     (nat.plus __ (div_mod.mod m n)))
                                  (div_mod.div_mod m n)
                                  (nat.times n (div_mod.div m n))
                                  (nat.commutative_times (div_mod.div m n) n))
                               (nat.plus (div_mod.mod m n)
                                  (nat.times n (div_mod.div m n)))
                               (nat.commutative_plus
                                  (nat.times n (div_mod.div m n))
                                  (div_mod.mod m n))))
                         (nat.plus (nat.times n (div_mod.div m n))
                            (div_mod.mod m n))
                         (nat.commutative_plus
                            (nat.times n (div_mod.div m n)) (div_mod.mod m n)))
                      (nat.times p q2) eq2)
                   (nat.times p (nat.times q2 (div_mod.div m n)))
                   (nat.associative_times p q2 (div_mod.div m n)))
                (nat.times p q1) eq1)
             (nat.times p (nat.plus (nat.times q2 (div_mod.div m n)) q1))
             (nat.distributive_times_plus p (nat.times q2 (div_mod.div m n))
                q1))) _clearme0) _clearme.

def divides_to_gcd_aux :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat
             (n:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.lt nat.O p)
                (sttfa.impl (nat.lt nat.O n)
                   (sttfa.impl (primes.divides n m)
                      (logic.eq nat.nat (gcd.gcd_aux p m n) n)))))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  posp:(sttfa.eps (nat.lt nat.O p)) =>
  nat.lt_O_n_elim p posp
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.impl (nat.lt nat.O n)
       (sttfa.impl (primes.divides n m)
          (logic.eq nat.nat (gcd.gcd_aux __ m n) n)))
    (l:(sttfa.etap (sttfa.p nat.nat)) =>
     gcd.sym_eq_gcd_aux (nat.S l)
       (y:
        (sttfa.etap
           (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
        sttfa.impl (nat.lt nat.O n)
          (sttfa.impl (primes.divides n m) (logic.eq nat.nat (y m n) n)))
       (nat.sym_eq_filter_nat_type_S
          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          gcd.gcd_aux_body l
          (y:
           (sttfa.etap
              (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
           sttfa.impl (nat.lt nat.O n)
             (sttfa.impl (primes.divides n m) (logic.eq nat.nat (y m n) n)))
          (gcd.sym_eq_gcd_aux_body_S l
             (y:
              (sttfa.etap
                 (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
              sttfa.impl (nat.lt nat.O n)
                (sttfa.impl (primes.divides n m) (logic.eq nat.nat (y m n) n)))
             (posn:(sttfa.eps (nat.lt nat.O n)) =>
              divnm:(sttfa.eps (primes.divides n m)) =>
              logic.eq_ind_r bool.bool bool.true
                (x:(sttfa.etap (sttfa.p bool.bool)) =>
                 logic.eq nat.nat
                   (bool.match_bool_type nat.nat n
                      (gcd.gcd_aux l n (div_mod.mod m n)) x) n)
                (bool.sym_eq_match_bool_type_true nat.nat n
                   (gcd.gcd_aux l n
                      (nat.match_nat_type nat.nat m
                         (p0:(sttfa.etap (sttfa.p nat.nat)) =>
                          div_mod.mod_aux m m p0) n))
                   (y:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat y n)
                   (logic.refl nat.nat n)) (primes.dividesb n m)
                (primes.divides_to_dividesb_true n m posn divnm))))).

def not_divides_to_gcd_aux :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat
             (n:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.lt nat.O n)
                (sttfa.impl (connectives.Not (primes.divides n m))
                   (logic.eq nat.nat (gcd.gcd_aux (nat.S p) m n)
                      (gcd.gcd_aux p n (div_mod.mod m n))))))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  gcd.sym_eq_gcd_aux (nat.S p)
    (y:
     (sttfa.etap
        (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
     sttfa.impl (nat.lt nat.O n)
       (sttfa.impl (connectives.Not (primes.divides n m))
          (logic.eq nat.nat (y m n) (gcd.gcd_aux p n (div_mod.mod m n)))))
    (nat.sym_eq_filter_nat_type_S
       (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) gcd.gcd_aux_body
       p
       (y:
        (sttfa.etap
           (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
        sttfa.impl (nat.lt nat.O n)
          (sttfa.impl (connectives.Not (primes.divides n m))
             (logic.eq nat.nat (y m n) (gcd.gcd_aux p n (div_mod.mod m n)))))
       (gcd.sym_eq_gcd_aux_body_S p
          (y:
           (sttfa.etap
              (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
           sttfa.impl (nat.lt nat.O n)
             (sttfa.impl (connectives.Not (primes.divides n m))
                (logic.eq nat.nat (y m n) (gcd.gcd_aux p n (div_mod.mod m n)))))
          (lenm:(sttfa.eps (nat.lt nat.O n)) =>
           divnm:(sttfa.eps (connectives.Not (primes.divides n m))) =>
           logic.eq_ind_r bool.bool bool.false
             (x:(sttfa.etap (sttfa.p bool.bool)) =>
              logic.eq nat.nat
                (bool.match_bool_type nat.nat n
                   (gcd.gcd_aux p n (div_mod.mod m n)) x)
                (gcd.gcd_aux p n (div_mod.mod m n)))
             (bool.sym_eq_match_bool_type_false nat.nat n
                (gcd.gcd_aux p n
                   (nat.match_nat_type nat.nat m
                      (p0:(sttfa.etap (sttfa.p nat.nat)) =>
                       div_mod.mod_aux m m p0) n))
                (y:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat y
                   (gcd.gcd_aux p n
                      (nat.match_nat_type nat.nat m
                         (p0:(sttfa.etap (sttfa.p nat.nat)) =>
                          div_mod.mod_aux m m p0) n)))
                (logic.refl nat.nat
                   (gcd.gcd_aux p n
                      (nat.match_nat_type nat.nat m
                         (p0:(sttfa.etap (sttfa.p nat.nat)) =>
                          div_mod.mod_aux m m p0) n))))
             (primes.dividesb n m)
             (primes.not_divides_to_dividesb_false n m lenm divnm)))).

def divides_gcd_aux_mn :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat
             (n:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.lt nat.O n)
                (sttfa.impl (nat.le n m)
                   (sttfa.impl (nat.le n p)
                      (connectives.And
                         (primes.divides (gcd.gcd_aux p m n) m)
                         (primes.divides (gcd.gcd_aux p m n) n))))))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.forall nat.nat
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.lt nat.O n)
             (sttfa.impl (nat.le n m)
                (sttfa.impl (nat.le n _x_365)
                   (connectives.And
                      (primes.divides (gcd.gcd_aux _x_365 m n) m)
                      (primes.divides (gcd.gcd_aux _x_365 m n) n)))))))
    (m:(sttfa.etap (sttfa.p nat.nat)) =>
     n:(sttfa.etap (sttfa.p nat.nat)) =>
     posn:(sttfa.eps (nat.lt nat.O n)) =>
     lenm:(sttfa.eps (nat.le n m)) =>
     lenO:(sttfa.eps (nat.le n nat.O)) =>
     connectives.falsity
       (connectives.And (primes.divides (gcd.gcd_aux nat.O m n) m)
          (primes.divides (gcd.gcd_aux nat.O m n) n))
       (logic.absurd (nat.lt nat.O n) posn (nat.le_to_not_lt n nat.O lenO)))
    (q:(sttfa.etap (sttfa.p nat.nat)) =>
     Hind:
     (sttfa.eps
        (sttfa.forall nat.nat
           (m:(sttfa.etap (sttfa.p nat.nat)) =>
            sttfa.forall nat.nat
              (n:(sttfa.etap (sttfa.p nat.nat)) =>
               sttfa.impl (nat.lt nat.O n)
                 (sttfa.impl (nat.le n m)
                    (sttfa.impl (nat.le n q)
                       (connectives.And
                          (primes.divides (gcd.gcd_aux q m n) m)
                          (primes.divides (gcd.gcd_aux q m n) n)))))))) =>
     m:(sttfa.etap (sttfa.p nat.nat)) =>
     n:(sttfa.etap (sttfa.p nat.nat)) =>
     posn:(sttfa.eps (nat.lt nat.O n)) =>
     lenm:(sttfa.eps (nat.le n m)) =>
     lenS:(sttfa.eps (nat.le n (nat.S q))) =>
     connectives.match_Or_prop (primes.divides n m)
       (connectives.Not (primes.divides n m))
       (connectives.And (primes.divides (gcd.gcd_aux (nat.S q) m n) m)
          (primes.divides (gcd.gcd_aux (nat.S q) m n) n))
       (divnm:(sttfa.eps (primes.divides n m)) =>
        logic.eq_ind_r nat.nat n
          (x:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.And (primes.divides x m) (primes.divides x n))
          (connectives.conj (primes.divides n m)(primes.divides n n)
           divnm (primes.divides_n_n n)) (gcd.gcd_aux (nat.S q) m n)
          (gcd.divides_to_gcd_aux (nat.S q) m n (nat.lt_O_S q) posn divnm))
       (ndivnm:(sttfa.eps (connectives.Not (primes.divides n m))) =>
        logic.eq_ind_r nat.nat (gcd.gcd_aux q n (div_mod.mod m n))
          (x:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.And (primes.divides x m) (primes.divides x n))
          (connectives.match_And_prop
             (primes.divides (gcd.gcd_aux q n (div_mod.mod m n)) n)
             (primes.divides (gcd.gcd_aux q n (div_mod.mod m n))
                (div_mod.mod m n))
             (connectives.And
                (primes.divides (gcd.gcd_aux q n (div_mod.mod m n)) m)
                (primes.divides (gcd.gcd_aux q n (div_mod.mod m n)) n))
             (H:
              (sttfa.eps
                 (primes.divides (gcd.gcd_aux q n (div_mod.mod m n)) n)) =>
              H1:
              (sttfa.eps
                 (primes.divides (gcd.gcd_aux q n (div_mod.mod m n))
                    (div_mod.mod m n))) =>
                    connectives.conj
                    (primes.divides (gcd.gcd_aux q n (div_mod.mod m n)) m)
                       (primes.divides (gcd.gcd_aux q n (div_mod.mod m n)) n)
                (gcd.divides_mod_to_divides
                   (gcd.gcd_aux q n (div_mod.mod m n)) m n posn H1 H) H)
             (Hind n (div_mod.mod m n)
                (connectives.match_Or_prop (nat.lt nat.O (div_mod.mod m n))
                   (logic.eq nat.nat nat.O (div_mod.mod m n))
                   (nat.lt nat.O (div_mod.mod m n))
                   (auto:(sttfa.eps (nat.lt nat.O (div_mod.mod m n))) => auto)
                   (modO:
                    (sttfa.eps (logic.eq nat.nat nat.O (div_mod.mod m n))) =>
                    connectives.falsity (nat.lt nat.O (div_mod.mod m n))
                      (logic.absurd (primes.divides n m)
                         (primes.mod_O_to_divides n m posn
                            (logic.rewrite_l nat.nat nat.O
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq nat.nat __ nat.O)
                               (logic.refl nat.nat nat.O) (div_mod.mod m n)
                               modO)) ndivnm))
                   (nat.le_to_or_lt_eq nat.O (div_mod.mod m n)
                      (nat.le_O_n (div_mod.mod m n))))
                (nat.lt_to_le (div_mod.mod m n) n
                   (div_mod.lt_mod_m_m m n posn))
                (nat.le_S_S_to_le (div_mod.mod m n) q
                   (nat.transitive_le (nat.S (div_mod.mod m n)) n (nat.S q)
                      (div_mod.lt_mod_m_m m n posn) lenS))))
          (gcd.gcd_aux (nat.S q) m n)
          (gcd.not_divides_to_gcd_aux q m n posn ndivnm))
       (primes.decidable_divides n m)) p.

def divides_gcd_nm :
  sttfa.eps
    (sttfa.forall nat.nat
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.And (primes.divides (gcd.gcd n m) m)
             (primes.divides (gcd.gcd n m) n))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  connectives.match_Or_prop (nat.lt nat.O n) (logic.eq nat.nat nat.O n)
    (connectives.And (primes.divides (gcd.gcd n m) m)
       (primes.divides (gcd.gcd n m) n))
    (posn:(sttfa.eps (nat.lt nat.O n)) =>
     connectives.match_Or_prop (nat.lt nat.O m) (logic.eq nat.nat nat.O m)
       (connectives.And (primes.divides (gcd.gcd n m) m)
          (primes.divides (gcd.gcd n m) n))
       (posm:(sttfa.eps (nat.lt nat.O m)) =>
        nat.leb_elim n m
          (__:(sttfa.etap (sttfa.p bool.bool)) =>
           connectives.And
             (primes.divides
                (bool.match_bool_type nat.nat (gcd.gcd_aux n m n)
                   (gcd.gcd_aux m n m) __) m)
             (primes.divides
                (bool.match_bool_type nat.nat (gcd.gcd_aux n m n)
                   (gcd.gcd_aux m n m) __) n))
          (bool.sym_eq_match_bool_type_true nat.nat (gcd.gcd_aux n m n)
             (gcd.gcd_aux m n m)
             (y:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.le n m)
                (connectives.And
                   (primes.divides
                      (bool.match_bool_type nat.nat (gcd.gcd_aux n m n)
                         (gcd.gcd_aux m n m) bool.true) m)
                   (primes.divides y n)))
             (bool.sym_eq_match_bool_type_true nat.nat (gcd.gcd_aux n m n)
                (gcd.gcd_aux m n m)
                (y:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (nat.le n m)
                   (connectives.And (primes.divides y m)
                      (primes.divides (gcd.gcd_aux n m n) n)))
                (lenm:(sttfa.eps (nat.le n m)) =>
                 gcd.divides_gcd_aux_mn n m n posn lenm (nat.le_n n))))
          (bool.sym_eq_match_bool_type_false nat.nat (gcd.gcd_aux n m n)
             (gcd.gcd_aux m n m)
             (y:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (connectives.Not (nat.le n m))
                (connectives.And
                   (primes.divides
                      (bool.match_bool_type nat.nat (gcd.gcd_aux n m n)
                         (gcd.gcd_aux m n m) bool.false) m)
                   (primes.divides y n)))
             (bool.sym_eq_match_bool_type_false nat.nat (gcd.gcd_aux n m n)
                (gcd.gcd_aux m n m)
                (y:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (connectives.Not (nat.le n m))
                   (connectives.And (primes.divides y m)
                      (primes.divides (gcd.gcd_aux m n m) n)))
                (notlt:(sttfa.eps (connectives.Not (nat.le n m))) =>
                 connectives.match_And_prop (primes.divides (gcd.gcd_aux m n m) n)
                   (primes.divides (gcd.gcd_aux m n m) m)
                   (connectives.And (primes.divides (gcd.gcd_aux m n m) m)
                      (primes.divides (gcd.gcd_aux m n m) n))
                   (auto:
                    (sttfa.eps (primes.divides (gcd.gcd_aux m n m) n)) =>
                    auto':
                    (sttfa.eps (primes.divides (gcd.gcd_aux m n m) m)) =>
                    connectives.conj (primes.divides (gcd.gcd_aux m n m) m)
                          (primes.divides (gcd.gcd_aux m n m) n)
                    auto' auto)
                   (gcd.divides_gcd_aux_mn m n m posm
                      (nat.transitive_le m (nat.S m) n (nat.le_n_Sn m)
                         (nat.not_le_to_lt n m notlt)) (nat.le_n m))))))
       (eqmO:(sttfa.eps (logic.eq nat.nat nat.O m)) =>
        logic.eq_ind nat.nat nat.O
          (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.And (primes.divides (gcd.gcd n x_1) x_1)
             (primes.divides (gcd.gcd n x_1) n))
          (connectives.conj (primes.divides (gcd.gcd n nat.O) nat.O)
                 (primes.divides (gcd.gcd n nat.O) n)
           (primes.divides_n_O (gcd.gcd n nat.O))
             (logic.eq_coerc
                (primes.divides (gcd.gcd n nat.O) (gcd.gcd n nat.O))
                (primes.divides (gcd.gcd n nat.O) n)
                (primes.divides_n_n (gcd.gcd n nat.O))
                (logic.rewrite_r nat.nat n
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq sttfa.bool
                      (primes.divides (gcd.gcd n nat.O) __)
                      (primes.divides (gcd.gcd n nat.O) n))
                   (logic.refl sttfa.bool
                      (primes.divides (gcd.gcd n nat.O) n))
                   (gcd.gcd n nat.O)
                   (logic.rewrite_l nat.nat (gcd.gcd nat.O n)
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat (gcd.gcd n nat.O) __)
                      (gcd.commutative_gcd n nat.O) n (gcd.gcd_O_l n))))) m
          eqmO) (nat.le_to_or_lt_eq nat.O m (nat.le_O_n m)))
    (eqnO:(sttfa.eps (logic.eq nat.nat nat.O n)) =>
     logic.eq_ind nat.nat nat.O
       (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
        connectives.And (primes.divides (gcd.gcd x_1 m) m)
          (primes.divides (gcd.gcd x_1 m) x_1))
       (connectives.conj (primes.divides (gcd.gcd nat.O m) m)
              (primes.divides (gcd.gcd nat.O m) nat.O)
          (bool.eq_match_bool_type_true nat.nat m (gcd.gcd_aux m nat.O m)
             (y:(sttfa.etap (sttfa.p nat.nat)) =>
              primes.divides
                (bool.match_bool_type nat.nat (gcd.gcd_aux nat.O m nat.O)
                   (gcd.gcd_aux m nat.O m) (nat.leb nat.O m)) y)
             (nat.eq_leb_body_O
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
                 primes.divides
                   (bool.match_bool_type nat.nat (gcd.gcd_aux nat.O m nat.O)
                      (gcd.gcd_aux m nat.O m) (nat.leb nat.O m))
                   (bool.match_bool_type nat.nat m (gcd.gcd_aux m nat.O m)
                      (y m)))
                (nat.eq_filter_nat_type_O (sttfa.arrow nat.nat bool.bool)
                   nat.leb_body
                   (y:
                    (sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
                    primes.divides
                      (bool.match_bool_type nat.nat
                         (gcd.gcd_aux nat.O m nat.O) (gcd.gcd_aux m nat.O m)
                         (nat.leb nat.O m))
                      (bool.match_bool_type nat.nat m
                         (gcd.gcd_aux m nat.O m) (y m)))
                   (nat.eq_leb nat.O
                      (y:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
                       primes.divides
                         (bool.match_bool_type nat.nat
                            (gcd.gcd_aux nat.O m nat.O)
                            (gcd.gcd_aux m nat.O m) (nat.leb nat.O m))
                         (bool.match_bool_type nat.nat m
                            (gcd.gcd_aux m nat.O m) (y m)))
                      (gcd.eq_gcd_aux_body_O
                         (y:
                          (sttfa.etap
                             (sttfa.p
                                (sttfa.arrow nat.nat
                                   (sttfa.arrow nat.nat nat.nat)))) =>
                          primes.divides (gcd.gcd nat.O m)
                            (bool.match_bool_type nat.nat (y m nat.O)
                               (gcd.gcd_aux m nat.O m) (nat.leb nat.O m)))
                         (nat.eq_filter_nat_type_O
                            (sttfa.arrow nat.nat
                               (sttfa.arrow nat.nat nat.nat))
                            gcd.gcd_aux_body
                            (y:
                             (sttfa.etap
                                (sttfa.p
                                   (sttfa.arrow nat.nat
                                      (sttfa.arrow nat.nat nat.nat)))) =>
                             primes.divides (gcd.gcd nat.O m)
                               (bool.match_bool_type nat.nat (y m nat.O)
                                  (gcd.gcd_aux m nat.O m) (nat.leb nat.O m)))
                            (gcd.eq_gcd_aux nat.O
                               (y:
                                (sttfa.etap
                                   (sttfa.p
                                      (sttfa.arrow nat.nat
                                         (sttfa.arrow nat.nat nat.nat)))) =>
                                primes.divides (gcd.gcd nat.O m)
                                  (bool.match_bool_type nat.nat (y m nat.O)
                                     (gcd.gcd_aux m nat.O m)
                                     (nat.leb nat.O m)))
                               (primes.divides_n_n (gcd.gcd nat.O m)))))))))
          (primes.divides_n_O (gcd.gcd nat.O m))) n eqnO)
    (nat.le_to_or_lt_eq nat.O n (nat.le_O_n n)).

def divides_gcd_l :
  sttfa.eps
    (sttfa.forall nat.nat
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (m:(sttfa.etap (sttfa.p nat.nat)) => primes.divides (gcd.gcd n m) n)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.proj2 (primes.divides (gcd.gcd n m) m)
    (primes.divides (gcd.gcd n m) n) (gcd.divides_gcd_nm n m).

def divides_gcd_r :
  sttfa.eps
    (sttfa.forall nat.nat
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (m:(sttfa.etap (sttfa.p nat.nat)) => primes.divides (gcd.gcd n m) m)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.proj1 (primes.divides (gcd.gcd n m) m)
    (primes.divides (gcd.gcd n m) n) (gcd.divides_gcd_nm n m).

def let_clause_1544 :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (q:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl
             (sttfa.forall nat.nat
                (m:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall nat.nat
                   (n:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (nat.lt nat.O n)
                      (sttfa.impl (nat.le n m)
                         (sttfa.impl (nat.le n q)
                            (connectives.ex nat.nat
                               (a:(sttfa.etap (sttfa.p nat.nat)) =>
                                connectives.ex nat.nat
                                  (b:(sttfa.etap (sttfa.p nat.nat)) =>
                                   connectives.Or
                                     (logic.eq nat.nat
                                        (nat.minus (nat.times a n)
                                           (nat.times b m))
                                        (gcd.gcd_aux q m n))
                                     (logic.eq nat.nat
                                        (nat.minus (nat.times b m)
                                           (nat.times a n))
                                        (gcd.gcd_aux q m n))))))))))
             (sttfa.forall nat.nat
                (m:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall nat.nat
                   (n:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (nat.lt nat.O n)
                      (sttfa.impl (nat.le n m)
                         (sttfa.impl (nat.le n (nat.S q))
                            (sttfa.impl
                               (connectives.Not (primes.divides n m))
                               (sttfa.forall nat.nat
                                  (a:(sttfa.etap (sttfa.p nat.nat)) =>
                                   sttfa.impl
                                     (connectives.ex nat.nat
                                        (b:(sttfa.etap (sttfa.p nat.nat)) =>
                                         connectives.Or
                                           (logic.eq nat.nat
                                              (nat.minus
                                                 (nat.times a
                                                    (div_mod.mod m n))
                                                 (nat.times b n))
                                              (gcd.gcd_aux q n
                                                 (div_mod.mod m n)))
                                           (logic.eq nat.nat
                                              (nat.minus (nat.times b n)
                                                 (nat.times a
                                                    (div_mod.mod m n)))
                                              (gcd.gcd_aux q n
                                                 (div_mod.mod m n)))))
                                     (sttfa.forall nat.nat
                                        (b:(sttfa.etap (sttfa.p nat.nat)) =>
                                         sttfa.impl
                                           (connectives.Or
                                              (logic.eq nat.nat
                                                 (nat.minus
                                                    (nat.times a
                                                       (div_mod.mod m n))
                                                    (nat.times b n))
                                                 (gcd.gcd_aux q n
                                                    (div_mod.mod m n)))
                                              (logic.eq nat.nat
                                                 (nat.minus (nat.times b n)
                                                    (nat.times a
                                                       (div_mod.mod m n)))
                                                 (gcd.gcd_aux q n
                                                    (div_mod.mod m n))))
                                           (sttfa.impl
                                              (logic.eq nat.nat
                                                 (nat.minus
                                                    (nat.times a
                                                       (div_mod.mod m n))
                                                    (nat.times b n))
                                                 (gcd.gcd_aux q n
                                                    (div_mod.mod m n)))
                                              (logic.eq nat.nat
                                                 (nat.minus
                                                    (nat.times a
                                                       (div_mod.mod m n))
                                                    (nat.times n b))
                                                 (gcd.gcd_aux q n
                                                    (div_mod.mod m n)))))))))))))))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  q:(sttfa.etap (sttfa.p nat.nat)) =>
  Hind:
  (sttfa.eps
     (sttfa.forall nat.nat
        (m:(sttfa.etap (sttfa.p nat.nat)) =>
         sttfa.forall nat.nat
           (n:(sttfa.etap (sttfa.p nat.nat)) =>
            sttfa.impl (nat.lt nat.O n)
              (sttfa.impl (nat.le n m)
                 (sttfa.impl (nat.le n q)
                    (connectives.ex nat.nat
                       (a:(sttfa.etap (sttfa.p nat.nat)) =>
                        connectives.ex nat.nat
                          (b:(sttfa.etap (sttfa.p nat.nat)) =>
                           connectives.Or
                             (logic.eq nat.nat
                                (nat.minus (nat.times a n) (nat.times b m))
                                (gcd.gcd_aux q m n))
                             (logic.eq nat.nat
                                (nat.minus (nat.times b m) (nat.times a n))
                                (gcd.gcd_aux q m n))))))))))) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  posn:(sttfa.eps (nat.lt nat.O n)) =>
  lenm:(sttfa.eps (nat.le n m)) =>
  lenS:(sttfa.eps (nat.le n (nat.S q))) =>
  ndivnm:(sttfa.eps (connectives.Not (primes.divides n m))) =>
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  _clearme:
  (sttfa.eps
     (connectives.ex nat.nat
        (b:(sttfa.etap (sttfa.p nat.nat)) =>
         connectives.Or
           (logic.eq nat.nat
              (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n))
              (gcd.gcd_aux q n (div_mod.mod m n)))
           (logic.eq nat.nat
              (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n)))
              (gcd.gcd_aux q n (div_mod.mod m n)))))) =>
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  _clearme0:
  (sttfa.eps
     (connectives.Or
        (logic.eq nat.nat
           (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n))
           (gcd.gcd_aux q n (div_mod.mod m n)))
        (logic.eq nat.nat
           (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n)))
           (gcd.gcd_aux q n (div_mod.mod m n))))) =>
  H:
  (sttfa.eps
     (logic.eq nat.nat
        (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n))
        (gcd.gcd_aux q n (div_mod.mod m n)))) =>
  logic.rewrite_l nat.nat (nat.times b n)
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq nat.nat (nat.minus (nat.times a (div_mod.mod m n)) __)
       (gcd.gcd_aux q n (div_mod.mod m n))) H (nat.times n b)
    (nat.commutative_times b n).

def let_clause_15441 :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (q:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl
             (sttfa.forall nat.nat
                (m:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall nat.nat
                   (n:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (nat.lt nat.O n)
                      (sttfa.impl (nat.le n m)
                         (sttfa.impl (nat.le n q)
                            (connectives.ex nat.nat
                               (a:(sttfa.etap (sttfa.p nat.nat)) =>
                                connectives.ex nat.nat
                                  (b:(sttfa.etap (sttfa.p nat.nat)) =>
                                   connectives.Or
                                     (logic.eq nat.nat
                                        (nat.minus (nat.times a n)
                                           (nat.times b m))
                                        (gcd.gcd_aux q m n))
                                     (logic.eq nat.nat
                                        (nat.minus (nat.times b m)
                                           (nat.times a n))
                                        (gcd.gcd_aux q m n))))))))))
             (sttfa.forall nat.nat
                (m:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall nat.nat
                   (n:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (nat.lt nat.O n)
                      (sttfa.impl (nat.le n m)
                         (sttfa.impl (nat.le n (nat.S q))
                            (sttfa.impl
                               (connectives.Not (primes.divides n m))
                               (sttfa.forall nat.nat
                                  (a:(sttfa.etap (sttfa.p nat.nat)) =>
                                   sttfa.impl
                                     (connectives.ex nat.nat
                                        (b:(sttfa.etap (sttfa.p nat.nat)) =>
                                         connectives.Or
                                           (logic.eq nat.nat
                                              (nat.minus
                                                 (nat.times a
                                                    (div_mod.mod m n))
                                                 (nat.times b n))
                                              (gcd.gcd_aux q n
                                                 (div_mod.mod m n)))
                                           (logic.eq nat.nat
                                              (nat.minus (nat.times b n)
                                                 (nat.times a
                                                    (div_mod.mod m n)))
                                              (gcd.gcd_aux q n
                                                 (div_mod.mod m n)))))
                                     (sttfa.forall nat.nat
                                        (b:(sttfa.etap (sttfa.p nat.nat)) =>
                                         sttfa.impl
                                           (connectives.Or
                                              (logic.eq nat.nat
                                                 (nat.minus
                                                    (nat.times a
                                                       (div_mod.mod m n))
                                                    (nat.times b n))
                                                 (gcd.gcd_aux q n
                                                    (div_mod.mod m n)))
                                              (logic.eq nat.nat
                                                 (nat.minus (nat.times b n)
                                                    (nat.times a
                                                       (div_mod.mod m n)))
                                                 (gcd.gcd_aux q n
                                                    (div_mod.mod m n))))
                                           (sttfa.impl
                                              (logic.eq nat.nat
                                                 (nat.minus (nat.times b n)
                                                    (nat.times a
                                                       (div_mod.mod m n)))
                                                 (gcd.gcd_aux q n
                                                    (div_mod.mod m n)))
                                              (logic.eq nat.nat
                                                 (nat.minus (nat.times n b)
                                                    (nat.times a
                                                       (div_mod.mod m n)))
                                                 (gcd.gcd_aux q n
                                                    (div_mod.mod m n)))))))))))))))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  q:(sttfa.etap (sttfa.p nat.nat)) =>
  Hind:
  (sttfa.eps
     (sttfa.forall nat.nat
        (m:(sttfa.etap (sttfa.p nat.nat)) =>
         sttfa.forall nat.nat
           (n:(sttfa.etap (sttfa.p nat.nat)) =>
            sttfa.impl (nat.lt nat.O n)
              (sttfa.impl (nat.le n m)
                 (sttfa.impl (nat.le n q)
                    (connectives.ex nat.nat
                       (a:(sttfa.etap (sttfa.p nat.nat)) =>
                        connectives.ex nat.nat
                          (b:(sttfa.etap (sttfa.p nat.nat)) =>
                           connectives.Or
                             (logic.eq nat.nat
                                (nat.minus (nat.times a n) (nat.times b m))
                                (gcd.gcd_aux q m n))
                             (logic.eq nat.nat
                                (nat.minus (nat.times b m) (nat.times a n))
                                (gcd.gcd_aux q m n))))))))))) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  posn:(sttfa.eps (nat.lt nat.O n)) =>
  lenm:(sttfa.eps (nat.le n m)) =>
  lenS:(sttfa.eps (nat.le n (nat.S q))) =>
  ndivnm:(sttfa.eps (connectives.Not (primes.divides n m))) =>
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  _clearme:
  (sttfa.eps
     (connectives.ex nat.nat
        (b:(sttfa.etap (sttfa.p nat.nat)) =>
         connectives.Or
           (logic.eq nat.nat
              (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n))
              (gcd.gcd_aux q n (div_mod.mod m n)))
           (logic.eq nat.nat
              (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n)))
              (gcd.gcd_aux q n (div_mod.mod m n)))))) =>
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  _clearme0:
  (sttfa.eps
     (connectives.Or
        (logic.eq nat.nat
           (nat.minus (nat.times a (div_mod.mod m n)) (nat.times b n))
           (gcd.gcd_aux q n (div_mod.mod m n)))
        (logic.eq nat.nat
           (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n)))
           (gcd.gcd_aux q n (div_mod.mod m n))))) =>
  H:
  (sttfa.eps
     (logic.eq nat.nat
        (nat.minus (nat.times b n) (nat.times a (div_mod.mod m n)))
        (gcd.gcd_aux q n (div_mod.mod m n)))) =>
  logic.rewrite_l nat.nat (nat.times b n)
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq nat.nat (nat.minus __ (nat.times a (div_mod.mod m n)))
       (gcd.gcd_aux q n (div_mod.mod m n))) H (nat.times n b)
    (nat.commutative_times b n).

def eq_minus_gcd_aux :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat
             (n:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.lt nat.O n)
                (sttfa.impl (nat.le n m)
                   (sttfa.impl (nat.le n p)
                      (connectives.ex nat.nat
                         (a:(sttfa.etap (sttfa.p nat.nat)) =>
                          connectives.ex nat.nat
                            (b:(sttfa.etap (sttfa.p nat.nat)) =>
                             connectives.Or
                               (logic.eq nat.nat
                                  (nat.minus (nat.times a n) (nat.times b m))
                                  (gcd.gcd_aux p m n))
                               (logic.eq nat.nat
                                  (nat.minus (nat.times b m) (nat.times a n))
                                  (gcd.gcd_aux p m n)))))))))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.forall nat.nat
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.lt nat.O n)
             (sttfa.impl (nat.le n m)
                (sttfa.impl (nat.le n _x_365)
                   (connectives.ex nat.nat
                      (a:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.ex nat.nat
                         (b:(sttfa.etap (sttfa.p nat.nat)) =>
                          connectives.Or
                            (logic.eq nat.nat
                               (nat.minus (nat.times a n) (nat.times b m))
                               (gcd.gcd_aux _x_365 m n))
                            (logic.eq nat.nat
                               (nat.minus (nat.times b m) (nat.times a n))
                               (gcd.gcd_aux _x_365 m n))))))))))
    (m:(sttfa.etap (sttfa.p nat.nat)) =>
     n:(sttfa.etap (sttfa.p nat.nat)) =>
     posn:(sttfa.eps (nat.lt nat.O n)) =>
     lenm:(sttfa.eps (nat.le n m)) =>
     lenO:(sttfa.eps (nat.le n nat.O)) =>
     connectives.falsity
       (connectives.ex nat.nat
          (a:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.ex nat.nat
             (b:(sttfa.etap (sttfa.p nat.nat)) =>
              connectives.Or
                (logic.eq nat.nat
                   (nat.minus (nat.times a n) (nat.times b m))
                   (gcd.gcd_aux nat.O m n))
                (logic.eq nat.nat
                   (nat.minus (nat.times b m) (nat.times a n))
                   (gcd.gcd_aux nat.O m n)))))
       (logic.absurd (nat.lt nat.O n) posn (nat.le_to_not_lt n nat.O lenO)))
    (q:(sttfa.etap (sttfa.p nat.nat)) =>
     Hind:
     (sttfa.eps
        (sttfa.forall nat.nat
           (m:(sttfa.etap (sttfa.p nat.nat)) =>
            sttfa.forall nat.nat
              (n:(sttfa.etap (sttfa.p nat.nat)) =>
               sttfa.impl (nat.lt nat.O n)
                 (sttfa.impl (nat.le n m)
                    (sttfa.impl (nat.le n q)
                       (connectives.ex nat.nat
                          (a:(sttfa.etap (sttfa.p nat.nat)) =>
                           connectives.ex nat.nat
                             (b:(sttfa.etap (sttfa.p nat.nat)) =>
                              connectives.Or
                                (logic.eq nat.nat
                                   (nat.minus (nat.times a n) (nat.times b m))
                                   (gcd.gcd_aux q m n))
                                (logic.eq nat.nat
                                   (nat.minus (nat.times b m) (nat.times a n))
                                   (gcd.gcd_aux q m n))))))))))) =>
     m:(sttfa.etap (sttfa.p nat.nat)) =>
     n:(sttfa.etap (sttfa.p nat.nat)) =>
     posn:(sttfa.eps (nat.lt nat.O n)) =>
     lenm:(sttfa.eps (nat.le n m)) =>
     lenS:(sttfa.eps (nat.le n (nat.S q))) =>
     connectives.match_Or_prop (primes.divides n m)
       (connectives.Not (primes.divides n m))
       (connectives.ex nat.nat
          (a:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.ex nat.nat
             (b:(sttfa.etap (sttfa.p nat.nat)) =>
              connectives.Or
                (logic.eq nat.nat
                   (nat.minus (nat.times a n) (nat.times b m))
                   (gcd.gcd_aux (nat.S q) m n))
                (logic.eq nat.nat
                   (nat.minus (nat.times b m) (nat.times a n))
                   (gcd.gcd_aux (nat.S q) m n)))))
       (divnm:(sttfa.eps (primes.divides n m)) =>
        logic.eq_ind_r nat.nat n
          (x:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.ex nat.nat
             (a:(sttfa.etap (sttfa.p nat.nat)) =>
              connectives.ex nat.nat
                (b:(sttfa.etap (sttfa.p nat.nat)) =>
                 connectives.Or
                   (logic.eq nat.nat
                      (nat.minus (nat.times a n) (nat.times b m)) x)
                   (logic.eq nat.nat
                      (nat.minus (nat.times b m) (nat.times a n)) x))))
          (connectives.ex_intro nat.nat
                 (x:(sttfa.etap (sttfa.p nat.nat)) =>
                    (connectives.ex nat.nat
                       (b:(sttfa.etap (sttfa.p nat.nat)) =>
                        connectives.Or
                          (logic.eq nat.nat
                             (nat.minus (nat.times x n) (nat.times b m)) n)
                          (logic.eq nat.nat
                             (nat.minus (nat.times b m) (nat.times x n)) n))))
           (nat.S nat.O)
             (connectives.ex_intro nat.nat
                    (x:(sttfa.etap (sttfa.p nat.nat)) =>
                       (connectives.Or
                          (logic.eq nat.nat
                             (nat.minus (nat.times (nat.S nat.O) n)
                                (nat.times x m)) n)
                          (logic.eq nat.nat
                             (nat.minus (nat.times x m)
                                (nat.times (nat.S nat.O) n)) n)))
              nat.O
                (connectives.or_introl
                       (logic.eq nat.nat
                          (nat.minus (nat.times (nat.S nat.O) n)
                             (nat.times nat.O m)) n)
                       (logic.eq nat.nat
                          (nat.minus (nat.times nat.O m)
                             (nat.times (nat.S nat.O) n)) n)
                   (logic.rewrite_r nat.nat (nat.times n (nat.S nat.O))
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat (nat.minus __ (nat.times nat.O m)) n)
                      (logic.rewrite_l nat.nat
                         (nat.plus n (nat.times n nat.O))
                         (__:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat
                            (nat.minus __ (nat.times nat.O m)) n)
                         (logic.rewrite_l nat.nat nat.O
                            (__:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq nat.nat
                               (nat.minus (nat.plus n __) (nat.times nat.O m))
                               n)
                            (logic.rewrite_l nat.nat n
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq nat.nat
                                  (nat.minus __ (nat.times nat.O m)) n)
                               (logic.rewrite_r nat.nat (nat.times m nat.O)
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq nat.nat (nat.minus n __) n)
                                  (logic.rewrite_l nat.nat nat.O
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq nat.nat (nat.minus n __) n)
                                     (logic.rewrite_l nat.nat n
                                        (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq nat.nat __ n)
                                        (logic.refl nat.nat n)
                                        (nat.minus n nat.O) (nat.minus_n_O n))
                                     (nat.times m nat.O) (nat.times_n_O m))
                                  (nat.times nat.O m)
                                  (nat.commutative_times nat.O m))
                               (nat.plus n nat.O) (nat.plus_n_O n))
                            (nat.times n nat.O) (nat.times_n_O n))
                         (nat.times n (nat.S nat.O)) (nat.times_n_Sm n nat.O))
                      (nat.times (nat.S nat.O) n)
                      (nat.commutative_times (nat.S nat.O) n)))))
          (gcd.gcd_aux (nat.S q) m n)
          (gcd.divides_to_gcd_aux (nat.S q) m n (nat.lt_O_S q) posn divnm))
       (ndivnm:(sttfa.eps (connectives.Not (primes.divides n m))) =>
        logic.eq_ind_r nat.nat (gcd.gcd_aux q n (div_mod.mod m n))
          (x:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.ex nat.nat
             (a:(sttfa.etap (sttfa.p nat.nat)) =>
              connectives.ex nat.nat
                (b:(sttfa.etap (sttfa.p nat.nat)) =>
                 connectives.Or
                   (logic.eq nat.nat
                      (nat.minus (nat.times a n) (nat.times b m)) x)
                   (logic.eq nat.nat
                      (nat.minus (nat.times b m) (nat.times a n)) x))))
          (connectives.match_ex_prop nat.nat
             (a:(sttfa.etap (sttfa.p nat.nat)) =>
              connectives.ex nat.nat
                (b:(sttfa.etap (sttfa.p nat.nat)) =>
                 connectives.Or
                   (logic.eq nat.nat
                      (nat.minus (nat.times a (div_mod.mod m n))
                         (nat.times b n)) (gcd.gcd_aux q n (div_mod.mod m n)))
                   (logic.eq nat.nat
                      (nat.minus (nat.times b n)
                         (nat.times a (div_mod.mod m n)))
                      (gcd.gcd_aux q n (div_mod.mod m n)))))
             (connectives.ex nat.nat
                (a:(sttfa.etap (sttfa.p nat.nat)) =>
                 connectives.ex nat.nat
                   (b:(sttfa.etap (sttfa.p nat.nat)) =>
                    connectives.Or
                      (logic.eq nat.nat
                         (nat.minus (nat.times a n) (nat.times b m))
                         (gcd.gcd_aux q n (div_mod.mod m n)))
                      (logic.eq nat.nat
                         (nat.minus (nat.times b m) (nat.times a n))
                         (gcd.gcd_aux q n (div_mod.mod m n))))))
             (a:(sttfa.etap (sttfa.p nat.nat)) =>
              _clearme:
              (sttfa.eps
                 (connectives.ex nat.nat
                    (b:(sttfa.etap (sttfa.p nat.nat)) =>
                     connectives.Or
                       (logic.eq nat.nat
                          (nat.minus (nat.times a (div_mod.mod m n))
                             (nat.times b n))
                          (gcd.gcd_aux q n (div_mod.mod m n)))
                       (logic.eq nat.nat
                          (nat.minus (nat.times b n)
                             (nat.times a (div_mod.mod m n)))
                          (gcd.gcd_aux q n (div_mod.mod m n)))))) =>
              connectives.match_ex_prop nat.nat
                (b:(sttfa.etap (sttfa.p nat.nat)) =>
                 connectives.Or
                   (logic.eq nat.nat
                      (nat.minus (nat.times a (div_mod.mod m n))
                         (nat.times b n)) (gcd.gcd_aux q n (div_mod.mod m n)))
                   (logic.eq nat.nat
                      (nat.minus (nat.times b n)
                         (nat.times a (div_mod.mod m n)))
                      (gcd.gcd_aux q n (div_mod.mod m n))))
                (connectives.ex nat.nat
                   (a0:(sttfa.etap (sttfa.p nat.nat)) =>
                    connectives.ex nat.nat
                      (b:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.Or
                         (logic.eq nat.nat
                            (nat.minus (nat.times a0 n) (nat.times b m))
                            (gcd.gcd_aux q n (div_mod.mod m n)))
                         (logic.eq nat.nat
                            (nat.minus (nat.times b m) (nat.times a0 n))
                            (gcd.gcd_aux q n (div_mod.mod m n))))))
                (b:(sttfa.etap (sttfa.p nat.nat)) =>
                 _clearme0:
                 (sttfa.eps
                    (connectives.Or
                       (logic.eq nat.nat
                          (nat.minus (nat.times a (div_mod.mod m n))
                             (nat.times b n))
                          (gcd.gcd_aux q n (div_mod.mod m n)))
                       (logic.eq nat.nat
                          (nat.minus (nat.times b n)
                             (nat.times a (div_mod.mod m n)))
                          (gcd.gcd_aux q n (div_mod.mod m n))))) =>
                 connectives.match_Or_prop
                   (logic.eq nat.nat
                      (nat.minus (nat.times a (div_mod.mod m n))
                         (nat.times b n)) (gcd.gcd_aux q n (div_mod.mod m n)))
                   (logic.eq nat.nat
                      (nat.minus (nat.times b n)
                         (nat.times a (div_mod.mod m n)))
                      (gcd.gcd_aux q n (div_mod.mod m n)))
                   (connectives.ex nat.nat
                      (a0:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.ex nat.nat
                         (b0:(sttfa.etap (sttfa.p nat.nat)) =>
                          connectives.Or
                            (logic.eq nat.nat
                               (nat.minus (nat.times a0 n) (nat.times b0 m))
                               (gcd.gcd_aux q n (div_mod.mod m n)))
                            (logic.eq nat.nat
                               (nat.minus (nat.times b0 m) (nat.times a0 n))
                               (gcd.gcd_aux q n (div_mod.mod m n))))))
                   (H:
                    (sttfa.eps
                       (logic.eq nat.nat
                          (nat.minus (nat.times a (div_mod.mod m n))
                             (nat.times b n))
                          (gcd.gcd_aux q n (div_mod.mod m n)))) =>
                    logic.eq_ind nat.nat
                      (nat.minus (nat.times a (div_mod.mod m n))
                         (nat.times b n))
                      (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.ex nat.nat
                         (a0:(sttfa.etap (sttfa.p nat.nat)) =>
                          connectives.ex nat.nat
                            (b0:(sttfa.etap (sttfa.p nat.nat)) =>
                             connectives.Or
                               (logic.eq nat.nat
                                  (nat.minus (nat.times a0 n)
                                     (nat.times b0 m)) x_1)
                               (logic.eq nat.nat
                                  (nat.minus (nat.times b0 m)
                                     (nat.times a0 n)) x_1))))
                      (connectives.ex_intro nat.nat
                             (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                (connectives.ex nat.nat
                                   (b0:(sttfa.etap (sttfa.p nat.nat)) =>
                                    connectives.Or
                                      (logic.eq nat.nat
                                         (nat.minus (nat.times x n)
                                            (nat.times b0 m))
                                         (nat.minus
                                            (nat.times a (div_mod.mod m n))
                                            (nat.times b n)))
                                      (logic.eq nat.nat
                                         (nat.minus (nat.times b0 m)
                                            (nat.times x n))
                                         (nat.minus
                                            (nat.times a (div_mod.mod m n))
                                            (nat.times b n))))))
                       (nat.plus b (nat.times a (div_mod.div m n)))
                         (connectives.ex_intro nat.nat
                                (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                   (connectives.Or
                                      (logic.eq nat.nat
                                         (nat.minus
                                            (nat.times
                                               (nat.plus b
                                                  (nat.times a
                                                     (div_mod.div m n))) n)
                                            (nat.times x m))
                                         (nat.minus
                                            (nat.times a (div_mod.mod m n))
                                            (nat.times b n)))
                                      (logic.eq nat.nat
                                         (nat.minus (nat.times x m)
                                            (nat.times
                                               (nat.plus b
                                                  (nat.times a
                                                     (div_mod.div m n))) n))
                                         (nat.minus
                                            (nat.times a (div_mod.mod m n))
                                            (nat.times b n)))))
                          a
                            (connectives.or_intror
                                   (logic.eq nat.nat
                                      (nat.minus
                                         (nat.times
                                            (nat.plus b
                                               (nat.times a (div_mod.div m n)))
                                            n) (nat.times a m))
                                      (nat.minus
                                         (nat.times a (div_mod.mod m n))
                                         (nat.times b n)))
                                   (logic.eq nat.nat
                                      (nat.minus (nat.times a m)
                                         (nat.times
                                            (nat.plus b
                                               (nat.times a (div_mod.div m n)))
                                            n))
                                      (nat.minus
                                         (nat.times a (div_mod.mod m n))
                                         (nat.times b n)))
                               (logic.eq_ind nat.nat
                                  (nat.plus (nat.times a (div_mod.div m n)) b)
                                  (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq nat.nat
                                     (nat.minus (nat.times a m)
                                        (nat.times x_1 n))
                                     (nat.minus
                                        (nat.times a (div_mod.mod m n))
                                        (nat.times b n)))
                                  (logic.eq_ind_r nat.nat
                                     (nat.plus
                                        (nat.times
                                           (nat.times a (div_mod.div m n)) n)
                                        (nat.times b n))
                                     (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq nat.nat
                                        (nat.minus (nat.times a m) x)
                                        (nat.minus
                                           (nat.times a (div_mod.mod m n))
                                           (nat.times b n)))
                                     (logic.eq_ind_r nat.nat
                                        (nat.plus
                                           (nat.times (div_mod.div m n) n)
                                           (div_mod.mod m n))
                                        (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq nat.nat
                                           (nat.minus (nat.times a x)
                                              (nat.plus
                                                 (nat.times
                                                    (nat.times a
                                                       (div_mod.div m n)) n)
                                                 (nat.times b n)))
                                           (nat.minus
                                              (nat.times a (div_mod.mod m n))
                                              (nat.times b n)))
                                        (logic.eq_ind_r nat.nat
                                           (nat.times a
                                              (nat.times (div_mod.div m n) n))
                                           (x:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq nat.nat
                                              (nat.minus
                                                 (nat.times a
                                                    (nat.plus
                                                       (nat.times
                                                          (div_mod.div m n) n)
                                                       (div_mod.mod m n)))
                                                 (nat.plus x (nat.times b n)))
                                              (nat.minus
                                                 (nat.times a
                                                    (div_mod.mod m n))
                                                 (nat.times b n)))
                                           (logic.eq_ind nat.nat
                                              (nat.plus (div_mod.mod m n)
                                                 (nat.times
                                                    (div_mod.div m n) n))
                                              (x_1:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq nat.nat
                                                 (nat.minus
                                                    (nat.times a x_1)
                                                    (nat.plus
                                                       (nat.times a
                                                          (nat.times
                                                             (div_mod.div m n)
                                                             n))
                                                       (nat.times b n)))
                                                 (nat.minus
                                                    (nat.times a
                                                       (div_mod.mod m n))
                                                    (nat.times b n)))
                                              (logic.eq_ind_r nat.nat
                                                 (nat.plus
                                                    (nat.times a
                                                       (div_mod.mod m n))
                                                    (nat.times a
                                                       (nat.times
                                                          (div_mod.div m n) n)))
                                                 (x:
                                                  (sttfa.etap
                                                     (sttfa.p nat.nat)) =>
                                                  logic.eq nat.nat
                                                    (nat.minus x
                                                       (nat.plus
                                                          (nat.times a
                                                             (nat.times
                                                                (div_mod.div
                                                                   m n) n))
                                                          (nat.times b n)))
                                                    (nat.minus
                                                       (nat.times a
                                                          (div_mod.mod m n))
                                                       (nat.times b n)))
                                                 (logic.eq_ind nat.nat
                                                    (nat.minus
                                                       (nat.minus
                                                          (nat.plus
                                                             (nat.times a
                                                                (div_mod.mod
                                                                   m n))
                                                             (nat.times a
                                                                (nat.times
                                                                   (div_mod.div
                                                                    m n) n)))
                                                          (nat.times a
                                                             (nat.times
                                                                (div_mod.div
                                                                   m n) n)))
                                                       (nat.times b n))
                                                    (x_1:
                                                     (sttfa.etap
                                                        (sttfa.p nat.nat)) =>
                                                     logic.eq nat.nat x_1
                                                       (nat.minus
                                                          (nat.times a
                                                             (div_mod.mod m n))
                                                          (nat.times b n)))
                                                    (logic.eq_ind nat.nat
                                                       (nat.plus
                                                          (nat.times a
                                                             (nat.times
                                                                (div_mod.div
                                                                   m n) n))
                                                          (nat.times a
                                                             (div_mod.mod m n)))
                                                       (x_1:
                                                        (sttfa.etap
                                                           (sttfa.p nat.nat)) =>
                                                        logic.eq nat.nat
                                                          (nat.minus
                                                             (nat.minus x_1
                                                                (nat.times a
                                                                   (nat.times
                                                                    (div_mod.div
                                                                    m n) n)))
                                                             (nat.times b n))
                                                          (nat.minus
                                                             (nat.times a
                                                                (div_mod.mod
                                                                   m n))
                                                             (nat.times b n)))
                                                       (logic.eq_ind nat.nat
                                                          (nat.plus
                                                             (nat.minus
                                                                (nat.times a
                                                                   (nat.times
                                                                    (div_mod.div
                                                                    m n) n))
                                                                (nat.times a
                                                                   (nat.times
                                                                    (div_mod.div
                                                                    m n) n)))
                                                             (nat.times a
                                                                (div_mod.mod
                                                                   m n)))
                                                          (x_1:
                                                           (sttfa.etap
                                                              (sttfa.p
                                                                 nat.nat)) =>
                                                           logic.eq nat.nat
                                                             (nat.minus x_1
                                                                (nat.times b
                                                                   n))
                                                             (nat.minus
                                                                (nat.times a
                                                                   (div_mod.mod
                                                                    m n))
                                                                (nat.times b
                                                                   n)))
                                                          (logic.rewrite_r
                                                             nat.nat
                                                             (nat.times n
                                                                (div_mod.div
                                                                   m n))
                                                             (__:
                                                              (sttfa.etap
                                                                 (sttfa.p
                                                                    nat.nat)) =>
                                                              logic.eq
                                                                nat.nat
                                                                (nat.minus
                                                                   (nat.plus
                                                                    (nat.minus
                                                                    (nat.times
                                                                    a __)
                                                                    (nat.times
                                                                    a
                                                                    (nat.times
                                                                    (div_mod.div
                                                                    m n) n)))
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n)))
                                                                   (nat.times
                                                                    b n))
                                                                (nat.minus
                                                                   (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n))
                                                                   (nat.times
                                                                    b n)))
                                                             (logic.rewrite_r
                                                                nat.nat
                                                                (nat.times n
                                                                   (nat.times
                                                                    a
                                                                    (div_mod.div
                                                                    m n)))
                                                                (__:
                                                                 (sttfa.etap
                                                                    (
                                                                    sttfa.p
                                                                    nat.nat)) =>
                                                                 logic.eq
                                                                   nat.nat
                                                                   (nat.minus
                                                                    (nat.plus
                                                                    (nat.minus
                                                                    __
                                                                    (nat.times
                                                                    a
                                                                    (nat.times
                                                                    (div_mod.div
                                                                    m n) n)))
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n)))
                                                                    (nat.times
                                                                    b n))
                                                                   (nat.minus
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n))
                                                                    (nat.times
                                                                    b n)))
                                                                (logic.rewrite_r
                                                                   nat.nat
                                                                   (nat.times
                                                                    n
                                                                    (div_mod.div
                                                                    m n))
                                                                   (__:
                                                                    (
                                                                    sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (nat.minus
                                                                    (nat.plus
                                                                    (nat.minus
                                                                    (nat.times
                                                                    n
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.div
                                                                    m n)))
                                                                    (nat.times
                                                                    a __))
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n)))
                                                                    (nat.times
                                                                    b n))
                                                                    (nat.minus
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n))
                                                                    (nat.times
                                                                    b n)))
                                                                   (logic.rewrite_r
                                                                    nat.nat
                                                                    (nat.times
                                                                    n
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.div
                                                                    m n)))
                                                                    (__:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (nat.minus
                                                                    (nat.plus
                                                                    (nat.minus
                                                                    (nat.times
                                                                    n
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.div
                                                                    m n))) __)
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n)))
                                                                    (nat.times
                                                                    b n))
                                                                    (nat.minus
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n))
                                                                    (nat.times
                                                                    b n)))
                                                                    (logic.rewrite_l
                                                                    nat.nat
                                                                    nat.O
                                                                    (__:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (nat.minus
                                                                    (nat.plus
                                                                    __
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n)))
                                                                    (nat.times
                                                                    b n))
                                                                    (nat.minus
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n))
                                                                    (nat.times
                                                                    b n)))
                                                                    (logic.rewrite_l
                                                                    nat.nat
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n))
                                                                    (__:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (nat.minus
                                                                    __
                                                                    (nat.times
                                                                    b n))
                                                                    (nat.minus
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n))
                                                                    (nat.times
                                                                    b n)))
                                                                    (logic.rewrite_r
                                                                    nat.nat
                                                                    (nat.times
                                                                    n b)
                                                                    (__:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (nat.minus
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n)) __)
                                                                    (nat.minus
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n))
                                                                    (nat.times
                                                                    b n)))
                                                                    (logic.rewrite_r
                                                                    nat.nat
                                                                    (gcd.gcd_aux
                                                                    q n
                                                                    (div_mod.mod
                                                                    m n))
                                                                    (__:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    __
                                                                    (nat.minus
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n))
                                                                    (nat.times
                                                                    b n)))
                                                                    (logic.rewrite_r
                                                                    nat.nat
                                                                    (nat.times
                                                                    n b)
                                                                    (__:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (gcd.gcd_aux
                                                                    q n
                                                                    (div_mod.mod
                                                                    m n))
                                                                    (nat.minus
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n)) __))
                                                                    (logic.rewrite_r
                                                                    nat.nat
                                                                    (gcd.gcd_aux
                                                                    q n
                                                                    (div_mod.mod
                                                                    m n))
                                                                    (__:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (gcd.gcd_aux
                                                                    q n
                                                                    (div_mod.mod
                                                                    m n)) __)
                                                                    (logic.refl
                                                                    nat.nat
                                                                    (gcd.gcd_aux
                                                                    q n
                                                                    (div_mod.mod
                                                                    m n)))
                                                                    (nat.minus
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n))
                                                                    (nat.times
                                                                    n b))
                                                                    (gcd.let_clause_1544
                                                                    p q Hind
                                                                    m n posn
                                                                    lenm
                                                                    lenS
                                                                    ndivnm a
                                                                    _clearme
                                                                    b
                                                                    _clearme0
                                                                    H))
                                                                    (nat.times
                                                                    b n)
                                                                    (nat.commutative_times
                                                                    b n))
                                                                    (nat.minus
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n))
                                                                    (nat.times
                                                                    n b))
                                                                    (gcd.let_clause_1544
                                                                    p q Hind
                                                                    m n posn
                                                                    lenm
                                                                    lenS
                                                                    ndivnm a
                                                                    _clearme
                                                                    b
                                                                    _clearme0
                                                                    H))
                                                                    (nat.times
                                                                    b n)
                                                                    (nat.commutative_times
                                                                    b n))
                                                                    (nat.plus
                                                                    nat.O
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n)))
                                                                    (nat.plus_O_n
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n))))
                                                                    (nat.minus
                                                                    (nat.times
                                                                    n
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.div
                                                                    m n)))
                                                                    (nat.times
                                                                    n
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.div
                                                                    m n))))
                                                                    (nat.minus_n_n
                                                                    (nat.times
                                                                    n
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.div
                                                                    m n)))))
                                                                    (nat.times
                                                                    a
                                                                    (nat.times
                                                                    n
                                                                    (div_mod.div
                                                                    m n)))
                                                                    (nat.times_times
                                                                    a n
                                                                    (div_mod.div
                                                                    m n)))
                                                                   (nat.times
                                                                    (div_mod.div
                                                                    m n) n)
                                                                   (nat.commutative_times
                                                                    (div_mod.div
                                                                    m n) n))
                                                                (nat.times a
                                                                   (nat.times
                                                                    n
                                                                    (div_mod.div
                                                                    m n)))
                                                                (nat.times_times
                                                                   a n
                                                                   (div_mod.div
                                                                    m n)))
                                                             (nat.times
                                                                (div_mod.div
                                                                   m n) n)
                                                             (nat.commutative_times
                                                                (div_mod.div
                                                                   m n) n))
                                                          (nat.minus
                                                             (nat.plus
                                                                (nat.times a
                                                                   (nat.times
                                                                    (div_mod.div
                                                                    m n) n))
                                                                (nat.times a
                                                                   (div_mod.mod
                                                                    m n)))
                                                             (nat.times a
                                                                (nat.times
                                                                   (div_mod.div
                                                                    m n) n)))
                                                          (nat.plus_minus
                                                             (nat.times a
                                                                (nat.times
                                                                   (div_mod.div
                                                                    m n) n))
                                                             (nat.times a
                                                                (nat.times
                                                                   (div_mod.div
                                                                    m n) n))
                                                             (nat.times a
                                                                (div_mod.mod
                                                                   m n))
                                                             (nat.le_n
                                                                (nat.times a
                                                                   (nat.times
                                                                    (div_mod.div
                                                                    m n) n)))))
                                                       (nat.plus
                                                          (nat.times a
                                                             (div_mod.mod m n))
                                                          (nat.times a
                                                             (nat.times
                                                                (div_mod.div
                                                                   m n) n)))
                                                       (nat.commutative_plus
                                                          (nat.times a
                                                             (nat.times
                                                                (div_mod.div
                                                                   m n) n))
                                                          (nat.times a
                                                             (div_mod.mod m n))))
                                                    (nat.minus
                                                       (nat.plus
                                                          (nat.times a
                                                             (div_mod.mod m n))
                                                          (nat.times a
                                                             (nat.times
                                                                (div_mod.div
                                                                   m n) n)))
                                                       (nat.plus
                                                          (nat.times a
                                                             (nat.times
                                                                (div_mod.div
                                                                   m n) n))
                                                          (nat.times b n)))
                                                    (nat.minus_plus
                                                       (nat.plus
                                                          (nat.times a
                                                             (div_mod.mod m n))
                                                          (nat.times a
                                                             (nat.times
                                                                (div_mod.div
                                                                   m n) n)))
                                                       (nat.times a
                                                          (nat.times
                                                             (div_mod.div m n)
                                                             n))
                                                       (nat.times b n)))
                                                 (nat.times a
                                                    (nat.plus
                                                       (div_mod.mod m n)
                                                       (nat.times
                                                          (div_mod.div m n) n)))
                                                 (nat.distributive_times_plus
                                                    a (div_mod.mod m n)
                                                    (nat.times
                                                       (div_mod.div m n) n)))
                                              (nat.plus
                                                 (nat.times
                                                    (div_mod.div m n) n)
                                                 (div_mod.mod m n))
                                              (nat.commutative_plus
                                                 (div_mod.mod m n)
                                                 (nat.times
                                                    (div_mod.div m n) n)))
                                           (nat.times
                                              (nat.times a (div_mod.div m n))
                                              n)
                                           (nat.associative_times a
                                              (div_mod.div m n) n)) m
                                        (div_mod.div_mod m n))
                                     (nat.times
                                        (nat.plus
                                           (nat.times a (div_mod.div m n)) b)
                                        n)
                                     (nat.distributive_times_plus_r n
                                        (nat.times a (div_mod.div m n)) b))
                                  (nat.plus b (nat.times a (div_mod.div m n)))
                                  (nat.commutative_plus
                                     (nat.times a (div_mod.div m n)) b)))))
                      (gcd.gcd_aux q n (div_mod.mod m n)) H)
                   (H:
                    (sttfa.eps
                       (logic.eq nat.nat
                          (nat.minus (nat.times b n)
                             (nat.times a (div_mod.mod m n)))
                          (gcd.gcd_aux q n (div_mod.mod m n)))) =>
                    logic.eq_ind nat.nat
                      (nat.minus (nat.times b n)
                         (nat.times a (div_mod.mod m n)))
                      (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.ex nat.nat
                         (a0:(sttfa.etap (sttfa.p nat.nat)) =>
                          connectives.ex nat.nat
                            (b0:(sttfa.etap (sttfa.p nat.nat)) =>
                             connectives.Or
                               (logic.eq nat.nat
                                  (nat.minus (nat.times a0 n)
                                     (nat.times b0 m)) x_1)
                               (logic.eq nat.nat
                                  (nat.minus (nat.times b0 m)
                                     (nat.times a0 n)) x_1))))
                      (connectives.ex_intro nat.nat
                             (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                (connectives.ex nat.nat
                                   (b0:(sttfa.etap (sttfa.p nat.nat)) =>
                                    connectives.Or
                                      (logic.eq nat.nat
                                         (nat.minus (nat.times x n)
                                            (nat.times b0 m))
                                         (nat.minus (nat.times b n)
                                            (nat.times a (div_mod.mod m n))))
                                      (logic.eq nat.nat
                                         (nat.minus (nat.times b0 m)
                                            (nat.times x n))
                                         (nat.minus (nat.times b n)
                                            (nat.times a (div_mod.mod m n)))))))
                       (nat.plus b (nat.times a (div_mod.div m n)))
                         (connectives.ex_intro nat.nat
                                (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                   (connectives.Or
                                      (logic.eq nat.nat
                                         (nat.minus
                                            (nat.times
                                               (nat.plus b
                                                  (nat.times a
                                                     (div_mod.div m n))) n)
                                            (nat.times x m))
                                         (nat.minus (nat.times b n)
                                            (nat.times a (div_mod.mod m n))))
                                      (logic.eq nat.nat
                                         (nat.minus (nat.times x m)
                                            (nat.times
                                               (nat.plus b
                                                  (nat.times a
                                                     (div_mod.div m n))) n))
                                         (nat.minus (nat.times b n)
                                            (nat.times a (div_mod.mod m n))))))
                          a
                            (connectives.or_introl
                                   (logic.eq nat.nat
                                      (nat.minus
                                         (nat.times
                                            (nat.plus b
                                               (nat.times a (div_mod.div m n)))
                                            n) (nat.times a m))
                                      (nat.minus (nat.times b n)
                                         (nat.times a (div_mod.mod m n))))
                                   (logic.eq nat.nat
                                      (nat.minus (nat.times a m)
                                         (nat.times
                                            (nat.plus b
                                               (nat.times a (div_mod.div m n)))
                                            n))
                                      (nat.minus (nat.times b n)
                                         (nat.times a (div_mod.mod m n))))
                               (logic.eq_ind_r nat.nat
                                  (nat.plus (nat.times b n)
                                     (nat.times
                                        (nat.times a (div_mod.div m n)) n))
                                  (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq nat.nat
                                     (nat.minus x (nat.times a m))
                                     (nat.minus (nat.times b n)
                                        (nat.times a (div_mod.mod m n))))
                                  (logic.eq_ind_r nat.nat
                                     (nat.plus
                                        (nat.times (div_mod.div m n) n)
                                        (div_mod.mod m n))
                                     (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq nat.nat
                                        (nat.minus
                                           (nat.plus (nat.times b n)
                                              (nat.times
                                                 (nat.times a
                                                    (div_mod.div m n)) n))
                                           (nat.times a x))
                                        (nat.minus (nat.times b n)
                                           (nat.times a (div_mod.mod m n))))
                                     (logic.eq_ind_r nat.nat
                                        (nat.plus
                                           (nat.times a
                                              (nat.times (div_mod.div m n) n))
                                           (nat.times a (div_mod.mod m n)))
                                        (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq nat.nat
                                           (nat.minus
                                              (nat.plus (nat.times b n)
                                                 (nat.times
                                                    (nat.times a
                                                       (div_mod.div m n)) n))
                                              x)
                                           (nat.minus (nat.times b n)
                                              (nat.times a (div_mod.mod m n))))
                                        (logic.eq_ind_r nat.nat
                                           (nat.times a
                                              (nat.times (div_mod.div m n) n))
                                           (x:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq nat.nat
                                              (nat.minus
                                                 (nat.plus (nat.times b n) x)
                                                 (nat.plus
                                                    (nat.times a
                                                       (nat.times
                                                          (div_mod.div m n) n))
                                                    (nat.times a
                                                       (div_mod.mod m n))))
                                              (nat.minus (nat.times b n)
                                                 (nat.times a
                                                    (div_mod.mod m n))))
                                           (logic.eq_ind nat.nat
                                              (nat.minus
                                                 (nat.minus
                                                    (nat.plus
                                                       (nat.times b n)
                                                       (nat.times a
                                                          (nat.times
                                                             (div_mod.div m n)
                                                             n)))
                                                    (nat.times a
                                                       (nat.times
                                                          (div_mod.div m n) n)))
                                                 (nat.times a
                                                    (div_mod.mod m n)))
                                              (x_1:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq nat.nat x_1
                                                 (nat.minus (nat.times b n)
                                                    (nat.times a
                                                       (div_mod.mod m n))))
                                              (logic.eq_ind nat.nat
                                                 (nat.plus
                                                    (nat.times a
                                                       (nat.times
                                                          (div_mod.div m n) n))
                                                    (nat.times b n))
                                                 (x_1:
                                                  (sttfa.etap
                                                     (sttfa.p nat.nat)) =>
                                                  logic.eq nat.nat
                                                    (nat.minus
                                                       (nat.minus x_1
                                                          (nat.times a
                                                             (nat.times
                                                                (div_mod.div
                                                                   m n) n)))
                                                       (nat.times a
                                                          (div_mod.mod m n)))
                                                    (nat.minus
                                                       (nat.times b n)
                                                       (nat.times a
                                                          (div_mod.mod m n))))
                                                 (logic.eq_ind nat.nat
                                                    (nat.plus
                                                       (nat.minus
                                                          (nat.times a
                                                             (nat.times
                                                                (div_mod.div
                                                                   m n) n))
                                                          (nat.times a
                                                             (nat.times
                                                                (div_mod.div
                                                                   m n) n)))
                                                       (nat.times b n))
                                                    (x_1:
                                                     (sttfa.etap
                                                        (sttfa.p nat.nat)) =>
                                                     logic.eq nat.nat
                                                       (nat.minus x_1
                                                          (nat.times a
                                                             (div_mod.mod m n)))
                                                       (nat.minus
                                                          (nat.times b n)
                                                          (nat.times a
                                                             (div_mod.mod m n))))
                                                    (logic.rewrite_r nat.nat
                                                       (nat.times n
                                                          (div_mod.div m n))
                                                       (__:
                                                        (sttfa.etap
                                                           (sttfa.p nat.nat)) =>
                                                        logic.eq nat.nat
                                                          (nat.minus
                                                             (nat.plus
                                                                (nat.minus
                                                                   (nat.times
                                                                    a __)
                                                                   (nat.times
                                                                    a
                                                                    (nat.times
                                                                    (div_mod.div
                                                                    m n) n)))
                                                                (nat.times b
                                                                   n))
                                                             (nat.times a
                                                                (div_mod.mod
                                                                   m n)))
                                                          (nat.minus
                                                             (nat.times b n)
                                                             (nat.times a
                                                                (div_mod.mod
                                                                   m n))))
                                                       (logic.rewrite_r
                                                          nat.nat
                                                          (nat.times n
                                                             (nat.times a
                                                                (div_mod.div
                                                                   m n)))
                                                          (__:
                                                           (sttfa.etap
                                                              (sttfa.p
                                                                 nat.nat)) =>
                                                           logic.eq nat.nat
                                                             (nat.minus
                                                                (nat.plus
                                                                   (nat.minus
                                                                    __
                                                                    (nat.times
                                                                    a
                                                                    (nat.times
                                                                    (div_mod.div
                                                                    m n) n)))
                                                                   (nat.times
                                                                    b n))
                                                                (nat.times a
                                                                   (div_mod.mod
                                                                    m n)))
                                                             (nat.minus
                                                                (nat.times b
                                                                   n)
                                                                (nat.times a
                                                                   (div_mod.mod
                                                                    m n))))
                                                          (logic.rewrite_r
                                                             nat.nat
                                                             (nat.times n
                                                                (div_mod.div
                                                                   m n))
                                                             (__:
                                                              (sttfa.etap
                                                                 (sttfa.p
                                                                    nat.nat)) =>
                                                              logic.eq
                                                                nat.nat
                                                                (nat.minus
                                                                   (nat.plus
                                                                    (nat.minus
                                                                    (nat.times
                                                                    n
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.div
                                                                    m n)))
                                                                    (nat.times
                                                                    a __))
                                                                    (nat.times
                                                                    b n))
                                                                   (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n)))
                                                                (nat.minus
                                                                   (nat.times
                                                                    b n)
                                                                   (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n))))
                                                             (logic.rewrite_r
                                                                nat.nat
                                                                (nat.times n
                                                                   (nat.times
                                                                    a
                                                                    (div_mod.div
                                                                    m n)))
                                                                (__:
                                                                 (sttfa.etap
                                                                    (
                                                                    sttfa.p
                                                                    nat.nat)) =>
                                                                 logic.eq
                                                                   nat.nat
                                                                   (nat.minus
                                                                    (nat.plus
                                                                    (nat.minus
                                                                    (nat.times
                                                                    n
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.div
                                                                    m n))) __)
                                                                    (nat.times
                                                                    b n))
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n)))
                                                                   (nat.minus
                                                                    (nat.times
                                                                    b n)
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n))))
                                                                (logic.rewrite_l
                                                                   nat.nat
                                                                   nat.O
                                                                   (__:
                                                                    (
                                                                    sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (nat.minus
                                                                    (nat.plus
                                                                    __
                                                                    (nat.times
                                                                    b n))
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n)))
                                                                    (nat.minus
                                                                    (nat.times
                                                                    b n)
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n))))
                                                                   (logic.rewrite_r
                                                                    nat.nat
                                                                    (nat.times
                                                                    n b)
                                                                    (__:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (nat.minus
                                                                    (nat.plus
                                                                    nat.O __)
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n)))
                                                                    (nat.minus
                                                                    (nat.times
                                                                    b n)
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n))))
                                                                    (logic.rewrite_l
                                                                    nat.nat
                                                                    (nat.times
                                                                    n b)
                                                                    (__:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (nat.minus
                                                                    __
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n)))
                                                                    (nat.minus
                                                                    (nat.times
                                                                    b n)
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n))))
                                                                    (logic.rewrite_r
                                                                    nat.nat
                                                                    (gcd.gcd_aux
                                                                    q n
                                                                    (div_mod.mod
                                                                    m n))
                                                                    (__:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    __
                                                                    (nat.minus
                                                                    (nat.times
                                                                    b n)
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n))))
                                                                    (logic.rewrite_r
                                                                    nat.nat
                                                                    (nat.times
                                                                    n b)
                                                                    (__:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (gcd.gcd_aux
                                                                    q n
                                                                    (div_mod.mod
                                                                    m n))
                                                                    (nat.minus
                                                                    __
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n))))
                                                                    (logic.rewrite_r
                                                                    nat.nat
                                                                    (gcd.gcd_aux
                                                                    q n
                                                                    (div_mod.mod
                                                                    m n))
                                                                    (__:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (gcd.gcd_aux
                                                                    q n
                                                                    (div_mod.mod
                                                                    m n)) __)
                                                                    (logic.refl
                                                                    nat.nat
                                                                    (gcd.gcd_aux
                                                                    q n
                                                                    (div_mod.mod
                                                                    m n)))
                                                                    (nat.minus
                                                                    (nat.times
                                                                    n b)
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n)))
                                                                    (gcd.let_clause_15441
                                                                    p q Hind
                                                                    m n posn
                                                                    lenm
                                                                    lenS
                                                                    ndivnm a
                                                                    _clearme
                                                                    b
                                                                    _clearme0
                                                                    H))
                                                                    (nat.times
                                                                    b n)
                                                                    (nat.commutative_times
                                                                    b n))
                                                                    (nat.minus
                                                                    (nat.times
                                                                    n b)
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.mod
                                                                    m n)))
                                                                    (gcd.let_clause_15441
                                                                    p q Hind
                                                                    m n posn
                                                                    lenm
                                                                    lenS
                                                                    ndivnm a
                                                                    _clearme
                                                                    b
                                                                    _clearme0
                                                                    H))
                                                                    (nat.plus
                                                                    nat.O
                                                                    (nat.times
                                                                    n b))
                                                                    (nat.plus_O_n
                                                                    (nat.times
                                                                    n b)))
                                                                    (nat.times
                                                                    b n)
                                                                    (nat.commutative_times
                                                                    b n))
                                                                   (nat.minus
                                                                    (nat.times
                                                                    n
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.div
                                                                    m n)))
                                                                    (nat.times
                                                                    n
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.div
                                                                    m n))))
                                                                   (nat.minus_n_n
                                                                    (nat.times
                                                                    n
                                                                    (nat.times
                                                                    a
                                                                    (div_mod.div
                                                                    m n)))))
                                                                (nat.times a
                                                                   (nat.times
                                                                    n
                                                                    (div_mod.div
                                                                    m n)))
                                                                (nat.times_times
                                                                   a n
                                                                   (div_mod.div
                                                                    m n)))
                                                             (nat.times
                                                                (div_mod.div
                                                                   m n) n)
                                                             (nat.commutative_times
                                                                (div_mod.div
                                                                   m n) n))
                                                          (nat.times a
                                                             (nat.times n
                                                                (div_mod.div
                                                                   m n)))
                                                          (nat.times_times a
                                                             n
                                                             (div_mod.div m n)))
                                                       (nat.times
                                                          (div_mod.div m n) n)
                                                       (nat.commutative_times
                                                          (div_mod.div m n) n))
                                                    (nat.minus
                                                       (nat.plus
                                                          (nat.times a
                                                             (nat.times
                                                                (div_mod.div
                                                                   m n) n))
                                                          (nat.times b n))
                                                       (nat.times a
                                                          (nat.times
                                                             (div_mod.div m n)
                                                             n)))
                                                    (nat.plus_minus
                                                       (nat.times a
                                                          (nat.times
                                                             (div_mod.div m n)
                                                             n))
                                                       (nat.times a
                                                          (nat.times
                                                             (div_mod.div m n)
                                                             n))
                                                       (nat.times b n)
                                                       (nat.le_n
                                                          (nat.times a
                                                             (nat.times
                                                                (div_mod.div
                                                                   m n) n)))))
                                                 (nat.plus (nat.times b n)
                                                    (nat.times a
                                                       (nat.times
                                                          (div_mod.div m n) n)))
                                                 (nat.commutative_plus
                                                    (nat.times a
                                                       (nat.times
                                                          (div_mod.div m n) n))
                                                    (nat.times b n)))
                                              (nat.minus
                                                 (nat.plus (nat.times b n)
                                                    (nat.times a
                                                       (nat.times
                                                          (div_mod.div m n) n)))
                                                 (nat.plus
                                                    (nat.times a
                                                       (nat.times
                                                          (div_mod.div m n) n))
                                                    (nat.times a
                                                       (div_mod.mod m n))))
                                              (nat.minus_plus
                                                 (nat.plus (nat.times b n)
                                                    (nat.times a
                                                       (nat.times
                                                          (div_mod.div m n) n)))
                                                 (nat.times a
                                                    (nat.times
                                                       (div_mod.div m n) n))
                                                 (nat.times a
                                                    (div_mod.mod m n))))
                                           (nat.times
                                              (nat.times a (div_mod.div m n))
                                              n)
                                           (nat.associative_times a
                                              (div_mod.div m n) n))
                                        (nat.times a
                                           (nat.plus
                                              (nat.times (div_mod.div m n) n)
                                              (div_mod.mod m n)))
                                        (nat.distributive_times_plus a
                                           (nat.times (div_mod.div m n) n)
                                           (div_mod.mod m n))) m
                                     (div_mod.div_mod m n))
                                  (nat.times
                                     (nat.plus b
                                        (nat.times a (div_mod.div m n))) n)
                                  (nat.distributive_times_plus_r n b
                                     (nat.times a (div_mod.div m n)))))))
                      (gcd.gcd_aux q n (div_mod.mod m n)) H) _clearme0)
                _clearme)
             (Hind n (div_mod.mod m n)
                (connectives.match_Or_prop (nat.lt nat.O (div_mod.mod m n))
                   (logic.eq nat.nat nat.O (div_mod.mod m n))
                   (nat.lt nat.O (div_mod.mod m n))
                   (auto:(sttfa.eps (nat.lt nat.O (div_mod.mod m n))) => auto)
                   (modO:
                    (sttfa.eps (logic.eq nat.nat nat.O (div_mod.mod m n))) =>
                    connectives.falsity (nat.lt nat.O (div_mod.mod m n))
                      (logic.absurd (primes.divides n m)
                         (primes.mod_O_to_divides n m posn
                            (logic.rewrite_l nat.nat nat.O
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq nat.nat __ nat.O)
                               (logic.refl nat.nat nat.O) (div_mod.mod m n)
                               modO)) ndivnm))
                   (nat.le_to_or_lt_eq nat.O (div_mod.mod m n)
                      (nat.le_O_n (div_mod.mod m n))))
                (nat.lt_to_le (div_mod.mod m n) n
                   (div_mod.lt_mod_m_m m n posn))
                (nat.le_S_S_to_le (div_mod.mod m n) q
                   (nat.transitive_le (nat.S (div_mod.mod m n)) n (nat.S q)
                      (div_mod.lt_mod_m_m m n posn) lenS))))
          (gcd.gcd_aux (nat.S q) m n)
          (gcd.not_divides_to_gcd_aux q m n posn ndivnm))
       (primes.decidable_divides n m)) p.

def let_clause_1549 :
  sttfa.eps
    (sttfa.forall nat.nat
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.lt nat.O n)
             (sttfa.impl (logic.eq nat.nat nat.O m)
                (sttfa.forall nat.nat
                   (x1106:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat x1106 (nat.minus x1106 m)))))))
  :=
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  posn:(sttfa.eps (nat.lt nat.O n)) =>
  eqm0:(sttfa.eps (logic.eq nat.nat nat.O m)) =>
  x1106:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.rewrite_l nat.nat nat.O
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq nat.nat x1106 (nat.minus x1106 __)) (nat.minus_n_O x1106) m
    eqm0.

def let_clause_15491 :
  sttfa.eps
    (sttfa.forall nat.nat
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (logic.eq nat.nat nat.O n)
             (sttfa.forall nat.nat
                (x1106:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat x1106 (nat.minus x1106 n))))))
  :=
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  eqn0:(sttfa.eps (logic.eq nat.nat nat.O n)) =>
  x1106:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.rewrite_l nat.nat nat.O
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq nat.nat x1106 (nat.minus x1106 __)) (nat.minus_n_O x1106) n
    eqn0.

def let_clause_1551 :
  sttfa.eps
    (sttfa.forall nat.nat
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (logic.eq nat.nat nat.O n)
             (sttfa.forall nat.nat
                (x347:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat n (nat.times x347 n))))))
  :=
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  eqn0:(sttfa.eps (logic.eq nat.nat nat.O n)) =>
  x347:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.rewrite_l nat.nat nat.O
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq nat.nat n (nat.times x347 __))
    (logic.rewrite_l nat.nat nat.O
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat __ (nat.times x347 nat.O)) (nat.times_n_O x347) n
       eqn0) n eqn0.

def eq_minus_gcd :
  sttfa.eps
    (sttfa.forall nat.nat
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.ex nat.nat
             (a:(sttfa.etap (sttfa.p nat.nat)) =>
              connectives.ex nat.nat
                (b:(sttfa.etap (sttfa.p nat.nat)) =>
                 connectives.Or
                   (logic.eq nat.nat
                      (nat.minus (nat.times a n) (nat.times b m))
                      (gcd.gcd n m))
                   (logic.eq nat.nat
                      (nat.minus (nat.times b m) (nat.times a n))
                      (gcd.gcd n m)))))))
  :=
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  connectives.match_Or_prop (nat.lt nat.O n) (logic.eq nat.nat nat.O n)
    (connectives.ex nat.nat
       (a:(sttfa.etap (sttfa.p nat.nat)) =>
        connectives.ex nat.nat
          (b:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.Or
             (logic.eq nat.nat (nat.minus (nat.times a n) (nat.times b m))
                (gcd.gcd n m))
             (logic.eq nat.nat (nat.minus (nat.times b m) (nat.times a n))
                (gcd.gcd n m)))))
    (posn:(sttfa.eps (nat.lt nat.O n)) =>
     connectives.match_Or_prop (nat.lt nat.O m) (logic.eq nat.nat nat.O m)
       (connectives.ex nat.nat
          (a:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.ex nat.nat
             (b:(sttfa.etap (sttfa.p nat.nat)) =>
              connectives.Or
                (logic.eq nat.nat
                   (nat.minus (nat.times a n) (nat.times b m)) (gcd.gcd n m))
                (logic.eq nat.nat
                   (nat.minus (nat.times b m) (nat.times a n)) (gcd.gcd n m)))))
       (posm:(sttfa.eps (nat.lt nat.O m)) =>
        nat.leb_elim n m
          (__:(sttfa.etap (sttfa.p bool.bool)) =>
           connectives.ex nat.nat
             (a:(sttfa.etap (sttfa.p nat.nat)) =>
              connectives.ex nat.nat
                (b:(sttfa.etap (sttfa.p nat.nat)) =>
                 connectives.Or
                   (logic.eq nat.nat
                      (nat.minus (nat.times a n) (nat.times b m))
                      (bool.match_bool_type nat.nat (gcd.gcd_aux n m n)
                         (gcd.gcd_aux m n m) __))
                   (logic.eq nat.nat
                      (nat.minus (nat.times b m) (nat.times a n))
                      (bool.match_bool_type nat.nat (gcd.gcd_aux n m n)
                         (gcd.gcd_aux m n m) __)))))
          (bool.sym_eq_match_bool_type_true nat.nat (gcd.gcd_aux n m n)
             (gcd.gcd_aux m n m)
             (y:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.le n m)
                (connectives.ex nat.nat
                   (a:(sttfa.etap (sttfa.p nat.nat)) =>
                    connectives.ex nat.nat
                      (b:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.Or
                         (logic.eq nat.nat
                            (nat.minus (nat.times a n) (nat.times b m))
                            (bool.match_bool_type nat.nat
                               (gcd.gcd_aux n m n) (gcd.gcd_aux m n m)
                               bool.true))
                         (logic.eq nat.nat
                            (nat.minus (nat.times b m) (nat.times a n)) y)))))
             (bool.sym_eq_match_bool_type_true nat.nat (gcd.gcd_aux n m n)
                (gcd.gcd_aux m n m)
                (y:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (nat.le n m)
                   (connectives.ex nat.nat
                      (a:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.ex nat.nat
                         (b:(sttfa.etap (sttfa.p nat.nat)) =>
                          connectives.Or
                            (logic.eq nat.nat
                               (nat.minus (nat.times a n) (nat.times b m)) y)
                            (logic.eq nat.nat
                               (nat.minus (nat.times b m) (nat.times a n))
                               (gcd.gcd_aux n m n))))))
                (lenm:(sttfa.eps (nat.le n m)) =>
                 gcd.eq_minus_gcd_aux n m n posn lenm (nat.le_n n))))
          (bool.sym_eq_match_bool_type_false nat.nat (gcd.gcd_aux n m n)
             (gcd.gcd_aux m n m)
             (y:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (connectives.Not (nat.le n m))
                (connectives.ex nat.nat
                   (a:(sttfa.etap (sttfa.p nat.nat)) =>
                    connectives.ex nat.nat
                      (b:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.Or
                         (logic.eq nat.nat
                            (nat.minus (nat.times a n) (nat.times b m))
                            (bool.match_bool_type nat.nat
                               (gcd.gcd_aux n m n) (gcd.gcd_aux m n m)
                               bool.false))
                         (logic.eq nat.nat
                            (nat.minus (nat.times b m) (nat.times a n)) y)))))
             (bool.sym_eq_match_bool_type_false nat.nat (gcd.gcd_aux n m n)
                (gcd.gcd_aux m n m)
                (y:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (connectives.Not (nat.le n m))
                   (connectives.ex nat.nat
                      (a:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.ex nat.nat
                         (b:(sttfa.etap (sttfa.p nat.nat)) =>
                          connectives.Or
                            (logic.eq nat.nat
                               (nat.minus (nat.times a n) (nat.times b m)) y)
                            (logic.eq nat.nat
                               (nat.minus (nat.times b m) (nat.times a n))
                               (gcd.gcd_aux m n m))))))
                (nlenm:(sttfa.eps (connectives.Not (nat.le n m))) =>
                 connectives.match_ex_prop nat.nat
                   (a:(sttfa.etap (sttfa.p nat.nat)) =>
                    connectives.ex nat.nat
                      (b:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.Or
                         (logic.eq nat.nat
                            (nat.minus (nat.times a m) (nat.times b n))
                            (gcd.gcd_aux m n m))
                         (logic.eq nat.nat
                            (nat.minus (nat.times b n) (nat.times a m))
                            (gcd.gcd_aux m n m))))
                   (connectives.ex nat.nat
                      (a:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.ex nat.nat
                         (b:(sttfa.etap (sttfa.p nat.nat)) =>
                          connectives.Or
                            (logic.eq nat.nat
                               (nat.minus (nat.times a n) (nat.times b m))
                               (gcd.gcd_aux m n m))
                            (logic.eq nat.nat
                               (nat.minus (nat.times b m) (nat.times a n))
                               (gcd.gcd_aux m n m)))))
                   (a:(sttfa.etap (sttfa.p nat.nat)) =>
                    _clearme:
                    (sttfa.eps
                       (connectives.ex nat.nat
                          (b:(sttfa.etap (sttfa.p nat.nat)) =>
                           connectives.Or
                             (logic.eq nat.nat
                                (nat.minus (nat.times a m) (nat.times b n))
                                (gcd.gcd_aux m n m))
                             (logic.eq nat.nat
                                (nat.minus (nat.times b n) (nat.times a m))
                                (gcd.gcd_aux m n m))))) =>
                    connectives.match_ex_prop nat.nat
                      (b:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.Or
                         (logic.eq nat.nat
                            (nat.minus (nat.times a m) (nat.times b n))
                            (gcd.gcd_aux m n m))
                         (logic.eq nat.nat
                            (nat.minus (nat.times b n) (nat.times a m))
                            (gcd.gcd_aux m n m)))
                      (connectives.ex nat.nat
                         (a0:(sttfa.etap (sttfa.p nat.nat)) =>
                          connectives.ex nat.nat
                            (b:(sttfa.etap (sttfa.p nat.nat)) =>
                             connectives.Or
                               (logic.eq nat.nat
                                  (nat.minus (nat.times a0 n) (nat.times b m))
                                  (gcd.gcd_aux m n m))
                               (logic.eq nat.nat
                                  (nat.minus (nat.times b m) (nat.times a0 n))
                                  (gcd.gcd_aux m n m)))))
                      (b:(sttfa.etap (sttfa.p nat.nat)) =>
                       _clearme0:
                       (sttfa.eps
                          (connectives.Or
                             (logic.eq nat.nat
                                (nat.minus (nat.times a m) (nat.times b n))
                                (gcd.gcd_aux m n m))
                             (logic.eq nat.nat
                                (nat.minus (nat.times b n) (nat.times a m))
                                (gcd.gcd_aux m n m)))) =>
                       connectives.match_Or_prop
                         (logic.eq nat.nat
                            (nat.minus (nat.times a m) (nat.times b n))
                            (gcd.gcd_aux m n m))
                         (logic.eq nat.nat
                            (nat.minus (nat.times b n) (nat.times a m))
                            (gcd.gcd_aux m n m))
                         (connectives.ex nat.nat
                            (a0:(sttfa.etap (sttfa.p nat.nat)) =>
                             connectives.ex nat.nat
                               (b0:(sttfa.etap (sttfa.p nat.nat)) =>
                                connectives.Or
                                  (logic.eq nat.nat
                                     (nat.minus (nat.times a0 n)
                                        (nat.times b0 m)) (gcd.gcd_aux m n m))
                                  (logic.eq nat.nat
                                     (nat.minus (nat.times b0 m)
                                        (nat.times a0 n)) (gcd.gcd_aux m n m)))))
                         (H:
                          (sttfa.eps
                             (logic.eq nat.nat
                                (nat.minus (nat.times a m) (nat.times b n))
                                (gcd.gcd_aux m n m))) =>
                                connectives.ex_intro nat.nat
                                (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                   (connectives.ex nat.nat
                                      (b0:(sttfa.etap (sttfa.p nat.nat)) =>
                                       connectives.Or
                                         (logic.eq nat.nat
                                            (nat.minus (nat.times x n)
                                               (nat.times b0 m))
                                            (gcd.gcd_aux m n m))
                                         (logic.eq nat.nat
                                            (nat.minus (nat.times b0 m)
                                               (nat.times x n))
                                            (gcd.gcd_aux m n m)))))
                          b
                            (connectives.ex_intro nat.nat
                                   (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                      (connectives.Or
                                         (logic.eq nat.nat
                                            (nat.minus (nat.times b n)
                                               (nat.times x m))
                                            (gcd.gcd_aux m n m))
                                         (logic.eq nat.nat
                                            (nat.minus (nat.times x m)
                                               (nat.times b n))
                                            (gcd.gcd_aux m n m))))
                             a
                               (connectives.or_intror
                                      (logic.eq nat.nat
                                         (nat.minus (nat.times b n)
                                            (nat.times a m))
                                         (gcd.gcd_aux m n m))
                                      (logic.eq nat.nat
                                         (nat.minus (nat.times a m)
                                            (nat.times b n))
                                         (gcd.gcd_aux m n m))
                                  (logic.rewrite_r nat.nat (nat.times m a)
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq nat.nat
                                        (nat.minus __ (nat.times b n))
                                        (gcd.gcd_aux m n m))
                                     (logic.rewrite_r nat.nat
                                        (nat.times n b)
                                        (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq nat.nat
                                           (nat.minus (nat.times m a) __)
                                           (gcd.gcd_aux m n m))
                                        (logic.rewrite_r nat.nat
                                           (gcd.gcd_aux m n m)
                                           (__:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq nat.nat __
                                              (gcd.gcd_aux m n m))
                                           (logic.refl nat.nat
                                              (gcd.gcd_aux m n m))
                                           (nat.minus (nat.times m a)
                                              (nat.times n b))
                                           (logic.rewrite_l nat.nat
                                              (nat.times b n)
                                              (__:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq nat.nat
                                                 (nat.minus (nat.times m a)
                                                    __) (gcd.gcd_aux m n m))
                                              (logic.rewrite_l nat.nat
                                                 (nat.times a m)
                                                 (__:
                                                  (sttfa.etap
                                                     (sttfa.p nat.nat)) =>
                                                  logic.eq nat.nat
                                                    (nat.minus __
                                                       (nat.times b n))
                                                    (gcd.gcd_aux m n m)) H
                                                 (nat.times m a)
                                                 (nat.commutative_times a m))
                                              (nat.times n b)
                                              (nat.commutative_times b n)))
                                        (nat.times b n)
                                        (nat.commutative_times b n))
                                     (nat.times a m)
                                     (nat.commutative_times a m)))))
                         (H:
                          (sttfa.eps
                             (logic.eq nat.nat
                                (nat.minus (nat.times b n) (nat.times a m))
                                (gcd.gcd_aux m n m))) =>
                                connectives.ex_intro nat.nat
                                (y:(sttfa.etap (sttfa.p nat.nat)) =>
                                   (connectives.ex nat.nat
                                      (b0:(sttfa.etap (sttfa.p nat.nat)) =>
                                       connectives.Or
                                         (logic.eq nat.nat
                                            (nat.minus (nat.times y n)
                                               (nat.times b0 m))
                                            (gcd.gcd_aux m n m))
                                         (logic.eq nat.nat
                                            (nat.minus (nat.times b0 m)
                                               (nat.times y n))
                                            (gcd.gcd_aux m n m)))))
                          b
                            (connectives.ex_intro nat.nat
                                   (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                      (connectives.Or
                                         (logic.eq nat.nat
                                            (nat.minus (nat.times b n)
                                               (nat.times x m))
                                            (gcd.gcd_aux m n m))
                                         (logic.eq nat.nat
                                            (nat.minus (nat.times x m)
                                               (nat.times b n))
                                            (gcd.gcd_aux m n m))))
                             a
                               (connectives.or_introl
                                      (logic.eq nat.nat
                                         (nat.minus (nat.times b n)
                                            (nat.times a m))
                                         (gcd.gcd_aux m n m))
                                      (logic.eq nat.nat
                                         (nat.minus (nat.times a m)
                                            (nat.times b n))
                                         (gcd.gcd_aux m n m))
                                  (logic.rewrite_r nat.nat (nat.times n b)
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq nat.nat
                                        (nat.minus __ (nat.times a m))
                                        (gcd.gcd_aux m n m))
                                     (logic.rewrite_r nat.nat
                                        (nat.times m a)
                                        (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq nat.nat
                                           (nat.minus (nat.times n b) __)
                                           (gcd.gcd_aux m n m))
                                        (logic.rewrite_r nat.nat
                                           (gcd.gcd_aux m n m)
                                           (__:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq nat.nat __
                                              (gcd.gcd_aux m n m))
                                           (logic.refl nat.nat
                                              (gcd.gcd_aux m n m))
                                           (nat.minus (nat.times n b)
                                              (nat.times m a))
                                           (logic.rewrite_l nat.nat
                                              (nat.times a m)
                                              (__:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq nat.nat
                                                 (nat.minus (nat.times n b)
                                                    __) (gcd.gcd_aux m n m))
                                              (logic.rewrite_l nat.nat
                                                 (nat.times b n)
                                                 (__:
                                                  (sttfa.etap
                                                     (sttfa.p nat.nat)) =>
                                                  logic.eq nat.nat
                                                    (nat.minus __
                                                       (nat.times a m))
                                                    (gcd.gcd_aux m n m)) H
                                                 (nat.times n b)
                                                 (nat.commutative_times b n))
                                              (nat.times m a)
                                              (nat.commutative_times a m)))
                                        (nat.times a m)
                                        (nat.commutative_times a m))
                                     (nat.times b n)
                                     (nat.commutative_times b n)))))
                         _clearme0) _clearme)
                   (gcd.eq_minus_gcd_aux m n m posm
                      (nat.transitive_le m (nat.S m) n (nat.le_n_Sn m)
                         (nat.not_le_to_lt n m nlenm)) (nat.le_n m))))))
       (eqm0:(sttfa.eps (logic.eq nat.nat nat.O m)) =>
        logic.eq_ind_r nat.nat m
          (x:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.ex nat.nat
             (a:(sttfa.etap (sttfa.p nat.nat)) =>
              connectives.ex nat.nat
                (b:(sttfa.etap (sttfa.p nat.nat)) =>
                 connectives.Or
                   (logic.eq nat.nat
                      (nat.minus (nat.times a n) (nat.times b m))
                      (gcd.gcd n m))
                   (logic.eq nat.nat
                      (nat.minus (nat.times b m) (nat.times a n))
                      (gcd.gcd n m)))))
          (connectives.ex_intro nat.nat
                 (x:(sttfa.etap (sttfa.p nat.nat)) =>
                    (connectives.ex nat.nat
                       (b:(sttfa.etap (sttfa.p nat.nat)) =>
                        connectives.Or
                          (logic.eq nat.nat
                             (nat.minus (nat.times x n) (nat.times b m))
                             (gcd.gcd n m))
                          (logic.eq nat.nat
                             (nat.minus (nat.times b m) (nat.times x n))
                             (gcd.gcd n m)))))
           (nat.S nat.O)
             (connectives.ex_intro nat.nat
                    (y:(sttfa.etap (sttfa.p nat.nat)) =>
                       (connectives.Or
                          (logic.eq nat.nat
                             (nat.minus (nat.times (nat.S nat.O) n)
                                (nat.times y m)) (gcd.gcd n m))
                          (logic.eq nat.nat
                             (nat.minus (nat.times y m)
                                (nat.times (nat.S nat.O) n)) (gcd.gcd n m))))
              nat.O
                (connectives.or_introl
                       (logic.eq nat.nat
                          (nat.minus (nat.times (nat.S nat.O) n)
                             (nat.times nat.O m)) (gcd.gcd n m))
                       (logic.eq nat.nat
                          (nat.minus (nat.times nat.O m)
                             (nat.times (nat.S nat.O) n)) (gcd.gcd n m))
                   (logic.eq_coerc (logic.eq nat.nat n (nat.minus n nat.O))
                      (logic.eq nat.nat
                         (nat.minus (nat.times (nat.S nat.O) n)
                            (nat.times nat.O m)) (gcd.gcd n m))
                      (nat.minus_n_O n)
                      (logic.rewrite_r nat.nat m
                         (__:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq sttfa.bool
                            (logic.eq nat.nat n (nat.minus n __))
                            (logic.eq nat.nat
                               (nat.minus (nat.times (nat.S nat.O) n)
                                  (nat.times nat.O m)) (gcd.gcd n m)))
                         (logic.rewrite_l nat.nat n
                            (__:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq sttfa.bool (logic.eq nat.nat n __)
                               (logic.eq nat.nat
                                  (nat.minus (nat.times (nat.S nat.O) n)
                                     (nat.times nat.O m)) (gcd.gcd n m)))
                            (logic.rewrite_r nat.nat m
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq sttfa.bool (logic.eq nat.nat n n)
                                  (logic.eq nat.nat
                                     (nat.minus (nat.times (nat.S __) n)
                                        (nat.times nat.O m)) (gcd.gcd n m)))
                               (logic.rewrite_r nat.nat
                                  (nat.times n (nat.S m))
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq sttfa.bool
                                     (logic.eq nat.nat n n)
                                     (logic.eq nat.nat
                                        (nat.minus __ (nat.times nat.O m))
                                        (gcd.gcd n m)))
                                  (logic.rewrite_l nat.nat
                                     (nat.plus n (nat.times n m))
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq sttfa.bool
                                        (logic.eq nat.nat n n)
                                        (logic.eq nat.nat
                                           (nat.minus __ (nat.times nat.O m))
                                           (gcd.gcd n m)))
                                     (logic.rewrite_r nat.nat
                                        (nat.times m n)
                                        (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq sttfa.bool
                                           (logic.eq nat.nat n n)
                                           (logic.eq nat.nat
                                              (nat.minus (nat.plus n __)
                                                 (nat.times nat.O m))
                                              (gcd.gcd n m)))
                                        (logic.rewrite_l nat.nat m
                                           (__:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq sttfa.bool
                                              (logic.eq nat.nat n n)
                                              (logic.eq nat.nat
                                                 (nat.minus (nat.plus n __)
                                                    (nat.times nat.O m))
                                                 (gcd.gcd n m)))
                                           (logic.rewrite_r nat.nat
                                              (nat.plus m n)
                                              (__:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq sttfa.bool
                                                 (logic.eq nat.nat n n)
                                                 (logic.eq nat.nat
                                                    (nat.minus __
                                                       (nat.times nat.O m))
                                                    (gcd.gcd n m)))
                                              (logic.rewrite_l nat.nat n
                                                 (__:
                                                  (sttfa.etap
                                                     (sttfa.p nat.nat)) =>
                                                  logic.eq sttfa.bool
                                                    (logic.eq nat.nat n n)
                                                    (logic.eq nat.nat
                                                       (nat.minus __
                                                          (nat.times nat.O m))
                                                       (gcd.gcd n m)))
                                                 (logic.rewrite_r nat.nat m
                                                    (__:
                                                     (sttfa.etap
                                                        (sttfa.p nat.nat)) =>
                                                     logic.eq sttfa.bool
                                                       (logic.eq nat.nat n n)
                                                       (logic.eq nat.nat
                                                          (nat.minus n
                                                             (nat.times __ m))
                                                          (gcd.gcd n m)))
                                                    (logic.rewrite_l nat.nat
                                                       m
                                                       (__:
                                                        (sttfa.etap
                                                           (sttfa.p nat.nat)) =>
                                                        logic.eq sttfa.bool
                                                          (logic.eq nat.nat
                                                             n n)
                                                          (logic.eq nat.nat
                                                             (nat.minus n __)
                                                             (gcd.gcd n m)))
                                                       (logic.rewrite_l
                                                          nat.nat n
                                                          (__:
                                                           (sttfa.etap
                                                              (sttfa.p
                                                                 nat.nat)) =>
                                                           logic.eq
                                                             sttfa.bool
                                                             (logic.eq
                                                                nat.nat n n)
                                                             (logic.eq
                                                                nat.nat __
                                                                (gcd.gcd n m)))
                                                          (logic.rewrite_r
                                                             nat.nat
                                                             (gcd.gcd m n)
                                                             (__:
                                                              (sttfa.etap
                                                                 (sttfa.p
                                                                    nat.nat)) =>
                                                              logic.eq
                                                                sttfa.bool
                                                                (logic.eq
                                                                   nat.nat n
                                                                   n)
                                                                (logic.eq
                                                                   nat.nat n
                                                                   __))
                                                             (logic.rewrite_r
                                                                nat.nat n
                                                                (__:
                                                                 (sttfa.etap
                                                                    (
                                                                    sttfa.p
                                                                    nat.nat)) =>
                                                                 logic.eq
                                                                   sttfa.bool
                                                                   (logic.eq
                                                                    nat.nat
                                                                    n n)
                                                                   (logic.eq
                                                                    nat.nat
                                                                    n __))
                                                                (logic.refl
                                                                   sttfa.bool
                                                                   (logic.eq
                                                                    nat.nat
                                                                    n n))
                                                                (gcd.gcd m n)
                                                                (logic.rewrite_l
                                                                   nat.nat
                                                                   nat.O
                                                                   (__:
                                                                    (
                                                                    sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (gcd.gcd
                                                                    __ n) n)
                                                                   (gcd.gcd_O_l
                                                                    n) m eqm0))
                                                             (gcd.gcd n m)
                                                             (gcd.commutative_gcd
                                                                n m))
                                                          (nat.minus n m)
                                                          (gcd.let_clause_1549
                                                             m n posn eqm0 n))
                                                       (nat.times m m)
                                                       (logic.rewrite_l
                                                          nat.nat nat.O
                                                          (__:
                                                           (sttfa.etap
                                                              (sttfa.p
                                                                 nat.nat)) =>
                                                           logic.eq nat.nat
                                                             m
                                                             (nat.times m __))
                                                          (logic.rewrite_l
                                                             nat.nat nat.O
                                                             (__:
                                                              (sttfa.etap
                                                                 (sttfa.p
                                                                    nat.nat)) =>
                                                              logic.eq
                                                                nat.nat __
                                                                (nat.times m
                                                                   nat.O))
                                                             (nat.times_n_O m)
                                                             m eqm0) m eqm0))
                                                    nat.O eqm0)
                                                 (nat.plus m n)
                                                 (logic.rewrite_l nat.nat
                                                    nat.O
                                                    (__:
                                                     (sttfa.etap
                                                        (sttfa.p nat.nat)) =>
                                                     logic.eq nat.nat n
                                                       (nat.plus __ n))
                                                    (nat.plus_O_n n) m eqm0))
                                              (nat.plus n m)
                                              (nat.commutative_plus n m))
                                           (nat.times m n)
                                           (logic.rewrite_l nat.nat nat.O
                                              (__:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq nat.nat m
                                                 (nat.times __ n))
                                              (logic.rewrite_l nat.nat nat.O
                                                 (__:
                                                  (sttfa.etap
                                                     (sttfa.p nat.nat)) =>
                                                  logic.eq nat.nat __
                                                    (nat.times nat.O n))
                                                 (nat.times_O_n n) m eqm0) m
                                              eqm0)) (nat.times n m)
                                        (nat.commutative_times n m))
                                     (nat.times n (nat.S m))
                                     (nat.times_n_Sm n m))
                                  (nat.times (nat.S m) n)
                                  (nat.commutative_times (nat.S m) n)) nat.O
                               eqm0) (nat.minus n m)
                            (gcd.let_clause_1549 m n posn eqm0 n)) nat.O eqm0)))))
          nat.O eqm0) (nat.le_to_or_lt_eq nat.O m (nat.le_O_n m)))
    (eqn0:(sttfa.eps (logic.eq nat.nat nat.O n)) =>
     logic.eq_ind_r nat.nat n
       (x:(sttfa.etap (sttfa.p nat.nat)) =>
        connectives.ex nat.nat
          (a:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.ex nat.nat
             (b:(sttfa.etap (sttfa.p nat.nat)) =>
              connectives.Or
                (logic.eq nat.nat
                   (nat.minus (nat.times a n) (nat.times b m)) (gcd.gcd n m))
                (logic.eq nat.nat
                   (nat.minus (nat.times b m) (nat.times a n)) (gcd.gcd n m)))))
       (connectives.ex_intro nat.nat
              (x:(sttfa.etap (sttfa.p nat.nat)) =>
                 (connectives.ex nat.nat
                    (b:(sttfa.etap (sttfa.p nat.nat)) =>
                     connectives.Or
                       (logic.eq nat.nat
                          (nat.minus (nat.times x n) (nat.times b m))
                          (gcd.gcd n m))
                       (logic.eq nat.nat
                          (nat.minus (nat.times b m) (nat.times x n))
                          (gcd.gcd n m)))))
        nat.O
          (connectives.ex_intro nat.nat
                 (x:(sttfa.etap (sttfa.p nat.nat)) =>
                    (connectives.Or
                       (logic.eq nat.nat
                          (nat.minus (nat.times nat.O n) (nat.times x m))
                          (gcd.gcd n m))
                       (logic.eq nat.nat
                          (nat.minus (nat.times x m) (nat.times nat.O n))
                          (gcd.gcd n m))))
           (nat.S nat.O)
             (connectives.or_intror
                    (logic.eq nat.nat
                       (nat.minus (nat.times nat.O n)
                          (nat.times (nat.S nat.O) m)) (gcd.gcd n m))
                    (logic.eq nat.nat
                       (nat.minus (nat.times (nat.S nat.O) m)
                          (nat.times nat.O n)) (gcd.gcd n m))
                (logic.eq_coerc (logic.eq nat.nat m (nat.minus m nat.O))
                   (logic.eq nat.nat
                      (nat.minus (nat.times (nat.S nat.O) m)
                         (nat.times nat.O n)) (gcd.gcd n m))
                   (nat.minus_n_O m)
                   (logic.rewrite_r nat.nat m
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq sttfa.bool
                         (logic.eq nat.nat m (nat.minus m nat.O))
                         (logic.eq nat.nat
                            (nat.minus (nat.times (nat.S nat.O) m)
                               (nat.times nat.O n)) __))
                      (logic.rewrite_r nat.nat n
                         (__:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq sttfa.bool
                            (logic.eq nat.nat m (nat.minus m __))
                            (logic.eq nat.nat
                               (nat.minus (nat.times (nat.S nat.O) m)
                                  (nat.times nat.O n)) m))
                         (logic.rewrite_l nat.nat m
                            (__:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq sttfa.bool (logic.eq nat.nat m __)
                               (logic.eq nat.nat
                                  (nat.minus (nat.times (nat.S nat.O) m)
                                     (nat.times nat.O n)) m))
                            (logic.rewrite_r nat.nat n
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq sttfa.bool (logic.eq nat.nat m m)
                                  (logic.eq nat.nat
                                     (nat.minus (nat.times (nat.S __) m)
                                        (nat.times nat.O n)) m))
                               (logic.rewrite_r nat.nat
                                  (nat.times m (nat.S n))
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq sttfa.bool
                                     (logic.eq nat.nat m m)
                                     (logic.eq nat.nat
                                        (nat.minus __ (nat.times nat.O n)) m))
                                  (logic.rewrite_l nat.nat
                                     (nat.plus m (nat.times m n))
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq sttfa.bool
                                        (logic.eq nat.nat m m)
                                        (logic.eq nat.nat
                                           (nat.minus __ (nat.times nat.O n))
                                           m))
                                     (logic.rewrite_l nat.nat n
                                        (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq sttfa.bool
                                           (logic.eq nat.nat m m)
                                           (logic.eq nat.nat
                                              (nat.minus (nat.plus m __)
                                                 (nat.times nat.O n)) m))
                                        (logic.rewrite_l nat.nat m
                                           (__:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq sttfa.bool
                                              (logic.eq nat.nat m m)
                                              (logic.eq nat.nat
                                                 (nat.minus __
                                                    (nat.times nat.O n)) m))
                                           (logic.rewrite_r nat.nat n
                                              (__:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq sttfa.bool
                                                 (logic.eq nat.nat m m)
                                                 (logic.eq nat.nat
                                                    (nat.minus m
                                                       (nat.times __ n)) m))
                                              (logic.rewrite_l nat.nat n
                                                 (__:
                                                  (sttfa.etap
                                                     (sttfa.p nat.nat)) =>
                                                  logic.eq sttfa.bool
                                                    (logic.eq nat.nat m m)
                                                    (logic.eq nat.nat
                                                       (nat.minus m __) m))
                                                 (logic.rewrite_l nat.nat m
                                                    (__:
                                                     (sttfa.etap
                                                        (sttfa.p nat.nat)) =>
                                                     logic.eq sttfa.bool
                                                       (logic.eq nat.nat m m)
                                                       (logic.eq nat.nat __ m))
                                                    (logic.refl sttfa.bool
                                                       (logic.eq nat.nat m m))
                                                    (nat.minus m n)
                                                    (gcd.let_clause_15491 m
                                                       n eqn0 m))
                                                 (nat.times n n)
                                                 (gcd.let_clause_1551 m n
                                                    eqn0 n)) nat.O eqn0)
                                           (nat.plus m n)
                                           (logic.rewrite_l nat.nat nat.O
                                              (__:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq nat.nat m
                                                 (nat.plus m __))
                                              (nat.plus_n_O m) n eqn0))
                                        (nat.times m n)
                                        (gcd.let_clause_1551 m n eqn0 m))
                                     (nat.times m (nat.S n))
                                     (nat.times_n_Sm m n))
                                  (nat.times (nat.S n) m)
                                  (nat.commutative_times (nat.S n) m)) nat.O
                               eqn0) (nat.minus m n)
                            (gcd.let_clause_15491 m n eqn0 m)) nat.O eqn0)
                      (gcd.gcd n m)
                      (logic.rewrite_l nat.nat nat.O
                         (__:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat (gcd.gcd __ m) m) (gcd.gcd_O_l m)
                         n eqn0)))))) nat.O eqn0)
    (nat.le_to_or_lt_eq nat.O n (nat.le_O_n n)).

def let_clause_1545 :
  sttfa.eps
    (sttfa.forall nat.nat
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (logic.eq nat.nat (gcd.gcd m n) nat.O)
             (sttfa.impl (primes.divides nat.O n)
                (sttfa.forall nat.nat
                   (q1:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (logic.eq nat.nat n (nat.times nat.O q1))
                      (sttfa.impl (primes.divides nat.O m)
                         (sttfa.forall nat.nat
                            (q2:(sttfa.etap (sttfa.p nat.nat)) =>
                             sttfa.impl
                               (logic.eq nat.nat m (nat.times nat.O q2))
                               (logic.eq nat.nat m nat.O))))))))))
  :=
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  H:(sttfa.eps (logic.eq nat.nat (gcd.gcd m n) nat.O)) =>
  _clearme:(sttfa.eps (primes.divides nat.O n)) =>
  q1:(sttfa.etap (sttfa.p nat.nat)) =>
  H1:(sttfa.eps (logic.eq nat.nat n (nat.times nat.O q1))) =>
  _clearme0:(sttfa.eps (primes.divides nat.O m)) =>
  q2:(sttfa.etap (sttfa.p nat.nat)) =>
  H2:(sttfa.eps (logic.eq nat.nat m (nat.times nat.O q2))) =>
  logic.rewrite_r nat.nat (nat.times q2 nat.O)
    (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat m __)
    (logic.rewrite_l nat.nat (nat.times nat.O q2)
       (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat m __) H2
       (nat.times q2 nat.O) (nat.commutative_times nat.O q2)) nat.O
    (nat.times_n_O q2).

def gcd_O_to_eq_O :
  sttfa.eps
    (sttfa.forall nat.nat
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (logic.eq nat.nat (gcd.gcd m n) nat.O)
             (connectives.And (logic.eq nat.nat m nat.O)
                (logic.eq nat.nat n nat.O)))))
  :=
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  H:(sttfa.eps (logic.eq nat.nat (gcd.gcd m n) nat.O)) =>
  connectives.match_And_prop (primes.divides nat.O n) (primes.divides nat.O m)
    (connectives.And (logic.eq nat.nat m nat.O) (logic.eq nat.nat n nat.O))
    (_clearme:(sttfa.eps (primes.divides nat.O n)) =>
     primes.match_divides_prop nat.O n
       (sttfa.impl (primes.divides nat.O m)
          (connectives.And (logic.eq nat.nat m nat.O)
             (logic.eq nat.nat n nat.O)))
       (q1:(sttfa.etap (sttfa.p nat.nat)) =>
        H1:(sttfa.eps (logic.eq nat.nat n (nat.times nat.O q1))) =>
        _clearme0:(sttfa.eps (primes.divides nat.O m)) =>
        primes.match_divides_prop nat.O m
          (connectives.And (logic.eq nat.nat m nat.O)
             (logic.eq nat.nat n nat.O))
          (q2:(sttfa.etap (sttfa.p nat.nat)) =>
           H2:(sttfa.eps (logic.eq nat.nat m (nat.times nat.O q2))) =>
           connectives.conj (logic.eq nat.nat m nat.O)
                 (logic.eq nat.nat n nat.O)
             (logic.rewrite_l nat.nat m
                (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat m __)
                (logic.refl nat.nat m) nat.O
                (logic.rewrite_r nat.nat (nat.times q2 nat.O)
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat m __)
                   (logic.rewrite_l nat.nat (nat.times nat.O q2)
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat m __) H2 (nat.times q2 nat.O)
                      (nat.commutative_times nat.O q2)) nat.O
                   (nat.times_n_O q2)))
             (logic.rewrite_r nat.nat m
                (__:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat __ nat.O)
                (logic.rewrite_l nat.nat m
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat m __) (logic.refl nat.nat m) nat.O
                   (gcd.let_clause_1545 m n H _clearme q1 H1 _clearme0 q2 H2))
                n
                (logic.rewrite_r nat.nat (nat.times m q1)
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat n __)
                   (logic.rewrite_r nat.nat nat.O
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat n (nat.times __ q1)) H1 m
                      (gcd.let_clause_1545 m n H _clearme q1 H1 _clearme0 q2
                         H2)) m
                   (logic.rewrite_r nat.nat nat.O
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat m (nat.times __ q1))
                      (logic.rewrite_r nat.nat nat.O
                         (__:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat __ (nat.times nat.O q1))
                         (nat.times_O_n q1) m
                         (gcd.let_clause_1545 m n H _clearme q1 H1 _clearme0
                            q2 H2)) m
                      (gcd.let_clause_1545 m n H _clearme q1 H1 _clearme0 q2
                         H2))))) _clearme0) _clearme)
    (logic.eq_ind nat.nat (gcd.gcd m n)
       (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
        connectives.And (primes.divides x_1 n) (primes.divides x_1 m))
       (gcd.divides_gcd_nm m n) nat.O H).

def let_clause_1571 :
  sttfa.eps
    (sttfa.forall nat.nat
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.lt nat.O n)
             (sttfa.impl (logic.eq nat.nat (gcd.gcd m n) nat.O)
                (sttfa.impl (logic.eq nat.nat m nat.O)
                   (sttfa.impl (logic.eq nat.nat n nat.O)
                      (logic.eq nat.nat m n)))))))
  :=
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  posn:(sttfa.eps (nat.lt nat.O n)) =>
  H:(sttfa.eps (logic.eq nat.nat (gcd.gcd m n) nat.O)) =>
  auto:(sttfa.eps (logic.eq nat.nat m nat.O)) =>
  auto':(sttfa.eps (logic.eq nat.nat n nat.O)) =>
  logic.rewrite_r nat.nat nat.O
    (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat m __) auto n auto'.

def let_clause_1572 :
  sttfa.eps
    (sttfa.forall nat.nat
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.lt nat.O n)
             (sttfa.impl (logic.eq nat.nat (gcd.gcd m n) nat.O)
                (sttfa.impl (logic.eq nat.nat m nat.O)
                   (sttfa.impl (logic.eq nat.nat n nat.O)
                      (logic.eq nat.nat m nat.O)))))))
  :=
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  posn:(sttfa.eps (nat.lt nat.O n)) =>
  H:(sttfa.eps (logic.eq nat.nat (gcd.gcd m n) nat.O)) =>
  auto:(sttfa.eps (logic.eq nat.nat m nat.O)) =>
  auto':(sttfa.eps (logic.eq nat.nat n nat.O)) =>
  logic.rewrite_r nat.nat n
    (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat __ nat.O) auto' m
    (gcd.let_clause_1571 m n posn H auto auto').

def lt_O_gcd :
  sttfa.eps
    (sttfa.forall nat.nat
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.lt nat.O n) (nat.lt nat.O (gcd.gcd m n)))))
  :=
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  posn:(sttfa.eps (nat.lt nat.O n)) =>
  nat.nat_case (gcd.gcd m n) (nat.lt nat.O)
    (H:(sttfa.eps (logic.eq nat.nat (gcd.gcd m n) nat.O)) =>
     connectives.match_And_prop (logic.eq nat.nat m nat.O)
       (logic.eq nat.nat n nat.O) (nat.lt nat.O nat.O)
       (auto:(sttfa.eps (logic.eq nat.nat m nat.O)) =>
        auto':(sttfa.eps (logic.eq nat.nat n nat.O)) =>
        logic.eq_coerc (nat.lt nat.O n) (nat.lt nat.O nat.O) posn
          (logic.rewrite_l nat.nat m
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq sttfa.bool (nat.lt __ n) (nat.lt nat.O nat.O))
             (logic.rewrite_l nat.nat m
                (__:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq sttfa.bool (nat.lt m __) (nat.lt nat.O nat.O))
                (logic.rewrite_l nat.nat m
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq sttfa.bool (nat.lt m m) (nat.lt __ nat.O))
                   (logic.rewrite_l nat.nat m
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq sttfa.bool (nat.lt m m) (nat.lt m __))
                      (logic.refl sttfa.bool (nat.lt m m)) nat.O
                      (gcd.let_clause_1572 m n posn H auto auto')) nat.O
                   (gcd.let_clause_1572 m n posn H auto auto')) n
                (gcd.let_clause_1571 m n posn H auto auto')) nat.O
             (gcd.let_clause_1572 m n posn H auto auto')))
       (gcd.gcd_O_to_eq_O m n H))
    (m0:(sttfa.etap (sttfa.p nat.nat)) =>
     auto:(sttfa.eps (logic.eq nat.nat (gcd.gcd m n) (nat.S m0))) =>
     nat.lt_O_S m0).

def prime_to_gcd_1 :
  sttfa.eps
    (sttfa.forall nat.nat
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (primes.prime n)
             (sttfa.impl (connectives.Not (primes.divides n m))
                (logic.eq nat.nat (gcd.gcd n m) (nat.S nat.O))))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  _clearme:(sttfa.eps (primes.prime n)) =>
  connectives.match_And_prop (nat.lt (nat.S nat.O) n)
    (sttfa.forall nat.nat
       (m1:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.impl (primes.divides m1 n)
          (sttfa.impl (nat.lt (nat.S nat.O) m1) (logic.eq nat.nat m1 n))))
    (sttfa.impl (connectives.Not (primes.divides n m))
       (logic.eq nat.nat (gcd.gcd n m) (nat.S nat.O)))
    (lt1n:(sttfa.eps (nat.lt (nat.S nat.O) n)) =>
     primen:
     (sttfa.eps
        (sttfa.forall nat.nat
           (m0:(sttfa.etap (sttfa.p nat.nat)) =>
            sttfa.impl (primes.divides m0 n)
              (sttfa.impl (nat.lt (nat.S nat.O) m0) (logic.eq nat.nat m0 n))))) =>
     ndivnm:(sttfa.eps (connectives.Not (primes.divides n m))) =>
     nat.le_to_le_to_eq (gcd.gcd n m) (nat.S nat.O)
       (nat.not_lt_to_le (nat.S nat.O) (gcd.gcd n m)
          (logic.not_to_not (nat.lt (nat.S nat.O) (gcd.gcd n m))
             (logic.eq nat.nat (gcd.gcd n m) n)
             (primen (gcd.gcd n m) (gcd.divides_gcd_l n m))
             (logic.not_to_not (logic.eq nat.nat (gcd.gcd n m) n)
                (primes.divides n m)
                (auto:(sttfa.eps (logic.eq nat.nat (gcd.gcd n m) n)) =>
                 logic.eq_coerc (primes.divides (gcd.gcd n m) m)
                   (primes.divides n m) (gcd.divides_gcd_r n m)
                   (logic.rewrite_r nat.nat n
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq sttfa.bool (primes.divides __ m)
                         (primes.divides n m))
                      (logic.refl sttfa.bool (primes.divides n m))
                      (gcd.gcd n m) auto)) ndivnm)))
       (gcd.lt_O_gcd n m
          (nat.not_eq_to_le_to_lt nat.O m
             (logic.not_to_not (logic.eq nat.nat nat.O m)
                (primes.divides n m)
                (auto:(sttfa.eps (logic.eq nat.nat nat.O m)) =>
                 logic.eq_coerc (primes.divides n nat.O)
                   (primes.divides n m) (primes.divides_n_O n)
                   (logic.rewrite_r nat.nat m
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq sttfa.bool (primes.divides n __)
                         (primes.divides n m))
                      (logic.refl sttfa.bool (primes.divides n m)) nat.O auto))
                ndivnm) (nat.le_O_n m)))) _clearme.

def divides_times_to_divides :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat
             (m:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (primes.prime p)
                (sttfa.impl (primes.divides p (nat.times n m))
                   (connectives.Or (primes.divides p n) (primes.divides p m)))))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  primp:(sttfa.eps (primes.prime p)) =>
  _clearme:(sttfa.eps (primes.divides p (nat.times n m))) =>
  primes.match_divides_prop p (nat.times n m)
    (connectives.Or (primes.divides p n) (primes.divides p m))
    (c:(sttfa.etap (sttfa.p nat.nat)) =>
     nm:(sttfa.eps (logic.eq nat.nat (nat.times n m) (nat.times p c))) =>
     connectives.match_Or_prop (primes.divides p n)
       (connectives.Not (primes.divides p n))
       (connectives.Or (primes.divides p n) (primes.divides p m))
       (auto:(sttfa.eps (primes.divides p n)) =>
        connectives.or_introl (primes.divides p n)
         (primes.divides p m) auto)
       (ndivpn:(sttfa.eps (connectives.Not (primes.divides p n))) =>
       connectives.or_intror (primes.divides p n)
                        (primes.divides p m)
          (connectives.match_ex_prop nat.nat
             (a:(sttfa.etap (sttfa.p nat.nat)) =>
              connectives.ex nat.nat
                (b:(sttfa.etap (sttfa.p nat.nat)) =>
                 connectives.Or
                   (logic.eq nat.nat
                      (nat.minus (nat.times a n) (nat.times b p))
                      (nat.S nat.O))
                   (logic.eq nat.nat
                      (nat.minus (nat.times b p) (nat.times a n))
                      (nat.S nat.O)))) (primes.divides p m)
             (a:(sttfa.etap (sttfa.p nat.nat)) =>
              _clearme0:
              (sttfa.eps
                 (connectives.ex nat.nat
                    (b:(sttfa.etap (sttfa.p nat.nat)) =>
                     connectives.Or
                       (logic.eq nat.nat
                          (nat.minus (nat.times a n) (nat.times b p))
                          (nat.S nat.O))
                       (logic.eq nat.nat
                          (nat.minus (nat.times b p) (nat.times a n))
                          (nat.S nat.O))))) =>
              connectives.match_ex_prop nat.nat
                (b:(sttfa.etap (sttfa.p nat.nat)) =>
                 connectives.Or
                   (logic.eq nat.nat
                      (nat.minus (nat.times a n) (nat.times b p))
                      (nat.S nat.O))
                   (logic.eq nat.nat
                      (nat.minus (nat.times b p) (nat.times a n))
                      (nat.S nat.O))) (primes.divides p m)
                (b:(sttfa.etap (sttfa.p nat.nat)) =>
                 _clearme1:
                 (sttfa.eps
                    (connectives.Or
                       (logic.eq nat.nat
                          (nat.minus (nat.times a n) (nat.times b p))
                          (nat.S nat.O))
                       (logic.eq nat.nat
                          (nat.minus (nat.times b p) (nat.times a n))
                          (nat.S nat.O)))) =>
                 connectives.match_Or_prop
                   (logic.eq nat.nat
                      (nat.minus (nat.times a n) (nat.times b p))
                      (nat.S nat.O))
                   (logic.eq nat.nat
                      (nat.minus (nat.times b p) (nat.times a n))
                      (nat.S nat.O)) (primes.divides p m)
                   (H:
                    (sttfa.eps
                       (logic.eq nat.nat
                          (nat.minus (nat.times a n) (nat.times b p))
                          (nat.S nat.O))) =>
                    primes.quotient p m
                      (nat.minus (nat.times a c) (nat.times b m))
                      (logic.eq_ind_r nat.nat
                         (nat.minus (nat.times p (nat.times a c))
                            (nat.times p (nat.times b m)))
                         (x:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat m x)
                         (logic.eq_ind nat.nat (nat.times (nat.times p a) c)
                            (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq nat.nat m
                               (nat.minus x_1 (nat.times p (nat.times b m))))
                            (logic.eq_ind_r nat.nat (nat.times a p)
                               (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq nat.nat m
                                  (nat.minus (nat.times x c)
                                     (nat.times p (nat.times b m))))
                               (logic.eq_ind_r nat.nat
                                  (nat.times a (nat.times p c))
                                  (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq nat.nat m
                                     (nat.minus x
                                        (nat.times p (nat.times b m))))
                                  (logic.eq_ind nat.nat (nat.times n m)
                                     (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq nat.nat m
                                        (nat.minus (nat.times a x_1)
                                           (nat.times p (nat.times b m))))
                                     (logic.eq_ind nat.nat
                                        (nat.times (nat.times a n) m)
                                        (x_1:
                                         (sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq nat.nat m
                                           (nat.minus x_1
                                              (nat.times p (nat.times b m))))
                                        (logic.eq_ind nat.nat
                                           (nat.times (nat.times p b) m)
                                           (x_1:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq nat.nat m
                                              (nat.minus
                                                 (nat.times (nat.times a n) m)
                                                 x_1))
                                           (logic.eq_ind nat.nat
                                              (nat.times m (nat.times a n))
                                              (x_1:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq nat.nat m
                                                 (nat.minus x_1
                                                    (nat.times
                                                       (nat.times p b) m)))
                                              (logic.eq_ind_r nat.nat
                                                 (nat.times m (nat.times p b))
                                                 (x:
                                                  (sttfa.etap
                                                     (sttfa.p nat.nat)) =>
                                                  logic.eq nat.nat m
                                                    (nat.minus
                                                       (nat.times m
                                                          (nat.times a n)) x))
                                                 (logic.eq_ind nat.nat
                                                    (nat.times m
                                                       (nat.minus
                                                          (nat.times a n)
                                                          (nat.times p b)))
                                                    (x_1:
                                                     (sttfa.etap
                                                        (sttfa.p nat.nat)) =>
                                                     logic.eq nat.nat m x_1)
                                                    (logic.rewrite_r nat.nat
                                                       (nat.times n a)
                                                       (__:
                                                        (sttfa.etap
                                                           (sttfa.p nat.nat)) =>
                                                        logic.eq nat.nat m
                                                          (nat.times m
                                                             (nat.minus __
                                                                (nat.times p
                                                                   b))))
                                                       (logic.rewrite_l
                                                          nat.nat m
                                                          (__:
                                                           (sttfa.etap
                                                              (sttfa.p
                                                                 nat.nat)) =>
                                                           logic.eq nat.nat
                                                             m __)
                                                          (logic.refl
                                                             nat.nat m)
                                                          (nat.times m
                                                             (nat.minus
                                                                (nat.times n
                                                                   a)
                                                                (nat.times p
                                                                   b)))
                                                          (logic.rewrite_r
                                                             nat.nat
                                                             (nat.S nat.O)
                                                             (__:
                                                              (sttfa.etap
                                                                 (sttfa.p
                                                                    nat.nat)) =>
                                                              logic.eq
                                                                nat.nat m
                                                                (nat.times m
                                                                   __))
                                                             (nat.times_n_1 m)
                                                             (nat.minus
                                                                (nat.times n
                                                                   a)
                                                                (nat.times p
                                                                   b))
                                                             (logic.rewrite_l
                                                                nat.nat
                                                                (nat.times b
                                                                   p)
                                                                (__:
                                                                 (sttfa.etap
                                                                    (
                                                                    sttfa.p
                                                                    nat.nat)) =>
                                                                 logic.eq
                                                                   nat.nat
                                                                   (nat.minus
                                                                    (nat.times
                                                                    n a) __)
                                                                   (nat.S
                                                                    nat.O))
                                                                (logic.rewrite_l
                                                                   nat.nat
                                                                   (nat.times
                                                                    a n)
                                                                   (__:
                                                                    (
                                                                    sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (nat.minus
                                                                    __
                                                                    (nat.times
                                                                    b p))
                                                                    (nat.S
                                                                    nat.O))
                                                                   H
                                                                   (nat.times
                                                                    n a)
                                                                   (nat.commutative_times
                                                                    a n))
                                                                (nat.times p
                                                                   b)
                                                                (nat.commutative_times
                                                                   b p))))
                                                       (nat.times a n)
                                                       (nat.commutative_times
                                                          a n))
                                                    (nat.minus
                                                       (nat.times m
                                                          (nat.times a n))
                                                       (nat.times m
                                                          (nat.times p b)))
                                                    (nat.distributive_times_minus
                                                       m (nat.times a n)
                                                       (nat.times p b)))
                                                 (nat.times (nat.times p b) m)
                                                 (nat.commutative_times
                                                    (nat.times p b) m))
                                              (nat.times (nat.times a n) m)
                                              (nat.commutative_times m
                                                 (nat.times a n)))
                                           (nat.times p (nat.times b m))
                                           (nat.associative_times p b m))
                                        (nat.times a (nat.times n m))
                                        (nat.associative_times a n m))
                                     (nat.times p c) nm)
                                  (nat.times (nat.times a p) c)
                                  (nat.associative_times a p c))
                               (nat.times p a) (nat.commutative_times p a))
                            (nat.times p (nat.times a c))
                            (nat.associative_times p a c))
                         (nat.times p
                            (nat.minus (nat.times a c) (nat.times b m)))
                         (nat.distributive_times_minus p (nat.times a c)
                            (nat.times b m))))
                   (H:
                    (sttfa.eps
                       (logic.eq nat.nat
                          (nat.minus (nat.times b p) (nat.times a n))
                          (nat.S nat.O))) =>
                    primes.quotient p m
                      (nat.minus (nat.times b m) (nat.times a c))
                      (logic.eq_ind_r nat.nat
                         (nat.minus (nat.times p (nat.times b m))
                            (nat.times p (nat.times a c)))
                         (x:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat m x)
                         (logic.eq_ind nat.nat (nat.times (nat.times p b) m)
                            (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq nat.nat m
                               (nat.minus x_1 (nat.times p (nat.times a c))))
                            (logic.eq_ind nat.nat
                               (nat.times (nat.times p a) c)
                               (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq nat.nat m
                                  (nat.minus (nat.times (nat.times p b) m)
                                     x_1))
                               (logic.eq_ind nat.nat (nat.times a p)
                                  (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq nat.nat m
                                     (nat.minus
                                        (nat.times (nat.times p b) m)
                                        (nat.times x_1 c)))
                                  (logic.eq_ind_r nat.nat
                                     (nat.times a (nat.times p c))
                                     (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq nat.nat m
                                        (nat.minus
                                           (nat.times (nat.times p b) m) x))
                                     (logic.eq_ind nat.nat (nat.times n m)
                                        (x_1:
                                         (sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq nat.nat m
                                           (nat.minus
                                              (nat.times (nat.times p b) m)
                                              (nat.times a x_1)))
                                        (logic.eq_ind nat.nat
                                           (nat.times (nat.times a n) m)
                                           (x_1:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq nat.nat m
                                              (nat.minus
                                                 (nat.times (nat.times p b) m)
                                                 x_1))
                                           (logic.eq_ind nat.nat
                                              (nat.times m (nat.times p b))
                                              (x_1:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq nat.nat m
                                                 (nat.minus x_1
                                                    (nat.times
                                                       (nat.times a n) m)))
                                              (logic.eq_ind_r nat.nat
                                                 (nat.times m (nat.times a n))
                                                 (x:
                                                  (sttfa.etap
                                                     (sttfa.p nat.nat)) =>
                                                  logic.eq nat.nat m
                                                    (nat.minus
                                                       (nat.times m
                                                          (nat.times p b)) x))
                                                 (logic.eq_ind nat.nat
                                                    (nat.times m
                                                       (nat.minus
                                                          (nat.times p b)
                                                          (nat.times a n)))
                                                    (x_1:
                                                     (sttfa.etap
                                                        (sttfa.p nat.nat)) =>
                                                     logic.eq nat.nat m x_1)
                                                    (logic.rewrite_r nat.nat
                                                       (nat.times n a)
                                                       (__:
                                                        (sttfa.etap
                                                           (sttfa.p nat.nat)) =>
                                                        logic.eq nat.nat m
                                                          (nat.times m
                                                             (nat.minus
                                                                (nat.times p
                                                                   b) __)))
                                                       (logic.rewrite_l
                                                          nat.nat m
                                                          (__:
                                                           (sttfa.etap
                                                              (sttfa.p
                                                                 nat.nat)) =>
                                                           logic.eq nat.nat
                                                             m __)
                                                          (logic.refl
                                                             nat.nat m)
                                                          (nat.times m
                                                             (nat.minus
                                                                (nat.times p
                                                                   b)
                                                                (nat.times n
                                                                   a)))
                                                          (logic.rewrite_r
                                                             nat.nat
                                                             (nat.S nat.O)
                                                             (__:
                                                              (sttfa.etap
                                                                 (sttfa.p
                                                                    nat.nat)) =>
                                                              logic.eq
                                                                nat.nat m
                                                                (nat.times m
                                                                   __))
                                                             (nat.times_n_1 m)
                                                             (nat.minus
                                                                (nat.times p
                                                                   b)
                                                                (nat.times n
                                                                   a))
                                                             (logic.rewrite_l
                                                                nat.nat
                                                                (nat.times a
                                                                   n)
                                                                (__:
                                                                 (sttfa.etap
                                                                    (
                                                                    sttfa.p
                                                                    nat.nat)) =>
                                                                 logic.eq
                                                                   nat.nat
                                                                   (nat.minus
                                                                    (nat.times
                                                                    p b) __)
                                                                   (nat.S
                                                                    nat.O))
                                                                (logic.rewrite_l
                                                                   nat.nat
                                                                   (nat.times
                                                                    b p)
                                                                   (__:
                                                                    (
                                                                    sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (nat.minus
                                                                    __
                                                                    (nat.times
                                                                    a n))
                                                                    (nat.S
                                                                    nat.O))
                                                                   H
                                                                   (nat.times
                                                                    p b)
                                                                   (nat.commutative_times
                                                                    b p))
                                                                (nat.times n
                                                                   a)
                                                                (nat.commutative_times
                                                                   a n))))
                                                       (nat.times a n)
                                                       (nat.commutative_times
                                                          a n))
                                                    (nat.minus
                                                       (nat.times m
                                                          (nat.times p b))
                                                       (nat.times m
                                                          (nat.times a n)))
                                                    (nat.distributive_times_minus
                                                       m (nat.times p b)
                                                       (nat.times a n)))
                                                 (nat.times (nat.times a n) m)
                                                 (nat.commutative_times
                                                    (nat.times a n) m))
                                              (nat.times (nat.times p b) m)
                                              (nat.commutative_times m
                                                 (nat.times p b)))
                                           (nat.times a (nat.times n m))
                                           (nat.associative_times a n m))
                                        (nat.times p c) nm)
                                     (nat.times (nat.times a p) c)
                                     (nat.associative_times a p c))
                                  (nat.times p a) (nat.commutative_times a p))
                               (nat.times p (nat.times a c))
                               (nat.associative_times p a c))
                            (nat.times p (nat.times b m))
                            (nat.associative_times p b m))
                         (nat.times p
                            (nat.minus (nat.times b m) (nat.times a c)))
                         (nat.distributive_times_minus p (nat.times b m)
                            (nat.times a c)))) _clearme1) _clearme0)
             (logic.eq_ind nat.nat (gcd.gcd p n)
                (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                 connectives.ex nat.nat
                   (a:(sttfa.etap (sttfa.p nat.nat)) =>
                    connectives.ex nat.nat
                      (b:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.Or
                         (logic.eq nat.nat
                            (nat.minus (nat.times a n) (nat.times b p)) x_1)
                         (logic.eq nat.nat
                            (nat.minus (nat.times b p) (nat.times a n)) x_1))))
                (logic.eq_ind_r nat.nat (gcd.gcd n p)
                   (x:(sttfa.etap (sttfa.p nat.nat)) =>
                    connectives.ex nat.nat
                      (a:(sttfa.etap (sttfa.p nat.nat)) =>
                       connectives.ex nat.nat
                         (b:(sttfa.etap (sttfa.p nat.nat)) =>
                          connectives.Or
                            (logic.eq nat.nat
                               (nat.minus (nat.times a n) (nat.times b p)) x)
                            (logic.eq nat.nat
                               (nat.minus (nat.times b p) (nat.times a n)) x))))
                   (gcd.eq_minus_gcd p n) (gcd.gcd p n)
                   (gcd.commutative_gcd p n)) (nat.S nat.O)
                (gcd.prime_to_gcd_1 p n primp ndivpn))))
       (primes.decidable_divides p n)) _clearme.
