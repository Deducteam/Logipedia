import .bool
import .connectives
import .div_mod
import .logic
import .nat
import .relations
constant primes.divides : ((nat.nat) ) -> ((nat.nat) ) -> Prop.
axiom primes.quotient : forall (n:(nat.nat) ) , forall (m:(nat.nat) ) , forall (q:(nat.nat) ) , ((((logic.eq_) ((nat.nat) )) (m)) ((((nat.times) ) (n)) (q))) -> (((primes.divides) ) (n)) (m).
axiom primes.match_divides_prop : forall (n:(nat.nat) ) , forall (m:(nat.nat) ) , forall (return_type:Prop) , (forall (q:(nat.nat) ) , ((((logic.eq_) ((nat.nat) )) (m)) ((((nat.times) ) (n)) (q))) -> return_type) -> ((((primes.divides) ) (n)) (m)) -> return_type.
theorem primes.reflexive_divides : ((relations.reflexive) ((nat.nat) )) ((primes.divides) ) := fun (x : (nat.nat) ) , ((((@primes.quotient) (x)) (x)) (((nat.S) ) ((nat.O) ))) (((((((@logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (x)) (((nat.S) ) ((nat.O) )))) (fun (__ : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) (__)) ((((nat.times) ) (x)) (((nat.S) ) ((nat.O) ))))) (((@logic.refl_) ((nat.nat) )) ((((nat.times) ) (x)) (((nat.S) ) ((nat.O) ))))) (x)) ((@nat.times_n_1) (x))).
theorem primes.divides_to_div_mod_spec : forall (n:(nat.nat) ) , forall (m:(nat.nat) ) , ((((nat.lt_) ) ((nat.O) )) (n)) -> ((((primes.divides) ) (n)) (m)) -> (((((div_mod.div_mod_spec) ) (m)) (n)) ((((div_mod.div) ) (m)) (n))) ((nat.O) ) := fun (n : (nat.nat) ) , fun (m : (nat.nat) ) , fun (posn : (((nat.lt_) ) ((nat.O) )) (n)) , (fun (_clearme : (((primes.divides) ) (n)) (m)) , ((((((@primes.match_divides_prop) (n)) (m)) ((((((div_mod.div_mod_spec) ) (m)) (n)) ((((div_mod.div) ) (m)) (n))) ((nat.O) ))) (fun (q : (nat.nat) ) , fun (eqm : (((logic.eq_) ((nat.nat) )) (m)) ((((nat.times) ) (n)) (q))) , (((((((@div_mod.div_mod_spec_intro) (m)) (n)) ((((div_mod.div) ) (m)) (n))) ((nat.O) )) (posn)) (((((((@logic.eq_ind_r) ((nat.nat) )) ((((nat.times) ) (n)) (q))) (fun (x : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) (x)) ((((nat.plus) ) ((((nat.times) ) ((((div_mod.div) ) (x)) (n))) (n))) ((nat.O) )))) (((((((@logic.eq_ind_r) ((nat.nat) )) ((((nat.times) ) (q)) (n))) (fun (x : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) (x)) ((((nat.plus) ) ((((nat.times) ) ((((div_mod.div) ) (x)) (n))) (n))) ((nat.O) )))) (((((((@logic.eq_ind_r) ((nat.nat) )) (q)) (fun (x : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) ((((nat.times) ) (q)) (n))) ((((nat.plus) ) ((((nat.times) ) (x)) (n))) ((nat.O) )))) (((((((@logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (n)) (q))) (fun (__ : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) (__)) ((((nat.plus) ) ((((nat.times) ) (q)) (n))) ((nat.O) )))) (((((((@logic.rewrite_l) ((nat.nat) )) (m)) (fun (__ : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) (__)) ((((nat.plus) ) ((((nat.times) ) (q)) (n))) ((nat.O) )))) (((((((@logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (n)) (q))) (fun (__ : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) (m)) ((((nat.plus) ) (__)) ((nat.O) )))) (((((((@logic.rewrite_l) ((nat.nat) )) (m)) (fun (__ : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) (m)) ((((nat.plus) ) (__)) ((nat.O) )))) (((((((@logic.rewrite_l) ((nat.nat) )) (m)) (fun (__ : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) (m)) (__))) (((@logic.refl_) ((nat.nat) )) (m))) ((((nat.plus) ) (m)) ((nat.O) ))) ((@nat.plus_n_O) (m)))) ((((nat.times) ) (n)) (q))) (eqm))) ((((nat.times) ) (q)) (n))) (((@nat.commutative_times) (q)) (n)))) ((((nat.times) ) (n)) (q))) (eqm))) ((((nat.times) ) (q)) (n))) (((@nat.commutative_times) (q)) (n)))) ((((div_mod.div) ) ((((nat.times) ) (q)) (n))) (n))) ((((@div_mod.div_times) (q)) (n)) (posn)))) ((((nat.times) ) (n)) (q))) (((@nat.commutative_times) (n)) (q)))) (m)) (eqm))))) (_clearme))).
theorem primes.divides_to_mod_O : forall (n:(nat.nat) ) , forall (m:(nat.nat) ) , ((((nat.lt_) ) ((nat.O) )) (n)) -> ((((primes.divides) ) (n)) (m)) -> (((logic.eq_) ((nat.nat) )) ((((div_mod.mod) ) (m)) (n))) ((nat.O) ) := fun (n : (nat.nat) ) , fun (m : (nat.nat) ) , fun (posn : (((nat.lt_) ) ((nat.O) )) (n)) , (fun (divnm : (((primes.divides) ) (n)) (m)) , (((((((((@div_mod.div_mod_spec_to_eq2) (m)) (n)) ((((div_mod.div) ) (m)) (n))) ((((div_mod.mod) ) (m)) (n))) ((((div_mod.div) ) (m)) (n))) ((nat.O) )) ((((@div_mod.div_mod_spec_div_mod) (m)) (n)) (posn))) (((((@primes.divides_to_div_mod_spec) (n)) (m)) (posn)) (divnm)))).
theorem primes.mod_O_to_divides : forall (n:(nat.nat) ) , forall (m:(nat.nat) ) , ((((nat.lt_) ) ((nat.O) )) (n)) -> ((((logic.eq_) ((nat.nat) )) ((((div_mod.mod) ) (m)) (n))) ((nat.O) )) -> (((primes.divides) ) (n)) (m) := fun (n : (nat.nat) ) , fun (m : (nat.nat) ) , fun (auto : (((nat.lt_) ) ((nat.O) )) (n)) , (fun (auto' : (((logic.eq_) ((nat.nat) )) ((((div_mod.mod) ) (m)) (n))) ((nat.O) )) , (((((@primes.quotient) (n)) (m)) ((((div_mod.div) ) (m)) (n))) (((((((@logic.rewrite_l) ((nat.nat) )) ((((nat.times) ) (n)) ((((div_mod.div) ) (m)) (n)))) (fun (__ : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) (__)) ((((nat.times) ) (n)) ((((div_mod.div) ) (m)) (n))))) (((@logic.refl_) ((nat.nat) )) ((((nat.times) ) (n)) ((((div_mod.div) ) (m)) (n))))) (m)) (((((((@logic.rewrite_r) ((nat.nat) )) ((((nat.minus) ) (m)) ((nat.O) ))) (fun (__ : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) ((((nat.times) ) (n)) ((((div_mod.div) ) (m)) (n)))) (__))) (((((((@logic.rewrite_l) ((nat.nat) )) ((((div_mod.mod) ) (m)) (n))) (fun (__ : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) ((((nat.times) ) (n)) ((((div_mod.div) ) (m)) (n)))) ((((nat.minus) ) (m)) (__)))) (((((((@logic.rewrite_l) ((nat.nat) )) ((((nat.times) ) ((((div_mod.div) ) (m)) (n))) (n))) (fun (__ : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) (__)) ((((nat.minus) ) (m)) ((((div_mod.mod) ) (m)) (n))))) (((@div_mod.eq_times_div_minus_mod) (m)) (n))) ((((nat.times) ) (n)) ((((div_mod.div) ) (m)) (n)))) (((@nat.commutative_times) ((((div_mod.div) ) (m)) (n))) (n)))) ((nat.O) )) (auto'))) (m)) ((@nat.minus_n_O) (m)))))).
theorem primes.divides_n_O : forall (n:(nat.nat) ) , (((primes.divides) ) (n)) ((nat.O) ) := fun (n : (nat.nat) ) , ((((@primes.quotient) (n)) ((nat.O) )) ((nat.O) )) (((((((@logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (n)) ((nat.O) ))) (fun (__ : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) (__)) ((((nat.times) ) (n)) ((nat.O) )))) (((@logic.refl_) ((nat.nat) )) ((((nat.times) ) (n)) ((nat.O) )))) ((nat.O) )) ((@nat.times_n_O) (n))).
theorem primes.divides_n_n : forall (n:(nat.nat) ) , (((primes.divides) ) (n)) (n) := fun (n : (nat.nat) ) , (@primes.reflexive_divides) (n).
theorem primes.eq_mod_to_divides : forall (n:(nat.nat) ) , forall (m:(nat.nat) ) , forall (q:(nat.nat) ) , ((((nat.lt_) ) ((nat.O) )) (q)) -> ((((logic.eq_) ((nat.nat) )) ((((div_mod.mod) ) (n)) (q))) ((((div_mod.mod) ) (m)) (q))) -> (((primes.divides) ) (q)) ((((nat.minus) ) (n)) (m)) := fun (n : (nat.nat) ) , fun (m : (nat.nat) ) , fun (q : (nat.nat) ) , fun (posq : (((nat.lt_) ) ((nat.O) )) (q)) , (fun (eqmod : (((logic.eq_) ((nat.nat) )) ((((div_mod.mod) ) (n)) (q))) ((((div_mod.mod) ) (m)) (q))) , ((((((@nat.leb_elim) (n)) (m)) (fun (__ : (bool.bool) ) , (((primes.divides) ) (q)) ((((nat.minus) ) (n)) (m)))) (fun (nm : (((nat.le_) ) (n)) (m)) , (((((@logic.eq_coerc) ((((primes.divides) ) (q)) ((nat.O) ))) ((((primes.divides) ) (q)) ((((nat.minus) ) (n)) (m)))) ((@primes.divides_n_O) (q))) (((((((@logic.rewrite_r) ((nat.nat) )) ((nat.O) )) (fun (__ : (nat.nat) ) , (((logic.eq_) (Prop)) ((((primes.divides) ) (q)) ((nat.O) ))) ((((primes.divides) ) (q)) (__)))) (((@logic.refl_) (Prop)) ((((primes.divides) ) (q)) ((nat.O) )))) ((((nat.minus) ) (n)) (m))) (((((@logic.sym_eq) ((nat.nat) )) ((nat.O) )) ((((nat.minus) ) (n)) (m))) (((((@logic.eq_coerc) ((((logic.eq_) ((nat.nat) )) ((((nat.minus) ) ((nat.O) )) ((((nat.minus) ) (m)) (n)))) ((((nat.minus) ) ((((nat.plus) ) ((nat.O) )) (n))) (m)))) ((((logic.eq_) ((nat.nat) )) ((nat.O) )) ((((nat.minus) ) (n)) (m)))) (((((@nat.minus_le_minus_minus_comm) (m)) (n)) ((nat.O) )) (nm))) (((((((@logic.rewrite_l) ((nat.nat) )) ((nat.O) )) (fun (__ : (nat.nat) ) , (((logic.eq_) (Prop)) ((((logic.eq_) ((nat.nat) )) (__)) ((((nat.minus) ) ((((nat.plus) ) ((nat.O) )) (n))) (m)))) ((((logic.eq_) ((nat.nat) )) ((nat.O) )) ((((nat.minus) ) (n)) (m))))) (((((((@logic.rewrite_l) ((nat.nat) )) (n)) (fun (__ : (nat.nat) ) , (((logic.eq_) (Prop)) ((((logic.eq_) ((nat.nat) )) ((nat.O) )) ((((nat.minus) ) (__)) (m)))) ((((logic.eq_) ((nat.nat) )) ((nat.O) )) ((((nat.minus) ) (n)) (m))))) (((@logic.refl_) (Prop)) ((((logic.eq_) ((nat.nat) )) ((nat.O) )) ((((nat.minus) ) (n)) (m))))) ((((nat.plus) ) ((nat.O) )) (n))) ((@nat.plus_O_n) (n)))) ((((nat.minus) ) ((nat.O) )) ((((nat.minus) ) (m)) (n)))) ((@nat.minus_O_n) ((((nat.minus) ) (m)) (n)))))))))) (fun (nm : ((connectives.Not) ) ((((nat.le_) ) (n)) (m))) , (((((@primes.quotient) (q)) ((((nat.minus) ) (n)) (m))) ((((nat.minus) ) ((((div_mod.div) ) (n)) (q))) ((((div_mod.div) ) (m)) (q)))) (((((((@logic.eq_ind_r) ((nat.nat) )) ((((nat.minus) ) ((((nat.times) ) (q)) ((((div_mod.div) ) (n)) (q)))) ((((nat.times) ) (q)) ((((div_mod.div) ) (m)) (q))))) (fun (x : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) ((((nat.minus) ) (n)) (m))) (x))) (((((((@logic.eq_ind_r) ((nat.nat) )) ((((nat.times) ) ((((div_mod.div) ) (n)) (q))) (q))) (fun (x : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) ((((nat.minus) ) (n)) (m))) ((((nat.minus) ) (x)) ((((nat.times) ) (q)) ((((div_mod.div) ) (m)) (q)))))) (((((((@logic.eq_ind_r) ((nat.nat) )) ((((nat.times) ) ((((div_mod.div) ) (m)) (q))) (q))) (fun (x : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) ((((nat.minus) ) (n)) (m))) ((((nat.minus) ) ((((nat.times) ) ((((div_mod.div) ) (n)) (q))) (q))) (x)))) (((((((@logic.eq_ind_r) ((nat.nat) )) ((((nat.minus) ) (n)) ((((div_mod.mod) ) (n)) (q)))) (fun (x : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) ((((nat.minus) ) (n)) (m))) ((((nat.minus) ) (x)) ((((nat.times) ) ((((div_mod.div) ) (m)) (q))) (q))))) (((((((@logic.eq_ind_r) ((nat.nat) )) ((((nat.minus) ) (n)) ((((nat.plus) ) ((((div_mod.mod) ) (n)) (q))) ((((nat.times) ) ((((div_mod.div) ) (m)) (q))) (q))))) (fun (x : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) ((((nat.minus) ) (n)) (m))) (x))) (((((((@logic.eq_ind_r) ((nat.nat) )) ((((div_mod.mod) ) (m)) (q))) (fun (x : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) ((((nat.minus) ) (n)) (m))) ((((nat.minus) ) (n)) ((((nat.plus) ) (x)) ((((nat.times) ) ((((div_mod.div) ) (m)) (q))) (q)))))) (((((((@logic.eq_ind_r) ((nat.nat) )) ((((nat.plus) ) ((((nat.times) ) ((((div_mod.div) ) (m)) (q))) (q))) ((((div_mod.mod) ) (m)) (q)))) (fun (x : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) ((((nat.minus) ) (n)) (m))) ((((nat.minus) ) (n)) (x)))) (((((((@logic.eq_ind) ((nat.nat) )) (m)) (fun (x_1 : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) ((((nat.minus) ) (n)) (m))) ((((nat.minus) ) (n)) (x_1)))) (((@logic.refl_) ((nat.nat) )) ((((nat.minus) ) (n)) (m)))) ((((nat.plus) ) ((((nat.times) ) ((((div_mod.div) ) (m)) (q))) (q))) ((((div_mod.mod) ) (m)) (q)))) (((@div_mod.div_mod) (m)) (q)))) ((((nat.plus) ) ((((div_mod.mod) ) (m)) (q))) ((((nat.times) ) ((((div_mod.div) ) (m)) (q))) (q)))) (((@nat.commutative_plus) ((((div_mod.mod) ) (m)) (q))) ((((nat.times) ) ((((div_mod.div) ) (m)) (q))) (q))))) ((((div_mod.mod) ) (n)) (q))) (eqmod))) ((((nat.minus) ) ((((nat.minus) ) (n)) ((((div_mod.mod) ) (n)) (q)))) ((((nat.times) ) ((((div_mod.div) ) (m)) (q))) (q)))) ((((@nat.minus_plus) (n)) ((((div_mod.mod) ) (n)) (q))) ((((nat.times) ) ((((div_mod.div) ) (m)) (q))) (q))))) ((((nat.times) ) ((((div_mod.div) ) (n)) (q))) (q))) (((((((@logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (q)) ((((div_mod.div) ) (n)) (q)))) (fun (__ : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) (__)) ((((nat.minus) ) (n)) ((((div_mod.mod) ) (n)) (q))))) (((((((@logic.rewrite_l) ((nat.nat) )) ((((nat.times) ) (q)) ((((div_mod.div) ) (n)) (q)))) (fun (__ : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) ((((nat.times) ) (q)) ((((div_mod.div) ) (n)) (q)))) (__))) (((@logic.refl_) ((nat.nat) )) ((((nat.times) ) (q)) ((((div_mod.div) ) (n)) (q))))) ((((nat.minus) ) (n)) ((((div_mod.mod) ) (n)) (q)))) (((((((@logic.rewrite_l) ((nat.nat) )) ((((nat.times) ) ((((div_mod.div) ) (n)) (q))) (q))) (fun (__ : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) (__)) ((((nat.minus) ) (n)) ((((div_mod.mod) ) (n)) (q))))) (((@div_mod.eq_times_div_minus_mod) (n)) (q))) ((((nat.times) ) (q)) ((((div_mod.div) ) (n)) (q)))) (((@nat.commutative_times) ((((div_mod.div) ) (n)) (q))) (q))))) ((((nat.times) ) ((((div_mod.div) ) (n)) (q))) (q))) (((@nat.commutative_times) ((((div_mod.div) ) (n)) (q))) (q))))) ((((nat.times) ) (q)) ((((div_mod.div) ) (m)) (q)))) (((@nat.commutative_times) (q)) ((((div_mod.div) ) (m)) (q))))) ((((nat.times) ) (q)) ((((div_mod.div) ) (n)) (q)))) (((@nat.commutative_times) (q)) ((((div_mod.div) ) (n)) (q))))) ((((nat.times) ) (q)) ((((nat.minus) ) ((((div_mod.div) ) (n)) (q))) ((((div_mod.div) ) (m)) (q))))) ((((@nat.distributive_times_minus) (q)) ((((div_mod.div) ) (n)) (q))) ((((div_mod.div) ) (m)) (q)))))))).
theorem primes.let_clause_1531 : forall (n:(nat.nat) ) , forall (m:(nat.nat) ) , ((((nat.lt_) ) ((nat.O) )) (m)) -> ((((primes.divides) ) (n)) (m)) -> forall (d:(nat.nat) ) , ((((logic.eq_) ((nat.nat) )) (m)) ((((nat.times) ) (n)) ((nat.O) ))) -> (((logic.eq_) ((nat.nat) )) (m)) ((nat.O) ) := fun (n : (nat.nat) ) , fun (m : (nat.nat) ) , fun (posm : (((nat.lt_) ) ((nat.O) )) (m)) , (fun (_clearme : (((primes.divides) ) (n)) (m)) , (fun (d : (nat.nat) ) , fun (eqm : (((logic.eq_) ((nat.nat) )) (m)) ((((nat.times) ) (n)) ((nat.O) ))) , (((((((@logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (n)) ((nat.O) ))) (fun (__ : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) (m)) (__))) (eqm)) ((nat.O) )) ((@nat.times_n_O) (n))))).
theorem primes.let_clause_15311 : forall (n:(nat.nat) ) , forall (m:(nat.nat) ) , ((((nat.lt_) ) ((nat.O) )) (m)) -> ((((primes.divides) ) (n)) (m)) -> forall (d:(nat.nat) ) , forall (p:(nat.nat) ) , ((((logic.eq_) ((nat.nat) )) (m)) ((((nat.times) ) (n)) (((nat.S) ) (p)))) -> (((logic.eq_) ((nat.nat) )) (m)) ((((nat.plus) ) (n)) ((((nat.times) ) (n)) (p))) := fun (n : (nat.nat) ) , fun (m : (nat.nat) ) , fun (posm : (((nat.lt_) ) ((nat.O) )) (m)) , (fun (_clearme : (((primes.divides) ) (n)) (m)) , (fun (d : (nat.nat) ) , fun (p : (nat.nat) ) , fun (eqm : (((logic.eq_) ((nat.nat) )) (m)) ((((nat.times) ) (n)) (((nat.S) ) (p)))) , (((((((@logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (n)) (((nat.S) ) (p)))) (fun (__ : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) (m)) (__))) (eqm)) ((((nat.plus) ) (n)) ((((nat.times) ) (n)) (p)))) (((@nat.times_n_Sm) (n)) (p))))).
theorem primes.divides_to_le : forall (n:(nat.nat) ) , forall (m:(nat.nat) ) , ((((nat.lt_) ) ((nat.O) )) (m)) -> ((((primes.divides) ) (n)) (m)) -> (((nat.le_) ) (n)) (m) := fun (n : (nat.nat) ) , fun (m : (nat.nat) ) , fun (posm : (((nat.lt_) ) ((nat.O) )) (m)) , (fun (_clearme : (((primes.divides) ) (n)) (m)) , ((((((@primes.match_divides_prop) (n)) (m)) ((((nat.le_) ) (n)) (m))) (fun (d : (nat.nat) ) , ((((@nat.match_nat_prop) (fun (__ : (nat.nat) ) , ((((logic.eq_) ((nat.nat) )) (m)) ((((nat.times) ) (n)) (__))) -> (((nat.le_) ) (n)) (m))) (fun (eqm : (((logic.eq_) ((nat.nat) )) (m)) ((((nat.times) ) (n)) ((nat.O) ))) , (((@connectives.falsity) ((((nat.le_) ) (n)) (m))) ((((@logic.absurd) ((((nat.le_) ) (((nat.S) ) (m))) ((nat.O) ))) (((((@logic.eq_coerc) ((((nat.le_) ) (((nat.S) ) ((nat.O) ))) (m))) ((((nat.le_) ) (((nat.S) ) (m))) ((nat.O) ))) (posm)) (((((((@logic.rewrite_l) ((nat.nat) )) (m)) (fun (__ : (nat.nat) ) , (((logic.eq_) (Prop)) ((((nat.le_) ) (((nat.S) ) (__))) (m))) ((((nat.le_) ) (((nat.S) ) (m))) ((nat.O) )))) (((((((@logic.rewrite_l) ((nat.nat) )) (m)) (fun (__ : (nat.nat) ) , (((logic.eq_) (Prop)) ((((nat.le_) ) (((nat.S) ) (m))) (m))) ((((nat.le_) ) (((nat.S) ) (m))) (__)))) (((@logic.refl_) (Prop)) ((((nat.le_) ) (((nat.S) ) (m))) (m)))) ((nat.O) )) (((((((@primes.let_clause_1531) (n)) (m)) (posm)) (_clearme)) (d)) (eqm)))) ((nat.O) )) (((((((@primes.let_clause_1531) (n)) (m)) (posm)) (_clearme)) (d)) (eqm))))) ((@nat.not_le_Sn_O) (m)))))) (fun (p : (nat.nat) ) , fun (eqm : (((logic.eq_) ((nat.nat) )) (m)) ((((nat.times) ) (n)) (((nat.S) ) (p)))) , (((((((@logic.eq_ind_r) ((nat.nat) )) ((((nat.times) ) (n)) (((nat.S) ) (p)))) (fun (x : (nat.nat) ) , (((nat.le_) ) (n)) (x))) (((((@logic.eq_coerc) ((((nat.le_) ) (n)) ((((nat.plus) ) (n)) ((((nat.times) ) (n)) (p))))) ((((nat.le_) ) (n)) ((((nat.times) ) (n)) (((nat.S) ) (p))))) (((@nat.le_plus_n_r) ((((nat.times) ) (n)) (p))) (n))) (((((((@logic.rewrite_l) ((nat.nat) )) ((((nat.plus) ) (n)) ((((nat.times) ) (n)) (p)))) (fun (__ : (nat.nat) ) , (((logic.eq_) (Prop)) ((((nat.le_) ) (n)) ((((nat.plus) ) (n)) ((((nat.times) ) (n)) (p))))) ((((nat.le_) ) (n)) (__)))) (((((((@logic.rewrite_l) ((nat.nat) )) (m)) (fun (__ : (nat.nat) ) , (((logic.eq_) (Prop)) ((((nat.le_) ) (n)) ((((nat.plus) ) (n)) ((((nat.times) ) (n)) (p))))) ((((nat.le_) ) (n)) (__)))) (((((((@logic.rewrite_l) ((nat.nat) )) (m)) (fun (__ : (nat.nat) ) , (((logic.eq_) (Prop)) ((((nat.le_) ) (n)) (__))) ((((nat.le_) ) (n)) (m)))) (((@logic.refl_) (Prop)) ((((nat.le_) ) (n)) (m)))) ((((nat.plus) ) (n)) ((((nat.times) ) (n)) (p)))) ((((((((@primes.let_clause_15311) (n)) (m)) (posm)) (_clearme)) (d)) (p)) (eqm)))) ((((nat.plus) ) (n)) ((((nat.times) ) (n)) (p)))) ((((((((@primes.let_clause_15311) (n)) (m)) (posm)) (_clearme)) (d)) (p)) (eqm)))) ((((nat.times) ) (n)) (((nat.S) ) (p)))) (((@nat.times_n_Sm) (n)) (p))))) (m)) (eqm)))) (d))) (_clearme))).
noncomputable def primes.dividesb : ((nat.nat) ) -> ((nat.nat) ) -> (bool.bool)  := fun (n : (nat.nat) ) , fun (m : (nat.nat) ) , (((nat.eqb) ) ((((div_mod.mod) ) (m)) (n))) ((nat.O) ).
theorem primes.dividesb_true_to_divides : forall (n:(nat.nat) ) , forall (m:(nat.nat) ) , ((((logic.eq_) ((bool.bool) )) ((((primes.dividesb) ) (n)) (m))) ((bool.true) )) -> (((primes.divides) ) (n)) (m) := fun (n : (nat.nat) ) , fun (m : (nat.nat) ) , ((((((@connectives.match_Or_prop) ((((nat.lt_) ) ((nat.O) )) (n))) ((((logic.eq_) ((nat.nat) )) ((nat.O) )) (n))) (((((logic.eq_) ((bool.bool) )) ((((primes.dividesb) ) (n)) (m))) ((bool.true) )) -> (((primes.divides) ) (n)) (m))) (fun (posn : (((nat.lt_) ) ((nat.O) )) (n)) , (fun (divbnm : (((logic.eq_) ((bool.bool) )) ((((primes.dividesb) ) (n)) (m))) ((bool.true) )) , (((((@primes.mod_O_to_divides) (n)) (m)) (posn)) ((((@nat.eqb_true_to_eq) ((((div_mod.mod) ) (m)) (n))) ((nat.O) )) (divbnm)))))) (fun (eqnO : (((logic.eq_) ((nat.nat) )) ((nat.O) )) (n)) , (((((((@logic.eq_ind) ((nat.nat) )) ((nat.O) )) (fun (x_1 : (nat.nat) ) , ((((logic.eq_) ((bool.bool) )) ((((primes.dividesb) ) (x_1)) (m))) ((bool.true) )) -> (((primes.divides) ) (x_1)) (m))) ((((((@nat.sym_eq_match_nat_type_O) ((nat.nat) )) (m)) (fun (p : (nat.nat) ) , ((((div_mod.mod_aux) ) (m)) (m)) (p))) (fun (y : (nat.nat) ) , ((((logic.eq_) ((bool.bool) )) ((((nat.eqb) ) (y)) ((nat.O) ))) ((bool.true) )) -> (((primes.divides) ) ((nat.O) )) (m))) (fun (eqbmO : (((logic.eq_) ((bool.bool) )) ((((nat.eqb) ) (m)) ((nat.O) ))) ((bool.true) )) , (((((((@logic.eq_ind_r) ((nat.nat) )) ((nat.O) )) (fun (x : (nat.nat) ) , (((primes.divides) ) ((nat.O) )) (x))) ((@primes.divides_n_n) ((nat.O) ))) (m)) ((((@nat.eqb_true_to_eq) (m)) ((nat.O) )) (eqbmO)))))) (n)) (eqnO)))) ((((@nat.le_to_or_lt_eq) ((nat.O) )) (n)) ((@nat.le_O_n) (n))).
theorem primes.dividesb_false_to_not_divides : forall (n:(nat.nat) ) , forall (m:(nat.nat) ) , ((((logic.eq_) ((bool.bool) )) ((((primes.dividesb) ) (n)) (m))) ((bool.false) )) -> ((connectives.Not) ) ((((primes.divides) ) (n)) (m)) := fun (n : (nat.nat) ) , fun (m : (nat.nat) ) , ((((((@connectives.match_Or_prop) ((((nat.lt_) ) ((nat.O) )) (n))) ((((logic.eq_) ((nat.nat) )) ((nat.O) )) (n))) (((((logic.eq_) ((bool.bool) )) ((((primes.dividesb) ) (n)) (m))) ((bool.false) )) -> ((connectives.Not) ) ((((primes.divides) ) (n)) (m)))) (fun (posn : (((nat.lt_) ) ((nat.O) )) (n)) , (fun (ndivbnm : (((logic.eq_) ((bool.bool) )) ((((primes.dividesb) ) (n)) (m))) ((bool.false) )) , (((((@logic.not_to_not) ((((primes.divides) ) (n)) (m))) ((((logic.eq_) ((nat.nat) )) ((((div_mod.mod) ) (m)) (n))) ((nat.O) ))) ((((@primes.divides_to_mod_O) (n)) (m)) (posn))) ((((@nat.eqb_false_to_not_eq) ((((div_mod.mod) ) (m)) (n))) ((nat.O) )) (ndivbnm)))))) (fun (eqnO : (((logic.eq_) ((nat.nat) )) ((nat.O) )) (n)) , (((((((@logic.eq_ind) ((nat.nat) )) ((nat.O) )) (fun (x_1 : (nat.nat) ) , ((((logic.eq_) ((bool.bool) )) ((((primes.dividesb) ) (x_1)) (m))) ((bool.false) )) -> ((connectives.Not) ) ((((primes.divides) ) (x_1)) (m)))) ((((((@nat.sym_eq_match_nat_type_O) ((nat.nat) )) (m)) (fun (p : (nat.nat) ) , ((((div_mod.mod_aux) ) (m)) (m)) (p))) (fun (y : (nat.nat) ) , ((((logic.eq_) ((bool.bool) )) ((((nat.eqb) ) (y)) ((nat.O) ))) ((bool.false) )) -> ((connectives.Not) ) ((((primes.divides) ) ((nat.O) )) (m)))) (((((@nat.nat_case) (m)) (fun (__ : (nat.nat) ) , ((((logic.eq_) ((bool.bool) )) ((((nat.eqb) ) (__)) ((nat.O) ))) ((bool.false) )) -> ((connectives.Not) ) ((((primes.divides) ) ((nat.O) )) (__)))) ((((@nat.sym_eq_eqb) ((nat.O) )) (fun (y : ((nat.nat) ) -> (bool.bool) ) , ((((logic.eq_) ((nat.nat) )) (m)) ((nat.O) )) -> ((((logic.eq_) ((bool.bool) )) ((y) ((nat.O) ))) ((bool.false) )) -> ((connectives.Not) ) ((((primes.divides) ) ((nat.O) )) ((nat.O) )))) (((((@nat.sym_eq_filter_nat_type_O) (((nat.nat) ) -> (bool.bool) )) ((nat.eqb_body) )) (fun (y : ((nat.nat) ) -> (bool.bool) ) , ((((logic.eq_) ((nat.nat) )) (m)) ((nat.O) )) -> ((((logic.eq_) ((bool.bool) )) ((y) ((nat.O) ))) ((bool.false) )) -> ((connectives.Not) ) ((((primes.divides) ) ((nat.O) )) ((nat.O) )))) (((@nat.sym_eq_eqb_body_O) (fun (y : ((nat.nat) ) -> (bool.bool) ) , ((((logic.eq_) ((nat.nat) )) (m)) ((nat.O) )) -> ((((logic.eq_) ((bool.bool) )) ((y) ((nat.O) ))) ((bool.false) )) -> ((connectives.Not) ) ((((primes.divides) ) ((nat.O) )) ((nat.O) )))) ((((((@nat.sym_eq_match_nat_type_O) ((bool.bool) )) ((bool.true) )) (fun (q : (nat.nat) ) , (bool.false) )) (fun (y : (bool.bool) ) , ((((logic.eq_) ((nat.nat) )) (m)) ((nat.O) )) -> ((((logic.eq_) ((bool.bool) )) (y)) ((bool.false) )) -> ((connectives.Not) ) ((((primes.divides) ) ((nat.O) )) ((nat.O) )))) (fun (auto : (((logic.eq_) ((nat.nat) )) (m)) ((nat.O) )) , (fun (auto' : (((logic.eq_) ((bool.bool) )) ((bool.true) )) ((bool.false) )) , (((((@logic.not_to_not) ((((primes.divides) ) ((nat.O) )) ((nat.O) ))) ((((logic.eq_) ((bool.bool) )) ((bool.true) )) ((bool.false) ))) (fun (auto'' : (((primes.divides) ) ((nat.O) )) ((nat.O) )) , (((((((@logic.rewrite_l) ((bool.bool) )) ((bool.true) )) (fun (__ : (bool.bool) ) , (((logic.eq_) ((bool.bool) )) ((bool.true) )) (__))) (((@logic.refl_) ((bool.bool) )) ((bool.true) ))) ((bool.false) )) (auto')))) (@bool.not_eq_true_false))))))))) (fun (a : (nat.nat) ) , fun (__ : (((logic.eq_) ((nat.nat) )) (m)) (((nat.S) ) (a))) , (fun (_0 : (((logic.eq_) ((bool.bool) )) ((((nat.eqb) ) (((nat.S) ) (a))) ((nat.O) ))) ((bool.false) )) , (((@connectives.nmk) ((((primes.divides) ) ((nat.O) )) (((nat.S) ) (a)))) (fun (_clearme : (((primes.divides) ) ((nat.O) )) (((nat.S) ) (a))) , ((((((@primes.match_divides_prop) ((nat.O) )) (((nat.S) ) (a))) ((connectives.False) )) (fun (q : (nat.nat) ) , fun (auto : (((logic.eq_) ((nat.nat) )) (((nat.S) ) (a))) ((((nat.times) ) ((nat.O) )) (q))) , ((((@logic.absurd) ((((logic.eq_) ((nat.nat) )) ((nat.O) )) (((nat.S) ) (a)))) (((((((@logic.rewrite_r) ((nat.nat) )) (n)) (fun (__1 : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) (__1)) (((nat.S) ) (a)))) (((((((@logic.rewrite_l) ((nat.nat) )) (((nat.S) ) (a))) (fun (__1 : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) (__1)) (((nat.S) ) (a)))) (((@logic.refl_) ((nat.nat) )) (((nat.S) ) (a)))) (n)) (((((((@logic.rewrite_l) ((nat.nat) )) ((nat.O) )) (fun (__1 : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) (((nat.S) ) (a))) (__1))) (((((((@logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (q)) ((nat.O) ))) (fun (__1 : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) (((nat.S) ) (a))) (__1))) (((((((@logic.rewrite_l) ((nat.nat) )) ((((nat.times) ) ((nat.O) )) (q))) (fun (__1 : (nat.nat) ) , (((logic.eq_) ((nat.nat) )) (((nat.S) ) (a))) (__1))) (auto)) ((((nat.times) ) (q)) ((nat.O) ))) (((@nat.commutative_times) ((nat.O) )) (q)))) ((nat.O) )) ((@nat.times_n_O) (q)))) (n)) (eqnO)))) ((nat.O) )) (eqnO))) ((@nat.not_eq_O_S) (a))))) (_clearme))))))))) (n)) (eqnO)))) ((((@nat.le_to_or_lt_eq) ((nat.O) )) (n)) ((@nat.le_O_n) (n))).
theorem primes.decidable_divides : forall (n:(nat.nat) ) , forall (m:(nat.nat) ) , ((logic.decidable) ) ((((primes.divides) ) (n)) (m)) := fun (n : (nat.nat) ) , fun (m : (nat.nat) ) , ((((((@connectives.match_Or_prop) ((((logic.eq_) ((bool.bool) )) ((((primes.dividesb) ) (n)) (m))) ((bool.true) ))) ((((logic.eq_) ((bool.bool) )) ((((primes.dividesb) ) (n)) (m))) ((bool.false) ))) (((logic.decidable) ) ((((primes.divides) ) (n)) (m)))) (fun (auto : (((logic.eq_) ((bool.bool) )) ((((primes.dividesb) ) (n)) (m))) ((bool.true) )) , ((((@connectives.or_introl) ((((primes.divides) ) (n)) (m))) (((connectives.Not) ) ((((primes.divides) ) (n)) (m)))) ((((@primes.dividesb_true_to_divides) (n)) (m)) (((((((@logic.rewrite_r) ((bool.bool) )) ((bool.true) )) (fun (__ : (bool.bool) ) , (((logic.eq_) ((bool.bool) )) (__)) ((bool.true) ))) (((@logic.refl_) ((bool.bool) )) ((bool.true) ))) ((((primes.dividesb) ) (n)) (m))) (auto)))))) (fun (auto : (((logic.eq_) ((bool.bool) )) ((((primes.dividesb) ) (n)) (m))) ((bool.false) )) , ((((@connectives.or_intror) ((((primes.divides) ) (n)) (m))) (((connectives.Not) ) ((((primes.divides) ) (n)) (m)))) ((((@primes.dividesb_false_to_not_divides) (n)) (m)) (((((((@logic.rewrite_r) ((bool.bool) )) ((bool.false) )) (fun (__ : (bool.bool) ) , (((logic.eq_) ((bool.bool) )) (__)) ((bool.false) ))) (((@logic.refl_) ((bool.bool) )) ((bool.false) ))) ((((primes.dividesb) ) (n)) (m))) (auto)))))) ((@bool.true_or_false) ((((primes.dividesb) ) (n)) (m))).
theorem primes.divides_to_dividesb_true : forall (n:(nat.nat) ) , forall (m:(nat.nat) ) , ((((nat.lt_) ) ((nat.O) )) (n)) -> ((((primes.divides) ) (n)) (m)) -> (((logic.eq_) ((bool.bool) )) ((((primes.dividesb) ) (n)) (m))) ((bool.true) ) := fun (n : (nat.nat) ) , fun (m : (nat.nat) ) , fun (posn : (((nat.lt_) ) ((nat.O) )) (n)) , (fun (divnm : (((primes.divides) ) (n)) (m)) , (((((((@connectives.match_Or_prop) ((((logic.eq_) ((bool.bool) )) ((((primes.dividesb) ) (n)) (m))) ((bool.true) ))) ((((logic.eq_) ((bool.bool) )) ((((primes.dividesb) ) (n)) (m))) ((bool.false) ))) ((((logic.eq_) ((bool.bool) )) ((((primes.dividesb) ) (n)) (m))) ((bool.true) ))) (fun (auto : (((logic.eq_) ((bool.bool) )) ((((primes.dividesb) ) (n)) (m))) ((bool.true) )) , (((((((@logic.rewrite_r) ((bool.bool) )) ((bool.true) )) (fun (__ : (bool.bool) ) , (((logic.eq_) ((bool.bool) )) (__)) ((bool.true) ))) (((@logic.refl_) ((bool.bool) )) ((bool.true) ))) ((((primes.dividesb) ) (n)) (m))) (auto)))) (fun (ndivbnm : (((logic.eq_) ((bool.bool) )) ((((primes.dividesb) ) (n)) (m))) ((bool.false) )) , (((@connectives.falsity) ((((logic.eq_) ((bool.bool) )) ((((primes.dividesb) ) (n)) (m))) ((bool.true) ))) ((((@logic.absurd) ((((primes.divides) ) (n)) (m))) (divnm)) ((((@primes.dividesb_false_to_not_divides) (n)) (m)) (((((((@logic.rewrite_r) ((bool.bool) )) ((bool.false) )) (fun (__ : (bool.bool) ) , (((logic.eq_) ((bool.bool) )) (__)) ((bool.false) ))) (((@logic.refl_) ((bool.bool) )) ((bool.false) ))) ((((primes.dividesb) ) (n)) (m))) (ndivbnm))))))) ((@bool.true_or_false) ((((primes.dividesb) ) (n)) (m))))).
theorem primes.not_divides_to_dividesb_false : forall (n:(nat.nat) ) , forall (m:(nat.nat) ) , ((((nat.lt_) ) ((nat.O) )) (n)) -> (((connectives.Not) ) ((((primes.divides) ) (n)) (m))) -> (((logic.eq_) ((bool.bool) )) ((((primes.dividesb) ) (n)) (m))) ((bool.false) ) := fun (n : (nat.nat) ) , fun (m : (nat.nat) ) , fun (posn : (((nat.lt_) ) ((nat.O) )) (n)) , (((((((@connectives.match_Or_prop) ((((logic.eq_) ((bool.bool) )) ((((primes.dividesb) ) (n)) (m))) ((bool.true) ))) ((((logic.eq_) ((bool.bool) )) ((((primes.dividesb) ) (n)) (m))) ((bool.false) ))) ((((connectives.Not) ) ((((primes.divides) ) (n)) (m))) -> (((logic.eq_) ((bool.bool) )) ((((primes.dividesb) ) (n)) (m))) ((bool.false) ))) (fun (divbnm : (((logic.eq_) ((bool.bool) )) ((((primes.dividesb) ) (n)) (m))) ((bool.true) )) , (fun (ndivnm : ((connectives.Not) ) ((((primes.divides) ) (n)) (m))) , (((@connectives.falsity) ((((logic.eq_) ((bool.bool) )) ((((primes.dividesb) ) (n)) (m))) ((bool.false) ))) ((((@logic.absurd) ((((primes.divides) ) (n)) (m))) ((((@primes.dividesb_true_to_divides) (n)) (m)) (((((((@logic.rewrite_r) ((bool.bool) )) ((bool.true) )) (fun (__ : (bool.bool) ) , (((logic.eq_) ((bool.bool) )) (__)) ((bool.true) ))) (((@logic.refl_) ((bool.bool) )) ((bool.true) ))) ((((primes.dividesb) ) (n)) (m))) (divbnm)))) (ndivnm)))))) (fun (auto : (((logic.eq_) ((bool.bool) )) ((((primes.dividesb) ) (n)) (m))) ((bool.false) )) , (fun (auto' : ((connectives.Not) ) ((((primes.divides) ) (n)) (m))) , (((((((@logic.rewrite_r) ((bool.bool) )) ((bool.false) )) (fun (__ : (bool.bool) ) , (((logic.eq_) ((bool.bool) )) (__)) ((bool.false) ))) (((@logic.refl_) ((bool.bool) )) ((bool.false) ))) ((((primes.dividesb) ) (n)) (m))) (auto))))) ((@bool.true_or_false) ((((primes.dividesb) ) (n)) (m)))).
def primes.prime : ((nat.nat) ) -> Prop := fun (n : (nat.nat) ) , (((connectives.And) ) ((((nat.lt_) ) (((nat.S) ) ((nat.O) ))) (n))) (forall (m:(nat.nat) ) , ((((primes.divides) ) (m)) (n)) -> ((((nat.lt_) ) (((nat.S) ) ((nat.O) ))) (m)) -> (((logic.eq_) ((nat.nat) )) (m)) (n)).
theorem primes.prime_to_lt_O : forall (p:(nat.nat) ) , (((primes.prime) ) (p)) -> (((nat.lt_) ) ((nat.O) )) (p) := fun (p : (nat.nat) ) , fun (_clearme : ((primes.prime) ) (p)) , ((((((@connectives.match_And_prop) ((((nat.lt_) ) (((nat.S) ) ((nat.O) ))) (p))) (forall (m:(nat.nat) ) , ((((primes.divides) ) (m)) (p)) -> ((((nat.lt_) ) (((nat.S) ) ((nat.O) ))) (m)) -> (((logic.eq_) ((nat.nat) )) (m)) (p))) ((((nat.lt_) ) ((nat.O) )) (p))) (fun (lt1p : (((nat.lt_) ) (((nat.S) ) ((nat.O) ))) (p)) , (fun (auto : forall (m:(nat.nat) ) , ((((primes.divides) ) (m)) (p)) -> ((((nat.lt_) ) (((nat.S) ) ((nat.O) ))) (m)) -> (((logic.eq_) ((nat.nat) )) (m)) (p)) , ((((@nat.lt_S_to_lt) ((nat.O) )) (p)) (lt1p))))) (_clearme)).
theorem primes.prime_to_lt_SO : forall (p:(nat.nat) ) , (((primes.prime) ) (p)) -> (((nat.lt_) ) (((nat.S) ) ((nat.O) ))) (p) := fun (p : (nat.nat) ) , fun (_clearme : ((primes.prime) ) (p)) , ((((((@connectives.match_And_prop) ((((nat.lt_) ) (((nat.S) ) ((nat.O) ))) (p))) (forall (m:(nat.nat) ) , ((((primes.divides) ) (m)) (p)) -> ((((nat.lt_) ) (((nat.S) ) ((nat.O) ))) (m)) -> (((logic.eq_) ((nat.nat) )) (m)) (p))) ((((nat.lt_) ) (((nat.S) ) ((nat.O) ))) (p))) (fun (lt1p : (((nat.lt_) ) (((nat.S) ) ((nat.O) ))) (p)) , (fun (auto : forall (m:(nat.nat) ) , ((((primes.divides) ) (m)) (p)) -> ((((nat.lt_) ) (((nat.S) ) ((nat.O) ))) (m)) -> (((logic.eq_) ((nat.nat) )) (m)) (p)) , (lt1p)))) (_clearme)).
