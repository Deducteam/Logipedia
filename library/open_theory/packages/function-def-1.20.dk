
(; This file was generated by Holide. ;)

#NAME function_2Ddef_2D1_2E20.

def type_0 : hol.type -> hol.type :=
  A : hol.type => A.

def type_1 : hol.type -> hol.type :=
  A : hol.type => hol.arr (type_0 A) (type_0 A).

def type_2 : hol.type :=
  hol.bool.

(; Constant function-def-1.20 ;)

function_2Ddef_2D1_2E20 : A : hol.type -> hol.term (type_0 A).

(; Constant Function.id ;)

def Function_2Eid : A : hol.type -> hol.term (type_1 A) :=
  A : hol.type => function_2Ddef_2D1_2E20 (type_1 A).

def term_0 : A : hol.type -> x_1 : hol.term (type_0 A) -> hol.term (type_0 A) :=
  A : hol.type => x_1 : hol.term (type_0 A) => x_1.

def term_1 : A : hol.type -> hol.term type_2 :=
  A : hol.type => hol.eq (type_1 A) (Function_2Eid (type_0 A)) (x_1 : hol.term (type_0 A) => term_0 A x_1).

(; axiom ;)

thm_0 : A : hol.type -> hol.proof (term_1 A).

(; Theorem: |- ((= Function.id) \lambda x. x) ;)

def type_3 : hol.type -> hol.type :=
  B : hol.type => B.

def type_4 : hol.type -> hol.type -> hol.type :=
  B : hol.type => A : hol.type => hol.arr (type_0 A) (hol.arr (type_3 B) (type_0 A)).

(; Constant Function.const ;)

def Function_2Econst : B : hol.type -> A : hol.type -> hol.term (type_4 B A) :=
  B : hol.type => A : hol.type => function_2Ddef_2D1_2E20 (type_4 B A).

def term_2 : B : hol.type -> A : hol.type -> hol.term type_2 :=
  B : hol.type => A : hol.type => hol.eq (type_4 B A) (Function_2Econst (type_3 B) (type_0 A)) (x_1 : hol.term (type_0 A) => y_2 : hol.term (type_3 B) => term_0 A x_1).

(; axiom ;)

thm_1 : B : hol.type -> A : hol.type -> hol.proof (term_2 B A).

(; Theorem: |- ((= Function.const) \lambda x. \lambda y. x) ;)

def type_5 : hol.type -> hol.type -> hol.type :=
  B : hol.type => A : hol.type => hol.arr (type_0 A) (type_3 B).

def type_6 : hol.type -> hol.type -> hol.type :=
  B : hol.type => A : hol.type => hol.arr (type_0 A) (type_5 B A).

def type_7 : hol.type -> hol.type -> hol.type :=
  B : hol.type => A : hol.type => hol.arr (type_6 B A) (type_5 B A).

(; Constant Function.Combinator.w ;)

def Function_2ECombinator_2Ew : B : hol.type -> A : hol.type -> hol.term (type_7 B A) :=
  B : hol.type => A : hol.type => function_2Ddef_2D1_2E20 (type_7 B A).

def term_3 : B : hol.type -> A : hol.type -> hol.term type_2 :=
  B : hol.type => A : hol.type => hol.eq (type_7 B A) (Function_2ECombinator_2Ew (type_3 B) (type_0 A)) (f_1 : hol.term (type_6 B A) => x_2 : hol.term (type_0 A) => f_1 (term_0 A x_2) (term_0 A x_2)).

(; axiom ;)

thm_2 : B : hol.type -> A : hol.type -> hol.proof (term_3 B A).

(; Theorem: |- ((= Function.Combinator.w) \lambda f. \lambda x. ((f x) x)) ;)

def type_8 : hol.type -> hol.type -> hol.type :=
  C : hol.type => B : hol.type => hol.arr (type_3 B) C.

def type_9 : hol.type -> hol.type -> hol.type -> hol.type :=
  A : hol.type => C : hol.type => B : hol.type => hol.arr (type_8 C B) (hol.arr (type_5 B A) (hol.arr (type_0 A) C)).

(; Constant Function.o ;)

def Function_2Eo : A : hol.type -> C : hol.type -> B : hol.type -> hol.term (type_9 A C B) :=
  A : hol.type => C : hol.type => B : hol.type => function_2Ddef_2D1_2E20 (type_9 A C B).

def term_4 : B : hol.type -> A : hol.type -> x_1 : hol.term (type_0 A) -> g_2 : hol.term (type_5 B A) -> hol.term (type_3 B) :=
  B : hol.type => A : hol.type => x_1 : hol.term (type_0 A) => g_2 : hol.term (type_5 B A) => g_2 (term_0 A x_1).

def term_5 : A : hol.type -> C : hol.type -> B : hol.type -> hol.term type_2 :=
  A : hol.type => C : hol.type => B : hol.type => hol.eq (type_9 A C B) (Function_2Eo (type_0 A) C (type_3 B)) (f_1 : hol.term (type_8 C B) => g_2 : hol.term (type_5 B A) => x_3 : hol.term (type_0 A) => f_1 (term_4 B A x_3 g_2)).

(; axiom ;)

thm_3 : A : hol.type -> C : hol.type -> B : hol.type -> hol.proof (term_5 A C B).

(; Theorem: |- ((= Function.o) \lambda f. \lambda g. \lambda x. (f (g x))) ;)

def type_10 : hol.type -> hol.type -> hol.type -> hol.type :=
  C : hol.type => B : hol.type => A : hol.type => hol.arr (type_0 A) (type_8 C B).

def type_11 : hol.type -> hol.type -> hol.type -> hol.type :=
  C : hol.type => B : hol.type => A : hol.type => hol.arr (type_10 C B A) (hol.arr (type_3 B) (hol.arr (type_0 A) C)).

(; Constant Function.flip ;)

def Function_2Eflip : C : hol.type -> B : hol.type -> A : hol.type -> hol.term (type_11 C B A) :=
  C : hol.type => B : hol.type => A : hol.type => function_2Ddef_2D1_2E20 (type_11 C B A).

def term_6 : C : hol.type -> B : hol.type -> A : hol.type -> f_1 : hol.term (type_10 C B A) -> hol.term (type_10 C B A) :=
  C : hol.type => B : hol.type => A : hol.type => f_1 : hol.term (type_10 C B A) => f_1.

def term_7 : C : hol.type -> B : hol.type -> A : hol.type -> hol.term type_2 :=
  C : hol.type => B : hol.type => A : hol.type => hol.eq (type_11 C B A) (Function_2Eflip C (type_3 B) (type_0 A)) (f_1 : hol.term (type_10 C B A) => x_2 : hol.term (type_3 B) => y_3 : hol.term (type_0 A) => term_6 C B A f_1 y_3 x_2).

(; axiom ;)

thm_4 : C : hol.type -> B : hol.type -> A : hol.type -> hol.proof (term_7 C B A).

(; Theorem: |- ((= Function.flip) \lambda f. \lambda x. \lambda y. ((f y) x)) ;)

def type_12 : hol.type -> hol.type -> hol.type -> hol.type :=
  C : hol.type => B : hol.type => A : hol.type => hol.arr (type_10 C B A) (hol.arr (type_5 B A) (hol.arr (type_0 A) C)).

(; Constant Function.Combinator.s ;)

def Function_2ECombinator_2Es : C : hol.type -> B : hol.type -> A : hol.type -> hol.term (type_12 C B A) :=
  C : hol.type => B : hol.type => A : hol.type => function_2Ddef_2D1_2E20 (type_12 C B A).

def term_8 : C : hol.type -> B : hol.type -> A : hol.type -> hol.term type_2 :=
  C : hol.type => B : hol.type => A : hol.type => hol.eq (type_12 C B A) (Function_2ECombinator_2Es C (type_3 B) (type_0 A)) (f_1 : hol.term (type_10 C B A) => g_2 : hol.term (type_5 B A) => x_3 : hol.term (type_0 A) => term_6 C B A f_1 (term_0 A x_3) (term_4 B A x_3 g_2)).

(; axiom ;)

thm_5 : C : hol.type -> B : hol.type -> A : hol.type -> hol.proof (term_8 C B A).

(; Theorem: |- ((= Function.Combinator.s) \lambda f. \lambda g. \lambda x. ((f x) (g x))) ;)

def type_13 : hol.type -> hol.type -> hol.type :=
  B : hol.type => A : hol.type => hol.arr (type_5 B A) type_2.

(; Constant Data.Bool.! ;)

Data_2EBool_2E_21 : A : hol.type -> hol.term (type_0 A).

def term_9 : B : hol.type -> A : hol.type -> hol.term (hol.arr (type_13 B A) type_2) :=
  B : hol.type => A : hol.type => Data_2EBool_2E_21 (hol.arr (type_13 B A) type_2).

def type_14 : hol.type :=
  hol.arr type_2 (hol.arr type_2 type_2).

def term_10 : hol.term type_14 :=
  hol.eq type_2.

def term_11 : B : hol.type -> A : hol.type -> hol.term (type_13 B A) :=
  B : hol.type => A : hol.type => function_2Ddef_2D1_2E20 (type_13 B A).

(; Constant Function.surjective ;)

def Function_2Esurjective : B : hol.type -> A : hol.type -> hol.term (type_13 B A) :=
  B : hol.type => A : hol.type => term_11 B A.

def term_12 : B : hol.type -> A : hol.type -> f_1 : hol.term (type_5 B A) -> hol.term (type_5 B A) :=
  B : hol.type => A : hol.type => f_1 : hol.term (type_5 B A) => f_1.

def type_15 : hol.type -> hol.type :=
  B : hol.type => hol.arr (type_3 B) type_2.

def type_16 : hol.type -> hol.type :=
  A : hol.type => hol.arr (type_0 A) type_2.

def type_17 : hol.type -> hol.type :=
  A : hol.type => hol.arr (type_16 A) type_2.

(; Constant Data.Bool.? ;)

Data_2EBool_2E_3F : A : hol.type -> hol.term (type_0 A).

def term_13 : B : hol.type -> hol.term (hol.arr (type_3 B) (type_15 B)) :=
  B : hol.type => hol.eq (type_3 B).

def term_14 : B : hol.type -> A : hol.type -> hol.term type_2 :=
  B : hol.type => A : hol.type => term_9 B A (f_1 : hol.term (type_5 B A) => term_10 (Function_2Esurjective (type_3 B) (type_0 A) (term_12 B A f_1)) (Data_2EBool_2E_21 (hol.arr (type_15 B) type_2) (y_2 : hol.term (type_3 B) => Data_2EBool_2E_3F (type_17 A) (x_3 : hol.term (type_0 A) => term_13 B y_2 (term_12 B A f_1 (term_0 A x_3)))))).

(; axiom ;)

thm_6 : B : hol.type -> A : hol.type -> hol.proof (term_14 B A).

(; Theorem: |- (Data.Bool.! \lambda f. ((= (Function.surjective f)) (Data.Bool.! \lambda y. (Data.Bool.? \lambda x. ((= y) (f x)))))) ;)

(; Constant Function.injective ;)

def Function_2Einjective : B : hol.type -> A : hol.type -> hol.term (type_13 B A) :=
  B : hol.type => A : hol.type => term_11 B A.

def term_15 : A : hol.type -> hol.term (type_17 A) :=
  A : hol.type => Data_2EBool_2E_21 (type_17 A).

(; Constant Data.Bool.==> ;)

Data_2EBool_2E_3D_3D_3E : A : hol.type -> hol.term (type_0 A).

def term_16 : A : hol.type -> x1_1 : hol.term (type_0 A) -> hol.term (type_0 A) :=
  A : hol.type => x1_1 : hol.term (type_0 A) => x1_1.

def term_17 : A : hol.type -> x2_1 : hol.term (type_0 A) -> hol.term (type_0 A) :=
  A : hol.type => x2_1 : hol.term (type_0 A) => x2_1.

def term_18 : B : hol.type -> A : hol.type -> hol.term type_2 :=
  B : hol.type => A : hol.type => term_9 B A (f_1 : hol.term (type_5 B A) => term_10 (Function_2Einjective (type_3 B) (type_0 A) (term_12 B A f_1)) (term_15 A (x1_2 : hol.term (type_0 A) => term_15 A (x2_3 : hol.term (type_0 A) => Data_2EBool_2E_3D_3D_3E type_14 (term_13 B (term_12 B A f_1 (term_16 A x1_2)) (term_12 B A f_1 (term_17 A x2_3))) (hol.eq (type_0 A) (term_16 A x1_2) (term_17 A x2_3)))))).

(; axiom ;)

thm_7 : B : hol.type -> A : hol.type -> hol.proof (term_18 B A).

(; Theorem: |- (Data.Bool.! \lambda f. ((= (Function.injective f)) (Data.Bool.! \lambda x1. (Data.Bool.! \lambda x2. ((Data.Bool.==> ((= (f x1)) (f x2))) ((= x1) x2)))))) ;)
