
(; This file was generated by Holide. ;)

#NAME set_2Dsize_2Ddef_2D1_2E33.

def type_0 : hol.type -> hol.type :=
  A : hol.type => A.

Set_2Eset : hol.type -> hol.type.

def type_1 : hol.type -> hol.type :=
  A : hol.type => Set_2Eset (type_0 A).

Number_2ENatural_2Enatural : hol.type.

def type_2 : hol.type :=
  Number_2ENatural_2Enatural.

def type_3 : hol.type -> hol.type :=
  A : hol.type => hol.arr (type_1 A) type_2.

def type_4 : hol.type :=
  hol.bool.

(; Constant set-size-def-1.33 ;)

set_2Dsize_2Ddef_2D1_2E33 : A : hol.type -> hol.term (type_0 A).

(; Constant Set.size ;)

def Set_2Esize : A : hol.type -> hol.term (type_3 A) :=
  A : hol.type => set_2Dsize_2Ddef_2D1_2E33 (type_3 A).

def term_0 : A : hol.type -> hol.term (type_3 A) :=
  A : hol.type => Set_2Esize (type_0 A).

def type_5 : hol.type :=
  hol.arr type_2 type_2.

(; Constant Set.fold ;)

Set_2Efold : A : hol.type -> hol.term (type_0 A).

(; Constant Number.Natural.suc ;)

Number_2ENatural_2Esuc : A : hol.type -> hol.term (type_0 A).

def term_1 : n_1 : hol.term type_2 -> hol.term type_2 :=
  n_1 : hol.term type_2 => n_1.

(; Constant Number.Natural.zero ;)

Number_2ENatural_2Ezero : A : hol.type -> hol.term (type_0 A).

def term_2 : A : hol.type -> hol.term type_4 :=
  A : hol.type => hol.eq (type_3 A) (term_0 A) (Set_2Efold (hol.arr (hol.arr (type_0 A) type_5) (hol.arr type_2 (type_3 A))) (x_1 : hol.term (type_0 A) => n_2 : hol.term type_2 => Number_2ENatural_2Esuc type_5 (term_1 n_2)) (Number_2ENatural_2Ezero type_2)).

(; axiom ;)

thm_0 : A : hol.type -> hol.proof (term_2 A).

(; Theorem: |- ((= Set.size) ((Set.fold \lambda x. \lambda n. (Number.Natural.suc n)) Number.Natural.zero)) ;)

def type_6 : hol.type -> hol.type :=
  A : hol.type => hol.arr (type_1 A) type_4.

(; Constant Data.Bool.! ;)

Data_2EBool_2E_21 : A : hol.type -> hol.term (type_0 A).

def type_7 : hol.type :=
  hol.arr type_2 type_4.

def type_8 : hol.type :=
  hol.arr type_4 (hol.arr type_4 type_4).

def type_9 : hol.type -> hol.type :=
  A : hol.type => hol.arr (type_1 A) type_7.

(; Constant Set.hasSize ;)

def Set_2EhasSize : A : hol.type -> hol.term (type_9 A) :=
  A : hol.type => set_2Dsize_2Ddef_2D1_2E33 (type_9 A).

def term_3 : A : hol.type -> s_1 : hol.term (type_1 A) -> hol.term (type_1 A) :=
  A : hol.type => s_1 : hol.term (type_1 A) => s_1.

(; Constant Data.Bool./\ ;)

Data_2EBool_2E_2F_5C : A : hol.type -> hol.term (type_0 A).

(; Constant Set.finite ;)

Set_2Efinite : A : hol.type -> hol.term (type_0 A).

def term_4 : A : hol.type -> hol.term type_4 :=
  A : hol.type => Data_2EBool_2E_21 (hol.arr (type_6 A) type_4) (s_1 : hol.term (type_1 A) => Data_2EBool_2E_21 (hol.arr type_7 type_4) (n_2 : hol.term type_2 => hol.eq type_4 (Set_2EhasSize (type_0 A) (term_3 A s_1) (term_1 n_2)) (Data_2EBool_2E_2F_5C type_8 (Set_2Efinite (type_6 A) (term_3 A s_1)) (hol.eq type_2 (term_0 A (term_3 A s_1)) (term_1 n_2))))).

(; axiom ;)

thm_1 : A : hol.type -> hol.proof (term_4 A).

(; Theorem: |- (Data.Bool.! \lambda s. (Data.Bool.! \lambda n. ((= ((Set.hasSize s) n)) ((Data.Bool./\ (Set.finite s)) ((= (Set.size s)) n))))) ;)
