mod_aux :
  sttfa.etap
    (sttfa.p
       (sttfa.arrow nat.nat
          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))).

mod_aux_body :
  sttfa.etap
    (sttfa.p
       (sttfa.arrow nat.nat
          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))).

axiom_mod_aux :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        connectives.equal (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          (div_mod.mod_aux p)
          (nat.filter_nat_type
             (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
             div_mod.mod_aux_body p))).

def eq_mod_aux :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        leibniz.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          (div_mod.mod_aux p)
          (nat.filter_nat_type
             (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
             div_mod.mod_aux_body p))) :=
p:(sttfa.etap (sttfa.p nat.nat)) =>
connectives.equal_leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          (div_mod.mod_aux p)
          (nat.filter_nat_type
             (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
             div_mod.mod_aux_body p) (axiom_mod_aux p).

def sym_eq_mod_aux :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        leibniz.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          (nat.filter_nat_type
             (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
             div_mod.mod_aux_body p) (div_mod.mod_aux p)))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  leibniz.sym_leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
    (div_mod.mod_aux p)
    (nat.filter_nat_type (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
       div_mod.mod_aux_body p) (div_mod.eq_mod_aux p).

axiom_mod_aux_body_O :
  sttfa.eps
    (connectives.equal (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
       (div_mod.mod_aux_body nat.O)
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        n:(sttfa.etap (sttfa.p nat.nat)) => m)).

def eq_mod_aux_body_O :
  sttfa.eps
    (leibniz.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
       (div_mod.mod_aux_body nat.O)
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        n:(sttfa.etap (sttfa.p nat.nat)) => m)) :=
connectives.equal_leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
       (div_mod.mod_aux_body nat.O)
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        n:(sttfa.etap (sttfa.p nat.nat)) => m) axiom_mod_aux_body_O.

def sym_eq_mod_aux_body_O :
  sttfa.eps
    (leibniz.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        n:(sttfa.etap (sttfa.p nat.nat)) => m) (div_mod.mod_aux_body nat.O))
  :=
  leibniz.sym_leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
    (div_mod.mod_aux_body nat.O)
    (m:(sttfa.etap (sttfa.p nat.nat)) =>
     n:(sttfa.etap (sttfa.p nat.nat)) => m) div_mod.eq_mod_aux_body_O.

axiom_mod_aux_body_S :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        connectives.equal (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          (div_mod.mod_aux_body (nat.S p))
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           n:(sttfa.etap (sttfa.p nat.nat)) =>
           bool.match_bool_type nat.nat m
             (div_mod.mod_aux p (nat.minus m (nat.S n)) n) (nat.leb m n)))).

def eq_mod_aux_body_S :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        leibniz.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          (div_mod.mod_aux_body (nat.S p))
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           n:(sttfa.etap (sttfa.p nat.nat)) =>
           bool.match_bool_type nat.nat m
             (div_mod.mod_aux p (nat.minus m (nat.S n)) n) (nat.leb m n)))) :=
p:(sttfa.etap (sttfa.p nat.nat)) =>
connectives.equal_leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          (div_mod.mod_aux_body (nat.S p))
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           n:(sttfa.etap (sttfa.p nat.nat)) =>
           bool.match_bool_type nat.nat m
             (div_mod.mod_aux p (nat.minus m (nat.S n)) n) (nat.leb m n)) (axiom_mod_aux_body_S p).

def sym_eq_mod_aux_body_S :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        leibniz.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           n:(sttfa.etap (sttfa.p nat.nat)) =>
           bool.match_bool_type nat.nat m
             (div_mod.mod_aux p (nat.minus m (nat.S n)) n) (nat.leb m n))
          (div_mod.mod_aux_body (nat.S p))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  leibniz.sym_leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
    (div_mod.mod_aux_body (nat.S p))
    (m:(sttfa.etap (sttfa.p nat.nat)) =>
     n:(sttfa.etap (sttfa.p nat.nat)) =>
     bool.match_bool_type nat.nat m
       (div_mod.mod_aux p (nat.minus m (nat.S n)) n) (nat.leb m n))
    (div_mod.eq_mod_aux_body_S p).

def mod :
  sttfa.etap (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.match_nat_type nat.nat n
    (p:(sttfa.etap (sttfa.p nat.nat)) => div_mod.mod_aux n n p) m.

div_aux :
  sttfa.etap
    (sttfa.p
       (sttfa.arrow nat.nat
          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))).

div_aux_body :
  sttfa.etap
    (sttfa.p
       (sttfa.arrow nat.nat
          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))).

axiom_div_aux :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        connectives.equal (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          (div_mod.div_aux p)
          (nat.filter_nat_type
             (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
             div_mod.div_aux_body p))).

def eq_div_aux :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        leibniz.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          (div_mod.div_aux p)
          (nat.filter_nat_type
             (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
             div_mod.div_aux_body p))) :=
p:(sttfa.etap (sttfa.p nat.nat)) =>
connectives.equal_leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          (div_mod.div_aux p)
          (nat.filter_nat_type
             (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
             div_mod.div_aux_body p) (axiom_div_aux p).

def sym_eq_div_aux :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        leibniz.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          (nat.filter_nat_type
             (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
             div_mod.div_aux_body p) (div_mod.div_aux p)))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  leibniz.sym_leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
    (div_mod.div_aux p)
    (nat.filter_nat_type (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
       div_mod.div_aux_body p) (div_mod.eq_div_aux p).

axiom_div_aux_body_O :
  sttfa.eps
    (connectives.equal (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
       (div_mod.div_aux_body nat.O)
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        n:(sttfa.etap (sttfa.p nat.nat)) => nat.O)).

def eq_div_aux_body_O :
  sttfa.eps
    (leibniz.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
       (div_mod.div_aux_body nat.O)
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        n:(sttfa.etap (sttfa.p nat.nat)) => nat.O)) :=
connectives.equal_leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
       (div_mod.div_aux_body nat.O)
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        n:(sttfa.etap (sttfa.p nat.nat)) => nat.O) axiom_div_aux_body_O.

def sym_eq_div_aux_body_O :
  sttfa.eps
    (leibniz.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        n:(sttfa.etap (sttfa.p nat.nat)) => nat.O)
       (div_mod.div_aux_body nat.O))
  :=
  leibniz.sym_leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
    (div_mod.div_aux_body nat.O)
    (m:(sttfa.etap (sttfa.p nat.nat)) =>
     n:(sttfa.etap (sttfa.p nat.nat)) => nat.O) div_mod.eq_div_aux_body_O.

axiom_div_aux_body_S :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        connectives.equal (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          (div_mod.div_aux_body (nat.S p))
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           n:(sttfa.etap (sttfa.p nat.nat)) =>
           bool.match_bool_type nat.nat nat.O
             (nat.S (div_mod.div_aux p (nat.minus m (nat.S n)) n))
             (nat.leb m n)))).

def eq_div_aux_body_S :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        leibniz.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          (div_mod.div_aux_body (nat.S p))
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           n:(sttfa.etap (sttfa.p nat.nat)) =>
           bool.match_bool_type nat.nat nat.O
             (nat.S (div_mod.div_aux p (nat.minus m (nat.S n)) n))
             (nat.leb m n)))) :=
p:(sttfa.etap (sttfa.p nat.nat)) =>
connectives.equal_leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          (div_mod.div_aux_body (nat.S p))
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           n:(sttfa.etap (sttfa.p nat.nat)) =>
           bool.match_bool_type nat.nat nat.O
             (nat.S (div_mod.div_aux p (nat.minus m (nat.S n)) n))
             (nat.leb m n)) (axiom_div_aux_body_S p).

def sym_eq_div_aux_body_S :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        leibniz.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           n:(sttfa.etap (sttfa.p nat.nat)) =>
           bool.match_bool_type nat.nat nat.O
             (nat.S (div_mod.div_aux p (nat.minus m (nat.S n)) n))
             (nat.leb m n)) (div_mod.div_aux_body (nat.S p))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  leibniz.sym_leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
    (div_mod.div_aux_body (nat.S p))
    (m:(sttfa.etap (sttfa.p nat.nat)) =>
     n:(sttfa.etap (sttfa.p nat.nat)) =>
     bool.match_bool_type nat.nat nat.O
       (nat.S (div_mod.div_aux p (nat.minus m (nat.S n)) n)) (nat.leb m n))
    (div_mod.eq_div_aux_body_S p).

def div :
  sttfa.etap (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.match_nat_type nat.nat (nat.S n)
    (p:(sttfa.etap (sttfa.p nat.nat)) => div_mod.div_aux n n p) m.

def le_mod_aux_m_m :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat
             (m:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.le n p) (nat.le (div_mod.mod_aux p n m) m)))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.forall nat.nat
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.le n _x_365)
             (nat.le (div_mod.mod_aux _x_365 n m) m))))
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     m:(sttfa.etap (sttfa.p nat.nat)) =>
     div_mod.sym_eq_mod_aux nat.O
       (y:
        (sttfa.etap
           (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
        sttfa.impl (nat.le n nat.O) (nat.le (y n m) m))
       (nat.sym_eq_filter_nat_type_O
          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          div_mod.mod_aux_body
          (y:
           (sttfa.etap
              (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
           sttfa.impl (nat.le n nat.O) (nat.le (y n m) m))
          (div_mod.sym_eq_mod_aux_body_O
             (y:
              (sttfa.etap
                 (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
              sttfa.impl (nat.le n nat.O) (nat.le (y n m) m))
             (lenO:(sttfa.eps (nat.le n nat.O)) =>
              nat.le_n_O_elim n lenO
                (__:(sttfa.etap (sttfa.p nat.nat)) => nat.le __ m)
                (nat.le_O_n m)))))
    (q:(sttfa.etap (sttfa.p nat.nat)) =>
     div_mod.sym_eq_mod_aux (nat.S q)
       (y:
        (sttfa.etap
           (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
        sttfa.impl
          (sttfa.forall nat.nat
             (n:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat
                (m:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (nat.le n q) (nat.le (div_mod.mod_aux q n m) m))))
          (sttfa.forall nat.nat
             (n:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat
                (m:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (nat.le n (nat.S q)) (nat.le (y n m) m)))))
       (nat.sym_eq_filter_nat_type_S
          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          div_mod.mod_aux_body q
          (y:
           (sttfa.etap
              (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
           sttfa.impl
             (sttfa.forall nat.nat
                (n:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall nat.nat
                   (m:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (nat.le n q)
                      (nat.le (div_mod.mod_aux q n m) m))))
             (sttfa.forall nat.nat
                (n:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall nat.nat
                   (m:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (nat.le n (nat.S q)) (nat.le (y n m) m)))))
          (div_mod.sym_eq_mod_aux_body_S q
             (y:
              (sttfa.etap
                 (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
              sttfa.impl
                (sttfa.forall nat.nat
                   (n:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.forall nat.nat
                      (m:(sttfa.etap (sttfa.p nat.nat)) =>
                       sttfa.impl (nat.le n q)
                         (nat.le (div_mod.mod_aux q n m) m))))
                (sttfa.forall nat.nat
                   (n:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.forall nat.nat
                      (m:(sttfa.etap (sttfa.p nat.nat)) =>
                       sttfa.impl (nat.le n (nat.S q)) (nat.le (y n m) m)))))
             (Hind:
              (sttfa.eps
                 (sttfa.forall nat.nat
                    (n:(sttfa.etap (sttfa.p nat.nat)) =>
                     sttfa.forall nat.nat
                       (m:(sttfa.etap (sttfa.p nat.nat)) =>
                        sttfa.impl (nat.le n q)
                          (nat.le (div_mod.mod_aux q n m) m))))) =>
              n:(sttfa.etap (sttfa.p nat.nat)) =>
              m:(sttfa.etap (sttfa.p nat.nat)) =>
              len:(sttfa.eps (nat.le n (nat.S q))) =>
              nat.leb_elim n m
                (__:(sttfa.etap (sttfa.p bool.bool)) =>
                 nat.le
                   (bool.match_bool_type nat.nat n
                      (div_mod.mod_aux q (nat.minus n (nat.S m)) m) __) m)
                (bool.sym_eq_match_bool_type_true nat.nat n
                   (div_mod.mod_aux q (nat.minus n (nat.S m)) m)
                   (y:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (nat.le n m) (nat.le y m))
                   (auto:(sttfa.eps (nat.le n m)) => auto))
                (bool.sym_eq_match_bool_type_false nat.nat n
                   (div_mod.mod_aux q (nat.minus n (nat.S m)) m)
                   (y:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (connectives.Not (nat.le n m)) (nat.le y m))
                   (notlenm:(sttfa.eps (connectives.Not (nat.le n m))) =>
                    Hind (nat.minus n (nat.S m)) m
                      (nat.le_plus_to_minus n (nat.S m) q
                         (nat.transitive_le n (nat.S q)
                            (nat.plus q (nat.S m)) len
                            (logic.eq_coerc
                               (nat.le (nat.S q) (nat.plus (nat.S q) m))
                               (nat.le (nat.S q) (nat.plus q (nat.S m)))
                               (nat.le_plus_n_r m (nat.S q))
                               (logic.rewrite_l nat.nat
                                  (nat.plus m (nat.S q))
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq sttfa.bool (nat.le (nat.S q) __)
                                     (nat.le (nat.S q) (nat.plus q (nat.S m))))
                                  (logic.rewrite_r nat.nat
                                     (nat.plus q (nat.S m))
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq sttfa.bool
                                        (nat.le (nat.S q) __)
                                        (nat.le (nat.S q)
                                           (nat.plus q (nat.S m))))
                                     (logic.refl sttfa.bool
                                        (nat.le (nat.S q)
                                           (nat.plus q (nat.S m))))
                                     (nat.plus m (nat.S q))
                                     (logic.rewrite_l nat.nat
                                        (nat.S (nat.plus m q))
                                        (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq nat.nat __
                                           (nat.plus q (nat.S m)))
                                        (logic.rewrite_l nat.nat
                                           (nat.plus q m)
                                           (__:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq nat.nat (nat.S __)
                                              (nat.plus q (nat.S m)))
                                           (nat.plus_n_Sm q m)
                                           (nat.plus m q)
                                           (nat.commutative_plus q m))
                                        (nat.plus m (nat.S q))
                                        (nat.plus_n_Sm m q)))
                                  (nat.plus (nat.S q) m)
                                  (nat.commutative_plus m (nat.S q))))))))))))
    p.

def lt_mod_m_m :
  sttfa.eps
    (sttfa.forall nat.nat
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.lt nat.O m) (nat.lt (div_mod.mod n m) m))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.match_nat_prop
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.impl (nat.lt nat.O __) (nat.lt (div_mod.mod n __) __))
    (abs:(sttfa.eps (nat.lt nat.O nat.O)) =>
     connectives.falsity (nat.lt (div_mod.mod n nat.O) nat.O)
       (logic.absurd (nat.le (nat.S nat.O) nat.O) abs (nat.not_le_Sn_O nat.O)))
    (p:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_match_nat_type_S nat.nat n
       (q:(sttfa.etap (sttfa.p nat.nat)) => div_mod.mod_aux n n q) p
       (y:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.impl (nat.lt nat.O (nat.S p)) (nat.lt y (nat.S p)))
       (__:(sttfa.eps (nat.lt nat.O (nat.S p))) =>
        nat.le_S_S (div_mod.mod_aux n n p) p
          (div_mod.le_mod_aux_m_m n n p (nat.le_n n)))) m.

def div_aux_mod_aux :
  sttfa.eps
    (sttfa.forall nat.nat
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat
             (m:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat n
                (nat.plus (nat.times (div_mod.div_aux p n m) (nat.S m))
                   (div_mod.mod_aux p n m))))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.forall nat.nat
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat n
             (nat.plus (nat.times (div_mod.div_aux _x_365 n m) (nat.S m))
                (div_mod.mod_aux _x_365 n m)))))
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     m:(sttfa.etap (sttfa.p nat.nat)) =>
     div_mod.sym_eq_div_aux nat.O
       (y:
        (sttfa.etap
           (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
        logic.eq nat.nat n
          (nat.plus (nat.times (y n m) (nat.S m)) (div_mod.mod_aux nat.O n m)))
       (nat.sym_eq_filter_nat_type_O
          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          div_mod.div_aux_body
          (y:
           (sttfa.etap
              (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
           logic.eq nat.nat n
             (nat.plus (nat.times (y n m) (nat.S m))
                (div_mod.mod_aux nat.O n m)))
          (div_mod.sym_eq_div_aux_body_O
             (y:
              (sttfa.etap
                 (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
              logic.eq nat.nat n
                (nat.plus (nat.times (y n m) (nat.S m))
                   (div_mod.mod_aux nat.O n m)))
             (nat.eq_match_nat_type_O nat.nat nat.O
                (q:(sttfa.etap (sttfa.p nat.nat)) =>
                 bool.match_bool_type nat.nat nat.O
                   (nat.S (div_mod.div_aux q (nat.minus n (nat.S m)) m))
                   (nat.leb n m))
                (y:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat n
                   (nat.plus (nat.times y (nat.S m))
                      (div_mod.mod_aux nat.O n m)))
                (div_mod.sym_eq_mod_aux nat.O
                   (y:
                    (sttfa.etap
                       (sttfa.p
                          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
                    logic.eq nat.nat n
                      (nat.plus
                         (nat.times
                            ((m0:(sttfa.etap (sttfa.p nat.nat)) =>
                              n0:(sttfa.etap (sttfa.p nat.nat)) =>
                              nat.match_nat_type nat.nat nat.O
                                (q:(sttfa.etap (sttfa.p nat.nat)) =>
                                 bool.match_bool_type nat.nat nat.O
                                   (nat.S
                                      (div_mod.div_aux q
                                         (nat.minus m0 (nat.S n0)) n0))
                                   (nat.leb m0 n0)) nat.O) n m) (nat.S m))
                         (y n m)))
                   (nat.sym_eq_filter_nat_type_O
                      (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
                      div_mod.mod_aux_body
                      (y:
                       (sttfa.etap
                          (sttfa.p
                             (sttfa.arrow nat.nat
                                (sttfa.arrow nat.nat nat.nat)))) =>
                       logic.eq nat.nat n
                         (nat.plus
                            (nat.times
                               ((m0:(sttfa.etap (sttfa.p nat.nat)) =>
                                 n0:(sttfa.etap (sttfa.p nat.nat)) =>
                                 nat.match_nat_type nat.nat nat.O
                                   (q:(sttfa.etap (sttfa.p nat.nat)) =>
                                    bool.match_bool_type nat.nat nat.O
                                      (nat.S
                                         (div_mod.div_aux q
                                            (nat.minus m0 (nat.S n0)) n0))
                                      (nat.leb m0 n0)) nat.O) n m) (nat.S m))
                            (y n m)))
                      (div_mod.sym_eq_mod_aux_body_O
                         (y:
                          (sttfa.etap
                             (sttfa.p
                                (sttfa.arrow nat.nat
                                   (sttfa.arrow nat.nat nat.nat)))) =>
                          logic.eq nat.nat n
                            (nat.plus
                               (nat.times
                                  ((m0:(sttfa.etap (sttfa.p nat.nat)) =>
                                    n0:(sttfa.etap (sttfa.p nat.nat)) =>
                                    nat.match_nat_type nat.nat nat.O
                                      (q:(sttfa.etap (sttfa.p nat.nat)) =>
                                       bool.match_bool_type nat.nat nat.O
                                         (nat.S
                                            (div_mod.div_aux q
                                               (nat.minus m0 (nat.S n0)) n0))
                                         (nat.leb m0 n0)) nat.O) n m)
                                  (nat.S m)) (y n m)))
                         (nat.sym_eq_match_nat_type_O nat.nat nat.O
                            (q:(sttfa.etap (sttfa.p nat.nat)) =>
                             bool.match_bool_type nat.nat nat.O
                               (nat.S
                                  (div_mod.div_aux q (nat.minus n (nat.S m))
                                     m)) (nat.leb n m))
                            (y:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq nat.nat n
                               (nat.plus
                                  (nat.times
                                     ((m0:(sttfa.etap (sttfa.p nat.nat)) =>
                                       n0:(sttfa.etap (sttfa.p nat.nat)) => y)
                                        n m) (nat.S m)) n))
                            (nat.sym_eq_times nat.O
                               (y:
                                (sttfa.etap
                                   (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                                logic.eq nat.nat n (nat.plus (y (nat.S m)) n))
                               (nat.sym_eq_filter_nat_type_O
                                  (sttfa.arrow nat.nat nat.nat)
                                  nat.times_body
                                  (y:
                                   (sttfa.etap
                                      (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                                   logic.eq nat.nat n
                                     (nat.plus (y (nat.S m)) n))
                                  (nat.sym_eq_times_body_O
                                     (y:
                                      (sttfa.etap
                                         (sttfa.p
                                            (sttfa.arrow nat.nat nat.nat))) =>
                                      logic.eq nat.nat n
                                        (nat.plus (y (nat.S m)) n))
                                     (nat.sym_eq_plus nat.O
                                        (y:
                                         (sttfa.etap
                                            (sttfa.p
                                               (sttfa.arrow nat.nat nat.nat))) =>
                                         logic.eq nat.nat n (y n))
                                        (nat.sym_eq_filter_nat_type_O
                                           (sttfa.arrow nat.nat nat.nat)
                                           nat.plus_body
                                           (y:
                                            (sttfa.etap
                                               (sttfa.p
                                                  (sttfa.arrow nat.nat
                                                     nat.nat))) =>
                                            logic.eq nat.nat n (y n))
                                           (nat.sym_eq_plus_body_O
                                              (y:
                                               (sttfa.etap
                                                  (sttfa.p
                                                     (sttfa.arrow nat.nat
                                                        nat.nat))) =>
                                               logic.eq nat.nat n (y n))
                                              (logic.refl nat.nat n)))))))))))))))
    (q:(sttfa.etap (sttfa.p nat.nat)) =>
     div_mod.sym_eq_div_aux (nat.S q)
       (y:
        (sttfa.etap
           (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
        sttfa.impl
          (sttfa.forall nat.nat
             (n:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat
                (m:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat n
                   (nat.plus (nat.times (div_mod.div_aux q n m) (nat.S m))
                      (div_mod.mod_aux q n m)))))
          (sttfa.forall nat.nat
             (n:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat
                (m:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat n
                   (nat.plus (nat.times (y n m) (nat.S m))
                      (div_mod.mod_aux (nat.S q) n m))))))
       (nat.sym_eq_filter_nat_type_S
          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
          div_mod.div_aux_body q
          (y:
           (sttfa.etap
              (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
           sttfa.impl
             (sttfa.forall nat.nat
                (n:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall nat.nat
                   (m:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat n
                      (nat.plus
                         (nat.times (div_mod.div_aux q n m) (nat.S m))
                         (div_mod.mod_aux q n m)))))
             (sttfa.forall nat.nat
                (n:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall nat.nat
                   (m:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat n
                      (nat.plus (nat.times (y n m) (nat.S m))
                         (div_mod.mod_aux (nat.S q) n m))))))
          (div_mod.sym_eq_div_aux_body_S q
             (y:
              (sttfa.etap
                 (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
              sttfa.impl
                (sttfa.forall nat.nat
                   (n:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.forall nat.nat
                      (m:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat n
                         (nat.plus
                            (nat.times (div_mod.div_aux q n m) (nat.S m))
                            (div_mod.mod_aux q n m)))))
                (sttfa.forall nat.nat
                   (n:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.forall nat.nat
                      (m:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat n
                         (nat.plus (nat.times (y n m) (nat.S m))
                            (div_mod.mod_aux (nat.S q) n m))))))
             (Hind:
              (sttfa.eps
                 (sttfa.forall nat.nat
                    (n:(sttfa.etap (sttfa.p nat.nat)) =>
                     sttfa.forall nat.nat
                       (m:(sttfa.etap (sttfa.p nat.nat)) =>
                        logic.eq nat.nat n
                          (nat.plus
                             (nat.times (div_mod.div_aux q n m) (nat.S m))
                             (div_mod.mod_aux q n m)))))) =>
              n:(sttfa.etap (sttfa.p nat.nat)) =>
              m:(sttfa.etap (sttfa.p nat.nat)) =>
              nat.eq_match_nat_type_S nat.nat nat.O
                (q0:(sttfa.etap (sttfa.p nat.nat)) =>
                 bool.match_bool_type nat.nat nat.O
                   (nat.S (div_mod.div_aux q0 (nat.minus n (nat.S m)) m))
                   (nat.leb n m)) q
                (y:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat n
                   (nat.plus (nat.times y (nat.S m))
                      (div_mod.mod_aux (nat.S q) n m)))
                (div_mod.sym_eq_mod_aux (nat.S q)
                   (y:
                    (sttfa.etap
                       (sttfa.p
                          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
                    logic.eq nat.nat n
                      (nat.plus
                         (nat.times
                            ((m0:(sttfa.etap (sttfa.p nat.nat)) =>
                              n0:(sttfa.etap (sttfa.p nat.nat)) =>
                              nat.match_nat_type nat.nat nat.O
                                (q0:(sttfa.etap (sttfa.p nat.nat)) =>
                                 bool.match_bool_type nat.nat nat.O
                                   (nat.S
                                      (div_mod.div_aux q0
                                         (nat.minus m0 (nat.S n0)) n0))
                                   (nat.leb m0 n0)) (nat.S q)) n m) (
                            nat.S m)) (y n m)))
                   (nat.sym_eq_filter_nat_type_S
                      (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
                      div_mod.mod_aux_body q
                      (y:
                       (sttfa.etap
                          (sttfa.p
                             (sttfa.arrow nat.nat
                                (sttfa.arrow nat.nat nat.nat)))) =>
                       logic.eq nat.nat n
                         (nat.plus
                            (nat.times
                               ((m0:(sttfa.etap (sttfa.p nat.nat)) =>
                                 n0:(sttfa.etap (sttfa.p nat.nat)) =>
                                 nat.match_nat_type nat.nat nat.O
                                   (q0:(sttfa.etap (sttfa.p nat.nat)) =>
                                    bool.match_bool_type nat.nat nat.O
                                      (nat.S
                                         (div_mod.div_aux q0
                                            (nat.minus m0 (nat.S n0)) n0))
                                      (nat.leb m0 n0)) (nat.S q)) n m)
                               (nat.S m)) (y n m)))
                      (div_mod.sym_eq_mod_aux_body_S q
                         (y:
                          (sttfa.etap
                             (sttfa.p
                                (sttfa.arrow nat.nat
                                   (sttfa.arrow nat.nat nat.nat)))) =>
                          logic.eq nat.nat n
                            (nat.plus
                               (nat.times
                                  ((m0:(sttfa.etap (sttfa.p nat.nat)) =>
                                    n0:(sttfa.etap (sttfa.p nat.nat)) =>
                                    nat.match_nat_type nat.nat nat.O
                                      (q0:(sttfa.etap (sttfa.p nat.nat)) =>
                                       bool.match_bool_type nat.nat nat.O
                                         (nat.S
                                            (div_mod.div_aux q0
                                               (nat.minus m0 (nat.S n0)) n0))
                                         (nat.leb m0 n0)) (nat.S q)) n m)
                                  (nat.S m)) (y n m)))
                         (nat.sym_eq_match_nat_type_S nat.nat nat.O
                            (z:(sttfa.etap (sttfa.p nat.nat)) =>
                             bool.match_bool_type nat.nat nat.O
                               (nat.S
                                  (div_mod.div_aux z (nat.minus n (nat.S m))
                                     m)) (nat.leb n m)) q
                            (y:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq nat.nat n
                               (nat.plus (nat.times y (nat.S m))
                                  (bool.match_bool_type nat.nat n
                                     (div_mod.mod_aux q
                                        (nat.minus n (nat.S m)) m)
                                     (nat.leb n m))))
                            (nat.leb_elim n m
                               (__:(sttfa.etap (sttfa.p bool.bool)) =>
                                logic.eq nat.nat n
                                  (nat.plus
                                     (nat.times
                                        (bool.match_bool_type nat.nat nat.O
                                           (nat.S
                                              (div_mod.div_aux q
                                                 (nat.minus n (nat.S m)) m))
                                           __) (nat.S m))
                                     (bool.match_bool_type nat.nat n
                                        (div_mod.mod_aux q
                                           (nat.minus n (nat.S m)) m) __)))
                               (bool.sym_eq_match_bool_type_true nat.nat
                                  nat.O
                                  (nat.S
                                     (div_mod.div_aux q
                                        (nat.minus n (nat.S m)) m))
                                  (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                   sttfa.impl (nat.le n m)
                                     (logic.eq nat.nat n
                                        (nat.plus (nat.times x (nat.S m))
                                           (bool.match_bool_type nat.nat n
                                              (div_mod.mod_aux q
                                                 (nat.minus n (nat.S m)) m)
                                              bool.true))))
                                  (nat.sym_eq_times nat.O
                                     (y:
                                      (sttfa.etap
                                         (sttfa.p
                                            (sttfa.arrow nat.nat nat.nat))) =>
                                      sttfa.impl (nat.le n m)
                                        (logic.eq nat.nat n
                                           (nat.plus (y (nat.S m))
                                              (bool.match_bool_type nat.nat
                                                 n
                                                 (div_mod.mod_aux q
                                                    (nat.minus n (nat.S m)) m)
                                                 bool.true))))
                                     (nat.sym_eq_filter_nat_type_O
                                        (sttfa.arrow nat.nat nat.nat)
                                        nat.times_body
                                        (y:
                                         (sttfa.etap
                                            (sttfa.p
                                               (sttfa.arrow nat.nat nat.nat))) =>
                                         sttfa.impl (nat.le n m)
                                           (logic.eq nat.nat n
                                              (nat.plus (y (nat.S m))
                                                 (bool.match_bool_type
                                                    nat.nat n
                                                    (div_mod.mod_aux q
                                                       (nat.minus n (nat.S m))
                                                       m) bool.true))))
                                        (nat.sym_eq_times_body_O
                                           (y:
                                            (sttfa.etap
                                               (sttfa.p
                                                  (sttfa.arrow nat.nat
                                                     nat.nat))) =>
                                            sttfa.impl (nat.le n m)
                                              (logic.eq nat.nat n
                                                 (nat.plus (y (nat.S m))
                                                    (bool.match_bool_type
                                                       nat.nat n
                                                       (div_mod.mod_aux q
                                                          (nat.minus n
                                                             (nat.S m)) m)
                                                       bool.true))))
                                           (bool.sym_eq_match_bool_type_true
                                              nat.nat n
                                              (div_mod.mod_aux q
                                                 (nat.minus n (nat.S m)) m)
                                              (y:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               sttfa.impl (nat.le n m)
                                                 (logic.eq nat.nat n
                                                    (nat.plus nat.O y)))
                                              (nat.sym_eq_plus nat.O
                                                 (y:
                                                  (sttfa.etap
                                                     (sttfa.p
                                                        (sttfa.arrow nat.nat
                                                           nat.nat))) =>
                                                  sttfa.impl (nat.le n m)
                                                    (logic.eq nat.nat n (y n)))
                                                 (nat.sym_eq_filter_nat_type_O
                                                    (sttfa.arrow nat.nat
                                                       nat.nat)
                                                    nat.plus_body
                                                    (y:
                                                     (sttfa.etap
                                                        (sttfa.p
                                                           (sttfa.arrow
                                                              nat.nat nat.nat))) =>
                                                     sttfa.impl (nat.le n m)
                                                       (logic.eq nat.nat n
                                                          (y n)))
                                                    (nat.sym_eq_plus_body_O
                                                       (y:
                                                        (sttfa.etap
                                                           (sttfa.p
                                                              (sttfa.arrow
                                                                 nat.nat
                                                                 nat.nat))) =>
                                                        sttfa.impl
                                                          (nat.le n m)
                                                          (logic.eq nat.nat
                                                             n (y n)))
                                                       (lenm:
                                                        (sttfa.eps
                                                           (nat.le n m)) =>
                                                        logic.refl nat.nat n)))))))))
                               (bool.sym_eq_match_bool_type_false nat.nat n
                                  (div_mod.mod_aux q (nat.minus n (nat.S m))
                                     m)
                                  (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                   sttfa.impl (connectives.Not (nat.le n m))
                                     (logic.eq nat.nat n
                                        (nat.plus
                                           (nat.times
                                              (bool.match_bool_type nat.nat
                                                 nat.O
                                                 (nat.S
                                                    (div_mod.div_aux q
                                                       (nat.minus n (nat.S m))
                                                       m)) bool.false)
                                              (nat.S m)) x)))
                                  (bool.sym_eq_match_bool_type_false nat.nat
                                     nat.O
                                     (nat.S
                                        (div_mod.div_aux q
                                           (nat.minus n (nat.S m)) m))
                                     (y:(sttfa.etap (sttfa.p nat.nat)) =>
                                      sttfa.impl
                                        (connectives.Not (nat.le n m))
                                        (logic.eq nat.nat n
                                           (nat.plus (nat.times y (nat.S m))
                                              (div_mod.mod_aux q
                                                 (nat.minus n (nat.S m)) m))))
                                     (nat.sym_eq_times
                                        (nat.S
                                           (div_mod.div_aux q
                                              (nat.minus n (nat.S m)) m))
                                        (y:
                                         (sttfa.etap
                                            (sttfa.p
                                               (sttfa.arrow nat.nat nat.nat))) =>
                                         sttfa.impl
                                           (connectives.Not (nat.le n m))
                                           (logic.eq nat.nat n
                                              (nat.plus (y (nat.S m))
                                                 (div_mod.mod_aux q
                                                    (nat.minus n (nat.S m)) m))))
                                        (nat.sym_eq_filter_nat_type_S
                                           (sttfa.arrow nat.nat nat.nat)
                                           nat.times_body
                                           (div_mod.div_aux q
                                              (nat.minus n (nat.S m)) m)
                                           (y:
                                            (sttfa.etap
                                               (sttfa.p
                                                  (sttfa.arrow nat.nat
                                                     nat.nat))) =>
                                            sttfa.impl
                                              (connectives.Not (nat.le n m))
                                              (logic.eq nat.nat n
                                                 (nat.plus (y (nat.S m))
                                                    (div_mod.mod_aux q
                                                       (nat.minus n (nat.S m))
                                                       m))))
                                           (nat.sym_eq_times_body_S
                                              (div_mod.div_aux q
                                                 (nat.minus n (nat.S m)) m)
                                              (y:
                                               (sttfa.etap
                                                  (sttfa.p
                                                     (sttfa.arrow nat.nat
                                                        nat.nat))) =>
                                               sttfa.impl
                                                 (connectives.Not
                                                    (nat.le n m))
                                                 (logic.eq nat.nat n
                                                    (nat.plus (y (nat.S m))
                                                       (div_mod.mod_aux q
                                                          (nat.minus n
                                                             (nat.S m)) m))))
                                              (nat.sym_eq_plus (nat.S m)
                                                 (y:
                                                  (sttfa.etap
                                                     (sttfa.p
                                                        (sttfa.arrow nat.nat
                                                           nat.nat))) =>
                                                  sttfa.impl
                                                    (connectives.Not
                                                       (nat.le n m))
                                                    (logic.eq nat.nat n
                                                       (nat.plus
                                                          (y
                                                             (nat.times
                                                                (div_mod.div_aux
                                                                   q
                                                                   (nat.minus
                                                                    n
                                                                    (nat.S m))
                                                                   m)
                                                                (nat.S m)))
                                                          (div_mod.mod_aux q
                                                             (nat.minus n
                                                                (nat.S m)) m))))
                                                 (nat.sym_eq_filter_nat_type_S
                                                    (sttfa.arrow nat.nat
                                                       nat.nat)
                                                    nat.plus_body m
                                                    (y:
                                                     (sttfa.etap
                                                        (sttfa.p
                                                           (sttfa.arrow
                                                              nat.nat nat.nat))) =>
                                                     sttfa.impl
                                                       (connectives.Not
                                                          (nat.le n m))
                                                       (logic.eq nat.nat n
                                                          (nat.plus
                                                             (y
                                                                (nat.times
                                                                   (div_mod.div_aux
                                                                    q
                                                                    (nat.minus
                                                                    n
                                                                    (nat.S m))
                                                                    m)
                                                                   (nat.S m)))
                                                             (div_mod.mod_aux
                                                                q
                                                                (nat.minus n
                                                                   (nat.S m))
                                                                m))))
                                                    (nat.sym_eq_plus_body_S
                                                       m
                                                       (y:
                                                        (sttfa.etap
                                                           (sttfa.p
                                                              (sttfa.arrow
                                                                 nat.nat
                                                                 nat.nat))) =>
                                                        sttfa.impl
                                                          (connectives.Not
                                                             (nat.le n m))
                                                          (logic.eq nat.nat
                                                             n
                                                             (nat.plus
                                                                (y
                                                                   (nat.times
                                                                    (div_mod.div_aux
                                                                    q
                                                                    (nat.minus
                                                                    n
                                                                    (nat.S m))
                                                                    m)
                                                                    (nat.S m)))
                                                                (div_mod.mod_aux
                                                                   q
                                                                   (nat.minus
                                                                    n
                                                                    (nat.S m))
                                                                   m))))
                                                       (nat.sym_eq_plus
                                                          (nat.S
                                                             (nat.plus m
                                                                (nat.times
                                                                   (div_mod.div_aux
                                                                    q
                                                                    (nat.minus
                                                                    n
                                                                    (nat.S m))
                                                                    m)
                                                                   (nat.S m))))
                                                          (y:
                                                           (sttfa.etap
                                                              (sttfa.p
                                                                 (sttfa.arrow
                                                                    nat.nat
                                                                    nat.nat))) =>
                                                           sttfa.impl
                                                             (connectives.Not
                                                                (nat.le n m))
                                                             (logic.eq
                                                                nat.nat n
                                                                (y
                                                                   (div_mod.mod_aux
                                                                    q
                                                                    (nat.minus
                                                                    n
                                                                    (nat.S m))
                                                                    m))))
                                                          (nat.sym_eq_filter_nat_type_S
                                                             (sttfa.arrow
                                                                nat.nat
                                                                nat.nat)
                                                             nat.plus_body
                                                             (nat.plus m
                                                                (nat.times
                                                                   (div_mod.div_aux
                                                                    q
                                                                    (nat.minus
                                                                    n
                                                                    (nat.S m))
                                                                    m)
                                                                   (nat.S m)))
                                                             (y:
                                                              (sttfa.etap
                                                                 (sttfa.p
                                                                    (
                                                                    sttfa.arrow
                                                                    nat.nat
                                                                    nat.nat))) =>
                                                              sttfa.impl
                                                                (connectives.Not
                                                                   (nat.le n
                                                                    m))
                                                                (logic.eq
                                                                   nat.nat n
                                                                   (y
                                                                    (div_mod.mod_aux
                                                                    q
                                                                    (nat.minus
                                                                    n
                                                                    (nat.S m))
                                                                    m))))
                                                             (nat.sym_eq_plus_body_S
                                                                (nat.plus m
                                                                   (nat.times
                                                                    (div_mod.div_aux
                                                                    q
                                                                    (nat.minus
                                                                    n
                                                                    (nat.S m))
                                                                    m)
                                                                    (nat.S m)))
                                                                (y:
                                                                 (sttfa.etap
                                                                    (
                                                                    sttfa.p
                                                                    (sttfa.arrow
                                                                    nat.nat
                                                                    nat.nat))) =>
                                                                 sttfa.impl
                                                                   (connectives.Not
                                                                    (nat.le
                                                                    n m))
                                                                   (logic.eq
                                                                    nat.nat
                                                                    n
                                                                    (y
                                                                    (div_mod.mod_aux
                                                                    q
                                                                    (nat.minus
                                                                    n
                                                                    (nat.S m))
                                                                    m))))
                                                                (lenm:
                                                                 (sttfa.eps
                                                                    (
                                                                    connectives.Not
                                                                    (nat.le
                                                                    n m))) =>
                                                                 logic.eq_ind_r
                                                                   nat.nat
                                                                   (nat.plus
                                                                    m
                                                                    (nat.plus
                                                                    (nat.times
                                                                    (div_mod.div_aux
                                                                    q
                                                                    (nat.minus
                                                                    n
                                                                    (nat.S m))
                                                                    m)
                                                                    (nat.S m))
                                                                    (div_mod.mod_aux
                                                                    q
                                                                    (nat.minus
                                                                    n
                                                                    (nat.S m))
                                                                    m)))
                                                                   (x:
                                                                    (
                                                                    sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    n
                                                                    (nat.S x))
                                                                   (logic.eq_ind
                                                                    nat.nat
                                                                    (nat.minus
                                                                    n
                                                                    (nat.S m))
                                                                    (x_1:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    n
                                                                    (nat.S
                                                                    (nat.plus
                                                                    m x_1)))
                                                                    (logic.eq_coerc
                                                                    (logic.eq
                                                                    nat.nat
                                                                    n
                                                                    (nat.plus
                                                                    (nat.minus
                                                                    n
                                                                    (nat.S m))
                                                                    (nat.S m)))
                                                                    (logic.eq
                                                                    nat.nat
                                                                    n
                                                                    (nat.S
                                                                    (nat.plus
                                                                    m
                                                                    (nat.minus
                                                                    n
                                                                    (nat.S m)))))
                                                                    (nat.plus_minus_m_m
                                                                    n
                                                                    (nat.S m)
                                                                    (nat.not_le_to_lt
                                                                    n m lenm))
                                                                    (logic.rewrite_r
                                                                    nat.nat
                                                                    (nat.pred
                                                                    (nat.minus
                                                                    n m))
                                                                    (__:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    sttfa.bool
                                                                    (logic.eq
                                                                    nat.nat
                                                                    n
                                                                    (nat.plus
                                                                    __
                                                                    (nat.S m)))
                                                                    (logic.eq
                                                                    nat.nat
                                                                    n
                                                                    (nat.S
                                                                    (nat.plus
                                                                    m
                                                                    (nat.minus
                                                                    n
                                                                    (nat.S m))))))
                                                                    (logic.rewrite_r
                                                                    nat.nat
                                                                    (nat.pred
                                                                    (nat.minus
                                                                    n m))
                                                                    (__:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    sttfa.bool
                                                                    (logic.eq
                                                                    nat.nat
                                                                    n
                                                                    (nat.plus
                                                                    (nat.pred
                                                                    (nat.minus
                                                                    n m))
                                                                    (nat.S m)))
                                                                    (logic.eq
                                                                    nat.nat
                                                                    n
                                                                    (nat.S
                                                                    (nat.plus
                                                                    m __))))
                                                                    (logic.rewrite_r
                                                                    nat.nat
                                                                    (nat.plus
                                                                    m
                                                                    (nat.S
                                                                    (nat.pred
                                                                    (nat.minus
                                                                    n m))))
                                                                    (__:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    sttfa.bool
                                                                    (logic.eq
                                                                    nat.nat
                                                                    n
                                                                    (nat.plus
                                                                    (nat.pred
                                                                    (nat.minus
                                                                    n m))
                                                                    (nat.S m)))
                                                                    (logic.eq
                                                                    nat.nat
                                                                    n __))
                                                                    (logic.rewrite_r
                                                                    nat.nat
                                                                    (nat.plus
                                                                    m
                                                                    (nat.S
                                                                    (nat.pred
                                                                    (nat.minus
                                                                    n m))))
                                                                    (__:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    sttfa.bool
                                                                    (logic.eq
                                                                    nat.nat
                                                                    n __)
                                                                    (logic.eq
                                                                    nat.nat
                                                                    n
                                                                    (nat.plus
                                                                    m
                                                                    (nat.S
                                                                    (nat.pred
                                                                    (nat.minus
                                                                    n m))))))
                                                                    (logic.refl
                                                                    sttfa.bool
                                                                    (logic.eq
                                                                    nat.nat
                                                                    n
                                                                    (nat.plus
                                                                    m
                                                                    (nat.S
                                                                    (nat.pred
                                                                    (nat.minus
                                                                    n m))))))
                                                                    (nat.plus
                                                                    (nat.pred
                                                                    (nat.minus
                                                                    n m))
                                                                    (nat.S m))
                                                                    (logic.rewrite_l
                                                                    nat.nat
                                                                    (nat.S
                                                                    (nat.plus
                                                                    (nat.pred
                                                                    (nat.minus
                                                                    n m)) m))
                                                                    (__:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    __
                                                                    (nat.plus
                                                                    m
                                                                    (nat.S
                                                                    (nat.pred
                                                                    (nat.minus
                                                                    n m)))))
                                                                    (logic.rewrite_l
                                                                    nat.nat
                                                                    (nat.plus
                                                                    m
                                                                    (nat.pred
                                                                    (nat.minus
                                                                    n m)))
                                                                    (__:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (nat.S __)
                                                                    (nat.plus
                                                                    m
                                                                    (nat.S
                                                                    (nat.pred
                                                                    (nat.minus
                                                                    n m)))))
                                                                    (nat.plus_n_Sm
                                                                    m
                                                                    (nat.pred
                                                                    (nat.minus
                                                                    n m)))
                                                                    (nat.plus
                                                                    (nat.pred
                                                                    (nat.minus
                                                                    n m)) m)
                                                                    (nat.commutative_plus
                                                                    m
                                                                    (nat.pred
                                                                    (nat.minus
                                                                    n m))))
                                                                    (nat.plus
                                                                    (nat.pred
                                                                    (nat.minus
                                                                    n m))
                                                                    (nat.S m))
                                                                    (nat.plus_n_Sm
                                                                    (nat.pred
                                                                    (nat.minus
                                                                    n m)) m)))
                                                                    (nat.S
                                                                    (nat.plus
                                                                    m
                                                                    (nat.pred
                                                                    (nat.minus
                                                                    n m))))
                                                                    (nat.plus_n_Sm
                                                                    m
                                                                    (nat.pred
                                                                    (nat.minus
                                                                    n m))))
                                                                    (nat.minus
                                                                    n
                                                                    (nat.S m))
                                                                    (nat.eq_minus_S_pred
                                                                    n m))
                                                                    (nat.minus
                                                                    n
                                                                    (nat.S m))
                                                                    (nat.eq_minus_S_pred
                                                                    n m)))
                                                                    (nat.plus
                                                                    (nat.times
                                                                    (div_mod.div_aux
                                                                    q
                                                                    (nat.minus
                                                                    n
                                                                    (nat.S m))
                                                                    m)
                                                                    (nat.S m))
                                                                    (div_mod.mod_aux
                                                                    q
                                                                    (nat.minus
                                                                    n
                                                                    (nat.S m))
                                                                    m))
                                                                    (Hind
                                                                    (nat.minus
                                                                    n
                                                                    (nat.S m))
                                                                    m))
                                                                   (nat.plus
                                                                    (nat.plus
                                                                    m
                                                                    (nat.times
                                                                    (div_mod.div_aux
                                                                    q
                                                                    (nat.minus
                                                                    n
                                                                    (nat.S m))
                                                                    m)
                                                                    (nat.S m)))
                                                                    (div_mod.mod_aux
                                                                    q
                                                                    (nat.minus
                                                                    n
                                                                    (nat.S m))
                                                                    m))
                                                                   (nat.associative_plus
                                                                    m
                                                                    (nat.times
                                                                    (div_mod.div_aux
                                                                    q
                                                                    (nat.minus
                                                                    n
                                                                    (nat.S m))
                                                                    m)
                                                                    (nat.S m))
                                                                    (div_mod.mod_aux
                                                                    q
                                                                    (nat.minus
                                                                    n
                                                                    (nat.S m))
                                                                    m)))))))))))))))))))))))
    p.

def div_mod :
  sttfa.eps
    (sttfa.forall nat.nat
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat n
             (nat.plus (nat.times (div_mod.div n m) m) (div_mod.mod n m)))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.match_nat_prop
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq nat.nat n
       (nat.plus (nat.times (div_mod.div n __) __) (div_mod.mod n __)))
    (nat.sym_eq_times (div_mod.div n nat.O)
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        logic.eq nat.nat n (nat.plus (y nat.O) (div_mod.mod n nat.O)))
       (nat.sym_eq_match_nat_type_O nat.nat (nat.S n)
          (p:(sttfa.etap (sttfa.p nat.nat)) => div_mod.div_aux n n p)
          (y:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat n
             (nat.plus
                (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat)
                   nat.times_body y nat.O)
                (nat.match_nat_type nat.nat n
                   (p:(sttfa.etap (sttfa.p nat.nat)) => div_mod.mod_aux n n p)
                   nat.O)))
          (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat)
             nat.times_body n
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              logic.eq nat.nat n (nat.plus (y nat.O) (div_mod.mod n nat.O)))
             (nat.sym_eq_times_body_S n
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 logic.eq nat.nat n
                   (nat.plus (y nat.O) (div_mod.mod n nat.O)))
                (nat.sym_eq_match_nat_type_O nat.nat n
                   (p:(sttfa.etap (sttfa.p nat.nat)) => div_mod.mod_aux n n p)
                   (y:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat n
                      (nat.plus (nat.plus nat.O (nat.times n nat.O)) y))
                   (nat.sym_eq_plus nat.O
                      (y:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       logic.eq nat.nat n
                         (nat.plus (y (nat.times n nat.O)) n))
                      (nat.sym_eq_filter_nat_type_O
                         (sttfa.arrow nat.nat nat.nat) nat.plus_body
                         (y:
                          (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                          logic.eq nat.nat n
                            (nat.plus (y (nat.times n nat.O)) n))
                         (nat.sym_eq_plus_body_O
                            (y:
                             (sttfa.etap
                                (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                             logic.eq nat.nat n
                               (nat.plus (y (nat.times n nat.O)) n))
                            (logic.rewrite_l nat.nat nat.O
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq nat.nat n (nat.plus __ n))
                               (logic.rewrite_r nat.nat (nat.plus n nat.O)
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq nat.nat n __)
                                  (logic.rewrite_l nat.nat n
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq nat.nat n __)
                                     (logic.refl nat.nat n)
                                     (nat.plus n nat.O) (nat.plus_n_O n))
                                  (nat.plus nat.O n)
                                  (nat.commutative_plus nat.O n))
                               (nat.times n nat.O) (nat.times_n_O n))))))))))
    (auto:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_match_nat_type_S nat.nat (nat.S n)
       (p:(sttfa.etap (sttfa.p nat.nat)) => div_mod.div_aux n n p) auto
       (y:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat n
          (nat.plus (nat.times y (nat.S auto))
             (nat.match_nat_type nat.nat n
                (p:(sttfa.etap (sttfa.p nat.nat)) => div_mod.mod_aux n n p)
                (nat.S auto))))
       (nat.sym_eq_match_nat_type_S nat.nat n
          (p:(sttfa.etap (sttfa.p nat.nat)) => div_mod.mod_aux n n p) auto
          (y:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat n
             (nat.plus (nat.times (div_mod.div_aux n n auto) (nat.S auto)) y))
          (logic.rewrite_r nat.nat
             (nat.plus (nat.times (div_mod.div_aux n n auto) (nat.S auto))
                (div_mod.mod_aux n n auto))
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat __
                (nat.plus
                   (nat.times (div_mod.div_aux n n auto) (nat.S auto))
                   (div_mod.mod_aux n n auto)))
             (logic.refl nat.nat
                (nat.plus
                   (nat.times (div_mod.div_aux n n auto) (nat.S auto))
                   (div_mod.mod_aux n n auto))) n
             (div_mod.div_aux_mod_aux n n auto)))) m.

def eq_times_div_minus_mod :
  sttfa.eps
    (sttfa.forall nat.nat
       (a:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (b:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat (nat.times (div_mod.div a b) b)
             (nat.minus a (div_mod.mod a b)))))
  :=
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.eq_coerc
    (logic.eq nat.nat (nat.times b (div_mod.div a b))
       (nat.minus
          (nat.plus (nat.times b (div_mod.div a b)) (div_mod.mod a b))
          (div_mod.mod a b)))
    (logic.eq nat.nat (nat.times (div_mod.div a b) b)
       (nat.minus a (div_mod.mod a b)))
    (nat.minus_plus_m_m (nat.times b (div_mod.div a b)) (div_mod.mod a b))
    (logic.rewrite_r nat.nat
       (nat.plus (div_mod.mod a b) (nat.times b (div_mod.div a b)))
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq sttfa.bool
          (logic.eq nat.nat (nat.times b (div_mod.div a b))
             (nat.minus __ (div_mod.mod a b)))
          (logic.eq nat.nat (nat.times (div_mod.div a b) b)
             (nat.minus a (div_mod.mod a b))))
       (logic.rewrite_r nat.nat (nat.times b (div_mod.div a b))
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq sttfa.bool
             (logic.eq nat.nat (nat.times b (div_mod.div a b))
                (nat.minus
                   (nat.plus (div_mod.mod a b)
                      (nat.times b (div_mod.div a b))) (div_mod.mod a b)))
             (logic.eq nat.nat __ (nat.minus a (div_mod.mod a b))))
          (logic.rewrite_l nat.nat a
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq sttfa.bool
                (logic.eq nat.nat (nat.times b (div_mod.div a b))
                   (nat.minus __ (div_mod.mod a b)))
                (logic.eq nat.nat (nat.times b (div_mod.div a b))
                   (nat.minus a (div_mod.mod a b))))
             (logic.refl sttfa.bool
                (logic.eq nat.nat (nat.times b (div_mod.div a b))
                   (nat.minus a (div_mod.mod a b))))
             (nat.plus (div_mod.mod a b) (nat.times b (div_mod.div a b)))
             (logic.rewrite_l nat.nat
                (nat.plus (nat.times b (div_mod.div a b)) (div_mod.mod a b))
                (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat a __)
                (logic.rewrite_l nat.nat (nat.times (div_mod.div a b) b)
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat a (nat.plus __ (div_mod.mod a b)))
                   (div_mod.div_mod a b) (nat.times b (div_mod.div a b))
                   (nat.commutative_times (div_mod.div a b) b))
                (nat.plus (div_mod.mod a b) (nat.times b (div_mod.div a b)))
                (nat.commutative_plus (nat.times b (div_mod.div a b))
                   (div_mod.mod a b)))) (nat.times (div_mod.div a b) b)
          (nat.commutative_times (div_mod.div a b) b))
       (nat.plus (nat.times b (div_mod.div a b)) (div_mod.mod a b))
       (nat.commutative_plus (nat.times b (div_mod.div a b))
          (div_mod.mod a b))).

div_mod_spec :
  sttfa.etap
    (sttfa.p
       (sttfa.arrow nat.nat
          (sttfa.arrow nat.nat
             (sttfa.arrow nat.nat (sttfa.arrow nat.nat sttfa.bool))))).

div_mod_spec_intro :
  sttfa.eps
    (sttfa.forall nat.nat
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat
             (q:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat
                (r:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (nat.lt r m)
                   (sttfa.impl
                      (logic.eq nat.nat n (nat.plus (nat.times q m) r))
                      (div_mod.div_mod_spec n m q r))))))).

match_div_mod_spec_prop :
  sttfa.eps
    (sttfa.forall nat.nat
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat
             (q:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat
                (r:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall sttfa.bool
                   (return:(sttfa.etap (sttfa.p sttfa.bool)) =>
                    sttfa.impl
                      (sttfa.impl (nat.lt r m)
                         (sttfa.impl
                            (logic.eq nat.nat n (nat.plus (nat.times q m) r))
                            return))
                      (sttfa.impl (div_mod.div_mod_spec n m q r) return))))))).

def div_mod_spec_div_mod :
  sttfa.eps
    (sttfa.forall nat.nat
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.lt nat.O m)
             (div_mod.div_mod_spec n m (div_mod.div n m) (div_mod.mod n m)))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  posm:(sttfa.eps (nat.lt nat.O m)) =>
  div_mod.div_mod_spec_intro n m (div_mod.div n m) (div_mod.mod n m)
    (div_mod.lt_mod_m_m n m posm)
    (logic.rewrite_r nat.nat (nat.times m (div_mod.div n m))
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat n (nat.plus __ (div_mod.mod n m)))
       (logic.rewrite_r nat.nat
          (nat.plus (div_mod.mod n m) (nat.times m (div_mod.div n m)))
          (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat n __)
          (logic.rewrite_l nat.nat n
             (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat n __)
             (logic.refl nat.nat n)
             (nat.plus (div_mod.mod n m) (nat.times m (div_mod.div n m)))
             (logic.rewrite_l nat.nat
                (nat.plus (nat.times m (div_mod.div n m)) (div_mod.mod n m))
                (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat n __)
                (logic.rewrite_l nat.nat (nat.times (div_mod.div n m) m)
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat n (nat.plus __ (div_mod.mod n m)))
                   (div_mod.div_mod n m) (nat.times m (div_mod.div n m))
                   (nat.commutative_times (div_mod.div n m) m))
                (nat.plus (div_mod.mod n m) (nat.times m (div_mod.div n m)))
                (nat.commutative_plus (nat.times m (div_mod.div n m))
                   (div_mod.mod n m))))
          (nat.plus (nat.times m (div_mod.div n m)) (div_mod.mod n m))
          (nat.commutative_plus (nat.times m (div_mod.div n m))
             (div_mod.mod n m))) (nat.times (div_mod.div n m) m)
       (nat.commutative_times (div_mod.div n m) m)).

def let_clause_1078 :
  sttfa.eps
    (sttfa.forall nat.nat
       (a:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (b:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat
             (q:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat
                (r:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall nat.nat
                   (q1:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.forall nat.nat
                      (r1:(sttfa.etap (sttfa.p nat.nat)) =>
                       sttfa.impl (div_mod.div_mod_spec a b q r)
                         (sttfa.impl (nat.lt r b)
                            (sttfa.impl
                               (logic.eq nat.nat a
                                  (nat.plus (nat.times q b) r))
                               (sttfa.impl (div_mod.div_mod_spec a b q1 r1)
                                  (sttfa.impl (nat.lt r1 b)
                                     (sttfa.impl
                                        (logic.eq nat.nat a
                                           (nat.plus (nat.times q1 b) r1))
                                        (sttfa.impl (nat.le q q1)
                                           (sttfa.impl (nat.lt q q1)
                                              (logic.eq nat.nat a
                                                 (nat.plus r (nat.times b q)))))))))))))))))
  :=
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  q:(sttfa.etap (sttfa.p nat.nat)) =>
  r:(sttfa.etap (sttfa.p nat.nat)) =>
  q1:(sttfa.etap (sttfa.p nat.nat)) =>
  r1:(sttfa.etap (sttfa.p nat.nat)) =>
  _clearme:(sttfa.eps (div_mod.div_mod_spec a b q r)) =>
  ltrb:(sttfa.eps (nat.lt r b)) =>
  spec:(sttfa.eps (logic.eq nat.nat a (nat.plus (nat.times q b) r))) =>
  _clearme0:(sttfa.eps (div_mod.div_mod_spec a b q1 r1)) =>
  ltr1b:(sttfa.eps (nat.lt r1 b)) =>
  spec1:(sttfa.eps (logic.eq nat.nat a (nat.plus (nat.times q1 b) r1))) =>
  leqq1:(sttfa.eps (nat.le q q1)) =>
  ltqq1:(sttfa.eps (nat.lt q q1)) =>
  logic.rewrite_l nat.nat (nat.plus (nat.times b q) r)
    (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat a __)
    (logic.rewrite_l nat.nat (nat.times q b)
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat a (nat.plus __ r)) spec (nat.times b q)
       (nat.commutative_times q b)) (nat.plus r (nat.times b q))
    (nat.commutative_plus (nat.times b q) r).

def let_clause_1062 :
  sttfa.eps
    (sttfa.forall nat.nat
       (a:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (b:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat
             (q:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat
                (r:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall nat.nat
                   (q1:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.forall nat.nat
                      (r1:(sttfa.etap (sttfa.p nat.nat)) =>
                       sttfa.impl (div_mod.div_mod_spec a b q r)
                         (sttfa.impl (nat.lt r b)
                            (sttfa.impl
                               (logic.eq nat.nat a
                                  (nat.plus (nat.times q b) r))
                               (sttfa.impl (div_mod.div_mod_spec a b q1 r1)
                                  (sttfa.impl (nat.lt r1 b)
                                     (sttfa.impl
                                        (logic.eq nat.nat a
                                           (nat.plus (nat.times q1 b) r1))
                                        (sttfa.impl
                                           (connectives.Not (nat.le q q1))
                                           (logic.eq nat.nat a
                                              (nat.plus r1 (nat.times b q1))))))))))))))))
  :=
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  q:(sttfa.etap (sttfa.p nat.nat)) =>
  r:(sttfa.etap (sttfa.p nat.nat)) =>
  q1:(sttfa.etap (sttfa.p nat.nat)) =>
  r1:(sttfa.etap (sttfa.p nat.nat)) =>
  _clearme:(sttfa.eps (div_mod.div_mod_spec a b q r)) =>
  ltrb:(sttfa.eps (nat.lt r b)) =>
  spec:(sttfa.eps (logic.eq nat.nat a (nat.plus (nat.times q b) r))) =>
  _clearme0:(sttfa.eps (div_mod.div_mod_spec a b q1 r1)) =>
  ltr1b:(sttfa.eps (nat.lt r1 b)) =>
  spec1:(sttfa.eps (logic.eq nat.nat a (nat.plus (nat.times q1 b) r1))) =>
  leqq1:(sttfa.eps (connectives.Not (nat.le q q1))) =>
  logic.rewrite_l nat.nat (nat.plus (nat.times b q1) r1)
    (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat a __)
    (logic.rewrite_l nat.nat (nat.times q1 b)
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat a (nat.plus __ r1)) spec1 (nat.times b q1)
       (nat.commutative_times q1 b)) (nat.plus r1 (nat.times b q1))
    (nat.commutative_plus (nat.times b q1) r1).

def div_mod_spec_to_eq :
  sttfa.eps
    (sttfa.forall nat.nat
       (a:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (b:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat
             (q:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat
                (r:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall nat.nat
                   (q1:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.forall nat.nat
                      (r1:(sttfa.etap (sttfa.p nat.nat)) =>
                       sttfa.impl (div_mod.div_mod_spec a b q r)
                         (sttfa.impl (div_mod.div_mod_spec a b q1 r1)
                            (logic.eq nat.nat q q1)))))))))
  :=
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  q:(sttfa.etap (sttfa.p nat.nat)) =>
  r:(sttfa.etap (sttfa.p nat.nat)) =>
  q1:(sttfa.etap (sttfa.p nat.nat)) =>
  r1:(sttfa.etap (sttfa.p nat.nat)) =>
  _clearme:(sttfa.eps (div_mod.div_mod_spec a b q r)) =>
  div_mod.match_div_mod_spec_prop a b q r
    (sttfa.impl (div_mod.div_mod_spec a b q1 r1) (logic.eq nat.nat q q1))
    (ltrb:(sttfa.eps (nat.lt r b)) =>
     spec:(sttfa.eps (logic.eq nat.nat a (nat.plus (nat.times q b) r))) =>
     _clearme0:(sttfa.eps (div_mod.div_mod_spec a b q1 r1)) =>
     div_mod.match_div_mod_spec_prop a b q1 r1 (logic.eq nat.nat q q1)
       (ltr1b:(sttfa.eps (nat.lt r1 b)) =>
        spec1:
        (sttfa.eps (logic.eq nat.nat a (nat.plus (nat.times q1 b) r1))) =>
        nat.leb_elim q q1
          (__:(sttfa.etap (sttfa.p bool.bool)) => logic.eq nat.nat q q1)
          (leqq1:(sttfa.eps (nat.le q q1)) =>
           connectives.match_Or_prop (nat.lt q q1) (logic.eq nat.nat q q1)
             (logic.eq nat.nat q q1)
             (ltqq1:(sttfa.eps (nat.lt q q1)) =>
              connectives.falsity (logic.eq nat.nat q q1)
                (logic.absurd (nat.le (nat.S a) a)
                   (nat.lt_to_le_to_lt a (nat.times (nat.S q) b) a
                      (logic.eq_ind_r nat.nat (nat.plus (nat.times q b) r)
                         (x:(sttfa.etap (sttfa.p nat.nat)) =>
                          nat.lt x (nat.times (nat.S q) b))
                         (logic.eq_coerc
                            (nat.lt (nat.plus (nat.times q b) r)
                               (nat.plus (nat.times q b) b))
                            (nat.lt (nat.plus (nat.times q b) r)
                               (nat.times (nat.S q) b))
                            (nat.monotonic_lt_plus_r (nat.times q b) r b ltrb)
                            (logic.rewrite_r nat.nat (nat.times b q)
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq sttfa.bool
                                  (nat.lt (nat.plus __ r) (nat.plus __ b))
                                  (nat.lt (nat.plus __ r)
                                     (nat.times (nat.S q) b)))
                               (logic.rewrite_r nat.nat
                                  (nat.plus r (nat.times b q))
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq sttfa.bool
                                     (nat.lt (nat.plus (nat.times b q) r)
                                        (nat.plus (nat.times b q) b))
                                     (nat.lt __ (nat.times (nat.S q) b)))
                                  (logic.rewrite_l nat.nat a
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq sttfa.bool
                                        (nat.lt (nat.plus (nat.times b q) r)
                                           (nat.plus (nat.times b q) b))
                                        (nat.lt __ (nat.times (nat.S q) b)))
                                     (logic.rewrite_r nat.nat
                                        (nat.times b (nat.S q))
                                        (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq sttfa.bool
                                           (nat.lt
                                              (nat.plus (nat.times b q) r)
                                              (nat.plus (nat.times b q) b))
                                           (nat.lt a __))
                                        (logic.rewrite_l nat.nat
                                           (nat.plus b (nat.times b q))
                                           (__:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq sttfa.bool
                                              (nat.lt
                                                 (nat.plus (nat.times b q) r)
                                                 (nat.plus (nat.times b q) b))
                                              (nat.lt a __))
                                           (logic.rewrite_r nat.nat
                                              (nat.plus r (nat.times b q))
                                              (__:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq sttfa.bool
                                                 (nat.lt __
                                                    (nat.plus
                                                       (nat.times b q) b))
                                                 (nat.lt a
                                                    (nat.plus b
                                                       (nat.times b q))))
                                              (logic.rewrite_l nat.nat a
                                                 (__:
                                                  (sttfa.etap
                                                     (sttfa.p nat.nat)) =>
                                                  logic.eq sttfa.bool
                                                    (nat.lt __
                                                       (nat.plus
                                                          (nat.times b q) b))
                                                    (nat.lt a
                                                       (nat.plus b
                                                          (nat.times b q))))
                                                 (logic.rewrite_r nat.nat
                                                    (nat.plus b
                                                       (nat.times b q))
                                                    (__:
                                                     (sttfa.etap
                                                        (sttfa.p nat.nat)) =>
                                                     logic.eq sttfa.bool
                                                       (nat.lt a __)
                                                       (nat.lt a
                                                          (nat.plus b
                                                             (nat.times b q))))
                                                    (logic.refl sttfa.bool
                                                       (nat.lt a
                                                          (nat.plus b
                                                             (nat.times b q))))
                                                    (nat.plus
                                                       (nat.times b q) b)
                                                    (nat.commutative_plus
                                                       (nat.times b q) b))
                                                 (nat.plus r (nat.times b q))
                                                 (div_mod.let_clause_1078 a
                                                    b q r q1 r1 _clearme
                                                    ltrb spec _clearme0
                                                    ltr1b spec1 leqq1 ltqq1))
                                              (nat.plus (nat.times b q) r)
                                              (nat.commutative_plus
                                                 (nat.times b q) r))
                                           (nat.times b (nat.S q))
                                           (nat.times_n_Sm b q))
                                        (nat.times (nat.S q) b)
                                        (nat.commutative_times (nat.S q) b))
                                     (nat.plus r (nat.times b q))
                                     (div_mod.let_clause_1078 a b q r q1 r1
                                        _clearme ltrb spec _clearme0 ltr1b
                                        spec1 leqq1 ltqq1))
                                  (nat.plus (nat.times b q) r)
                                  (nat.commutative_plus (nat.times b q) r))
                               (nat.times q b) (nat.commutative_times q b)))
                         a spec)
                      (nat.transitive_le (nat.times (nat.S q) b)
                         (nat.times q1 b) a
                         (logic.eq_coerc
                            (nat.le (nat.times b (nat.S q)) (nat.times b q1))
                            (nat.le (nat.times (nat.S q) b) (nat.times q1 b))
                            (nat.monotonic_le_times_r b (nat.S q) q1 ltqq1)
                            (logic.rewrite_r nat.nat (nat.times b (nat.S q))
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq sttfa.bool
                                  (nat.le (nat.times b (nat.S q))
                                     (nat.times b q1))
                                  (nat.le __ (nat.times q1 b)))
                               (logic.rewrite_l nat.nat
                                  (nat.plus b (nat.times b q))
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq sttfa.bool
                                     (nat.le (nat.times b (nat.S q))
                                        (nat.times b q1))
                                     (nat.le __ (nat.times q1 b)))
                                  (logic.rewrite_r nat.nat (nat.times b q1)
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq sttfa.bool
                                        (nat.le (nat.times b (nat.S q))
                                           (nat.times b q1))
                                        (nat.le (nat.plus b (nat.times b q))
                                           __))
                                     (logic.rewrite_l nat.nat
                                        (nat.plus b (nat.times b q))
                                        (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq sttfa.bool
                                           (nat.le __ (nat.times b q1))
                                           (nat.le
                                              (nat.plus b (nat.times b q))
                                              (nat.times b q1)))
                                        (logic.refl sttfa.bool
                                           (nat.le
                                              (nat.plus b (nat.times b q))
                                              (nat.times b q1)))
                                        (nat.times b (nat.S q))
                                        (nat.times_n_Sm b q))
                                     (nat.times q1 b)
                                     (nat.commutative_times q1 b))
                                  (nat.times b (nat.S q))
                                  (nat.times_n_Sm b q))
                               (nat.times (nat.S q) b)
                               (nat.commutative_times (nat.S q) b)))
                         (logic.eq_coerc
                            (nat.le (nat.times q1 b)
                               (nat.plus (nat.times q1 b) r1))
                            (nat.le (nat.times q1 b) a)
                            (nat.le_plus_n_r r1 (nat.times q1 b))
                            (logic.rewrite_r nat.nat (nat.times b q1)
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq sttfa.bool
                                  (nat.le __ (nat.plus __ r1)) (nat.le __ a))
                               (logic.rewrite_r nat.nat
                                  (nat.plus r1 (nat.times b q1))
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq sttfa.bool
                                     (nat.le (nat.times b q1) __)
                                     (nat.le (nat.times b q1) a))
                                  (logic.rewrite_l nat.nat a
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq sttfa.bool
                                        (nat.le (nat.times b q1) __)
                                        (nat.le (nat.times b q1) a))
                                     (logic.refl sttfa.bool
                                        (nat.le (nat.times b q1) a))
                                     (nat.plus r1 (nat.times b q1))
                                     (logic.rewrite_l nat.nat
                                        (nat.plus (nat.times b q1) r1)
                                        (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq nat.nat a __)
                                        (logic.rewrite_l nat.nat
                                           (nat.times q1 b)
                                           (__:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq nat.nat a
                                              (nat.plus __ r1)) spec1
                                           (nat.times b q1)
                                           (nat.commutative_times q1 b))
                                        (nat.plus r1 (nat.times b q1))
                                        (nat.commutative_plus
                                           (nat.times b q1) r1)))
                                  (nat.plus (nat.times b q1) r1)
                                  (nat.commutative_plus (nat.times b q1) r1))
                               (nat.times q1 b) (nat.commutative_times q1 b)))))
                   (nat.not_le_Sn_n a)))
             (_x_172:(sttfa.eps (logic.eq nat.nat q q1)) =>
              logic.rewrite_l nat.nat q
                (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat q __)
                (logic.refl nat.nat q) q1 _x_172)
             (nat.le_to_or_lt_eq q q1 leqq1))
          (leqq1:(sttfa.eps (connectives.Not (nat.le q q1))) =>
           connectives.falsity (logic.eq nat.nat q q1)
             (logic.absurd (nat.le (nat.S a) a)
                (nat.lt_to_le_to_lt a (nat.times (nat.S q1) b) a
                   (logic.eq_ind_r nat.nat (nat.plus (nat.times q1 b) r1)
                      (x:(sttfa.etap (sttfa.p nat.nat)) =>
                       nat.lt x (nat.times (nat.S q1) b))
                      (logic.eq_coerc
                         (nat.lt (nat.plus (nat.times q1 b) r1)
                            (nat.plus (nat.times q1 b) b))
                         (nat.lt (nat.plus (nat.times q1 b) r1)
                            (nat.times (nat.S q1) b))
                         (nat.monotonic_lt_plus_r (nat.times q1 b) r1 b ltr1b)
                         (logic.rewrite_r nat.nat (nat.times b q1)
                            (__:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq sttfa.bool
                               (nat.lt (nat.plus __ r1) (nat.plus __ b))
                               (nat.lt (nat.plus __ r1)
                                  (nat.times (nat.S q1) b)))
                            (logic.rewrite_r nat.nat
                               (nat.plus r1 (nat.times b q1))
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq sttfa.bool
                                  (nat.lt (nat.plus (nat.times b q1) r1)
                                     (nat.plus (nat.times b q1) b))
                                  (nat.lt __ (nat.times (nat.S q1) b)))
                               (logic.rewrite_l nat.nat a
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq sttfa.bool
                                     (nat.lt (nat.plus (nat.times b q1) r1)
                                        (nat.plus (nat.times b q1) b))
                                     (nat.lt __ (nat.times (nat.S q1) b)))
                                  (logic.rewrite_r nat.nat
                                     (nat.times b (nat.S q1))
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq sttfa.bool
                                        (nat.lt
                                           (nat.plus (nat.times b q1) r1)
                                           (nat.plus (nat.times b q1) b))
                                        (nat.lt a __))
                                     (logic.rewrite_l nat.nat
                                        (nat.plus b (nat.times b q1))
                                        (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq sttfa.bool
                                           (nat.lt
                                              (nat.plus (nat.times b q1) r1)
                                              (nat.plus (nat.times b q1) b))
                                           (nat.lt a __))
                                        (logic.rewrite_r nat.nat
                                           (nat.plus r1 (nat.times b q1))
                                           (__:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq sttfa.bool
                                              (nat.lt __
                                                 (nat.plus (nat.times b q1) b))
                                              (nat.lt a
                                                 (nat.plus b (nat.times b q1))))
                                           (logic.rewrite_l nat.nat a
                                              (__:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq sttfa.bool
                                                 (nat.lt __
                                                    (nat.plus
                                                       (nat.times b q1) b))
                                                 (nat.lt a
                                                    (nat.plus b
                                                       (nat.times b q1))))
                                              (logic.rewrite_r nat.nat
                                                 (nat.plus b (nat.times b q1))
                                                 (__:
                                                  (sttfa.etap
                                                     (sttfa.p nat.nat)) =>
                                                  logic.eq sttfa.bool
                                                    (nat.lt a __)
                                                    (nat.lt a
                                                       (nat.plus b
                                                          (nat.times b q1))))
                                                 (logic.refl sttfa.bool
                                                    (nat.lt a
                                                       (nat.plus b
                                                          (nat.times b q1))))
                                                 (nat.plus (nat.times b q1) b)
                                                 (nat.commutative_plus
                                                    (nat.times b q1) b))
                                              (nat.plus r1 (nat.times b q1))
                                              (div_mod.let_clause_1062 a b q
                                                 r q1 r1 _clearme ltrb spec
                                                 _clearme0 ltr1b spec1 leqq1))
                                           (nat.plus (nat.times b q1) r1)
                                           (nat.commutative_plus
                                              (nat.times b q1) r1))
                                        (nat.times b (nat.S q1))
                                        (nat.times_n_Sm b q1))
                                     (nat.times (nat.S q1) b)
                                     (nat.commutative_times (nat.S q1) b))
                                  (nat.plus r1 (nat.times b q1))
                                  (div_mod.let_clause_1062 a b q r q1 r1
                                     _clearme ltrb spec _clearme0 ltr1b
                                     spec1 leqq1))
                               (nat.plus (nat.times b q1) r1)
                               (nat.commutative_plus (nat.times b q1) r1))
                            (nat.times q1 b) (nat.commutative_times q1 b)))
                      a spec1)
                   (nat.transitive_le (nat.times (nat.S q1) b)
                      (nat.times q b) a
                      (logic.eq_coerc
                         (nat.le (nat.times b (nat.S q1)) (nat.times b q))
                         (nat.le (nat.times (nat.S q1) b) (nat.times q b))
                         (nat.monotonic_le_times_r b (nat.S q1) q
                            (nat.not_le_to_lt q q1 leqq1))
                         (logic.rewrite_r nat.nat (nat.times b (nat.S q1))
                            (__:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq sttfa.bool
                               (nat.le (nat.times b (nat.S q1))
                                  (nat.times b q))
                               (nat.le __ (nat.times q b)))
                            (logic.rewrite_l nat.nat
                               (nat.plus b (nat.times b q1))
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq sttfa.bool
                                  (nat.le (nat.times b (nat.S q1))
                                     (nat.times b q))
                                  (nat.le __ (nat.times q b)))
                               (logic.rewrite_r nat.nat (nat.times b q)
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq sttfa.bool
                                     (nat.le (nat.times b (nat.S q1))
                                        (nat.times b q))
                                     (nat.le (nat.plus b (nat.times b q1)) __))
                                  (logic.rewrite_l nat.nat
                                     (nat.plus b (nat.times b q1))
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq sttfa.bool
                                        (nat.le __ (nat.times b q))
                                        (nat.le
                                           (nat.plus b (nat.times b q1))
                                           (nat.times b q)))
                                     (logic.refl sttfa.bool
                                        (nat.le
                                           (nat.plus b (nat.times b q1))
                                           (nat.times b q)))
                                     (nat.times b (nat.S q1))
                                     (nat.times_n_Sm b q1)) (nat.times q b)
                                  (nat.commutative_times q b))
                               (nat.times b (nat.S q1)) (nat.times_n_Sm b q1))
                            (nat.times (nat.S q1) b)
                            (nat.commutative_times (nat.S q1) b)))
                      (logic.eq_coerc
                         (nat.le (nat.times q b) (nat.plus (nat.times q b) r))
                         (nat.le (nat.times q b) a)
                         (nat.le_plus_n_r r (nat.times q b))
                         (logic.rewrite_r nat.nat (nat.times b q)
                            (__:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq sttfa.bool (nat.le __ (nat.plus __ r))
                               (nat.le __ a))
                            (logic.rewrite_r nat.nat
                               (nat.plus r (nat.times b q))
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq sttfa.bool
                                  (nat.le (nat.times b q) __)
                                  (nat.le (nat.times b q) a))
                               (logic.rewrite_l nat.nat a
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq sttfa.bool
                                     (nat.le (nat.times b q) __)
                                     (nat.le (nat.times b q) a))
                                  (logic.refl sttfa.bool
                                     (nat.le (nat.times b q) a))
                                  (nat.plus r (nat.times b q))
                                  (logic.rewrite_l nat.nat
                                     (nat.plus (nat.times b q) r)
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq nat.nat a __)
                                     (logic.rewrite_l nat.nat
                                        (nat.times q b)
                                        (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq nat.nat a (nat.plus __ r))
                                        spec (nat.times b q)
                                        (nat.commutative_times q b))
                                     (nat.plus r (nat.times b q))
                                     (nat.commutative_plus (nat.times b q) r)))
                               (nat.plus (nat.times b q) r)
                               (nat.commutative_plus (nat.times b q) r))
                            (nat.times q b) (nat.commutative_times q b)))))
                (nat.not_le_Sn_n a)))) _clearme0) _clearme.

def div_mod_spec_to_eq2 :
  sttfa.eps
    (sttfa.forall nat.nat
       (a:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (b:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat
             (q:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat
                (r:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall nat.nat
                   (q1:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.forall nat.nat
                      (r1:(sttfa.etap (sttfa.p nat.nat)) =>
                       sttfa.impl (div_mod.div_mod_spec a b q r)
                         (sttfa.impl (div_mod.div_mod_spec a b q1 r1)
                            (logic.eq nat.nat r r1)))))))))
  :=
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  q:(sttfa.etap (sttfa.p nat.nat)) =>
  r:(sttfa.etap (sttfa.p nat.nat)) =>
  q1:(sttfa.etap (sttfa.p nat.nat)) =>
  r1:(sttfa.etap (sttfa.p nat.nat)) =>
  spec:(sttfa.eps (div_mod.div_mod_spec a b q r)) =>
  spec1:(sttfa.eps (div_mod.div_mod_spec a b q1 r1)) =>
  div_mod.match_div_mod_spec_prop a b q r (logic.eq nat.nat r r1)
    (__:(sttfa.eps (nat.lt r b)) =>
     eqa:(sttfa.eps (logic.eq nat.nat a (nat.plus (nat.times q b) r))) =>
     div_mod.match_div_mod_spec_prop a b q1 r1 (logic.eq nat.nat r r1)
       (_0:(sttfa.eps (nat.lt r1 b)) =>
        eqa1:
        (sttfa.eps (logic.eq nat.nat a (nat.plus (nat.times q1 b) r1))) =>
        nat.injective_plus_r (nat.times q b) r r1
          (logic.rewrite_r nat.nat (nat.times b q)
             (__1:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat (nat.plus __1 r) (nat.plus (nat.times q b) r1))
             (logic.rewrite_r nat.nat (nat.plus r (nat.times b q))
                (__1:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat __1 (nat.plus (nat.times q b) r1))
                (logic.rewrite_l nat.nat a
                   (__1:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat __1 (nat.plus (nat.times q b) r1))
                   (logic.rewrite_r nat.nat (nat.times b q)
                      (__1:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat a (nat.plus __1 r1))
                      (logic.rewrite_r nat.nat (nat.plus r1 (nat.times b q))
                         (__1:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat a __1)
                         (logic.rewrite_l nat.nat a
                            (__1:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq nat.nat a __1) (logic.refl nat.nat a)
                            (nat.plus r1 (nat.times b q))
                            (logic.rewrite_r nat.nat q1
                               (__1:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq nat.nat a
                                  (nat.plus r1 (nat.times b __1)))
                               (logic.rewrite_l nat.nat
                                  (nat.plus (nat.times b q1) r1)
                                  (__1:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq nat.nat a __1)
                                  (logic.rewrite_l nat.nat (nat.times q1 b)
                                     (__1:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq nat.nat a (nat.plus __1 r1))
                                     eqa1 (nat.times b q1)
                                     (nat.commutative_times q1 b))
                                  (nat.plus r1 (nat.times b q1))
                                  (nat.commutative_plus (nat.times b q1) r1))
                               q
                               (div_mod.div_mod_spec_to_eq a b q r q1 r1
                                  spec spec1)))
                         (nat.plus (nat.times b q) r1)
                         (nat.commutative_plus (nat.times b q) r1))
                      (nat.times q b) (nat.commutative_times q b))
                   (nat.plus r (nat.times b q))
                   (logic.rewrite_l nat.nat (nat.plus (nat.times b q) r)
                      (__1:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat a __1)
                      (logic.rewrite_l nat.nat (nat.times q b)
                         (__1:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat a (nat.plus __1 r)) eqa
                         (nat.times b q) (nat.commutative_times q b))
                      (nat.plus r (nat.times b q))
                      (nat.commutative_plus (nat.times b q) r)))
                (nat.plus (nat.times b q) r)
                (nat.commutative_plus (nat.times b q) r)) (nat.times q b)
             (nat.commutative_times q b))) spec1) spec.

def div_times :
  sttfa.eps
    (sttfa.forall nat.nat
       (a:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (b:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.lt nat.O b)
             (logic.eq nat.nat (div_mod.div (nat.times a b) b) a))))
  :=
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  posb:(sttfa.eps (nat.lt nat.O b)) =>
  div_mod.div_mod_spec_to_eq (nat.times a b) b
    (div_mod.div (nat.times a b) b) (div_mod.mod (nat.times a b) b) a nat.O
    (div_mod.div_mod_spec_div_mod (nat.times a b) b posb)
    (div_mod.div_mod_spec_intro (nat.times a b) b a nat.O posb
       (logic.rewrite_r nat.nat (nat.plus nat.O (nat.times a b))
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat (nat.times a b) __)
          (logic.rewrite_l nat.nat (nat.times a b)
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat (nat.times a b) __)
             (logic.refl nat.nat (nat.times a b))
             (nat.plus nat.O (nat.times a b)) (nat.plus_O_n (nat.times a b)))
          (nat.plus (nat.times a b) nat.O)
          (nat.commutative_plus (nat.times a b) nat.O))).

def eq_div_O :
  sttfa.eps
    (sttfa.forall nat.nat
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.lt n m) (logic.eq nat.nat (div_mod.div n m) nat.O))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  ltnm:(sttfa.eps (nat.lt n m)) =>
  div_mod.div_mod_spec_to_eq n m (div_mod.div n m) (div_mod.mod n m) nat.O n
    (div_mod.div_mod_spec_div_mod n m (nat.ltn_to_ltO n m ltnm))
    (div_mod.div_mod_spec_intro n m nat.O n ltnm
       (logic.rewrite_r nat.nat (nat.times m nat.O)
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat n (nat.plus __ n))
          (logic.rewrite_l nat.nat nat.O
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat n (nat.plus __ n))
             (logic.rewrite_r nat.nat (nat.plus n nat.O)
                (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat n __)
                (logic.rewrite_l nat.nat n
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat n __) (logic.refl nat.nat n)
                   (nat.plus n nat.O) (nat.plus_n_O n)) (nat.plus nat.O n)
                (nat.commutative_plus nat.O n)) (nat.times m nat.O)
             (nat.times_n_O m)) (nat.times nat.O m)
          (nat.commutative_times nat.O m))).

def mod_O_n :
  sttfa.eps
    (sttfa.forall nat.nat
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat (div_mod.mod nat.O n) nat.O))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.sym_eq nat.nat nat.O (div_mod.mod nat.O n)
    (logic.eq_coerc (logic.eq nat.nat nat.O (div_mod.mod nat.O n))
       (logic.eq nat.nat nat.O (div_mod.mod nat.O n))
       (nat.le_n_O_to_eq (div_mod.mod nat.O n)
          (logic.eq_coerc
             (nat.le
                (nat.minus
                   (nat.plus (div_mod.mod nat.O n)
                      (nat.times n (div_mod.div nat.O n)))
                   (nat.plus nat.O (nat.times n (div_mod.div nat.O n))))
                (nat.plus (div_mod.mod nat.O n)
                   (nat.times n (div_mod.div nat.O n))))
             (nat.le (div_mod.mod nat.O n) nat.O)
             (nat.minus_le
                (nat.plus (div_mod.mod nat.O n)
                   (nat.times n (div_mod.div nat.O n)))
                (nat.plus nat.O (nat.times n (div_mod.div nat.O n))))
             (logic.rewrite_r nat.nat
                (nat.minus (div_mod.mod nat.O n) nat.O)
                (__:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq sttfa.bool
                   (nat.le __
                      (nat.plus (div_mod.mod nat.O n)
                         (nat.times n (div_mod.div nat.O n))))
                   (nat.le (div_mod.mod nat.O n) nat.O))
                (logic.rewrite_l nat.nat (div_mod.mod nat.O n)
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq sttfa.bool
                      (nat.le __
                         (nat.plus (div_mod.mod nat.O n)
                            (nat.times n (div_mod.div nat.O n))))
                      (nat.le (div_mod.mod nat.O n) nat.O))
                   (logic.rewrite_l nat.nat nat.O
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq sttfa.bool (nat.le (div_mod.mod nat.O n) __)
                         (nat.le (div_mod.mod nat.O n) nat.O))
                      (logic.refl sttfa.bool
                         (nat.le (div_mod.mod nat.O n) nat.O))
                      (nat.plus (div_mod.mod nat.O n)
                         (nat.times n (div_mod.div nat.O n)))
                      (logic.rewrite_l nat.nat
                         (nat.plus (nat.times n (div_mod.div nat.O n))
                            (div_mod.mod nat.O n))
                         (__:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat nat.O __)
                         (logic.rewrite_l nat.nat
                            (nat.times (div_mod.div nat.O n) n)
                            (__:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq nat.nat nat.O
                               (nat.plus __ (div_mod.mod nat.O n)))
                            (div_mod.div_mod nat.O n)
                            (nat.times n (div_mod.div nat.O n))
                            (nat.commutative_times (div_mod.div nat.O n) n))
                         (nat.plus (div_mod.mod nat.O n)
                            (nat.times n (div_mod.div nat.O n)))
                         (nat.commutative_plus
                            (nat.times n (div_mod.div nat.O n))
                            (div_mod.mod nat.O n))))
                   (nat.minus (div_mod.mod nat.O n) nat.O)
                   (nat.minus_n_O (div_mod.mod nat.O n)))
                (nat.minus
                   (nat.plus (div_mod.mod nat.O n)
                      (nat.times n (div_mod.div nat.O n)))
                   (nat.plus nat.O (nat.times n (div_mod.div nat.O n))))
                (nat.minus_plus_plus_l (div_mod.mod nat.O n) nat.O
                   (nat.times n (div_mod.div nat.O n))))))
       (logic.refl sttfa.bool (logic.eq nat.nat nat.O (div_mod.mod nat.O n)))).
