#NAME div_mod.

mod_aux :
  sttfa.etap 
    (sttfa.p 
       (sttfa.arrow nat.nat 
          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))).

mod_aux_body :
  sttfa.etap 
    (sttfa.p 
       (sttfa.arrow nat.nat 
          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))).

eq_mod_aux :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
          (div_mod.mod_aux p) 
          (nat.filter_nat_type 
             (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
             div_mod.mod_aux_body p))).

def sym_eq_mod_aux :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
          (nat.filter_nat_type 
             (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
             div_mod.mod_aux_body p) (div_mod.mod_aux p)))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  sttfa.sym_leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
    (div_mod.mod_aux p) 
    (nat.filter_nat_type (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
       div_mod.mod_aux_body p) (div_mod.eq_mod_aux p).

eq_mod_aux_body_O :
  sttfa.eps 
    (sttfa.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
       (div_mod.mod_aux_body nat.O) 
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        n:(sttfa.etap (sttfa.p nat.nat)) => m)).

def sym_eq_mod_aux_body_O :
  sttfa.eps 
    (sttfa.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        n:(sttfa.etap (sttfa.p nat.nat)) => m) (div_mod.mod_aux_body nat.O))
  :=
  sttfa.sym_leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
    (div_mod.mod_aux_body nat.O) 
    (m:(sttfa.etap (sttfa.p nat.nat)) =>
     n:(sttfa.etap (sttfa.p nat.nat)) => m) div_mod.eq_mod_aux_body_O.

eq_mod_aux_body_S :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
          (div_mod.mod_aux_body (nat.S p)) 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           n:(sttfa.etap (sttfa.p nat.nat)) =>
           bool.match_bool_type nat.nat m 
             (div_mod.mod_aux p (nat.minus m (nat.S n)) n) (nat.leb m n)))).

def sym_eq_mod_aux_body_S :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           n:(sttfa.etap (sttfa.p nat.nat)) =>
           bool.match_bool_type nat.nat m 
             (div_mod.mod_aux p (nat.minus m (nat.S n)) n) (nat.leb m n)) 
          (div_mod.mod_aux_body (nat.S p))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  sttfa.sym_leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
    (div_mod.mod_aux_body (nat.S p)) 
    (m:(sttfa.etap (sttfa.p nat.nat)) =>
     n:(sttfa.etap (sttfa.p nat.nat)) =>
     bool.match_bool_type nat.nat m 
       (div_mod.mod_aux p (nat.minus m (nat.S n)) n) (nat.leb m n)) 
    (div_mod.eq_mod_aux_body_S p).

def mod :
  sttfa.etap (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.match_nat_type nat.nat n 
    (p:(sttfa.etap (sttfa.p nat.nat)) => div_mod.mod_aux n n p) m.

div_aux :
  sttfa.etap 
    (sttfa.p 
       (sttfa.arrow nat.nat 
          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))).

div_aux_body :
  sttfa.etap 
    (sttfa.p 
       (sttfa.arrow nat.nat 
          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))).

eq_div_aux :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
          (div_mod.div_aux p) 
          (nat.filter_nat_type 
             (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
             div_mod.div_aux_body p))).

def sym_eq_div_aux :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
          (nat.filter_nat_type 
             (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
             div_mod.div_aux_body p) (div_mod.div_aux p)))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  sttfa.sym_leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
    (div_mod.div_aux p) 
    (nat.filter_nat_type (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
       div_mod.div_aux_body p) (div_mod.eq_div_aux p).

eq_div_aux_body_O :
  sttfa.eps 
    (sttfa.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
       (div_mod.div_aux_body nat.O) 
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        n:(sttfa.etap (sttfa.p nat.nat)) => nat.O)).

def sym_eq_div_aux_body_O :
  sttfa.eps 
    (sttfa.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        n:(sttfa.etap (sttfa.p nat.nat)) => nat.O) 
       (div_mod.div_aux_body nat.O))
  :=
  sttfa.sym_leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
    (div_mod.div_aux_body nat.O) 
    (m:(sttfa.etap (sttfa.p nat.nat)) =>
     n:(sttfa.etap (sttfa.p nat.nat)) => nat.O) div_mod.eq_div_aux_body_O.

eq_div_aux_body_S :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
          (div_mod.div_aux_body (nat.S p)) 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           n:(sttfa.etap (sttfa.p nat.nat)) =>
           bool.match_bool_type nat.nat nat.O 
             (nat.S (div_mod.div_aux p (nat.minus m (nat.S n)) n)) 
             (nat.leb m n)))).

def sym_eq_div_aux_body_S :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           n:(sttfa.etap (sttfa.p nat.nat)) =>
           bool.match_bool_type nat.nat nat.O 
             (nat.S (div_mod.div_aux p (nat.minus m (nat.S n)) n)) 
             (nat.leb m n)) (div_mod.div_aux_body (nat.S p))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  sttfa.sym_leibniz (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
    (div_mod.div_aux_body (nat.S p)) 
    (m:(sttfa.etap (sttfa.p nat.nat)) =>
     n:(sttfa.etap (sttfa.p nat.nat)) =>
     bool.match_bool_type nat.nat nat.O 
       (nat.S (div_mod.div_aux p (nat.minus m (nat.S n)) n)) (nat.leb m n)) 
    (div_mod.eq_div_aux_body_S p).

def div :
  sttfa.etap (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.match_nat_type nat.nat (nat.S n) 
    (p:(sttfa.etap (sttfa.p nat.nat)) => div_mod.div_aux n n p) m.

def le_mod_aux_m_m :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (m:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.le n p) (nat.le (div_mod.mod_aux p n m) m)))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind 
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.le n _x_365) 
             (nat.le (div_mod.mod_aux _x_365 n m) m)))) 
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     m:(sttfa.etap (sttfa.p nat.nat)) =>
     div_mod.sym_eq_mod_aux nat.O 
       (y:
        (sttfa.etap 
           (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
        sttfa.impl (nat.le n nat.O) (nat.le (y n m) m)) 
       (nat.sym_eq_filter_nat_type_O 
          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
          div_mod.mod_aux_body 
          (y:
           (sttfa.etap 
              (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
           sttfa.impl (nat.le n nat.O) (nat.le (y n m) m)) 
          (div_mod.sym_eq_mod_aux_body_O 
             (y:
              (sttfa.etap 
                 (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
              sttfa.impl (nat.le n nat.O) (nat.le (y n m) m)) 
             (lenO:(sttfa.eps (nat.le n nat.O)) =>
              nat.le_n_O_elim n lenO 
                (__:(sttfa.etap (sttfa.p nat.nat)) => nat.le __ m) 
                (nat.le_O_n m))))) 
    (q:(sttfa.etap (sttfa.p nat.nat)) =>
     div_mod.sym_eq_mod_aux (nat.S q) 
       (y:
        (sttfa.etap 
           (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
        sttfa.impl 
          (sttfa.forall nat.nat 
             (n:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat 
                (m:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (nat.le n q) (nat.le (div_mod.mod_aux q n m) m)))) 
          (sttfa.forall nat.nat 
             (n:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat 
                (m:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (nat.le n (nat.S q)) (nat.le (y n m) m))))) 
       (nat.sym_eq_filter_nat_type_S 
          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
          div_mod.mod_aux_body q 
          (y:
           (sttfa.etap 
              (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
           sttfa.impl 
             (sttfa.forall nat.nat 
                (n:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall nat.nat 
                   (m:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (nat.le n q) 
                      (nat.le (div_mod.mod_aux q n m) m)))) 
             (sttfa.forall nat.nat 
                (n:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall nat.nat 
                   (m:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (nat.le n (nat.S q)) (nat.le (y n m) m))))) 
          (div_mod.sym_eq_mod_aux_body_S q 
             (y:
              (sttfa.etap 
                 (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
              sttfa.impl 
                (sttfa.forall nat.nat 
                   (n:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.forall nat.nat 
                      (m:(sttfa.etap (sttfa.p nat.nat)) =>
                       sttfa.impl (nat.le n q) 
                         (nat.le (div_mod.mod_aux q n m) m)))) 
                (sttfa.forall nat.nat 
                   (n:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.forall nat.nat 
                      (m:(sttfa.etap (sttfa.p nat.nat)) =>
                       sttfa.impl (nat.le n (nat.S q)) (nat.le (y n m) m))))) 
             (Hind:
              (sttfa.eps 
                 (sttfa.forall nat.nat 
                    (n:(sttfa.etap (sttfa.p nat.nat)) =>
                     sttfa.forall nat.nat 
                       (m:(sttfa.etap (sttfa.p nat.nat)) =>
                        sttfa.impl (nat.le n q) 
                          (nat.le (div_mod.mod_aux q n m) m))))) =>
              n:(sttfa.etap (sttfa.p nat.nat)) =>
              m:(sttfa.etap (sttfa.p nat.nat)) =>
              len:(sttfa.eps (nat.le n (nat.S q))) =>
              nat.leb_elim n m 
                (__:(sttfa.etap (sttfa.p bool.bool)) =>
                 nat.le 
                   (bool.match_bool_type nat.nat n 
                      (div_mod.mod_aux q (nat.minus n (nat.S m)) m) __) m) 
                (bool.sym_eq_match_bool_type_true nat.nat n 
                   (div_mod.mod_aux q (nat.minus n (nat.S m)) m) 
                   (y:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (nat.le n m) (nat.le y m)) 
                   (auto:(sttfa.eps (nat.le n m)) => auto)) 
                (bool.sym_eq_match_bool_type_false nat.nat n 
                   (div_mod.mod_aux q (nat.minus n (nat.S m)) m) 
                   (y:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (connectives.Not (nat.le n m)) (nat.le y m)) 
                   (notlenm:(sttfa.eps (connectives.Not (nat.le n m))) =>
                    Hind (nat.minus n (nat.S m)) m 
                      (nat.le_plus_to_minus n (nat.S m) q 
                         (nat.transitive_le n (nat.S q) 
                            (nat.plus q (nat.S m)) len 
                            (logic.eq_coerc 
                               (nat.le (nat.S q) (nat.plus (nat.S q) m)) 
                               (nat.le (nat.S q) (nat.plus q (nat.S m))) 
                               (nat.le_plus_n_r m (nat.S q)) 
                               (logic.rewrite_l nat.nat 
                                  (nat.plus m (nat.S q)) 
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq sttfa.bool (nat.le (nat.S q) __) 
                                     (nat.le (nat.S q) (nat.plus q (nat.S m)))) 
                                  (logic.rewrite_r nat.nat 
                                     (nat.plus q (nat.S m)) 
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq sttfa.bool 
                                        (nat.le (nat.S q) __) 
                                        (nat.le (nat.S q) 
                                           (nat.plus q (nat.S m)))) 
                                     (logic.refl sttfa.bool 
                                        (nat.le (nat.S q) 
                                           (nat.plus q (nat.S m)))) 
                                     (nat.plus m (nat.S q)) 
                                     (logic.rewrite_l nat.nat 
                                        (nat.S (nat.plus m q)) 
                                        (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq nat.nat __ 
                                           (nat.plus q (nat.S m))) 
                                        (logic.rewrite_l nat.nat 
                                           (nat.plus q m) 
                                           (__:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq nat.nat (nat.S __) 
                                              (nat.plus q (nat.S m))) 
                                           (nat.plus_n_Sm q m) 
                                           (nat.plus m q) 
                                           (nat.commutative_plus q m)) 
                                        (nat.plus m (nat.S q)) 
                                        (nat.plus_n_Sm m q))) 
                                  (nat.plus (nat.S q) m) 
                                  (nat.commutative_plus m (nat.S q)))))))))))) 
    p.

def lt_mod_m_m :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.lt nat.O m) (nat.lt (div_mod.mod n m) m))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.match_nat_prop 
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.impl (nat.lt nat.O __) (nat.lt (div_mod.mod n __) __)) 
    (abs:(sttfa.eps (nat.lt nat.O nat.O)) =>
     logic.falsity (nat.lt (div_mod.mod n nat.O) nat.O) 
       (logic.absurd (nat.le (nat.S nat.O) nat.O) abs (nat.not_le_Sn_O nat.O))) 
    (p:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_match_nat_type_S nat.nat n 
       (q:(sttfa.etap (sttfa.p nat.nat)) => div_mod.mod_aux n n q) p 
       (y:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.impl (nat.lt nat.O (nat.S p)) (nat.lt y (nat.S p))) 
       (__:(sttfa.eps (nat.lt nat.O (nat.S p))) =>
        nat.le_S_S (div_mod.mod_aux n n p) p 
          (div_mod.le_mod_aux_m_m n n p (nat.le_n n)))) m.

def div_aux_mod_aux :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (m:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat n 
                (nat.plus (nat.times (div_mod.div_aux p n m) (nat.S m)) 
                   (div_mod.mod_aux p n m))))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind 
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat n 
             (nat.plus (nat.times (div_mod.div_aux _x_365 n m) (nat.S m)) 
                (div_mod.mod_aux _x_365 n m))))) 
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     m:(sttfa.etap (sttfa.p nat.nat)) =>
     div_mod.sym_eq_div_aux nat.O 
       (y:
        (sttfa.etap 
           (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
        logic.eq nat.nat n 
          (nat.plus (nat.times (y n m) (nat.S m)) (div_mod.mod_aux nat.O n m))) 
       (nat.sym_eq_filter_nat_type_O 
          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
          div_mod.div_aux_body 
          (y:
           (sttfa.etap 
              (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
           logic.eq nat.nat n 
             (nat.plus (nat.times (y n m) (nat.S m)) 
                (div_mod.mod_aux nat.O n m))) 
          (div_mod.sym_eq_div_aux_body_O 
             (y:
              (sttfa.etap 
                 (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
              logic.eq nat.nat n 
                (nat.plus (nat.times (y n m) (nat.S m)) 
                   (div_mod.mod_aux nat.O n m))) 
             (nat.eq_match_nat_type_O nat.nat nat.O 
                (q:(sttfa.etap (sttfa.p nat.nat)) =>
                 bool.match_bool_type nat.nat nat.O 
                   (nat.S (div_mod.div_aux q (nat.minus n (nat.S m)) m)) 
                   (nat.leb n m)) 
                (y:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat n 
                   (nat.plus (nat.times y (nat.S m)) 
                      (div_mod.mod_aux nat.O n m))) 
                (div_mod.sym_eq_mod_aux nat.O 
                   (y:
                    (sttfa.etap 
                       (sttfa.p 
                          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
                    logic.eq nat.nat n 
                      (nat.plus 
                         (nat.times 
                            ((m0:(sttfa.etap (sttfa.p nat.nat)) =>
                              n0:(sttfa.etap (sttfa.p nat.nat)) =>
                              nat.match_nat_type nat.nat nat.O 
                                (q:(sttfa.etap (sttfa.p nat.nat)) =>
                                 bool.match_bool_type nat.nat nat.O 
                                   (nat.S 
                                      (div_mod.div_aux q 
                                         (nat.minus m0 (nat.S n0)) n0)) 
                                   (nat.leb m0 n0)) nat.O) n m) (nat.S m)) 
                         (y n m))) 
                   (nat.sym_eq_filter_nat_type_O 
                      (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
                      div_mod.mod_aux_body 
                      (y:
                       (sttfa.etap 
                          (sttfa.p 
                             (sttfa.arrow nat.nat 
                                (sttfa.arrow nat.nat nat.nat)))) =>
                       logic.eq nat.nat n 
                         (nat.plus 
                            (nat.times 
                               ((m0:(sttfa.etap (sttfa.p nat.nat)) =>
                                 n0:(sttfa.etap (sttfa.p nat.nat)) =>
                                 nat.match_nat_type nat.nat nat.O 
                                   (q:(sttfa.etap (sttfa.p nat.nat)) =>
                                    bool.match_bool_type nat.nat nat.O 
                                      (nat.S 
                                         (div_mod.div_aux q 
                                            (nat.minus m0 (nat.S n0)) n0)) 
                                      (nat.leb m0 n0)) nat.O) n m) (nat.S m)) 
                            (y n m))) 
                      (div_mod.sym_eq_mod_aux_body_O 
                         (y:
                          (sttfa.etap 
                             (sttfa.p 
                                (sttfa.arrow nat.nat 
                                   (sttfa.arrow nat.nat nat.nat)))) =>
                          logic.eq nat.nat n 
                            (nat.plus 
                               (nat.times 
                                  ((m0:(sttfa.etap (sttfa.p nat.nat)) =>
                                    n0:(sttfa.etap (sttfa.p nat.nat)) =>
                                    nat.match_nat_type nat.nat nat.O 
                                      (q:(sttfa.etap (sttfa.p nat.nat)) =>
                                       bool.match_bool_type nat.nat nat.O 
                                         (nat.S 
                                            (div_mod.div_aux q 
                                               (nat.minus m0 (nat.S n0)) n0)) 
                                         (nat.leb m0 n0)) nat.O) n m) 
                                  (nat.S m)) (y n m))) 
                         (nat.sym_eq_match_nat_type_O nat.nat nat.O 
                            (q:(sttfa.etap (sttfa.p nat.nat)) =>
                             bool.match_bool_type nat.nat nat.O 
                               (nat.S 
                                  (div_mod.div_aux q (nat.minus n (nat.S m)) 
                                     m)) (nat.leb n m)) 
                            (y:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq nat.nat n 
                               (nat.plus 
                                  (nat.times 
                                     ((m0:(sttfa.etap (sttfa.p nat.nat)) =>
                                       n0:(sttfa.etap (sttfa.p nat.nat)) => y) 
                                        n m) (nat.S m)) n)) 
                            (nat.sym_eq_times nat.O 
                               (y:
                                (sttfa.etap 
                                   (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                                logic.eq nat.nat n (nat.plus (y (nat.S m)) n)) 
                               (nat.sym_eq_filter_nat_type_O 
                                  (sttfa.arrow nat.nat nat.nat) 
                                  nat.times_body 
                                  (y:
                                   (sttfa.etap 
                                      (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                                   logic.eq nat.nat n 
                                     (nat.plus (y (nat.S m)) n)) 
                                  (nat.sym_eq_times_body_O 
                                     (y:
                                      (sttfa.etap 
                                         (sttfa.p 
                                            (sttfa.arrow nat.nat nat.nat))) =>
                                      logic.eq nat.nat n 
                                        (nat.plus (y (nat.S m)) n)) 
                                     (nat.sym_eq_plus nat.O 
                                        (y:
                                         (sttfa.etap 
                                            (sttfa.p 
                                               (sttfa.arrow nat.nat nat.nat))) =>
                                         logic.eq nat.nat n (y n)) 
                                        (nat.sym_eq_filter_nat_type_O 
                                           (sttfa.arrow nat.nat nat.nat) 
                                           nat.plus_body 
                                           (y:
                                            (sttfa.etap 
                                               (sttfa.p 
                                                  (sttfa.arrow nat.nat 
                                                     nat.nat))) =>
                                            logic.eq nat.nat n (y n)) 
                                           (nat.sym_eq_plus_body_O 
                                              (y:
                                               (sttfa.etap 
                                                  (sttfa.p 
                                                     (sttfa.arrow nat.nat 
                                                        nat.nat))) =>
                                               logic.eq nat.nat n (y n)) 
                                              (logic.refl nat.nat n))))))))))))))) 
    (q:(sttfa.etap (sttfa.p nat.nat)) =>
     div_mod.sym_eq_div_aux (nat.S q) 
       (y:
        (sttfa.etap 
           (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
        sttfa.impl 
          (sttfa.forall nat.nat 
             (n:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat 
                (m:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat n 
                   (nat.plus (nat.times (div_mod.div_aux q n m) (nat.S m)) 
                      (div_mod.mod_aux q n m))))) 
          (sttfa.forall nat.nat 
             (n:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat 
                (m:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat n 
                   (nat.plus (nat.times (y n m) (nat.S m)) 
                      (div_mod.mod_aux (nat.S q) n m)))))) 
       (nat.sym_eq_filter_nat_type_S 
          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
          div_mod.div_aux_body q 
          (y:
           (sttfa.etap 
              (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
           sttfa.impl 
             (sttfa.forall nat.nat 
                (n:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall nat.nat 
                   (m:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat n 
                      (nat.plus 
                         (nat.times (div_mod.div_aux q n m) (nat.S m)) 
                         (div_mod.mod_aux q n m))))) 
             (sttfa.forall nat.nat 
                (n:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall nat.nat 
                   (m:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat n 
                      (nat.plus (nat.times (y n m) (nat.S m)) 
                         (div_mod.mod_aux (nat.S q) n m)))))) 
          (div_mod.sym_eq_div_aux_body_S q 
             (y:
              (sttfa.etap 
                 (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
              sttfa.impl 
                (sttfa.forall nat.nat 
                   (n:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.forall nat.nat 
                      (m:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat n 
                         (nat.plus 
                            (nat.times (div_mod.div_aux q n m) (nat.S m)) 
                            (div_mod.mod_aux q n m))))) 
                (sttfa.forall nat.nat 
                   (n:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.forall nat.nat 
                      (m:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat n 
                         (nat.plus (nat.times (y n m) (nat.S m)) 
                            (div_mod.mod_aux (nat.S q) n m)))))) 
             (Hind:
              (sttfa.eps 
                 (sttfa.forall nat.nat 
                    (n:(sttfa.etap (sttfa.p nat.nat)) =>
                     sttfa.forall nat.nat 
                       (m:(sttfa.etap (sttfa.p nat.nat)) =>
                        logic.eq nat.nat n 
                          (nat.plus 
                             (nat.times (div_mod.div_aux q n m) (nat.S m)) 
                             (div_mod.mod_aux q n m)))))) =>
              n:(sttfa.etap (sttfa.p nat.nat)) =>
              m:(sttfa.etap (sttfa.p nat.nat)) =>
              nat.eq_match_nat_type_S nat.nat nat.O 
                (q0:(sttfa.etap (sttfa.p nat.nat)) =>
                 bool.match_bool_type nat.nat nat.O 
                   (nat.S (div_mod.div_aux q0 (nat.minus n (nat.S m)) m)) 
                   (nat.leb n m)) q 
                (y:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat n 
                   (nat.plus (nat.times y (nat.S m)) 
                      (div_mod.mod_aux (nat.S q) n m))) 
                (div_mod.sym_eq_mod_aux (nat.S q) 
                   (y:
                    (sttfa.etap 
                       (sttfa.p 
                          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)))) =>
                    logic.eq nat.nat n 
                      (nat.plus 
                         (nat.times 
                            ((m0:(sttfa.etap (sttfa.p nat.nat)) =>
                              n0:(sttfa.etap (sttfa.p nat.nat)) =>
                              nat.match_nat_type nat.nat nat.O 
                                (q0:(sttfa.etap (sttfa.p nat.nat)) =>
                                 bool.match_bool_type nat.nat nat.O 
                                   (nat.S 
                                      (div_mod.div_aux q0 
                                         (nat.minus m0 (nat.S n0)) n0)) 
                                   (nat.leb m0 n0)) (nat.S q)) n m) (
                            nat.S m)) (y n m))) 
                   (nat.sym_eq_filter_nat_type_S 
                      (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat)) 
                      div_mod.mod_aux_body q 
                      (y:
                       (sttfa.etap 
                          (sttfa.p 
                             (sttfa.arrow nat.nat 
                                (sttfa.arrow nat.nat nat.nat)))) =>
                       logic.eq nat.nat n 
                         (nat.plus 
                            (nat.times 
                               ((m0:(sttfa.etap (sttfa.p nat.nat)) =>
                                 n0:(sttfa.etap (sttfa.p nat.nat)) =>
                                 nat.match_nat_type nat.nat nat.O 
                                   (q0:(sttfa.etap (sttfa.p nat.nat)) =>
                                    bool.match_bool_type nat.nat nat.O 
                                      (nat.S 
                                         (div_mod.div_aux q0 
                                            (nat.minus m0 (nat.S n0)) n0)) 
                                      (nat.leb m0 n0)) (nat.S q)) n m) 
                               (nat.S m)) (y n m))) 
                      (div_mod.sym_eq_mod_aux_body_S q 
                         (y:
                          (sttfa.etap 
                             (sttfa.p 
                                (sttfa.arrow nat.nat 
                                   (sttfa.arrow nat.nat nat.nat)))) =>
                          logic.eq nat.nat n 
                            (nat.plus 
                               (nat.times 
                                  ((m0:(sttfa.etap (sttfa.p nat.nat)) =>
                                    n0:(sttfa.etap (sttfa.p nat.nat)) =>
                                    nat.match_nat_type nat.nat nat.O 
                                      (q0:(sttfa.etap (sttfa.p nat.nat)) =>
                                       bool.match_bool_type nat.nat nat.O 
                                         (nat.S 
                                            (div_mod.div_aux q0 
                                               (nat.minus m0 (nat.S n0)) n0)) 
                                         (nat.leb m0 n0)) (nat.S q)) n m) 
                                  (nat.S m)) (y n m))) 
                         (nat.sym_eq_match_nat_type_S nat.nat nat.O 
                            (z:(sttfa.etap (sttfa.p nat.nat)) =>
                             bool.match_bool_type nat.nat nat.O 
                               (nat.S 
                                  (div_mod.div_aux z (nat.minus n (nat.S m)) 
                                     m)) (nat.leb n m)) q 
                            (y:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq nat.nat n 
                               (nat.plus (nat.times y (nat.S m)) 
                                  (bool.match_bool_type nat.nat n 
                                     (div_mod.mod_aux q 
                                        (nat.minus n (nat.S m)) m) 
                                     (nat.leb n m)))) 
                            (nat.leb_elim n m 
                               (__:(sttfa.etap (sttfa.p bool.bool)) =>
                                logic.eq nat.nat n 
                                  (nat.plus 
                                     (nat.times 
                                        (bool.match_bool_type nat.nat nat.O 
                                           (nat.S 
                                              (div_mod.div_aux q 
                                                 (nat.minus n (nat.S m)) m)) 
                                           __) (nat.S m)) 
                                     (bool.match_bool_type nat.nat n 
                                        (div_mod.mod_aux q 
                                           (nat.minus n (nat.S m)) m) __))) 
                               (bool.sym_eq_match_bool_type_true nat.nat 
                                  nat.O 
                                  (nat.S 
                                     (div_mod.div_aux q 
                                        (nat.minus n (nat.S m)) m)) 
                                  (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                   sttfa.impl (nat.le n m) 
                                     (logic.eq nat.nat n 
                                        (nat.plus (nat.times x (nat.S m)) 
                                           (bool.match_bool_type nat.nat n 
                                              (div_mod.mod_aux q 
                                                 (nat.minus n (nat.S m)) m) 
                                              bool.true)))) 
                                  (nat.sym_eq_times nat.O 
                                     (y:
                                      (sttfa.etap 
                                         (sttfa.p 
                                            (sttfa.arrow nat.nat nat.nat))) =>
                                      sttfa.impl (nat.le n m) 
                                        (logic.eq nat.nat n 
                                           (nat.plus (y (nat.S m)) 
                                              (bool.match_bool_type nat.nat 
                                                 n 
                                                 (div_mod.mod_aux q 
                                                    (nat.minus n (nat.S m)) m) 
                                                 bool.true)))) 
                                     (nat.sym_eq_filter_nat_type_O 
                                        (sttfa.arrow nat.nat nat.nat) 
                                        nat.times_body 
                                        (y:
                                         (sttfa.etap 
                                            (sttfa.p 
                                               (sttfa.arrow nat.nat nat.nat))) =>
                                         sttfa.impl (nat.le n m) 
                                           (logic.eq nat.nat n 
                                              (nat.plus (y (nat.S m)) 
                                                 (bool.match_bool_type 
                                                    nat.nat n 
                                                    (div_mod.mod_aux q 
                                                       (nat.minus n (nat.S m)) 
                                                       m) bool.true)))) 
                                        (nat.sym_eq_times_body_O 
                                           (y:
                                            (sttfa.etap 
                                               (sttfa.p 
                                                  (sttfa.arrow nat.nat 
                                                     nat.nat))) =>
                                            sttfa.impl (nat.le n m) 
                                              (logic.eq nat.nat n 
                                                 (nat.plus (y (nat.S m)) 
                                                    (bool.match_bool_type 
                                                       nat.nat n 
                                                       (div_mod.mod_aux q 
                                                          (nat.minus n 
                                                             (nat.S m)) m) 
                                                       bool.true)))) 
                                           (bool.sym_eq_match_bool_type_true 
                                              nat.nat n 
                                              (div_mod.mod_aux q 
                                                 (nat.minus n (nat.S m)) m) 
                                              (y:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               sttfa.impl (nat.le n m) 
                                                 (logic.eq nat.nat n 
                                                    (nat.plus nat.O y))) 
                                              (nat.sym_eq_plus nat.O 
                                                 (y:
                                                  (sttfa.etap 
                                                     (sttfa.p 
                                                        (sttfa.arrow nat.nat 
                                                           nat.nat))) =>
                                                  sttfa.impl (nat.le n m) 
                                                    (logic.eq nat.nat n (y n))) 
                                                 (nat.sym_eq_filter_nat_type_O 
                                                    (sttfa.arrow nat.nat 
                                                       nat.nat) 
                                                    nat.plus_body 
                                                    (y:
                                                     (sttfa.etap 
                                                        (sttfa.p 
                                                           (sttfa.arrow 
                                                              nat.nat nat.nat))) =>
                                                     sttfa.impl (nat.le n m) 
                                                       (logic.eq nat.nat n 
                                                          (y n))) 
                                                    (nat.sym_eq_plus_body_O 
                                                       (y:
                                                        (sttfa.etap 
                                                           (sttfa.p 
                                                              (sttfa.arrow 
                                                                 nat.nat 
                                                                 nat.nat))) =>
                                                        sttfa.impl 
                                                          (nat.le n m) 
                                                          (logic.eq nat.nat 
                                                             n (y n))) 
                                                       (lenm:
                                                        (sttfa.eps 
                                                           (nat.le n m)) =>
                                                        logic.refl nat.nat n))))))))) 
                               (bool.sym_eq_match_bool_type_false nat.nat n 
                                  (div_mod.mod_aux q (nat.minus n (nat.S m)) 
                                     m) 
                                  (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                   sttfa.impl (connectives.Not (nat.le n m)) 
                                     (logic.eq nat.nat n 
                                        (nat.plus 
                                           (nat.times 
                                              (bool.match_bool_type nat.nat 
                                                 nat.O 
                                                 (nat.S 
                                                    (div_mod.div_aux q 
                                                       (nat.minus n (nat.S m)) 
                                                       m)) bool.false) 
                                              (nat.S m)) x))) 
                                  (bool.sym_eq_match_bool_type_false nat.nat 
                                     nat.O 
                                     (nat.S 
                                        (div_mod.div_aux q 
                                           (nat.minus n (nat.S m)) m)) 
                                     (y:(sttfa.etap (sttfa.p nat.nat)) =>
                                      sttfa.impl 
                                        (connectives.Not (nat.le n m)) 
                                        (logic.eq nat.nat n 
                                           (nat.plus (nat.times y (nat.S m)) 
                                              (div_mod.mod_aux q 
                                                 (nat.minus n (nat.S m)) m)))) 
                                     (nat.sym_eq_times 
                                        (nat.S 
                                           (div_mod.div_aux q 
                                              (nat.minus n (nat.S m)) m)) 
                                        (y:
                                         (sttfa.etap 
                                            (sttfa.p 
                                               (sttfa.arrow nat.nat nat.nat))) =>
                                         sttfa.impl 
                                           (connectives.Not (nat.le n m)) 
                                           (logic.eq nat.nat n 
                                              (nat.plus (y (nat.S m)) 
                                                 (div_mod.mod_aux q 
                                                    (nat.minus n (nat.S m)) m)))) 
                                        (nat.sym_eq_filter_nat_type_S 
                                           (sttfa.arrow nat.nat nat.nat) 
                                           nat.times_body 
                                           (div_mod.div_aux q 
                                              (nat.minus n (nat.S m)) m) 
                                           (y:
                                            (sttfa.etap 
                                               (sttfa.p 
                                                  (sttfa.arrow nat.nat 
                                                     nat.nat))) =>
                                            sttfa.impl 
                                              (connectives.Not (nat.le n m)) 
                                              (logic.eq nat.nat n 
                                                 (nat.plus (y (nat.S m)) 
                                                    (div_mod.mod_aux q 
                                                       (nat.minus n (nat.S m)) 
                                                       m)))) 
                                           (nat.sym_eq_times_body_S 
                                              (div_mod.div_aux q 
                                                 (nat.minus n (nat.S m)) m) 
                                              (y:
                                               (sttfa.etap 
                                                  (sttfa.p 
                                                     (sttfa.arrow nat.nat 
                                                        nat.nat))) =>
                                               sttfa.impl 
                                                 (connectives.Not 
                                                    (nat.le n m)) 
                                                 (logic.eq nat.nat n 
                                                    (nat.plus (y (nat.S m)) 
                                                       (div_mod.mod_aux q 
                                                          (nat.minus n 
                                                             (nat.S m)) m)))) 
                                              (nat.sym_eq_plus (nat.S m) 
                                                 (y:
                                                  (sttfa.etap 
                                                     (sttfa.p 
                                                        (sttfa.arrow nat.nat 
                                                           nat.nat))) =>
                                                  sttfa.impl 
                                                    (connectives.Not 
                                                       (nat.le n m)) 
                                                    (logic.eq nat.nat n 
                                                       (nat.plus 
                                                          (y 
                                                             (nat.times 
                                                                (div_mod.div_aux 
                                                                   q 
                                                                   (nat.minus 
                                                                    n 
                                                                    (nat.S m)) 
                                                                   m) 
                                                                (nat.S m))) 
                                                          (div_mod.mod_aux q 
                                                             (nat.minus n 
                                                                (nat.S m)) m)))) 
                                                 (nat.sym_eq_filter_nat_type_S 
                                                    (sttfa.arrow nat.nat 
                                                       nat.nat) 
                                                    nat.plus_body m 
                                                    (y:
                                                     (sttfa.etap 
                                                        (sttfa.p 
                                                           (sttfa.arrow 
                                                              nat.nat nat.nat))) =>
                                                     sttfa.impl 
                                                       (connectives.Not 
                                                          (nat.le n m)) 
                                                       (logic.eq nat.nat n 
                                                          (nat.plus 
                                                             (y 
                                                                (nat.times 
                                                                   (div_mod.div_aux 
                                                                    q 
                                                                    (nat.minus 
                                                                    n 
                                                                    (nat.S m)) 
                                                                    m) 
                                                                   (nat.S m))) 
                                                             (div_mod.mod_aux 
                                                                q 
                                                                (nat.minus n 
                                                                   (nat.S m)) 
                                                                m)))) 
                                                    (nat.sym_eq_plus_body_S 
                                                       m 
                                                       (y:
                                                        (sttfa.etap 
                                                           (sttfa.p 
                                                              (sttfa.arrow 
                                                                 nat.nat 
                                                                 nat.nat))) =>
                                                        sttfa.impl 
                                                          (connectives.Not 
                                                             (nat.le n m)) 
                                                          (logic.eq nat.nat 
                                                             n 
                                                             (nat.plus 
                                                                (y 
                                                                   (nat.times 
                                                                    (div_mod.div_aux 
                                                                    q 
                                                                    (nat.minus 
                                                                    n 
                                                                    (nat.S m)) 
                                                                    m) 
                                                                    (nat.S m))) 
                                                                (div_mod.mod_aux 
                                                                   q 
                                                                   (nat.minus 
                                                                    n 
                                                                    (nat.S m)) 
                                                                   m)))) 
                                                       (nat.sym_eq_plus 
                                                          (nat.S 
                                                             (nat.plus m 
                                                                (nat.times 
                                                                   (div_mod.div_aux 
                                                                    q 
                                                                    (nat.minus 
                                                                    n 
                                                                    (nat.S m)) 
                                                                    m) 
                                                                   (nat.S m)))) 
                                                          (y:
                                                           (sttfa.etap 
                                                              (sttfa.p 
                                                                 (sttfa.arrow 
                                                                    nat.nat 
                                                                    nat.nat))) =>
                                                           sttfa.impl 
                                                             (connectives.Not 
                                                                (nat.le n m)) 
                                                             (logic.eq 
                                                                nat.nat n 
                                                                (y 
                                                                   (div_mod.mod_aux 
                                                                    q 
                                                                    (nat.minus 
                                                                    n 
                                                                    (nat.S m)) 
                                                                    m)))) 
                                                          (nat.sym_eq_filter_nat_type_S 
                                                             (sttfa.arrow 
                                                                nat.nat 
                                                                nat.nat) 
                                                             nat.plus_body 
                                                             (nat.plus m 
                                                                (nat.times 
                                                                   (div_mod.div_aux 
                                                                    q 
                                                                    (nat.minus 
                                                                    n 
                                                                    (nat.S m)) 
                                                                    m) 
                                                                   (nat.S m))) 
                                                             (y:
                                                              (sttfa.etap 
                                                                 (sttfa.p 
                                                                    (
                                                                    sttfa.arrow 
                                                                    nat.nat 
                                                                    nat.nat))) =>
                                                              sttfa.impl 
                                                                (connectives.Not 
                                                                   (nat.le n 
                                                                    m)) 
                                                                (logic.eq 
                                                                   nat.nat n 
                                                                   (y 
                                                                    (div_mod.mod_aux 
                                                                    q 
                                                                    (nat.minus 
                                                                    n 
                                                                    (nat.S m)) 
                                                                    m)))) 
                                                             (nat.sym_eq_plus_body_S 
                                                                (nat.plus m 
                                                                   (nat.times 
                                                                    (div_mod.div_aux 
                                                                    q 
                                                                    (nat.minus 
                                                                    n 
                                                                    (nat.S m)) 
                                                                    m) 
                                                                    (nat.S m))) 
                                                                (y:
                                                                 (sttfa.etap 
                                                                    (
                                                                    sttfa.p 
                                                                    (sttfa.arrow 
                                                                    nat.nat 
                                                                    nat.nat))) =>
                                                                 sttfa.impl 
                                                                   (connectives.Not 
                                                                    (nat.le 
                                                                    n m)) 
                                                                   (logic.eq 
                                                                    nat.nat 
                                                                    n 
                                                                    (y 
                                                                    (div_mod.mod_aux 
                                                                    q 
                                                                    (nat.minus 
                                                                    n 
                                                                    (nat.S m)) 
                                                                    m)))) 
                                                                (lenm:
                                                                 (sttfa.eps 
                                                                    (
                                                                    connectives.Not 
                                                                    (nat.le 
                                                                    n m))) =>
                                                                 logic.eq_ind_r 
                                                                   nat.nat 
                                                                   (nat.plus 
                                                                    m 
                                                                    (nat.plus 
                                                                    (nat.times 
                                                                    (div_mod.div_aux 
                                                                    q 
                                                                    (nat.minus 
                                                                    n 
                                                                    (nat.S m)) 
                                                                    m) 
                                                                    (nat.S m)) 
                                                                    (div_mod.mod_aux 
                                                                    q 
                                                                    (nat.minus 
                                                                    n 
                                                                    (nat.S m)) 
                                                                    m))) 
                                                                   (x:
                                                                    (
                                                                    sttfa.etap 
                                                                    (sttfa.p 
                                                                    nat.nat)) =>
                                                                    logic.eq 
                                                                    nat.nat 
                                                                    n 
                                                                    (nat.S x)) 
                                                                   (logic.eq_ind 
                                                                    nat.nat 
                                                                    (nat.minus 
                                                                    n 
                                                                    (nat.S m)) 
                                                                    (x_1:
                                                                    (sttfa.etap 
                                                                    (sttfa.p 
                                                                    nat.nat)) =>
                                                                    logic.eq 
                                                                    nat.nat 
                                                                    n 
                                                                    (nat.S 
                                                                    (nat.plus 
                                                                    m x_1))) 
                                                                    (logic.eq_coerc 
                                                                    (logic.eq 
                                                                    nat.nat 
                                                                    n 
                                                                    (nat.plus 
                                                                    (nat.minus 
                                                                    n 
                                                                    (nat.S m)) 
                                                                    (nat.S m))) 
                                                                    (logic.eq 
                                                                    nat.nat 
                                                                    n 
                                                                    (nat.S 
                                                                    (nat.plus 
                                                                    m 
                                                                    (nat.minus 
                                                                    n 
                                                                    (nat.S m))))) 
                                                                    (nat.plus_minus_m_m 
                                                                    n 
                                                                    (nat.S m) 
                                                                    (nat.not_le_to_lt 
                                                                    n m lenm)) 
                                                                    (logic.rewrite_r 
                                                                    nat.nat 
                                                                    (nat.pred 
                                                                    (nat.minus 
                                                                    n m)) 
                                                                    (__:
                                                                    (sttfa.etap 
                                                                    (sttfa.p 
                                                                    nat.nat)) =>
                                                                    logic.eq 
                                                                    sttfa.bool 
                                                                    (logic.eq 
                                                                    nat.nat 
                                                                    n 
                                                                    (nat.plus 
                                                                    __ 
                                                                    (nat.S m))) 
                                                                    (logic.eq 
                                                                    nat.nat 
                                                                    n 
                                                                    (nat.S 
                                                                    (nat.plus 
                                                                    m 
                                                                    (nat.minus 
                                                                    n 
                                                                    (nat.S m)))))) 
                                                                    (logic.rewrite_r 
                                                                    nat.nat 
                                                                    (nat.pred 
                                                                    (nat.minus 
                                                                    n m)) 
                                                                    (__:
                                                                    (sttfa.etap 
                                                                    (sttfa.p 
                                                                    nat.nat)) =>
                                                                    logic.eq 
                                                                    sttfa.bool 
                                                                    (logic.eq 
                                                                    nat.nat 
                                                                    n 
                                                                    (nat.plus 
                                                                    (nat.pred 
                                                                    (nat.minus 
                                                                    n m)) 
                                                                    (nat.S m))) 
                                                                    (logic.eq 
                                                                    nat.nat 
                                                                    n 
                                                                    (nat.S 
                                                                    (nat.plus 
                                                                    m __)))) 
                                                                    (logic.rewrite_r 
                                                                    nat.nat 
                                                                    (nat.plus 
                                                                    m 
                                                                    (nat.S 
                                                                    (nat.pred 
                                                                    (nat.minus 
                                                                    n m)))) 
                                                                    (__:
                                                                    (sttfa.etap 
                                                                    (sttfa.p 
                                                                    nat.nat)) =>
                                                                    logic.eq 
                                                                    sttfa.bool 
                                                                    (logic.eq 
                                                                    nat.nat 
                                                                    n 
                                                                    (nat.plus 
                                                                    (nat.pred 
                                                                    (nat.minus 
                                                                    n m)) 
                                                                    (nat.S m))) 
                                                                    (logic.eq 
                                                                    nat.nat 
                                                                    n __)) 
                                                                    (logic.rewrite_r 
                                                                    nat.nat 
                                                                    (nat.plus 
                                                                    m 
                                                                    (nat.S 
                                                                    (nat.pred 
                                                                    (nat.minus 
                                                                    n m)))) 
                                                                    (__:
                                                                    (sttfa.etap 
                                                                    (sttfa.p 
                                                                    nat.nat)) =>
                                                                    logic.eq 
                                                                    sttfa.bool 
                                                                    (logic.eq 
                                                                    nat.nat 
                                                                    n __) 
                                                                    (logic.eq 
                                                                    nat.nat 
                                                                    n 
                                                                    (nat.plus 
                                                                    m 
                                                                    (nat.S 
                                                                    (nat.pred 
                                                                    (nat.minus 
                                                                    n m)))))) 
                                                                    (logic.refl 
                                                                    sttfa.bool 
                                                                    (logic.eq 
                                                                    nat.nat 
                                                                    n 
                                                                    (nat.plus 
                                                                    m 
                                                                    (nat.S 
                                                                    (nat.pred 
                                                                    (nat.minus 
                                                                    n m)))))) 
                                                                    (nat.plus 
                                                                    (nat.pred 
                                                                    (nat.minus 
                                                                    n m)) 
                                                                    (nat.S m)) 
                                                                    (logic.rewrite_l 
                                                                    nat.nat 
                                                                    (nat.S 
                                                                    (nat.plus 
                                                                    (nat.pred 
                                                                    (nat.minus 
                                                                    n m)) m)) 
                                                                    (__:
                                                                    (sttfa.etap 
                                                                    (sttfa.p 
                                                                    nat.nat)) =>
                                                                    logic.eq 
                                                                    nat.nat 
                                                                    __ 
                                                                    (nat.plus 
                                                                    m 
                                                                    (nat.S 
                                                                    (nat.pred 
                                                                    (nat.minus 
                                                                    n m))))) 
                                                                    (logic.rewrite_l 
                                                                    nat.nat 
                                                                    (nat.plus 
                                                                    m 
                                                                    (nat.pred 
                                                                    (nat.minus 
                                                                    n m))) 
                                                                    (__:
                                                                    (sttfa.etap 
                                                                    (sttfa.p 
                                                                    nat.nat)) =>
                                                                    logic.eq 
                                                                    nat.nat 
                                                                    (nat.S __) 
                                                                    (nat.plus 
                                                                    m 
                                                                    (nat.S 
                                                                    (nat.pred 
                                                                    (nat.minus 
                                                                    n m))))) 
                                                                    (nat.plus_n_Sm 
                                                                    m 
                                                                    (nat.pred 
                                                                    (nat.minus 
                                                                    n m))) 
                                                                    (nat.plus 
                                                                    (nat.pred 
                                                                    (nat.minus 
                                                                    n m)) m) 
                                                                    (nat.commutative_plus 
                                                                    m 
                                                                    (nat.pred 
                                                                    (nat.minus 
                                                                    n m)))) 
                                                                    (nat.plus 
                                                                    (nat.pred 
                                                                    (nat.minus 
                                                                    n m)) 
                                                                    (nat.S m)) 
                                                                    (nat.plus_n_Sm 
                                                                    (nat.pred 
                                                                    (nat.minus 
                                                                    n m)) m))) 
                                                                    (nat.S 
                                                                    (nat.plus 
                                                                    m 
                                                                    (nat.pred 
                                                                    (nat.minus 
                                                                    n m)))) 
                                                                    (nat.plus_n_Sm 
                                                                    m 
                                                                    (nat.pred 
                                                                    (nat.minus 
                                                                    n m)))) 
                                                                    (nat.minus 
                                                                    n 
                                                                    (nat.S m)) 
                                                                    (nat.eq_minus_S_pred 
                                                                    n m)) 
                                                                    (nat.minus 
                                                                    n 
                                                                    (nat.S m)) 
                                                                    (nat.eq_minus_S_pred 
                                                                    n m))) 
                                                                    (nat.plus 
                                                                    (nat.times 
                                                                    (div_mod.div_aux 
                                                                    q 
                                                                    (nat.minus 
                                                                    n 
                                                                    (nat.S m)) 
                                                                    m) 
                                                                    (nat.S m)) 
                                                                    (div_mod.mod_aux 
                                                                    q 
                                                                    (nat.minus 
                                                                    n 
                                                                    (nat.S m)) 
                                                                    m)) 
                                                                    (Hind 
                                                                    (nat.minus 
                                                                    n 
                                                                    (nat.S m)) 
                                                                    m)) 
                                                                   (nat.plus 
                                                                    (nat.plus 
                                                                    m 
                                                                    (nat.times 
                                                                    (div_mod.div_aux 
                                                                    q 
                                                                    (nat.minus 
                                                                    n 
                                                                    (nat.S m)) 
                                                                    m) 
                                                                    (nat.S m))) 
                                                                    (div_mod.mod_aux 
                                                                    q 
                                                                    (nat.minus 
                                                                    n 
                                                                    (nat.S m)) 
                                                                    m)) 
                                                                   (nat.associative_plus 
                                                                    m 
                                                                    (nat.times 
                                                                    (div_mod.div_aux 
                                                                    q 
                                                                    (nat.minus 
                                                                    n 
                                                                    (nat.S m)) 
                                                                    m) 
                                                                    (nat.S m)) 
                                                                    (div_mod.mod_aux 
                                                                    q 
                                                                    (nat.minus 
                                                                    n 
                                                                    (nat.S m)) 
                                                                    m))))))))))))))))))))))) 
    p.

def div_mod :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat n 
             (nat.plus (nat.times (div_mod.div n m) m) (div_mod.mod n m)))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.match_nat_prop 
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq nat.nat n 
       (nat.plus (nat.times (div_mod.div n __) __) (div_mod.mod n __))) 
    (nat.sym_eq_times (div_mod.div n nat.O) 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        logic.eq nat.nat n (nat.plus (y nat.O) (div_mod.mod n nat.O))) 
       (nat.sym_eq_match_nat_type_O nat.nat (nat.S n) 
          (p:(sttfa.etap (sttfa.p nat.nat)) => div_mod.div_aux n n p) 
          (y:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat n 
             (nat.plus 
                (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                   nat.times_body y nat.O) 
                (nat.match_nat_type nat.nat n 
                   (p:(sttfa.etap (sttfa.p nat.nat)) => div_mod.mod_aux n n p) 
                   nat.O))) 
          (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
             nat.times_body n 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              logic.eq nat.nat n (nat.plus (y nat.O) (div_mod.mod n nat.O))) 
             (nat.sym_eq_times_body_S n 
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 logic.eq nat.nat n 
                   (nat.plus (y nat.O) (div_mod.mod n nat.O))) 
                (nat.sym_eq_match_nat_type_O nat.nat n 
                   (p:(sttfa.etap (sttfa.p nat.nat)) => div_mod.mod_aux n n p) 
                   (y:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat n 
                      (nat.plus (nat.plus nat.O (nat.times n nat.O)) y)) 
                   (nat.sym_eq_plus nat.O 
                      (y:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       logic.eq nat.nat n 
                         (nat.plus (y (nat.times n nat.O)) n)) 
                      (nat.sym_eq_filter_nat_type_O 
                         (sttfa.arrow nat.nat nat.nat) nat.plus_body 
                         (y:
                          (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                          logic.eq nat.nat n 
                            (nat.plus (y (nat.times n nat.O)) n)) 
                         (nat.sym_eq_plus_body_O 
                            (y:
                             (sttfa.etap 
                                (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                             logic.eq nat.nat n 
                               (nat.plus (y (nat.times n nat.O)) n)) 
                            (logic.rewrite_l nat.nat nat.O 
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq nat.nat n (nat.plus __ n)) 
                               (logic.rewrite_r nat.nat (nat.plus n nat.O) 
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq nat.nat n __) 
                                  (logic.rewrite_l nat.nat n 
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq nat.nat n __) 
                                     (logic.refl nat.nat n) 
                                     (nat.plus n nat.O) (nat.plus_n_O n)) 
                                  (nat.plus nat.O n) 
                                  (nat.commutative_plus nat.O n)) 
                               (nat.times n nat.O) (nat.times_n_O n)))))))))) 
    (auto:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_match_nat_type_S nat.nat (nat.S n) 
       (p:(sttfa.etap (sttfa.p nat.nat)) => div_mod.div_aux n n p) auto 
       (y:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat n 
          (nat.plus (nat.times y (nat.S auto)) 
             (nat.match_nat_type nat.nat n 
                (p:(sttfa.etap (sttfa.p nat.nat)) => div_mod.mod_aux n n p) 
                (nat.S auto)))) 
       (nat.sym_eq_match_nat_type_S nat.nat n 
          (p:(sttfa.etap (sttfa.p nat.nat)) => div_mod.mod_aux n n p) auto 
          (y:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat n 
             (nat.plus (nat.times (div_mod.div_aux n n auto) (nat.S auto)) y)) 
          (logic.rewrite_r nat.nat 
             (nat.plus (nat.times (div_mod.div_aux n n auto) (nat.S auto)) 
                (div_mod.mod_aux n n auto)) 
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat __ 
                (nat.plus 
                   (nat.times (div_mod.div_aux n n auto) (nat.S auto)) 
                   (div_mod.mod_aux n n auto))) 
             (logic.refl nat.nat 
                (nat.plus 
                   (nat.times (div_mod.div_aux n n auto) (nat.S auto)) 
                   (div_mod.mod_aux n n auto))) n 
             (div_mod.div_aux_mod_aux n n auto)))) m.

def eq_times_div_minus_mod :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (a:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (b:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat (nat.times (div_mod.div a b) b) 
             (nat.minus a (div_mod.mod a b)))))
  :=
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.eq_coerc 
    (logic.eq nat.nat (nat.times b (div_mod.div a b)) 
       (nat.minus 
          (nat.plus (nat.times b (div_mod.div a b)) (div_mod.mod a b)) 
          (div_mod.mod a b))) 
    (logic.eq nat.nat (nat.times (div_mod.div a b) b) 
       (nat.minus a (div_mod.mod a b))) 
    (nat.minus_plus_m_m (nat.times b (div_mod.div a b)) (div_mod.mod a b)) 
    (logic.rewrite_r nat.nat 
       (nat.plus (div_mod.mod a b) (nat.times b (div_mod.div a b))) 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq sttfa.bool 
          (logic.eq nat.nat (nat.times b (div_mod.div a b)) 
             (nat.minus __ (div_mod.mod a b))) 
          (logic.eq nat.nat (nat.times (div_mod.div a b) b) 
             (nat.minus a (div_mod.mod a b)))) 
       (logic.rewrite_r nat.nat (nat.times b (div_mod.div a b)) 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq sttfa.bool 
             (logic.eq nat.nat (nat.times b (div_mod.div a b)) 
                (nat.minus 
                   (nat.plus (div_mod.mod a b) 
                      (nat.times b (div_mod.div a b))) (div_mod.mod a b))) 
             (logic.eq nat.nat __ (nat.minus a (div_mod.mod a b)))) 
          (logic.rewrite_l nat.nat a 
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq sttfa.bool 
                (logic.eq nat.nat (nat.times b (div_mod.div a b)) 
                   (nat.minus __ (div_mod.mod a b))) 
                (logic.eq nat.nat (nat.times b (div_mod.div a b)) 
                   (nat.minus a (div_mod.mod a b)))) 
             (logic.refl sttfa.bool 
                (logic.eq nat.nat (nat.times b (div_mod.div a b)) 
                   (nat.minus a (div_mod.mod a b)))) 
             (nat.plus (div_mod.mod a b) (nat.times b (div_mod.div a b))) 
             (logic.rewrite_l nat.nat 
                (nat.plus (nat.times b (div_mod.div a b)) (div_mod.mod a b)) 
                (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat a __) 
                (logic.rewrite_l nat.nat (nat.times (div_mod.div a b) b) 
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat a (nat.plus __ (div_mod.mod a b))) 
                   (div_mod.div_mod a b) (nat.times b (div_mod.div a b)) 
                   (nat.commutative_times (div_mod.div a b) b)) 
                (nat.plus (div_mod.mod a b) (nat.times b (div_mod.div a b))) 
                (nat.commutative_plus (nat.times b (div_mod.div a b)) 
                   (div_mod.mod a b)))) (nat.times (div_mod.div a b) b) 
          (nat.commutative_times (div_mod.div a b) b)) 
       (nat.plus (nat.times b (div_mod.div a b)) (div_mod.mod a b)) 
       (nat.commutative_plus (nat.times b (div_mod.div a b)) 
          (div_mod.mod a b))).

div_mod_spec :
  sttfa.etap 
    (sttfa.p 
       (sttfa.arrow nat.nat 
          (sttfa.arrow nat.nat 
             (sttfa.arrow nat.nat (sttfa.arrow nat.nat sttfa.bool))))).

div_mod_spec_intro :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (q:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat 
                (r:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (nat.lt r m) 
                   (sttfa.impl 
                      (logic.eq nat.nat n (nat.plus (nat.times q m) r)) 
                      (div_mod.div_mod_spec n m q r))))))).

match_div_mod_spec_prop :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (q:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat 
                (r:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall sttfa.bool 
                   (return:(sttfa.etap (sttfa.p sttfa.bool)) =>
                    sttfa.impl 
                      (sttfa.impl (nat.lt r m) 
                         (sttfa.impl 
                            (logic.eq nat.nat n (nat.plus (nat.times q m) r)) 
                            return)) 
                      (sttfa.impl (div_mod.div_mod_spec n m q r) return))))))).

def div_mod_spec_div_mod :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.lt nat.O m) 
             (div_mod.div_mod_spec n m (div_mod.div n m) (div_mod.mod n m)))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  posm:(sttfa.eps (nat.lt nat.O m)) =>
  div_mod.div_mod_spec_intro n m (div_mod.div n m) (div_mod.mod n m) 
    (div_mod.lt_mod_m_m n m posm) 
    (logic.rewrite_r nat.nat (nat.times m (div_mod.div n m)) 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat n (nat.plus __ (div_mod.mod n m))) 
       (logic.rewrite_r nat.nat 
          (nat.plus (div_mod.mod n m) (nat.times m (div_mod.div n m))) 
          (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat n __) 
          (logic.rewrite_l nat.nat n 
             (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat n __) 
             (logic.refl nat.nat n) 
             (nat.plus (div_mod.mod n m) (nat.times m (div_mod.div n m))) 
             (logic.rewrite_l nat.nat 
                (nat.plus (nat.times m (div_mod.div n m)) (div_mod.mod n m)) 
                (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat n __) 
                (logic.rewrite_l nat.nat (nat.times (div_mod.div n m) m) 
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat n (nat.plus __ (div_mod.mod n m))) 
                   (div_mod.div_mod n m) (nat.times m (div_mod.div n m)) 
                   (nat.commutative_times (div_mod.div n m) m)) 
                (nat.plus (div_mod.mod n m) (nat.times m (div_mod.div n m))) 
                (nat.commutative_plus (nat.times m (div_mod.div n m)) 
                   (div_mod.mod n m)))) 
          (nat.plus (nat.times m (div_mod.div n m)) (div_mod.mod n m)) 
          (nat.commutative_plus (nat.times m (div_mod.div n m)) 
             (div_mod.mod n m))) (nat.times (div_mod.div n m) m) 
       (nat.commutative_times (div_mod.div n m) m)).

def let_clause_1078 :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (a:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (b:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (q:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat 
                (r:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall nat.nat 
                   (q1:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.forall nat.nat 
                      (r1:(sttfa.etap (sttfa.p nat.nat)) =>
                       sttfa.impl (div_mod.div_mod_spec a b q r) 
                         (sttfa.impl (nat.lt r b) 
                            (sttfa.impl 
                               (logic.eq nat.nat a 
                                  (nat.plus (nat.times q b) r)) 
                               (sttfa.impl (div_mod.div_mod_spec a b q1 r1) 
                                  (sttfa.impl (nat.lt r1 b) 
                                     (sttfa.impl 
                                        (logic.eq nat.nat a 
                                           (nat.plus (nat.times q1 b) r1)) 
                                        (sttfa.impl (nat.le q q1) 
                                           (sttfa.impl (nat.lt q q1) 
                                              (logic.eq nat.nat a 
                                                 (nat.plus r (nat.times b q)))))))))))))))))
  :=
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  q:(sttfa.etap (sttfa.p nat.nat)) =>
  r:(sttfa.etap (sttfa.p nat.nat)) =>
  q1:(sttfa.etap (sttfa.p nat.nat)) =>
  r1:(sttfa.etap (sttfa.p nat.nat)) =>
  _clearme:(sttfa.eps (div_mod.div_mod_spec a b q r)) =>
  ltrb:(sttfa.eps (nat.lt r b)) =>
  spec:(sttfa.eps (logic.eq nat.nat a (nat.plus (nat.times q b) r))) =>
  _clearme0:(sttfa.eps (div_mod.div_mod_spec a b q1 r1)) =>
  ltr1b:(sttfa.eps (nat.lt r1 b)) =>
  spec1:(sttfa.eps (logic.eq nat.nat a (nat.plus (nat.times q1 b) r1))) =>
  leqq1:(sttfa.eps (nat.le q q1)) =>
  ltqq1:(sttfa.eps (nat.lt q q1)) =>
  logic.rewrite_l nat.nat (nat.plus (nat.times b q) r) 
    (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat a __) 
    (logic.rewrite_l nat.nat (nat.times q b) 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat a (nat.plus __ r)) spec (nat.times b q) 
       (nat.commutative_times q b)) (nat.plus r (nat.times b q)) 
    (nat.commutative_plus (nat.times b q) r).

def let_clause_1062 :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (a:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (b:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (q:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat 
                (r:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall nat.nat 
                   (q1:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.forall nat.nat 
                      (r1:(sttfa.etap (sttfa.p nat.nat)) =>
                       sttfa.impl (div_mod.div_mod_spec a b q r) 
                         (sttfa.impl (nat.lt r b) 
                            (sttfa.impl 
                               (logic.eq nat.nat a 
                                  (nat.plus (nat.times q b) r)) 
                               (sttfa.impl (div_mod.div_mod_spec a b q1 r1) 
                                  (sttfa.impl (nat.lt r1 b) 
                                     (sttfa.impl 
                                        (logic.eq nat.nat a 
                                           (nat.plus (nat.times q1 b) r1)) 
                                        (sttfa.impl 
                                           (connectives.Not (nat.le q q1)) 
                                           (logic.eq nat.nat a 
                                              (nat.plus r1 (nat.times b q1))))))))))))))))
  :=
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  q:(sttfa.etap (sttfa.p nat.nat)) =>
  r:(sttfa.etap (sttfa.p nat.nat)) =>
  q1:(sttfa.etap (sttfa.p nat.nat)) =>
  r1:(sttfa.etap (sttfa.p nat.nat)) =>
  _clearme:(sttfa.eps (div_mod.div_mod_spec a b q r)) =>
  ltrb:(sttfa.eps (nat.lt r b)) =>
  spec:(sttfa.eps (logic.eq nat.nat a (nat.plus (nat.times q b) r))) =>
  _clearme0:(sttfa.eps (div_mod.div_mod_spec a b q1 r1)) =>
  ltr1b:(sttfa.eps (nat.lt r1 b)) =>
  spec1:(sttfa.eps (logic.eq nat.nat a (nat.plus (nat.times q1 b) r1))) =>
  leqq1:(sttfa.eps (connectives.Not (nat.le q q1))) =>
  logic.rewrite_l nat.nat (nat.plus (nat.times b q1) r1) 
    (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat a __) 
    (logic.rewrite_l nat.nat (nat.times q1 b) 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat a (nat.plus __ r1)) spec1 (nat.times b q1) 
       (nat.commutative_times q1 b)) (nat.plus r1 (nat.times b q1)) 
    (nat.commutative_plus (nat.times b q1) r1).

def div_mod_spec_to_eq :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (a:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (b:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (q:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat 
                (r:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall nat.nat 
                   (q1:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.forall nat.nat 
                      (r1:(sttfa.etap (sttfa.p nat.nat)) =>
                       sttfa.impl (div_mod.div_mod_spec a b q r) 
                         (sttfa.impl (div_mod.div_mod_spec a b q1 r1) 
                            (logic.eq nat.nat q q1)))))))))
  :=
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  q:(sttfa.etap (sttfa.p nat.nat)) =>
  r:(sttfa.etap (sttfa.p nat.nat)) =>
  q1:(sttfa.etap (sttfa.p nat.nat)) =>
  r1:(sttfa.etap (sttfa.p nat.nat)) =>
  _clearme:(sttfa.eps (div_mod.div_mod_spec a b q r)) =>
  div_mod.match_div_mod_spec_prop a b q r 
    (sttfa.impl (div_mod.div_mod_spec a b q1 r1) (logic.eq nat.nat q q1)) 
    (ltrb:(sttfa.eps (nat.lt r b)) =>
     spec:(sttfa.eps (logic.eq nat.nat a (nat.plus (nat.times q b) r))) =>
     _clearme0:(sttfa.eps (div_mod.div_mod_spec a b q1 r1)) =>
     div_mod.match_div_mod_spec_prop a b q1 r1 (logic.eq nat.nat q q1) 
       (ltr1b:(sttfa.eps (nat.lt r1 b)) =>
        spec1:
        (sttfa.eps (logic.eq nat.nat a (nat.plus (nat.times q1 b) r1))) =>
        nat.leb_elim q q1 
          (__:(sttfa.etap (sttfa.p bool.bool)) => logic.eq nat.nat q q1) 
          (leqq1:(sttfa.eps (nat.le q q1)) =>
           logic.match_Or_prop (nat.lt q q1) (logic.eq nat.nat q q1) 
             (logic.eq nat.nat q q1) 
             (ltqq1:(sttfa.eps (nat.lt q q1)) =>
              logic.falsity (logic.eq nat.nat q q1) 
                (logic.absurd (nat.le (nat.S a) a) 
                   (nat.lt_to_le_to_lt a (nat.times (nat.S q) b) a 
                      (logic.eq_ind_r nat.nat (nat.plus (nat.times q b) r) 
                         (x:(sttfa.etap (sttfa.p nat.nat)) =>
                          nat.lt x (nat.times (nat.S q) b)) 
                         (logic.eq_coerc 
                            (nat.lt (nat.plus (nat.times q b) r) 
                               (nat.plus (nat.times q b) b)) 
                            (nat.lt (nat.plus (nat.times q b) r) 
                               (nat.times (nat.S q) b)) 
                            (nat.monotonic_lt_plus_r (nat.times q b) r b ltrb) 
                            (logic.rewrite_r nat.nat (nat.times b q) 
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq sttfa.bool 
                                  (nat.lt (nat.plus __ r) (nat.plus __ b)) 
                                  (nat.lt (nat.plus __ r) 
                                     (nat.times (nat.S q) b))) 
                               (logic.rewrite_r nat.nat 
                                  (nat.plus r (nat.times b q)) 
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq sttfa.bool 
                                     (nat.lt (nat.plus (nat.times b q) r) 
                                        (nat.plus (nat.times b q) b)) 
                                     (nat.lt __ (nat.times (nat.S q) b))) 
                                  (logic.rewrite_l nat.nat a 
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq sttfa.bool 
                                        (nat.lt (nat.plus (nat.times b q) r) 
                                           (nat.plus (nat.times b q) b)) 
                                        (nat.lt __ (nat.times (nat.S q) b))) 
                                     (logic.rewrite_r nat.nat 
                                        (nat.times b (nat.S q)) 
                                        (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq sttfa.bool 
                                           (nat.lt 
                                              (nat.plus (nat.times b q) r) 
                                              (nat.plus (nat.times b q) b)) 
                                           (nat.lt a __)) 
                                        (logic.rewrite_l nat.nat 
                                           (nat.plus b (nat.times b q)) 
                                           (__:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq sttfa.bool 
                                              (nat.lt 
                                                 (nat.plus (nat.times b q) r) 
                                                 (nat.plus (nat.times b q) b)) 
                                              (nat.lt a __)) 
                                           (logic.rewrite_r nat.nat 
                                              (nat.plus r (nat.times b q)) 
                                              (__:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq sttfa.bool 
                                                 (nat.lt __ 
                                                    (nat.plus 
                                                       (nat.times b q) b)) 
                                                 (nat.lt a 
                                                    (nat.plus b 
                                                       (nat.times b q)))) 
                                              (logic.rewrite_l nat.nat a 
                                                 (__:
                                                  (sttfa.etap 
                                                     (sttfa.p nat.nat)) =>
                                                  logic.eq sttfa.bool 
                                                    (nat.lt __ 
                                                       (nat.plus 
                                                          (nat.times b q) b)) 
                                                    (nat.lt a 
                                                       (nat.plus b 
                                                          (nat.times b q)))) 
                                                 (logic.rewrite_r nat.nat 
                                                    (nat.plus b 
                                                       (nat.times b q)) 
                                                    (__:
                                                     (sttfa.etap 
                                                        (sttfa.p nat.nat)) =>
                                                     logic.eq sttfa.bool 
                                                       (nat.lt a __) 
                                                       (nat.lt a 
                                                          (nat.plus b 
                                                             (nat.times b q)))) 
                                                    (logic.refl sttfa.bool 
                                                       (nat.lt a 
                                                          (nat.plus b 
                                                             (nat.times b q)))) 
                                                    (nat.plus 
                                                       (nat.times b q) b) 
                                                    (nat.commutative_plus 
                                                       (nat.times b q) b)) 
                                                 (nat.plus r (nat.times b q)) 
                                                 (div_mod.let_clause_1078 a 
                                                    b q r q1 r1 _clearme 
                                                    ltrb spec _clearme0 
                                                    ltr1b spec1 leqq1 ltqq1)) 
                                              (nat.plus (nat.times b q) r) 
                                              (nat.commutative_plus 
                                                 (nat.times b q) r)) 
                                           (nat.times b (nat.S q)) 
                                           (nat.times_n_Sm b q)) 
                                        (nat.times (nat.S q) b) 
                                        (nat.commutative_times (nat.S q) b)) 
                                     (nat.plus r (nat.times b q)) 
                                     (div_mod.let_clause_1078 a b q r q1 r1 
                                        _clearme ltrb spec _clearme0 ltr1b 
                                        spec1 leqq1 ltqq1)) 
                                  (nat.plus (nat.times b q) r) 
                                  (nat.commutative_plus (nat.times b q) r)) 
                               (nat.times q b) (nat.commutative_times q b))) 
                         a spec) 
                      (nat.transitive_le (nat.times (nat.S q) b) 
                         (nat.times q1 b) a 
                         (logic.eq_coerc 
                            (nat.le (nat.times b (nat.S q)) (nat.times b q1)) 
                            (nat.le (nat.times (nat.S q) b) (nat.times q1 b)) 
                            (nat.monotonic_le_times_r b (nat.S q) q1 ltqq1) 
                            (logic.rewrite_r nat.nat (nat.times b (nat.S q)) 
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq sttfa.bool 
                                  (nat.le (nat.times b (nat.S q)) 
                                     (nat.times b q1)) 
                                  (nat.le __ (nat.times q1 b))) 
                               (logic.rewrite_l nat.nat 
                                  (nat.plus b (nat.times b q)) 
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq sttfa.bool 
                                     (nat.le (nat.times b (nat.S q)) 
                                        (nat.times b q1)) 
                                     (nat.le __ (nat.times q1 b))) 
                                  (logic.rewrite_r nat.nat (nat.times b q1) 
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq sttfa.bool 
                                        (nat.le (nat.times b (nat.S q)) 
                                           (nat.times b q1)) 
                                        (nat.le (nat.plus b (nat.times b q)) 
                                           __)) 
                                     (logic.rewrite_l nat.nat 
                                        (nat.plus b (nat.times b q)) 
                                        (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq sttfa.bool 
                                           (nat.le __ (nat.times b q1)) 
                                           (nat.le 
                                              (nat.plus b (nat.times b q)) 
                                              (nat.times b q1))) 
                                        (logic.refl sttfa.bool 
                                           (nat.le 
                                              (nat.plus b (nat.times b q)) 
                                              (nat.times b q1))) 
                                        (nat.times b (nat.S q)) 
                                        (nat.times_n_Sm b q)) 
                                     (nat.times q1 b) 
                                     (nat.commutative_times q1 b)) 
                                  (nat.times b (nat.S q)) 
                                  (nat.times_n_Sm b q)) 
                               (nat.times (nat.S q) b) 
                               (nat.commutative_times (nat.S q) b))) 
                         (logic.eq_coerc 
                            (nat.le (nat.times q1 b) 
                               (nat.plus (nat.times q1 b) r1)) 
                            (nat.le (nat.times q1 b) a) 
                            (nat.le_plus_n_r r1 (nat.times q1 b)) 
                            (logic.rewrite_r nat.nat (nat.times b q1) 
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq sttfa.bool 
                                  (nat.le __ (nat.plus __ r1)) (nat.le __ a)) 
                               (logic.rewrite_r nat.nat 
                                  (nat.plus r1 (nat.times b q1)) 
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq sttfa.bool 
                                     (nat.le (nat.times b q1) __) 
                                     (nat.le (nat.times b q1) a)) 
                                  (logic.rewrite_l nat.nat a 
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq sttfa.bool 
                                        (nat.le (nat.times b q1) __) 
                                        (nat.le (nat.times b q1) a)) 
                                     (logic.refl sttfa.bool 
                                        (nat.le (nat.times b q1) a)) 
                                     (nat.plus r1 (nat.times b q1)) 
                                     (logic.rewrite_l nat.nat 
                                        (nat.plus (nat.times b q1) r1) 
                                        (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq nat.nat a __) 
                                        (logic.rewrite_l nat.nat 
                                           (nat.times q1 b) 
                                           (__:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq nat.nat a 
                                              (nat.plus __ r1)) spec1 
                                           (nat.times b q1) 
                                           (nat.commutative_times q1 b)) 
                                        (nat.plus r1 (nat.times b q1)) 
                                        (nat.commutative_plus 
                                           (nat.times b q1) r1))) 
                                  (nat.plus (nat.times b q1) r1) 
                                  (nat.commutative_plus (nat.times b q1) r1)) 
                               (nat.times q1 b) (nat.commutative_times q1 b))))) 
                   (nat.not_le_Sn_n a))) 
             (_x_172:(sttfa.eps (logic.eq nat.nat q q1)) =>
              logic.rewrite_l nat.nat q 
                (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat q __) 
                (logic.refl nat.nat q) q1 _x_172) 
             (nat.le_to_or_lt_eq q q1 leqq1)) 
          (leqq1:(sttfa.eps (connectives.Not (nat.le q q1))) =>
           logic.falsity (logic.eq nat.nat q q1) 
             (logic.absurd (nat.le (nat.S a) a) 
                (nat.lt_to_le_to_lt a (nat.times (nat.S q1) b) a 
                   (logic.eq_ind_r nat.nat (nat.plus (nat.times q1 b) r1) 
                      (x:(sttfa.etap (sttfa.p nat.nat)) =>
                       nat.lt x (nat.times (nat.S q1) b)) 
                      (logic.eq_coerc 
                         (nat.lt (nat.plus (nat.times q1 b) r1) 
                            (nat.plus (nat.times q1 b) b)) 
                         (nat.lt (nat.plus (nat.times q1 b) r1) 
                            (nat.times (nat.S q1) b)) 
                         (nat.monotonic_lt_plus_r (nat.times q1 b) r1 b ltr1b) 
                         (logic.rewrite_r nat.nat (nat.times b q1) 
                            (__:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq sttfa.bool 
                               (nat.lt (nat.plus __ r1) (nat.plus __ b)) 
                               (nat.lt (nat.plus __ r1) 
                                  (nat.times (nat.S q1) b))) 
                            (logic.rewrite_r nat.nat 
                               (nat.plus r1 (nat.times b q1)) 
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq sttfa.bool 
                                  (nat.lt (nat.plus (nat.times b q1) r1) 
                                     (nat.plus (nat.times b q1) b)) 
                                  (nat.lt __ (nat.times (nat.S q1) b))) 
                               (logic.rewrite_l nat.nat a 
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq sttfa.bool 
                                     (nat.lt (nat.plus (nat.times b q1) r1) 
                                        (nat.plus (nat.times b q1) b)) 
                                     (nat.lt __ (nat.times (nat.S q1) b))) 
                                  (logic.rewrite_r nat.nat 
                                     (nat.times b (nat.S q1)) 
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq sttfa.bool 
                                        (nat.lt 
                                           (nat.plus (nat.times b q1) r1) 
                                           (nat.plus (nat.times b q1) b)) 
                                        (nat.lt a __)) 
                                     (logic.rewrite_l nat.nat 
                                        (nat.plus b (nat.times b q1)) 
                                        (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq sttfa.bool 
                                           (nat.lt 
                                              (nat.plus (nat.times b q1) r1) 
                                              (nat.plus (nat.times b q1) b)) 
                                           (nat.lt a __)) 
                                        (logic.rewrite_r nat.nat 
                                           (nat.plus r1 (nat.times b q1)) 
                                           (__:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq sttfa.bool 
                                              (nat.lt __ 
                                                 (nat.plus (nat.times b q1) b)) 
                                              (nat.lt a 
                                                 (nat.plus b (nat.times b q1)))) 
                                           (logic.rewrite_l nat.nat a 
                                              (__:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq sttfa.bool 
                                                 (nat.lt __ 
                                                    (nat.plus 
                                                       (nat.times b q1) b)) 
                                                 (nat.lt a 
                                                    (nat.plus b 
                                                       (nat.times b q1)))) 
                                              (logic.rewrite_r nat.nat 
                                                 (nat.plus b (nat.times b q1)) 
                                                 (__:
                                                  (sttfa.etap 
                                                     (sttfa.p nat.nat)) =>
                                                  logic.eq sttfa.bool 
                                                    (nat.lt a __) 
                                                    (nat.lt a 
                                                       (nat.plus b 
                                                          (nat.times b q1)))) 
                                                 (logic.refl sttfa.bool 
                                                    (nat.lt a 
                                                       (nat.plus b 
                                                          (nat.times b q1)))) 
                                                 (nat.plus (nat.times b q1) b) 
                                                 (nat.commutative_plus 
                                                    (nat.times b q1) b)) 
                                              (nat.plus r1 (nat.times b q1)) 
                                              (div_mod.let_clause_1062 a b q 
                                                 r q1 r1 _clearme ltrb spec 
                                                 _clearme0 ltr1b spec1 leqq1)) 
                                           (nat.plus (nat.times b q1) r1) 
                                           (nat.commutative_plus 
                                              (nat.times b q1) r1)) 
                                        (nat.times b (nat.S q1)) 
                                        (nat.times_n_Sm b q1)) 
                                     (nat.times (nat.S q1) b) 
                                     (nat.commutative_times (nat.S q1) b)) 
                                  (nat.plus r1 (nat.times b q1)) 
                                  (div_mod.let_clause_1062 a b q r q1 r1 
                                     _clearme ltrb spec _clearme0 ltr1b 
                                     spec1 leqq1)) 
                               (nat.plus (nat.times b q1) r1) 
                               (nat.commutative_plus (nat.times b q1) r1)) 
                            (nat.times q1 b) (nat.commutative_times q1 b))) 
                      a spec1) 
                   (nat.transitive_le (nat.times (nat.S q1) b) 
                      (nat.times q b) a 
                      (logic.eq_coerc 
                         (nat.le (nat.times b (nat.S q1)) (nat.times b q)) 
                         (nat.le (nat.times (nat.S q1) b) (nat.times q b)) 
                         (nat.monotonic_le_times_r b (nat.S q1) q 
                            (nat.not_le_to_lt q q1 leqq1)) 
                         (logic.rewrite_r nat.nat (nat.times b (nat.S q1)) 
                            (__:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq sttfa.bool 
                               (nat.le (nat.times b (nat.S q1)) 
                                  (nat.times b q)) 
                               (nat.le __ (nat.times q b))) 
                            (logic.rewrite_l nat.nat 
                               (nat.plus b (nat.times b q1)) 
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq sttfa.bool 
                                  (nat.le (nat.times b (nat.S q1)) 
                                     (nat.times b q)) 
                                  (nat.le __ (nat.times q b))) 
                               (logic.rewrite_r nat.nat (nat.times b q) 
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq sttfa.bool 
                                     (nat.le (nat.times b (nat.S q1)) 
                                        (nat.times b q)) 
                                     (nat.le (nat.plus b (nat.times b q1)) __)) 
                                  (logic.rewrite_l nat.nat 
                                     (nat.plus b (nat.times b q1)) 
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq sttfa.bool 
                                        (nat.le __ (nat.times b q)) 
                                        (nat.le 
                                           (nat.plus b (nat.times b q1)) 
                                           (nat.times b q))) 
                                     (logic.refl sttfa.bool 
                                        (nat.le 
                                           (nat.plus b (nat.times b q1)) 
                                           (nat.times b q))) 
                                     (nat.times b (nat.S q1)) 
                                     (nat.times_n_Sm b q1)) (nat.times q b) 
                                  (nat.commutative_times q b)) 
                               (nat.times b (nat.S q1)) (nat.times_n_Sm b q1)) 
                            (nat.times (nat.S q1) b) 
                            (nat.commutative_times (nat.S q1) b))) 
                      (logic.eq_coerc 
                         (nat.le (nat.times q b) (nat.plus (nat.times q b) r)) 
                         (nat.le (nat.times q b) a) 
                         (nat.le_plus_n_r r (nat.times q b)) 
                         (logic.rewrite_r nat.nat (nat.times b q) 
                            (__:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq sttfa.bool (nat.le __ (nat.plus __ r)) 
                               (nat.le __ a)) 
                            (logic.rewrite_r nat.nat 
                               (nat.plus r (nat.times b q)) 
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq sttfa.bool 
                                  (nat.le (nat.times b q) __) 
                                  (nat.le (nat.times b q) a)) 
                               (logic.rewrite_l nat.nat a 
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq sttfa.bool 
                                     (nat.le (nat.times b q) __) 
                                     (nat.le (nat.times b q) a)) 
                                  (logic.refl sttfa.bool 
                                     (nat.le (nat.times b q) a)) 
                                  (nat.plus r (nat.times b q)) 
                                  (logic.rewrite_l nat.nat 
                                     (nat.plus (nat.times b q) r) 
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq nat.nat a __) 
                                     (logic.rewrite_l nat.nat 
                                        (nat.times q b) 
                                        (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq nat.nat a (nat.plus __ r)) 
                                        spec (nat.times b q) 
                                        (nat.commutative_times q b)) 
                                     (nat.plus r (nat.times b q)) 
                                     (nat.commutative_plus (nat.times b q) r))) 
                               (nat.plus (nat.times b q) r) 
                               (nat.commutative_plus (nat.times b q) r)) 
                            (nat.times q b) (nat.commutative_times q b))))) 
                (nat.not_le_Sn_n a)))) _clearme0) _clearme.

def div_mod_spec_to_eq2 :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (a:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (b:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (q:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat 
                (r:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall nat.nat 
                   (q1:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.forall nat.nat 
                      (r1:(sttfa.etap (sttfa.p nat.nat)) =>
                       sttfa.impl (div_mod.div_mod_spec a b q r) 
                         (sttfa.impl (div_mod.div_mod_spec a b q1 r1) 
                            (logic.eq nat.nat r r1)))))))))
  :=
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  q:(sttfa.etap (sttfa.p nat.nat)) =>
  r:(sttfa.etap (sttfa.p nat.nat)) =>
  q1:(sttfa.etap (sttfa.p nat.nat)) =>
  r1:(sttfa.etap (sttfa.p nat.nat)) =>
  spec:(sttfa.eps (div_mod.div_mod_spec a b q r)) =>
  spec1:(sttfa.eps (div_mod.div_mod_spec a b q1 r1)) =>
  div_mod.match_div_mod_spec_prop a b q r (logic.eq nat.nat r r1) 
    (__:(sttfa.eps (nat.lt r b)) =>
     eqa:(sttfa.eps (logic.eq nat.nat a (nat.plus (nat.times q b) r))) =>
     div_mod.match_div_mod_spec_prop a b q1 r1 (logic.eq nat.nat r r1) 
       (_0:(sttfa.eps (nat.lt r1 b)) =>
        eqa1:
        (sttfa.eps (logic.eq nat.nat a (nat.plus (nat.times q1 b) r1))) =>
        nat.injective_plus_r (nat.times q b) r r1 
          (logic.rewrite_r nat.nat (nat.times b q) 
             (__1:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat (nat.plus __1 r) (nat.plus (nat.times q b) r1)) 
             (logic.rewrite_r nat.nat (nat.plus r (nat.times b q)) 
                (__1:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat __1 (nat.plus (nat.times q b) r1)) 
                (logic.rewrite_l nat.nat a 
                   (__1:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat __1 (nat.plus (nat.times q b) r1)) 
                   (logic.rewrite_r nat.nat (nat.times b q) 
                      (__1:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat a (nat.plus __1 r1)) 
                      (logic.rewrite_r nat.nat (nat.plus r1 (nat.times b q)) 
                         (__1:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat a __1) 
                         (logic.rewrite_l nat.nat a 
                            (__1:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq nat.nat a __1) (logic.refl nat.nat a) 
                            (nat.plus r1 (nat.times b q)) 
                            (logic.rewrite_r nat.nat q1 
                               (__1:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq nat.nat a 
                                  (nat.plus r1 (nat.times b __1))) 
                               (logic.rewrite_l nat.nat 
                                  (nat.plus (nat.times b q1) r1) 
                                  (__1:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq nat.nat a __1) 
                                  (logic.rewrite_l nat.nat (nat.times q1 b) 
                                     (__1:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq nat.nat a (nat.plus __1 r1)) 
                                     eqa1 (nat.times b q1) 
                                     (nat.commutative_times q1 b)) 
                                  (nat.plus r1 (nat.times b q1)) 
                                  (nat.commutative_plus (nat.times b q1) r1)) 
                               q 
                               (div_mod.div_mod_spec_to_eq a b q r q1 r1 
                                  spec spec1))) 
                         (nat.plus (nat.times b q) r1) 
                         (nat.commutative_plus (nat.times b q) r1)) 
                      (nat.times q b) (nat.commutative_times q b)) 
                   (nat.plus r (nat.times b q)) 
                   (logic.rewrite_l nat.nat (nat.plus (nat.times b q) r) 
                      (__1:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat a __1) 
                      (logic.rewrite_l nat.nat (nat.times q b) 
                         (__1:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat a (nat.plus __1 r)) eqa 
                         (nat.times b q) (nat.commutative_times q b)) 
                      (nat.plus r (nat.times b q)) 
                      (nat.commutative_plus (nat.times b q) r))) 
                (nat.plus (nat.times b q) r) 
                (nat.commutative_plus (nat.times b q) r)) (nat.times q b) 
             (nat.commutative_times q b))) spec1) spec.

def div_times :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (a:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (b:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.lt nat.O b) 
             (logic.eq nat.nat (div_mod.div (nat.times a b) b) a))))
  :=
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  posb:(sttfa.eps (nat.lt nat.O b)) =>
  div_mod.div_mod_spec_to_eq (nat.times a b) b 
    (div_mod.div (nat.times a b) b) (div_mod.mod (nat.times a b) b) a nat.O 
    (div_mod.div_mod_spec_div_mod (nat.times a b) b posb) 
    (div_mod.div_mod_spec_intro (nat.times a b) b a nat.O posb 
       (logic.rewrite_r nat.nat (nat.plus nat.O (nat.times a b)) 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat (nat.times a b) __) 
          (logic.rewrite_l nat.nat (nat.times a b) 
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat (nat.times a b) __) 
             (logic.refl nat.nat (nat.times a b)) 
             (nat.plus nat.O (nat.times a b)) (nat.plus_O_n (nat.times a b))) 
          (nat.plus (nat.times a b) nat.O) 
          (nat.commutative_plus (nat.times a b) nat.O))).

def eq_div_O :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.lt n m) (logic.eq nat.nat (div_mod.div n m) nat.O))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  ltnm:(sttfa.eps (nat.lt n m)) =>
  div_mod.div_mod_spec_to_eq n m (div_mod.div n m) (div_mod.mod n m) nat.O n 
    (div_mod.div_mod_spec_div_mod n m (nat.ltn_to_ltO n m ltnm)) 
    (div_mod.div_mod_spec_intro n m nat.O n ltnm 
       (logic.rewrite_r nat.nat (nat.times m nat.O) 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat n (nat.plus __ n)) 
          (logic.rewrite_l nat.nat nat.O 
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat n (nat.plus __ n)) 
             (logic.rewrite_r nat.nat (nat.plus n nat.O) 
                (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat n __) 
                (logic.rewrite_l nat.nat n 
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat n __) (logic.refl nat.nat n) 
                   (nat.plus n nat.O) (nat.plus_n_O n)) (nat.plus nat.O n) 
                (nat.commutative_plus nat.O n)) (nat.times m nat.O) 
             (nat.times_n_O m)) (nat.times nat.O m) 
          (nat.commutative_times nat.O m))).

def mod_O_n :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat (div_mod.mod nat.O n) nat.O))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.sym_eq nat.nat nat.O (div_mod.mod nat.O n) 
    (logic.eq_coerc (logic.eq nat.nat nat.O (div_mod.mod nat.O n)) 
       (logic.eq nat.nat nat.O (div_mod.mod nat.O n)) 
       (nat.le_n_O_to_eq (div_mod.mod nat.O n) 
          (logic.eq_coerc 
             (nat.le 
                (nat.minus 
                   (nat.plus (div_mod.mod nat.O n) 
                      (nat.times n (div_mod.div nat.O n))) 
                   (nat.plus nat.O (nat.times n (div_mod.div nat.O n)))) 
                (nat.plus (div_mod.mod nat.O n) 
                   (nat.times n (div_mod.div nat.O n)))) 
             (nat.le (div_mod.mod nat.O n) nat.O) 
             (nat.minus_le 
                (nat.plus (div_mod.mod nat.O n) 
                   (nat.times n (div_mod.div nat.O n))) 
                (nat.plus nat.O (nat.times n (div_mod.div nat.O n)))) 
             (logic.rewrite_r nat.nat 
                (nat.minus (div_mod.mod nat.O n) nat.O) 
                (__:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq sttfa.bool 
                   (nat.le __ 
                      (nat.plus (div_mod.mod nat.O n) 
                         (nat.times n (div_mod.div nat.O n)))) 
                   (nat.le (div_mod.mod nat.O n) nat.O)) 
                (logic.rewrite_l nat.nat (div_mod.mod nat.O n) 
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq sttfa.bool 
                      (nat.le __ 
                         (nat.plus (div_mod.mod nat.O n) 
                            (nat.times n (div_mod.div nat.O n)))) 
                      (nat.le (div_mod.mod nat.O n) nat.O)) 
                   (logic.rewrite_l nat.nat nat.O 
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq sttfa.bool (nat.le (div_mod.mod nat.O n) __) 
                         (nat.le (div_mod.mod nat.O n) nat.O)) 
                      (logic.refl sttfa.bool 
                         (nat.le (div_mod.mod nat.O n) nat.O)) 
                      (nat.plus (div_mod.mod nat.O n) 
                         (nat.times n (div_mod.div nat.O n))) 
                      (logic.rewrite_l nat.nat 
                         (nat.plus (nat.times n (div_mod.div nat.O n)) 
                            (div_mod.mod nat.O n)) 
                         (__:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat nat.O __) 
                         (logic.rewrite_l nat.nat 
                            (nat.times (div_mod.div nat.O n) n) 
                            (__:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq nat.nat nat.O 
                               (nat.plus __ (div_mod.mod nat.O n))) 
                            (div_mod.div_mod nat.O n) 
                            (nat.times n (div_mod.div nat.O n)) 
                            (nat.commutative_times (div_mod.div nat.O n) n)) 
                         (nat.plus (div_mod.mod nat.O n) 
                            (nat.times n (div_mod.div nat.O n))) 
                         (nat.commutative_plus 
                            (nat.times n (div_mod.div nat.O n)) 
                            (div_mod.mod nat.O n)))) 
                   (nat.minus (div_mod.mod nat.O n) nat.O) 
                   (nat.minus_n_O (div_mod.mod nat.O n))) 
                (nat.minus 
                   (nat.plus (div_mod.mod nat.O n) 
                      (nat.times n (div_mod.div nat.O n))) 
                   (nat.plus nat.O (nat.times n (div_mod.div nat.O n)))) 
                (nat.minus_plus_plus_l (div_mod.mod nat.O n) nat.O 
                   (nat.times n (div_mod.div nat.O n)))))) 
       (logic.refl sttfa.bool (logic.eq nat.nat nat.O (div_mod.mod nat.O n)))).

