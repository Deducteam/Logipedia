import .connectives
constant logic.eq_ : forall (A : Type) , (A) -> (A) -> Prop.
axiom logic.refl_ : forall (A : Type) , forall (x:A) , (((logic.eq_) (A)) (x)) (x).
axiom logic.eq_ind : forall (A : Type) , forall (x:A) , forall (P:(A) -> Prop) , ((P) (x)) -> forall (y:A) , ((((logic.eq_) (A)) (x)) (y)) -> (P) (y).
theorem logic.eq_rect_r : forall (A : Type) , forall (a:A) , forall (x:A) , ((((logic.eq_) (A)) (x)) (a)) -> forall (P:(A) -> Prop) , ((P) (a)) -> (P) (x) := fun (A : Type) , fun (a : A) , fun (x : A) , fun (p : (((logic.eq_) (A)) (x)) (a)) , (((((((@logic.eq_ind) (A)) (x)) (fun (__ : A) , forall (P:(A) -> Prop) , ((P) (__)) -> (P) (x))) (fun (P : (A) -> Prop) , fun (auto : (P) (x)) , (auto))) (a)) (p)).
theorem logic.eq_ind_r : forall (A : Type) , forall (a:A) , forall (P:(A) -> Prop) , ((P) (a)) -> forall (x:A) , ((((logic.eq_) (A)) (x)) (a)) -> (P) (x) := fun (A : Type) , fun (a : A) , fun (P : (A) -> Prop) , fun (p : (P) (a)) , (fun (x0 : A) , fun (p0 : (((logic.eq_) (A)) (x0)) (a)) , (((((((@logic.eq_rect_r) (A)) (a)) (x0)) (p0)) (fun (x01 : A) , (P) (x01))) (p))).
theorem logic.rewrite_l : forall (A : Type) , forall (x:A) , forall (P:(A) -> Prop) , ((P) (x)) -> forall (y:A) , ((((logic.eq_) (A)) (x)) (y)) -> (P) (y) := fun (A : Type) , fun (x : A) , fun (P : (A) -> Prop) , fun (Hx : (P) (x)) , (fun (y : A) , fun (Heq : (((logic.eq_) (A)) (x)) (y)) , (((((((@logic.eq_ind) (A)) (x)) (fun (__ : A) , (P) (__))) (Hx)) (y)) (Heq))).
theorem logic.sym_eq : forall (A : Type) , forall (x:A) , forall (y:A) , ((((logic.eq_) (A)) (x)) (y)) -> (((logic.eq_) (A)) (y)) (x) := fun (A : Type) , fun (x : A) , fun (y : A) , fun (Heq : (((logic.eq_) (A)) (x)) (y)) , (((((((@logic.rewrite_l) (A)) (x)) (fun (__ : A) , (((logic.eq_) (A)) (__)) (x))) (((@logic.refl_) (A)) (x))) (y)) (((((((@logic.rewrite_l) (A)) (x)) (fun (__ : A) , (((logic.eq_) (A)) (x)) (__))) (((@logic.refl_) (A)) (x))) (y)) (Heq))).
theorem logic.rewrite_r : forall (A : Type) , forall (x:A) , forall (P:(A) -> Prop) , ((P) (x)) -> forall (y:A) , ((((logic.eq_) (A)) (y)) (x)) -> (P) (y) := fun (A : Type) , fun (x : A) , fun (P : (A) -> Prop) , fun (Hx : (P) (x)) , (fun (y : A) , fun (Heq : (((logic.eq_) (A)) (y)) (x)) , (((((((@logic.eq_ind) (A)) (x)) (fun (__ : A) , (P) (__))) (Hx)) (y)) (((((@logic.sym_eq) (A)) (y)) (x)) (Heq)))).
theorem logic.eq_coerc : forall (A:Prop) , forall (B:Prop) , (A) -> ((((logic.eq_) (Prop)) (A)) (B)) -> B := fun (A : Prop) , fun (B : Prop) , fun (Ha : A) , (fun (Heq : (((logic.eq_) (Prop)) (A)) (B)) , (((((((@logic.eq_ind) (Prop)) (A)) (fun (x_19 : Prop) , x_19)) (Ha)) (B)) (Heq))).
theorem logic.trans_eq : forall (A : Type) , forall (x:A) , forall (y:A) , forall (z:A) , ((((logic.eq_) (A)) (x)) (y)) -> ((((logic.eq_) (A)) (y)) (z)) -> (((logic.eq_) (A)) (x)) (z) := fun (A : Type) , fun (x : A) , fun (y : A) , fun (z : A) , fun (H1 : (((logic.eq_) (A)) (x)) (y)) , (fun (H2 : (((logic.eq_) (A)) (y)) (z)) , (((((((@logic.eq_ind_r) (A)) (y)) (fun (x0 : A) , (((logic.eq_) (A)) (x0)) (z))) (((((((@logic.rewrite_l) (A)) (x)) (fun (__ : A) , (((logic.eq_) (A)) (__)) (z))) (((((((@logic.rewrite_l) (A)) (x)) (fun (__ : A) , (((logic.eq_) (A)) (x)) (__))) (((@logic.refl_) (A)) (x))) (z)) (((((((@logic.rewrite_r) (A)) (y)) (fun (__ : A) , (((logic.eq_) (A)) (__)) (z))) (H2)) (x)) (H1)))) (y)) (H1))) (x)) (H1))).
theorem logic.eq_f : forall (A : Type) , forall (B : Type) , forall (f:(A) -> B) , forall (x:A) , forall (y:A) , ((((logic.eq_) (A)) (x)) (y)) -> (((logic.eq_) (B)) ((f) (x))) ((f) (y)) := fun (A : Type) , fun (B : Type) , fun (f : (A) -> B) , fun (x : A) , fun (y : A) , fun (H : (((logic.eq_) (A)) (x)) (y)) , (((((((@logic.eq_ind_r) (A)) (y)) (fun (x0 : A) , (((logic.eq_) (B)) ((f) (x0))) ((f) (y)))) (((((((@logic.rewrite_l) (A)) (x)) (fun (__ : A) , (((logic.eq_) (B)) ((f) (__))) ((f) (y)))) (((((((@logic.rewrite_l) (A)) (x)) (fun (__ : A) , (((logic.eq_) (B)) ((f) (x))) ((f) (__)))) (((@logic.refl_) (B)) ((f) (x)))) (y)) (H))) (y)) (H))) (x)) (H)).
theorem logic.eq_f2 : forall (A : Type) , forall (B : Type) , forall (C : Type) , forall (f:(A) -> (B) -> C) , forall (x1:A) , forall (x2:A) , forall (y1:B) , forall (y2:B) , ((((logic.eq_) (A)) (x1)) (x2)) -> ((((logic.eq_) (B)) (y1)) (y2)) -> (((logic.eq_) (C)) (((f) (x1)) (y1))) (((f) (x2)) (y2)) := fun (A : Type) , fun (B : Type) , fun (C : Type) , fun (f : (A) -> (B) -> C) , fun (x1 : A) , fun (x2 : A) , fun (y1 : B) , fun (y2 : B) , fun (E1 : (((logic.eq_) (A)) (x1)) (x2)) , (fun (E2 : (((logic.eq_) (B)) (y1)) (y2)) , (((((((@logic.eq_ind_r) (A)) (x2)) (fun (x : A) , (((logic.eq_) (C)) (((f) (x)) (y1))) (((f) (x2)) (y2)))) (((((((@logic.eq_ind_r) (B)) (y2)) (fun (x : B) , (((logic.eq_) (C)) (((f) (x2)) (x))) (((f) (x2)) (y2)))) (((((((@logic.rewrite_l) (A)) (x1)) (fun (__ : A) , (((logic.eq_) (C)) (((f) (__)) (y2))) (((f) (x2)) (y2)))) (((((((@logic.rewrite_l) (B)) (y1)) (fun (__ : B) , (((logic.eq_) (C)) (((f) (x1)) (__))) (((f) (x2)) (y2)))) (((((((@logic.rewrite_l) (A)) (x1)) (fun (__ : A) , (((logic.eq_) (C)) (((f) (x1)) (y1))) (((f) (__)) (y2)))) (((((((@logic.rewrite_l) (B)) (y1)) (fun (__ : B) , (((logic.eq_) (C)) (((f) (x1)) (y1))) (((f) (x1)) (__)))) (((@logic.refl_) (C)) (((f) (x1)) (y1)))) (y2)) (E2))) (x2)) (E1))) (y2)) (E2))) (x2)) (E1))) (y1)) (E2))) (x1)) (E1))).
theorem logic.absurd : forall (A:Prop) , (A) -> (((connectives.Not) ) (A)) -> (connectives.False)  := fun (A : Prop) , fun (H : A) , (fun (Hn : ((connectives.Not) ) (A)) , (((((@connectives.Not_ind) (A)) ((connectives.False) )) (fun (_x_80 : (A) -> (connectives.False) ) , ((_x_80) (H)))) (Hn))).
theorem logic.not_to_not : forall (A:Prop) , forall (B:Prop) , ((A) -> B) -> (((connectives.Not) ) (B)) -> ((connectives.Not) ) (A) := fun (A : Prop) , fun (B : Prop) , fun (auto : (A) -> B) , (fun (auto' : ((connectives.Not) ) (B)) , (((@connectives.nmk) (A)) (fun (auto'' : A) , ((((@logic.absurd) (B)) ((auto) (auto''))) (auto'))))).
theorem logic.sym_not_eq : forall (A : Type) , forall (x:A) , forall (y:A) , (((connectives.Not) ) ((((logic.eq_) (A)) (x)) (y))) -> ((connectives.Not) ) ((((logic.eq_) (A)) (y)) (x)) := fun (A : Type) , fun (x : A) , fun (y : A) , fun (auto : ((connectives.Not) ) ((((logic.eq_) (A)) (x)) (y))) , (((@connectives.nmk) ((((logic.eq_) (A)) (y)) (x))) (fun (auto' : (((logic.eq_) (A)) (y)) (x)) , ((((@logic.absurd) ((((logic.eq_) (A)) (x)) (y))) (((((((@logic.rewrite_r) (A)) (x)) (fun (__ : A) , (((logic.eq_) (A)) (x)) (__))) (((@logic.refl_) (A)) (x))) (y)) (auto'))) (auto)))).
theorem logic.proj1 : forall (A:Prop) , forall (B:Prop) , ((((connectives.And) ) (A)) (B)) -> A := fun (A : Prop) , fun (B : Prop) , fun (AB : (((connectives.And) ) (A)) (B)) , ((((((@connectives.match_And_prop) (A)) (B)) (A)) (fun (_x_120 : A) , (fun (_x_119 : B) , (_x_120)))) (AB)).
theorem logic.proj2 : forall (A:Prop) , forall (B:Prop) , ((((connectives.And) ) (A)) (B)) -> B := fun (A : Prop) , fun (B : Prop) , fun (AB : (((connectives.And) ) (A)) (B)) , ((((((@connectives.match_And_prop) (A)) (B)) (B)) (fun (_x_120 : A) , (fun (_x_119 : B) , (_x_119)))) (AB)).
def logic.decidable : (Prop) -> Prop := fun (A : Prop) , (((connectives.Or) ) (A)) (((connectives.Not) ) (A)).
