logic_sttfa : THEORY
BEGIN
IMPORTING connectives_sttfa

eq [A:TYPE+]: [A -> [A -> bool]]

refl [A:TYPE+] : AXIOM (FORALL(x:A):logic_sttfa.eq[A](x)(x))

eq_ind [A:TYPE+] : AXIOM (FORALL(x:A):(FORALL(P:[A -> bool]):(P(x) => (FORALL(y:A):(logic_sttfa.eq[A](x)(y) => P(y))))))

eq_rect_r [A:TYPE+] : LEMMA (FORALL(a:A):(FORALL(x:A):(logic_sttfa.eq[A](x)(a) => (FORALL(P:[A -> bool]):(P(a) => P(x))))))

%|- eq_rect_r : PROOF
%|- (then@ (sttfa-forall-i "a")
%|- (then@ (sttfa-forall-i "x")
%|- (sttfa-impl-i "logic_sttfa.eq[A](x)(a)" "(FORALL(P:[A -> bool]):(P(a) => P(x)))"
%|- (sttfa-impl-e "(logic_sttfa.eq[A](x)(a) => (FORALL(P:[A -> bool]):(P(a) => P(x))))" "logic_sttfa.eq[A](x)(a)"
%|- (propax)
%|- (sttfa-conv "(logic_sttfa.eq[A](x)(a) => (FORALL(P:[A -> bool]):(P(a) => P(x))))" () ()
%|- (sttfa-forall-e "(FORALL(y:A):(logic_sttfa.eq[A](x)(y) => (FORALL(P:[A -> bool]):(P(y) => P(x)))))" "a"
%|- (sttfa-impl-e "((FORALL(P:[A -> bool]):(P(x) => P(x))) => (FORALL(y:A):(logic_sttfa.eq[A](x)(y) => (FORALL(P:[A -> bool]):(P(y) => P(x))))))" "(FORALL(P:[A -> bool]):(P(x) => P(x)))"
%|- (then@ (sttfa-forall-i "P")
%|- (sttfa-impl-i "P(x)" "P(x)"
%|- (propax)))
%|- (sttfa-conv "((LAMBDA(sttfa___:A):(FORALL(P:[A -> bool]):(P(sttfa___) => P(x))))(x) => (FORALL(y:A):(logic_sttfa.eq[A](x)(y) => (LAMBDA(sttfa___:A):(FORALL(P:[A -> bool]):(P(sttfa___) => P(x))))(y))))" () ()
%|- (sttfa-forall-e "(FORALL(P:[A -> bool]):(P(x) => (FORALL(y:A):(logic_sttfa.eq[A](x)(y) => P(y)))))" "(LAMBDA(sttfa___:A):(FORALL(P:[A -> bool]):(P(sttfa___) => P(x))))"
%|- (sttfa-conv "(FORALL(P:[A -> bool]):(P(x) => (FORALL(y:A):(logic_sttfa.eq[A](x)(y) => P(y)))))" () ()
%|- (sttfa-forall-e "(FORALL(x0:A):(FORALL(P:[A -> bool]):(P(x0) => (FORALL(y:A):(logic_sttfa.eq[A](x0)(y) => P(y))))))" "x"
%|- (sttfa-lemma "logic_sttfa.eq_ind[A]"))))))))))))
%|- QED

eq_ind_r [A:TYPE+] : LEMMA (FORALL(a:A):(FORALL(P:[A -> bool]):(P(a) => (FORALL(x:A):(logic_sttfa.eq[A](x)(a) => P(x))))))

%|- eq_ind_r : PROOF
%|- (sttfa-conv "(FORALL(a:A):(FORALL(P:[A -> bool]):(P(a) => (FORALL(x0:A):(logic_sttfa.eq[A](x0)(a) => P(x0))))))" () ()
%|- (then@ (sttfa-forall-i "a")
%|- (then@ (sttfa-forall-i "P")
%|- (sttfa-impl-i "P(a)" "(FORALL(x0:A):(logic_sttfa.eq[A](x0)(a) => P(x0)))"
%|- (then@ (sttfa-forall-i "x0")
%|- (sttfa-impl-i "logic_sttfa.eq[A](x0)(a)" "P(x0)"
%|- (sttfa-impl-e "(P(a) => P(x0))" "P(a)"
%|- (propax)
%|- (sttfa-conv "((LAMBDA(x01:A):P(x01))(a) => (LAMBDA(x01:A):P(x01))(x0))" () ()
%|- (sttfa-forall-e "(FORALL(P0:[A -> bool]):(P0(a) => P0(x0)))" "(LAMBDA(x01:A):P(x01))"
%|- (sttfa-impl-e "(logic_sttfa.eq[A](x0)(a) => (FORALL(P0:[A -> bool]):(P0(a) => P0(x0))))" "logic_sttfa.eq[A](x0)(a)"
%|- (propax)
%|- (sttfa-conv "(logic_sttfa.eq[A](x0)(a) => (FORALL(P0:[A -> bool]):(P0(a) => P0(x0))))" () ()
%|- (sttfa-forall-e "(FORALL(x:A):(logic_sttfa.eq[A](x)(a) => (FORALL(P0:[A -> bool]):(P0(a) => P0(x)))))" "x0"
%|- (sttfa-conv "(FORALL(x:A):(logic_sttfa.eq[A](x)(a) => (FORALL(P0:[A -> bool]):(P0(a) => P0(x)))))" () ()
%|- (sttfa-forall-e "(FORALL(a0:A):(FORALL(x:A):(logic_sttfa.eq[A](x)(a0) => (FORALL(P0:[A -> bool]):(P0(a0) => P0(x))))))" "a"
%|- (sttfa-lemma "logic_sttfa.eq_rect_r[A]")))))))))))))))
%|- QED

rewrite_l [A:TYPE+] : LEMMA (FORALL(x:A):(FORALL(P:[A -> bool]):(P(x) => (FORALL(y:A):(logic_sttfa.eq[A](x)(y) => P(y))))))

%|- rewrite_l : PROOF
%|- (then@ (sttfa-forall-i "x")
%|- (then@ (sttfa-forall-i "P")
%|- (sttfa-impl-i "P(x)" "(FORALL(y:A):(logic_sttfa.eq[A](x)(y) => P(y)))"
%|- (then@ (sttfa-forall-i "y")
%|- (sttfa-impl-i "logic_sttfa.eq[A](x)(y)" "P(y)"
%|- (sttfa-impl-e "(logic_sttfa.eq[A](x)(y) => P(y))" "logic_sttfa.eq[A](x)(y)"
%|- (propax)
%|- (sttfa-conv "(logic_sttfa.eq[A](x)(y) => P(y))" () ()
%|- (sttfa-forall-e "(FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => P(y0)))" "y"
%|- (sttfa-impl-e "(P(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => P(y0))))" "P(x)"
%|- (propax)
%|- (sttfa-conv "((LAMBDA(sttfa___:A):P(sttfa___))(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => (LAMBDA(sttfa___:A):P(sttfa___))(y0))))" () ()
%|- (sttfa-forall-e "(FORALL(P0:[A -> bool]):(P0(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => P0(y0)))))" "(LAMBDA(sttfa___:A):P(sttfa___))"
%|- (sttfa-conv "(FORALL(P0:[A -> bool]):(P0(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => P0(y0)))))" () ()
%|- (sttfa-forall-e "(FORALL(x0:A):(FORALL(P0:[A -> bool]):(P0(x0) => (FORALL(y0:A):(logic_sttfa.eq[A](x0)(y0) => P0(y0))))))" "x"
%|- (sttfa-lemma "logic_sttfa.eq_ind[A]"))))))))))))))
%|- QED

sym_eq [A:TYPE+] : LEMMA (FORALL(x:A):(FORALL(y:A):(logic_sttfa.eq[A](x)(y) => logic_sttfa.eq[A](y)(x))))

%|- sym_eq : PROOF
%|- (then@ (sttfa-forall-i "x")
%|- (then@ (sttfa-forall-i "y")
%|- (sttfa-impl-i "logic_sttfa.eq[A](x)(y)" "logic_sttfa.eq[A](y)(x)"
%|- (sttfa-impl-e "(logic_sttfa.eq[A](x)(y) => logic_sttfa.eq[A](y)(x))" "logic_sttfa.eq[A](x)(y)"
%|- (sttfa-impl-e "(logic_sttfa.eq[A](x)(y) => logic_sttfa.eq[A](x)(y))" "logic_sttfa.eq[A](x)(y)"
%|- (propax)
%|- (sttfa-conv "(logic_sttfa.eq[A](x)(y) => logic_sttfa.eq[A](x)(y))" () ()
%|- (sttfa-forall-e "(FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => logic_sttfa.eq[A](x)(y0)))" "y"
%|- (sttfa-impl-e "(logic_sttfa.eq[A](x)(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => logic_sttfa.eq[A](x)(y0))))" "logic_sttfa.eq[A](x)(x)"
%|- (sttfa-conv "logic_sttfa.eq[A](x)(x)" () ()
%|- (sttfa-forall-e "(FORALL(x0:A):logic_sttfa.eq[A](x0)(x0))" "x"
%|- (sttfa-lemma "logic_sttfa.refl[A]")))
%|- (sttfa-conv "((LAMBDA(sttfa___:A):logic_sttfa.eq[A](x)(sttfa___))(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => (LAMBDA(sttfa___:A):logic_sttfa.eq[A](x)(sttfa___))(y0))))" () ()
%|- (sttfa-forall-e "(FORALL(P:[A -> bool]):(P(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => P(y0)))))" "(LAMBDA(sttfa___:A):logic_sttfa.eq[A](x)(sttfa___))"
%|- (sttfa-conv "(FORALL(P:[A -> bool]):(P(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => P(y0)))))" () ()
%|- (sttfa-forall-e "(FORALL(x0:A):(FORALL(P:[A -> bool]):(P(x0) => (FORALL(y0:A):(logic_sttfa.eq[A](x0)(y0) => P(y0))))))" "x"
%|- (sttfa-lemma "logic_sttfa.rewrite_l[A]")))))))))
%|- (sttfa-conv "(logic_sttfa.eq[A](x)(y) => logic_sttfa.eq[A](y)(x))" () ()
%|- (sttfa-forall-e "(FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => logic_sttfa.eq[A](y0)(x)))" "y"
%|- (sttfa-impl-e "(logic_sttfa.eq[A](x)(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => logic_sttfa.eq[A](y0)(x))))" "logic_sttfa.eq[A](x)(x)"
%|- (sttfa-conv "logic_sttfa.eq[A](x)(x)" () ()
%|- (sttfa-forall-e "(FORALL(x0:A):logic_sttfa.eq[A](x0)(x0))" "x"
%|- (sttfa-lemma "logic_sttfa.refl[A]")))
%|- (sttfa-conv "((LAMBDA(sttfa___:A):logic_sttfa.eq[A](sttfa___)(x))(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => (LAMBDA(sttfa___:A):logic_sttfa.eq[A](sttfa___)(x))(y0))))" () ()
%|- (sttfa-forall-e "(FORALL(P:[A -> bool]):(P(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => P(y0)))))" "(LAMBDA(sttfa___:A):logic_sttfa.eq[A](sttfa___)(x))"
%|- (sttfa-conv "(FORALL(P:[A -> bool]):(P(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => P(y0)))))" () ()
%|- (sttfa-forall-e "(FORALL(x0:A):(FORALL(P:[A -> bool]):(P(x0) => (FORALL(y0:A):(logic_sttfa.eq[A](x0)(y0) => P(y0))))))" "x"
%|- (sttfa-lemma "logic_sttfa.rewrite_l[A]"))))))))))))
%|- QED

rewrite_r [A:TYPE+] : LEMMA (FORALL(x:A):(FORALL(P:[A -> bool]):(P(x) => (FORALL(y:A):(logic_sttfa.eq[A](y)(x) => P(y))))))

%|- rewrite_r : PROOF
%|- (then@ (sttfa-forall-i "x")
%|- (then@ (sttfa-forall-i "P")
%|- (sttfa-impl-i "P(x)" "(FORALL(y:A):(logic_sttfa.eq[A](y)(x) => P(y)))"
%|- (then@ (sttfa-forall-i "y")
%|- (sttfa-impl-i "logic_sttfa.eq[A](y)(x)" "P(y)"
%|- (sttfa-impl-e "(logic_sttfa.eq[A](x)(y) => P(y))" "logic_sttfa.eq[A](x)(y)"
%|- (sttfa-impl-e "(logic_sttfa.eq[A](y)(x) => logic_sttfa.eq[A](x)(y))" "logic_sttfa.eq[A](y)(x)"
%|- (propax)
%|- (sttfa-conv "(logic_sttfa.eq[A](y)(x) => logic_sttfa.eq[A](x)(y))" () ()
%|- (sttfa-forall-e "(FORALL(y0:A):(logic_sttfa.eq[A](y)(y0) => logic_sttfa.eq[A](y0)(y)))" "x"
%|- (sttfa-conv "(FORALL(y0:A):(logic_sttfa.eq[A](y)(y0) => logic_sttfa.eq[A](y0)(y)))" () ()
%|- (sttfa-forall-e "(FORALL(x0:A):(FORALL(y0:A):(logic_sttfa.eq[A](x0)(y0) => logic_sttfa.eq[A](y0)(x0))))" "y"
%|- (sttfa-lemma "logic_sttfa.sym_eq[A]"))))))
%|- (sttfa-conv "(logic_sttfa.eq[A](x)(y) => P(y))" () ()
%|- (sttfa-forall-e "(FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => P(y0)))" "y"
%|- (sttfa-impl-e "(P(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => P(y0))))" "P(x)"
%|- (propax)
%|- (sttfa-conv "((LAMBDA(sttfa___:A):P(sttfa___))(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => (LAMBDA(sttfa___:A):P(sttfa___))(y0))))" () ()
%|- (sttfa-forall-e "(FORALL(P0:[A -> bool]):(P0(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => P0(y0)))))" "(LAMBDA(sttfa___:A):P(sttfa___))"
%|- (sttfa-conv "(FORALL(P0:[A -> bool]):(P0(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => P0(y0)))))" () ()
%|- (sttfa-forall-e "(FORALL(x0:A):(FORALL(P0:[A -> bool]):(P0(x0) => (FORALL(y0:A):(logic_sttfa.eq[A](x0)(y0) => P0(y0))))))" "x"
%|- (sttfa-lemma "logic_sttfa.eq_ind[A]"))))))))))))))
%|- QED

eq_coerc  : LEMMA (FORALL(A:bool):(FORALL(B:bool):(A => (logic_sttfa.eq[bool](A)(B) => B))))

%|- eq_coerc : PROOF
%|- (then@ (sttfa-forall-i "A")
%|- (then@ (sttfa-forall-i "B")
%|- (sttfa-impl-i "A" "(logic_sttfa.eq[bool](A)(B) => B)"
%|- (sttfa-impl-i "logic_sttfa.eq[bool](A)(B)" "B"
%|- (sttfa-impl-e "(logic_sttfa.eq[bool](A)(B) => B)" "logic_sttfa.eq[bool](A)(B)"
%|- (propax)
%|- (sttfa-conv "(logic_sttfa.eq[bool](A)(B) => B)" () ()
%|- (sttfa-forall-e "(FORALL(y:bool):(logic_sttfa.eq[bool](A)(y) => y))" "B"
%|- (sttfa-impl-e "(A => (FORALL(y:bool):(logic_sttfa.eq[bool](A)(y) => y)))" "A"
%|- (propax)
%|- (sttfa-conv "((LAMBDA(x_19:bool):x_19)(A) => (FORALL(y:bool):(logic_sttfa.eq[bool](A)(y) => (LAMBDA(x_19:bool):x_19)(y))))" () ()
%|- (sttfa-forall-e "(FORALL(P:[bool -> bool]):(P(A) => (FORALL(y:bool):(logic_sttfa.eq[bool](A)(y) => P(y)))))" "(LAMBDA(x_19:bool):x_19)"
%|- (sttfa-conv "(FORALL(P:[bool -> bool]):(P(A) => (FORALL(y:bool):(logic_sttfa.eq[bool](A)(y) => P(y)))))" () ()
%|- (sttfa-forall-e "(FORALL(x:bool):(FORALL(P:[bool -> bool]):(P(x) => (FORALL(y:bool):(logic_sttfa.eq[bool](x)(y) => P(y))))))" "A"
%|- (sttfa-lemma "logic_sttfa.eq_ind[bool]")))))))))))))
%|- QED

trans_eq [A:TYPE+] : LEMMA (FORALL(x:A):(FORALL(y:A):(FORALL(z:A):(logic_sttfa.eq[A](x)(y) => (logic_sttfa.eq[A](y)(z) => logic_sttfa.eq[A](x)(z))))))

%|- trans_eq : PROOF
%|- (then@ (sttfa-forall-i "x")
%|- (then@ (sttfa-forall-i "y")
%|- (then@ (sttfa-forall-i "z")
%|- (sttfa-impl-i "logic_sttfa.eq[A](x)(y)" "(logic_sttfa.eq[A](y)(z) => logic_sttfa.eq[A](x)(z))"
%|- (sttfa-impl-i "logic_sttfa.eq[A](y)(z)" "logic_sttfa.eq[A](x)(z)"
%|- (sttfa-impl-e "(logic_sttfa.eq[A](x)(y) => logic_sttfa.eq[A](x)(z))" "logic_sttfa.eq[A](x)(y)"
%|- (propax)
%|- (sttfa-conv "(logic_sttfa.eq[A](x)(y) => logic_sttfa.eq[A](x)(z))" () ()
%|- (sttfa-forall-e "(FORALL(x0:A):(logic_sttfa.eq[A](x0)(y) => logic_sttfa.eq[A](x0)(z)))" "x"
%|- (sttfa-impl-e "(logic_sttfa.eq[A](y)(z) => (FORALL(x0:A):(logic_sttfa.eq[A](x0)(y) => logic_sttfa.eq[A](x0)(z))))" "logic_sttfa.eq[A](y)(z)"
%|- (sttfa-impl-e "(logic_sttfa.eq[A](x)(y) => logic_sttfa.eq[A](y)(z))" "logic_sttfa.eq[A](x)(y)"
%|- (propax)
%|- (sttfa-conv "(logic_sttfa.eq[A](x)(y) => logic_sttfa.eq[A](y)(z))" () ()
%|- (sttfa-forall-e "(FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => logic_sttfa.eq[A](y0)(z)))" "y"
%|- (sttfa-impl-e "(logic_sttfa.eq[A](x)(z) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => logic_sttfa.eq[A](y0)(z))))" "logic_sttfa.eq[A](x)(z)"
%|- (sttfa-impl-e "(logic_sttfa.eq[A](x)(z) => logic_sttfa.eq[A](x)(z))" "logic_sttfa.eq[A](x)(z)"
%|- (sttfa-impl-e "(logic_sttfa.eq[A](x)(y) => logic_sttfa.eq[A](x)(z))" "logic_sttfa.eq[A](x)(y)"
%|- (propax)
%|- (sttfa-conv "(logic_sttfa.eq[A](x)(y) => logic_sttfa.eq[A](x)(z))" () ()
%|- (sttfa-forall-e "(FORALL(y0:A):(logic_sttfa.eq[A](y0)(y) => logic_sttfa.eq[A](y0)(z)))" "x"
%|- (sttfa-impl-e "(logic_sttfa.eq[A](y)(z) => (FORALL(y0:A):(logic_sttfa.eq[A](y0)(y) => logic_sttfa.eq[A](y0)(z))))" "logic_sttfa.eq[A](y)(z)"
%|- (propax)
%|- (sttfa-conv "((LAMBDA(sttfa___:A):logic_sttfa.eq[A](sttfa___)(z))(y) => (FORALL(y0:A):(logic_sttfa.eq[A](y0)(y) => (LAMBDA(sttfa___:A):logic_sttfa.eq[A](sttfa___)(z))(y0))))" () ()
%|- (sttfa-forall-e "(FORALL(P:[A -> bool]):(P(y) => (FORALL(y0:A):(logic_sttfa.eq[A](y0)(y) => P(y0)))))" "(LAMBDA(sttfa___:A):logic_sttfa.eq[A](sttfa___)(z))"
%|- (sttfa-conv "(FORALL(P:[A -> bool]):(P(y) => (FORALL(y0:A):(logic_sttfa.eq[A](y0)(y) => P(y0)))))" () ()
%|- (sttfa-forall-e "(FORALL(x0:A):(FORALL(P:[A -> bool]):(P(x0) => (FORALL(y0:A):(logic_sttfa.eq[A](y0)(x0) => P(y0))))))" "y"
%|- (sttfa-lemma "logic_sttfa.rewrite_r[A]")))))))))
%|- (sttfa-conv "(logic_sttfa.eq[A](x)(z) => logic_sttfa.eq[A](x)(z))" () ()
%|- (sttfa-forall-e "(FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => logic_sttfa.eq[A](x)(y0)))" "z"
%|- (sttfa-impl-e "(logic_sttfa.eq[A](x)(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => logic_sttfa.eq[A](x)(y0))))" "logic_sttfa.eq[A](x)(x)"
%|- (sttfa-conv "logic_sttfa.eq[A](x)(x)" () ()
%|- (sttfa-forall-e "(FORALL(x0:A):logic_sttfa.eq[A](x0)(x0))" "x"
%|- (sttfa-lemma "logic_sttfa.refl[A]")))
%|- (sttfa-conv "((LAMBDA(sttfa___:A):logic_sttfa.eq[A](x)(sttfa___))(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => (LAMBDA(sttfa___:A):logic_sttfa.eq[A](x)(sttfa___))(y0))))" () ()
%|- (sttfa-forall-e "(FORALL(P:[A -> bool]):(P(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => P(y0)))))" "(LAMBDA(sttfa___:A):logic_sttfa.eq[A](x)(sttfa___))"
%|- (sttfa-conv "(FORALL(P:[A -> bool]):(P(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => P(y0)))))" () ()
%|- (sttfa-forall-e "(FORALL(x0:A):(FORALL(P:[A -> bool]):(P(x0) => (FORALL(y0:A):(logic_sttfa.eq[A](x0)(y0) => P(y0))))))" "x"
%|- (sttfa-lemma "logic_sttfa.rewrite_l[A]")))))))))
%|- (sttfa-conv "((LAMBDA(sttfa___:A):logic_sttfa.eq[A](sttfa___)(z))(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => (LAMBDA(sttfa___:A):logic_sttfa.eq[A](sttfa___)(z))(y0))))" () ()
%|- (sttfa-forall-e "(FORALL(P:[A -> bool]):(P(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => P(y0)))))" "(LAMBDA(sttfa___:A):logic_sttfa.eq[A](sttfa___)(z))"
%|- (sttfa-conv "(FORALL(P:[A -> bool]):(P(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => P(y0)))))" () ()
%|- (sttfa-forall-e "(FORALL(x0:A):(FORALL(P:[A -> bool]):(P(x0) => (FORALL(y0:A):(logic_sttfa.eq[A](x0)(y0) => P(y0))))))" "x"
%|- (sttfa-lemma "logic_sttfa.rewrite_l[A]")))))))))
%|- (sttfa-conv "((LAMBDA(x0:A):logic_sttfa.eq[A](x0)(z))(y) => (FORALL(x0:A):(logic_sttfa.eq[A](x0)(y) => (LAMBDA(x00:A):logic_sttfa.eq[A](x00)(z))(x0))))" () ()
%|- (sttfa-forall-e "(FORALL(P:[A -> bool]):(P(y) => (FORALL(x0:A):(logic_sttfa.eq[A](x0)(y) => P(x0)))))" "(LAMBDA(x0:A):logic_sttfa.eq[A](x0)(z))"
%|- (sttfa-conv "(FORALL(P:[A -> bool]):(P(y) => (FORALL(x0:A):(logic_sttfa.eq[A](x0)(y) => P(x0)))))" () ()
%|- (sttfa-forall-e "(FORALL(a:A):(FORALL(P:[A -> bool]):(P(a) => (FORALL(x0:A):(logic_sttfa.eq[A](x0)(a) => P(x0))))))" "y"
%|- (sttfa-lemma "logic_sttfa.eq_ind_r[A]"))))))))))))))
%|- QED

eq_f [A:TYPE+,B:TYPE+] : LEMMA (FORALL(f:[A -> B]):(FORALL(x:A):(FORALL(y:A):(logic_sttfa.eq[A](x)(y) => logic_sttfa.eq[B](f(x))(f(y))))))

%|- eq_f : PROOF
%|- (then@ (sttfa-forall-i "f")
%|- (then@ (sttfa-forall-i "x")
%|- (then@ (sttfa-forall-i "y")
%|- (sttfa-impl-i "logic_sttfa.eq[A](x)(y)" "logic_sttfa.eq[B](f(x))(f(y))"
%|- (sttfa-impl-e "(logic_sttfa.eq[A](x)(y) => logic_sttfa.eq[B](f(x))(f(y)))" "logic_sttfa.eq[A](x)(y)"
%|- (propax)
%|- (sttfa-conv "(logic_sttfa.eq[A](x)(y) => logic_sttfa.eq[B](f(x))(f(y)))" () ()
%|- (sttfa-forall-e "(FORALL(x0:A):(logic_sttfa.eq[A](x0)(y) => logic_sttfa.eq[B](f(x0))(f(y))))" "x"
%|- (sttfa-impl-e "(logic_sttfa.eq[B](f(y))(f(y)) => (FORALL(x0:A):(logic_sttfa.eq[A](x0)(y) => logic_sttfa.eq[B](f(x0))(f(y)))))" "logic_sttfa.eq[B](f(y))(f(y))"
%|- (sttfa-impl-e "(logic_sttfa.eq[A](x)(y) => logic_sttfa.eq[B](f(y))(f(y)))" "logic_sttfa.eq[A](x)(y)"
%|- (propax)
%|- (sttfa-conv "(logic_sttfa.eq[A](x)(y) => logic_sttfa.eq[B](f(y))(f(y)))" () ()
%|- (sttfa-forall-e "(FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => logic_sttfa.eq[B](f(y0))(f(y))))" "y"
%|- (sttfa-impl-e "(logic_sttfa.eq[B](f(x))(f(y)) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => logic_sttfa.eq[B](f(y0))(f(y)))))" "logic_sttfa.eq[B](f(x))(f(y))"
%|- (sttfa-impl-e "(logic_sttfa.eq[A](x)(y) => logic_sttfa.eq[B](f(x))(f(y)))" "logic_sttfa.eq[A](x)(y)"
%|- (propax)
%|- (sttfa-conv "(logic_sttfa.eq[A](x)(y) => logic_sttfa.eq[B](f(x))(f(y)))" () ()
%|- (sttfa-forall-e "(FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => logic_sttfa.eq[B](f(x))(f(y0))))" "y"
%|- (sttfa-impl-e "(logic_sttfa.eq[B](f(x))(f(x)) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => logic_sttfa.eq[B](f(x))(f(y0)))))" "logic_sttfa.eq[B](f(x))(f(x))"
%|- (sttfa-conv "logic_sttfa.eq[B](f(x))(f(x))" () ()
%|- (sttfa-forall-e "(FORALL(x0:B):logic_sttfa.eq[B](x0)(x0))" "f(x)"
%|- (sttfa-lemma "logic_sttfa.refl[B]")))
%|- (sttfa-conv "((LAMBDA(sttfa___:A):logic_sttfa.eq[B](f(x))(f(sttfa___)))(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => (LAMBDA(sttfa___:A):logic_sttfa.eq[B](f(x))(f(sttfa___)))(y0))))" () ()
%|- (sttfa-forall-e "(FORALL(P:[A -> bool]):(P(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => P(y0)))))" "(LAMBDA(sttfa___:A):logic_sttfa.eq[B](f(x))(f(sttfa___)))"
%|- (sttfa-conv "(FORALL(P:[A -> bool]):(P(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => P(y0)))))" () ()
%|- (sttfa-forall-e "(FORALL(x0:A):(FORALL(P:[A -> bool]):(P(x0) => (FORALL(y0:A):(logic_sttfa.eq[A](x0)(y0) => P(y0))))))" "x"
%|- (sttfa-lemma "logic_sttfa.rewrite_l[A]")))))))))
%|- (sttfa-conv "((LAMBDA(sttfa___:A):logic_sttfa.eq[B](f(sttfa___))(f(y)))(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => (LAMBDA(sttfa___:A):logic_sttfa.eq[B](f(sttfa___))(f(y)))(y0))))" () ()
%|- (sttfa-forall-e "(FORALL(P:[A -> bool]):(P(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => P(y0)))))" "(LAMBDA(sttfa___:A):logic_sttfa.eq[B](f(sttfa___))(f(y)))"
%|- (sttfa-conv "(FORALL(P:[A -> bool]):(P(x) => (FORALL(y0:A):(logic_sttfa.eq[A](x)(y0) => P(y0)))))" () ()
%|- (sttfa-forall-e "(FORALL(x0:A):(FORALL(P:[A -> bool]):(P(x0) => (FORALL(y0:A):(logic_sttfa.eq[A](x0)(y0) => P(y0))))))" "x"
%|- (sttfa-lemma "logic_sttfa.rewrite_l[A]")))))))))
%|- (sttfa-conv "((LAMBDA(x0:A):logic_sttfa.eq[B](f(x0))(f(y)))(y) => (FORALL(x0:A):(logic_sttfa.eq[A](x0)(y) => (LAMBDA(x00:A):logic_sttfa.eq[B](f(x00))(f(y)))(x0))))" () ()
%|- (sttfa-forall-e "(FORALL(P:[A -> bool]):(P(y) => (FORALL(x0:A):(logic_sttfa.eq[A](x0)(y) => P(x0)))))" "(LAMBDA(x0:A):logic_sttfa.eq[B](f(x0))(f(y)))"
%|- (sttfa-conv "(FORALL(P:[A -> bool]):(P(y) => (FORALL(x0:A):(logic_sttfa.eq[A](x0)(y) => P(x0)))))" () ()
%|- (sttfa-forall-e "(FORALL(a:A):(FORALL(P:[A -> bool]):(P(a) => (FORALL(x0:A):(logic_sttfa.eq[A](x0)(a) => P(x0))))))" "y"
%|- (sttfa-lemma "logic_sttfa.eq_ind_r[A]")))))))))))))
%|- QED

eq_f2 [A:TYPE+,B:TYPE+,C:TYPE+] : LEMMA (FORALL(f:[A -> [B -> C]]):(FORALL(x1:A):(FORALL(x2:A):(FORALL(y1:B):(FORALL(y2:B):(logic_sttfa.eq[A](x1)(x2) => (logic_sttfa.eq[B](y1)(y2) => logic_sttfa.eq[C](f(x1)(y1))(f(x2)(y2)))))))))

%|- eq_f2 : PROOF
%|- (then@ (sttfa-forall-i "f")
%|- (then@ (sttfa-forall-i "x1")
%|- (then@ (sttfa-forall-i "x2")
%|- (then@ (sttfa-forall-i "y1")
%|- (then@ (sttfa-forall-i "y2")
%|- (sttfa-impl-i "logic_sttfa.eq[A](x1)(x2)" "(logic_sttfa.eq[B](y1)(y2) => logic_sttfa.eq[C](f(x1)(y1))(f(x2)(y2)))"
%|- (sttfa-impl-i "logic_sttfa.eq[B](y1)(y2)" "logic_sttfa.eq[C](f(x1)(y1))(f(x2)(y2))"
%|- (sttfa-impl-e "(logic_sttfa.eq[A](x1)(x2) => logic_sttfa.eq[C](f(x1)(y1))(f(x2)(y2)))" "logic_sttfa.eq[A](x1)(x2)"
%|- (propax)
%|- (sttfa-conv "(logic_sttfa.eq[A](x1)(x2) => logic_sttfa.eq[C](f(x1)(y1))(f(x2)(y2)))" () ()
%|- (sttfa-forall-e "(FORALL(x:A):(logic_sttfa.eq[A](x)(x2) => logic_sttfa.eq[C](f(x)(y1))(f(x2)(y2))))" "x1"
%|- (sttfa-impl-e "(logic_sttfa.eq[C](f(x2)(y1))(f(x2)(y2)) => (FORALL(x:A):(logic_sttfa.eq[A](x)(x2) => logic_sttfa.eq[C](f(x)(y1))(f(x2)(y2)))))" "logic_sttfa.eq[C](f(x2)(y1))(f(x2)(y2))"
%|- (sttfa-impl-e "(logic_sttfa.eq[B](y1)(y2) => logic_sttfa.eq[C](f(x2)(y1))(f(x2)(y2)))" "logic_sttfa.eq[B](y1)(y2)"
%|- (propax)
%|- (sttfa-conv "(logic_sttfa.eq[B](y1)(y2) => logic_sttfa.eq[C](f(x2)(y1))(f(x2)(y2)))" () ()
%|- (sttfa-forall-e "(FORALL(x:B):(logic_sttfa.eq[B](x)(y2) => logic_sttfa.eq[C](f(x2)(x))(f(x2)(y2))))" "y1"
%|- (sttfa-impl-e "(logic_sttfa.eq[C](f(x2)(y2))(f(x2)(y2)) => (FORALL(x:B):(logic_sttfa.eq[B](x)(y2) => logic_sttfa.eq[C](f(x2)(x))(f(x2)(y2)))))" "logic_sttfa.eq[C](f(x2)(y2))(f(x2)(y2))"
%|- (sttfa-impl-e "(logic_sttfa.eq[A](x1)(x2) => logic_sttfa.eq[C](f(x2)(y2))(f(x2)(y2)))" "logic_sttfa.eq[A](x1)(x2)"
%|- (propax)
%|- (sttfa-conv "(logic_sttfa.eq[A](x1)(x2) => logic_sttfa.eq[C](f(x2)(y2))(f(x2)(y2)))" () ()
%|- (sttfa-forall-e "(FORALL(y:A):(logic_sttfa.eq[A](x1)(y) => logic_sttfa.eq[C](f(y)(y2))(f(x2)(y2))))" "x2"
%|- (sttfa-impl-e "(logic_sttfa.eq[C](f(x1)(y2))(f(x2)(y2)) => (FORALL(y:A):(logic_sttfa.eq[A](x1)(y) => logic_sttfa.eq[C](f(y)(y2))(f(x2)(y2)))))" "logic_sttfa.eq[C](f(x1)(y2))(f(x2)(y2))"
%|- (sttfa-impl-e "(logic_sttfa.eq[B](y1)(y2) => logic_sttfa.eq[C](f(x1)(y2))(f(x2)(y2)))" "logic_sttfa.eq[B](y1)(y2)"
%|- (propax)
%|- (sttfa-conv "(logic_sttfa.eq[B](y1)(y2) => logic_sttfa.eq[C](f(x1)(y2))(f(x2)(y2)))" () ()
%|- (sttfa-forall-e "(FORALL(y:B):(logic_sttfa.eq[B](y1)(y) => logic_sttfa.eq[C](f(x1)(y))(f(x2)(y2))))" "y2"
%|- (sttfa-impl-e "(logic_sttfa.eq[C](f(x1)(y1))(f(x2)(y2)) => (FORALL(y:B):(logic_sttfa.eq[B](y1)(y) => logic_sttfa.eq[C](f(x1)(y))(f(x2)(y2)))))" "logic_sttfa.eq[C](f(x1)(y1))(f(x2)(y2))"
%|- (sttfa-impl-e "(logic_sttfa.eq[A](x1)(x2) => logic_sttfa.eq[C](f(x1)(y1))(f(x2)(y2)))" "logic_sttfa.eq[A](x1)(x2)"
%|- (propax)
%|- (sttfa-conv "(logic_sttfa.eq[A](x1)(x2) => logic_sttfa.eq[C](f(x1)(y1))(f(x2)(y2)))" () ()
%|- (sttfa-forall-e "(FORALL(y:A):(logic_sttfa.eq[A](x1)(y) => logic_sttfa.eq[C](f(x1)(y1))(f(y)(y2))))" "x2"
%|- (sttfa-impl-e "(logic_sttfa.eq[C](f(x1)(y1))(f(x1)(y2)) => (FORALL(y:A):(logic_sttfa.eq[A](x1)(y) => logic_sttfa.eq[C](f(x1)(y1))(f(y)(y2)))))" "logic_sttfa.eq[C](f(x1)(y1))(f(x1)(y2))"
%|- (sttfa-impl-e "(logic_sttfa.eq[B](y1)(y2) => logic_sttfa.eq[C](f(x1)(y1))(f(x1)(y2)))" "logic_sttfa.eq[B](y1)(y2)"
%|- (propax)
%|- (sttfa-conv "(logic_sttfa.eq[B](y1)(y2) => logic_sttfa.eq[C](f(x1)(y1))(f(x1)(y2)))" () ()
%|- (sttfa-forall-e "(FORALL(y:B):(logic_sttfa.eq[B](y1)(y) => logic_sttfa.eq[C](f(x1)(y1))(f(x1)(y))))" "y2"
%|- (sttfa-impl-e "(logic_sttfa.eq[C](f(x1)(y1))(f(x1)(y1)) => (FORALL(y:B):(logic_sttfa.eq[B](y1)(y) => logic_sttfa.eq[C](f(x1)(y1))(f(x1)(y)))))" "logic_sttfa.eq[C](f(x1)(y1))(f(x1)(y1))"
%|- (sttfa-conv "logic_sttfa.eq[C](f(x1)(y1))(f(x1)(y1))" () ()
%|- (sttfa-forall-e "(FORALL(x:C):logic_sttfa.eq[C](x)(x))" "f(x1)(y1)"
%|- (sttfa-lemma "logic_sttfa.refl[C]")))
%|- (sttfa-conv "((LAMBDA(sttfa___:B):logic_sttfa.eq[C](f(x1)(y1))(f(x1)(sttfa___)))(y1) => (FORALL(y:B):(logic_sttfa.eq[B](y1)(y) => (LAMBDA(sttfa___:B):logic_sttfa.eq[C](f(x1)(y1))(f(x1)(sttfa___)))(y))))" () ()
%|- (sttfa-forall-e "(FORALL(P:[B -> bool]):(P(y1) => (FORALL(y:B):(logic_sttfa.eq[B](y1)(y) => P(y)))))" "(LAMBDA(sttfa___:B):logic_sttfa.eq[C](f(x1)(y1))(f(x1)(sttfa___)))"
%|- (sttfa-conv "(FORALL(P:[B -> bool]):(P(y1) => (FORALL(y:B):(logic_sttfa.eq[B](y1)(y) => P(y)))))" () ()
%|- (sttfa-forall-e "(FORALL(x:B):(FORALL(P:[B -> bool]):(P(x) => (FORALL(y:B):(logic_sttfa.eq[B](x)(y) => P(y))))))" "y1"
%|- (sttfa-lemma "logic_sttfa.rewrite_l[B]")))))))))
%|- (sttfa-conv "((LAMBDA(sttfa___:A):logic_sttfa.eq[C](f(x1)(y1))(f(sttfa___)(y2)))(x1) => (FORALL(y:A):(logic_sttfa.eq[A](x1)(y) => (LAMBDA(sttfa___:A):logic_sttfa.eq[C](f(x1)(y1))(f(sttfa___)(y2)))(y))))" () ()
%|- (sttfa-forall-e "(FORALL(P:[A -> bool]):(P(x1) => (FORALL(y:A):(logic_sttfa.eq[A](x1)(y) => P(y)))))" "(LAMBDA(sttfa___:A):logic_sttfa.eq[C](f(x1)(y1))(f(sttfa___)(y2)))"
%|- (sttfa-conv "(FORALL(P:[A -> bool]):(P(x1) => (FORALL(y:A):(logic_sttfa.eq[A](x1)(y) => P(y)))))" () ()
%|- (sttfa-forall-e "(FORALL(x:A):(FORALL(P:[A -> bool]):(P(x) => (FORALL(y:A):(logic_sttfa.eq[A](x)(y) => P(y))))))" "x1"
%|- (sttfa-lemma "logic_sttfa.rewrite_l[A]")))))))))
%|- (sttfa-conv "((LAMBDA(sttfa___:B):logic_sttfa.eq[C](f(x1)(sttfa___))(f(x2)(y2)))(y1) => (FORALL(y:B):(logic_sttfa.eq[B](y1)(y) => (LAMBDA(sttfa___:B):logic_sttfa.eq[C](f(x1)(sttfa___))(f(x2)(y2)))(y))))" () ()
%|- (sttfa-forall-e "(FORALL(P:[B -> bool]):(P(y1) => (FORALL(y:B):(logic_sttfa.eq[B](y1)(y) => P(y)))))" "(LAMBDA(sttfa___:B):logic_sttfa.eq[C](f(x1)(sttfa___))(f(x2)(y2)))"
%|- (sttfa-conv "(FORALL(P:[B -> bool]):(P(y1) => (FORALL(y:B):(logic_sttfa.eq[B](y1)(y) => P(y)))))" () ()
%|- (sttfa-forall-e "(FORALL(x:B):(FORALL(P:[B -> bool]):(P(x) => (FORALL(y:B):(logic_sttfa.eq[B](x)(y) => P(y))))))" "y1"
%|- (sttfa-lemma "logic_sttfa.rewrite_l[B]")))))))))
%|- (sttfa-conv "((LAMBDA(sttfa___:A):logic_sttfa.eq[C](f(sttfa___)(y2))(f(x2)(y2)))(x1) => (FORALL(y:A):(logic_sttfa.eq[A](x1)(y) => (LAMBDA(sttfa___:A):logic_sttfa.eq[C](f(sttfa___)(y2))(f(x2)(y2)))(y))))" () ()
%|- (sttfa-forall-e "(FORALL(P:[A -> bool]):(P(x1) => (FORALL(y:A):(logic_sttfa.eq[A](x1)(y) => P(y)))))" "(LAMBDA(sttfa___:A):logic_sttfa.eq[C](f(sttfa___)(y2))(f(x2)(y2)))"
%|- (sttfa-conv "(FORALL(P:[A -> bool]):(P(x1) => (FORALL(y:A):(logic_sttfa.eq[A](x1)(y) => P(y)))))" () ()
%|- (sttfa-forall-e "(FORALL(x:A):(FORALL(P:[A -> bool]):(P(x) => (FORALL(y:A):(logic_sttfa.eq[A](x)(y) => P(y))))))" "x1"
%|- (sttfa-lemma "logic_sttfa.rewrite_l[A]")))))))))
%|- (sttfa-conv "((LAMBDA(x:B):logic_sttfa.eq[C](f(x2)(x))(f(x2)(y2)))(y2) => (FORALL(x:B):(logic_sttfa.eq[B](x)(y2) => (LAMBDA(x0:B):logic_sttfa.eq[C](f(x2)(x0))(f(x2)(y2)))(x))))" () ()
%|- (sttfa-forall-e "(FORALL(P:[B -> bool]):(P(y2) => (FORALL(x:B):(logic_sttfa.eq[B](x)(y2) => P(x)))))" "(LAMBDA(x:B):logic_sttfa.eq[C](f(x2)(x))(f(x2)(y2)))"
%|- (sttfa-conv "(FORALL(P:[B -> bool]):(P(y2) => (FORALL(x:B):(logic_sttfa.eq[B](x)(y2) => P(x)))))" () ()
%|- (sttfa-forall-e "(FORALL(a:B):(FORALL(P:[B -> bool]):(P(a) => (FORALL(x:B):(logic_sttfa.eq[B](x)(a) => P(x))))))" "y2"
%|- (sttfa-lemma "logic_sttfa.eq_ind_r[B]")))))))))
%|- (sttfa-conv "((LAMBDA(x:A):logic_sttfa.eq[C](f(x)(y1))(f(x2)(y2)))(x2) => (FORALL(x:A):(logic_sttfa.eq[A](x)(x2) => (LAMBDA(x0:A):logic_sttfa.eq[C](f(x0)(y1))(f(x2)(y2)))(x))))" () ()
%|- (sttfa-forall-e "(FORALL(P:[A -> bool]):(P(x2) => (FORALL(x:A):(logic_sttfa.eq[A](x)(x2) => P(x)))))" "(LAMBDA(x:A):logic_sttfa.eq[C](f(x)(y1))(f(x2)(y2)))"
%|- (sttfa-conv "(FORALL(P:[A -> bool]):(P(x2) => (FORALL(x:A):(logic_sttfa.eq[A](x)(x2) => P(x)))))" () ()
%|- (sttfa-forall-e "(FORALL(a:A):(FORALL(P:[A -> bool]):(P(a) => (FORALL(x:A):(logic_sttfa.eq[A](x)(a) => P(x))))))" "x2"
%|- (sttfa-lemma "logic_sttfa.eq_ind_r[A]"))))))))))))))))
%|- QED

absurd  : LEMMA (FORALL(A:bool):(A => (connectives_sttfa.sttfa_Not(A) => connectives_sttfa.sttfa_False)))

%|- absurd : PROOF
%|- (then@ (sttfa-forall-i "A")
%|- (sttfa-impl-i "A" "(connectives_sttfa.sttfa_Not(A) => connectives_sttfa.sttfa_False)"
%|- (sttfa-impl-i "connectives_sttfa.sttfa_Not(A)" "connectives_sttfa.sttfa_False"
%|- (sttfa-impl-e "(connectives_sttfa.sttfa_Not(A) => connectives_sttfa.sttfa_False)" "connectives_sttfa.sttfa_Not(A)"
%|- (propax)
%|- (sttfa-impl-e "(((A => connectives_sttfa.sttfa_False) => connectives_sttfa.sttfa_False) => (connectives_sttfa.sttfa_Not(A) => connectives_sttfa.sttfa_False))" "((A => connectives_sttfa.sttfa_False) => connectives_sttfa.sttfa_False)"
%|- (sttfa-impl-i "(A => connectives_sttfa.sttfa_False)" "connectives_sttfa.sttfa_False"
%|- (sttfa-impl-e "(A => connectives_sttfa.sttfa_False)" "A"
%|- (propax)
%|- (propax)))
%|- (sttfa-conv "(((A => connectives_sttfa.sttfa_False) => connectives_sttfa.sttfa_False) => (connectives_sttfa.sttfa_Not(A) => connectives_sttfa.sttfa_False))" () ()
%|- (sttfa-forall-e "(FORALL(Q:bool):(((A => connectives_sttfa.sttfa_False) => Q) => (connectives_sttfa.sttfa_Not(A) => Q)))" "connectives_sttfa.sttfa_False"
%|- (sttfa-conv "(FORALL(Q:bool):(((A => connectives_sttfa.sttfa_False) => Q) => (connectives_sttfa.sttfa_Not(A) => Q)))" () ()
%|- (sttfa-forall-e "(FORALL(A:bool):(FORALL(Q:bool):(((A => connectives_sttfa.sttfa_False) => Q) => (connectives_sttfa.sttfa_Not(A) => Q))))" "A"
%|- (sttfa-lemma "connectives_sttfa.Not_ind"))))))))))
%|- QED

not_to_not  : LEMMA (FORALL(A:bool):(FORALL(B:bool):((A => B) => (connectives_sttfa.sttfa_Not(B) => connectives_sttfa.sttfa_Not(A)))))

%|- not_to_not : PROOF
%|- (then@ (sttfa-forall-i "A")
%|- (then@ (sttfa-forall-i "B")
%|- (sttfa-impl-i "(A => B)" "(connectives_sttfa.sttfa_Not(B) => connectives_sttfa.sttfa_Not(A))"
%|- (sttfa-impl-i "connectives_sttfa.sttfa_Not(B)" "connectives_sttfa.sttfa_Not(A)"
%|- (sttfa-impl-e "((A => connectives_sttfa.sttfa_False) => connectives_sttfa.sttfa_Not(A))" "(A => connectives_sttfa.sttfa_False)"
%|- (sttfa-impl-i "A" "connectives_sttfa.sttfa_False"
%|- (sttfa-impl-e "(connectives_sttfa.sttfa_Not(B) => connectives_sttfa.sttfa_False)" "connectives_sttfa.sttfa_Not(B)"
%|- (propax)
%|- (sttfa-impl-e "(B => (connectives_sttfa.sttfa_Not(B) => connectives_sttfa.sttfa_False))" "B"
%|- (sttfa-impl-e "(A => B)" "A"
%|- (propax)
%|- (propax))
%|- (sttfa-conv "(B => (connectives_sttfa.sttfa_Not(B) => connectives_sttfa.sttfa_False))" () ()
%|- (sttfa-forall-e "(FORALL(A:bool):(A => (connectives_sttfa.sttfa_Not(A) => connectives_sttfa.sttfa_False)))" "B"
%|- (sttfa-lemma "logic_sttfa.absurd"))))))
%|- (sttfa-conv "((A => connectives_sttfa.sttfa_False) => connectives_sttfa.sttfa_Not(A))" () ()
%|- (sttfa-forall-e "(FORALL(A:bool):((A => connectives_sttfa.sttfa_False) => connectives_sttfa.sttfa_Not(A)))" "A"
%|- (sttfa-lemma "connectives_sttfa.nmk"))))))))
%|- QED

sym_not_eq [A:TYPE+] : LEMMA (FORALL(x:A):(FORALL(y:A):(connectives_sttfa.sttfa_Not(logic_sttfa.eq[A](x)(y)) => connectives_sttfa.sttfa_Not(logic_sttfa.eq[A](y)(x)))))

%|- sym_not_eq : PROOF
%|- (then@ (sttfa-forall-i "x")
%|- (then@ (sttfa-forall-i "y")
%|- (sttfa-impl-i "connectives_sttfa.sttfa_Not(logic_sttfa.eq[A](x)(y))" "connectives_sttfa.sttfa_Not(logic_sttfa.eq[A](y)(x))"
%|- (sttfa-impl-e "((logic_sttfa.eq[A](y)(x) => connectives_sttfa.sttfa_False) => connectives_sttfa.sttfa_Not(logic_sttfa.eq[A](y)(x)))" "(logic_sttfa.eq[A](y)(x) => connectives_sttfa.sttfa_False)"
%|- (sttfa-impl-i "logic_sttfa.eq[A](y)(x)" "connectives_sttfa.sttfa_False"
%|- (sttfa-impl-e "(connectives_sttfa.sttfa_Not(logic_sttfa.eq[A](x)(y)) => connectives_sttfa.sttfa_False)" "connectives_sttfa.sttfa_Not(logic_sttfa.eq[A](x)(y))"
%|- (propax)
%|- (sttfa-impl-e "(logic_sttfa.eq[A](x)(y) => (connectives_sttfa.sttfa_Not(logic_sttfa.eq[A](x)(y)) => connectives_sttfa.sttfa_False))" "logic_sttfa.eq[A](x)(y)"
%|- (sttfa-impl-e "(logic_sttfa.eq[A](y)(x) => logic_sttfa.eq[A](x)(y))" "logic_sttfa.eq[A](y)(x)"
%|- (propax)
%|- (sttfa-conv "(logic_sttfa.eq[A](y)(x) => logic_sttfa.eq[A](x)(y))" () ()
%|- (sttfa-forall-e "(FORALL(y0:A):(logic_sttfa.eq[A](y0)(x) => logic_sttfa.eq[A](x)(y0)))" "y"
%|- (sttfa-impl-e "(logic_sttfa.eq[A](x)(x) => (FORALL(y0:A):(logic_sttfa.eq[A](y0)(x) => logic_sttfa.eq[A](x)(y0))))" "logic_sttfa.eq[A](x)(x)"
%|- (sttfa-conv "logic_sttfa.eq[A](x)(x)" () ()
%|- (sttfa-forall-e "(FORALL(x0:A):logic_sttfa.eq[A](x0)(x0))" "x"
%|- (sttfa-lemma "logic_sttfa.refl[A]")))
%|- (sttfa-conv "((LAMBDA(sttfa___:A):logic_sttfa.eq[A](x)(sttfa___))(x) => (FORALL(y0:A):(logic_sttfa.eq[A](y0)(x) => (LAMBDA(sttfa___:A):logic_sttfa.eq[A](x)(sttfa___))(y0))))" () ()
%|- (sttfa-forall-e "(FORALL(P:[A -> bool]):(P(x) => (FORALL(y0:A):(logic_sttfa.eq[A](y0)(x) => P(y0)))))" "(LAMBDA(sttfa___:A):logic_sttfa.eq[A](x)(sttfa___))"
%|- (sttfa-conv "(FORALL(P:[A -> bool]):(P(x) => (FORALL(y0:A):(logic_sttfa.eq[A](y0)(x) => P(y0)))))" () ()
%|- (sttfa-forall-e "(FORALL(x0:A):(FORALL(P:[A -> bool]):(P(x0) => (FORALL(y0:A):(logic_sttfa.eq[A](y0)(x0) => P(y0))))))" "x"
%|- (sttfa-lemma "logic_sttfa.rewrite_r[A]")))))))))
%|- (sttfa-conv "(logic_sttfa.eq[A](x)(y) => (connectives_sttfa.sttfa_Not(logic_sttfa.eq[A](x)(y)) => connectives_sttfa.sttfa_False))" () ()
%|- (sttfa-forall-e "(FORALL(A:bool):(A => (connectives_sttfa.sttfa_Not(A) => connectives_sttfa.sttfa_False)))" "logic_sttfa.eq[A](x)(y)"
%|- (sttfa-lemma "logic_sttfa.absurd"))))))
%|- (sttfa-conv "((logic_sttfa.eq[A](y)(x) => connectives_sttfa.sttfa_False) => connectives_sttfa.sttfa_Not(logic_sttfa.eq[A](y)(x)))" () ()
%|- (sttfa-forall-e "(FORALL(A:bool):((A => connectives_sttfa.sttfa_False) => connectives_sttfa.sttfa_Not(A)))" "logic_sttfa.eq[A](y)(x)"
%|- (sttfa-lemma "connectives_sttfa.nmk")))))))
%|- QED

proj1  : LEMMA (FORALL(A:bool):(FORALL(B:bool):(connectives_sttfa.sttfa_And(A)(B) => A)))

%|- proj1 : PROOF
%|- (then@ (sttfa-forall-i "A")
%|- (then@ (sttfa-forall-i "B")
%|- (sttfa-impl-i "connectives_sttfa.sttfa_And(A)(B)" "A"
%|- (sttfa-impl-e "(connectives_sttfa.sttfa_And(A)(B) => A)" "connectives_sttfa.sttfa_And(A)(B)"
%|- (propax)
%|- (sttfa-impl-e "((A => (B => A)) => (connectives_sttfa.sttfa_And(A)(B) => A))" "(A => (B => A))"
%|- (sttfa-impl-i "A" "(B => A)"
%|- (sttfa-impl-i "B" "A"
%|- (propax)))
%|- (sttfa-conv "((A => (B => A)) => (connectives_sttfa.sttfa_And(A)(B) => A))" () ()
%|- (sttfa-forall-e "(FORALL(return:bool):((A => (B => return)) => (connectives_sttfa.sttfa_And(A)(B) => return)))" "A"
%|- (sttfa-conv "(FORALL(return:bool):((A => (B => return)) => (connectives_sttfa.sttfa_And(A)(B) => return)))" () ()
%|- (sttfa-forall-e "(FORALL(B0:bool):(FORALL(return:bool):((A => (B0 => return)) => (connectives_sttfa.sttfa_And(A)(B0) => return))))" "B"
%|- (sttfa-conv "(FORALL(B0:bool):(FORALL(return:bool):((A => (B0 => return)) => (connectives_sttfa.sttfa_And(A)(B0) => return))))" () ()
%|- (sttfa-forall-e "(FORALL(A:bool):(FORALL(B:bool):(FORALL(return:bool):((A => (B => return)) => (connectives_sttfa.sttfa_And(A)(B) => return)))))" "A"
%|- (sttfa-lemma "connectives_sttfa.match_And_prop"))))))))))))
%|- QED

proj2  : LEMMA (FORALL(A:bool):(FORALL(B:bool):(connectives_sttfa.sttfa_And(A)(B) => B)))

%|- proj2 : PROOF
%|- (then@ (sttfa-forall-i "A")
%|- (then@ (sttfa-forall-i "B")
%|- (sttfa-impl-i "connectives_sttfa.sttfa_And(A)(B)" "B"
%|- (sttfa-impl-e "(connectives_sttfa.sttfa_And(A)(B) => B)" "connectives_sttfa.sttfa_And(A)(B)"
%|- (propax)
%|- (sttfa-impl-e "((A => (B => B)) => (connectives_sttfa.sttfa_And(A)(B) => B))" "(A => (B => B))"
%|- (sttfa-impl-i "A" "(B => B)"
%|- (sttfa-impl-i "B" "B"
%|- (propax)))
%|- (sttfa-conv "((A => (B => B)) => (connectives_sttfa.sttfa_And(A)(B) => B))" () ()
%|- (sttfa-forall-e "(FORALL(return:bool):((A => (B => return)) => (connectives_sttfa.sttfa_And(A)(B) => return)))" "B"
%|- (sttfa-conv "(FORALL(return:bool):((A => (B => return)) => (connectives_sttfa.sttfa_And(A)(B) => return)))" () ()
%|- (sttfa-forall-e "(FORALL(B0:bool):(FORALL(return:bool):((A => (B0 => return)) => (connectives_sttfa.sttfa_And(A)(B0) => return))))" "B"
%|- (sttfa-conv "(FORALL(B0:bool):(FORALL(return:bool):((A => (B0 => return)) => (connectives_sttfa.sttfa_And(A)(B0) => return))))" () ()
%|- (sttfa-forall-e "(FORALL(A:bool):(FORALL(B:bool):(FORALL(return:bool):((A => (B => return)) => (connectives_sttfa.sttfa_And(A)(B) => return)))))" "A"
%|- (sttfa-lemma "connectives_sttfa.match_And_prop"))))))))))))
%|- QED

decidable  : [bool -> bool] = (LAMBDA(A:bool):connectives_sttfa.sttfa_Or(A)(connectives_sttfa.sttfa_Not(A)))

END logic_sttfa
