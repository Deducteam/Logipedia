Require Import connectives.
Parameter eq : forall (A:Type), (A) -> (A) -> Prop.
Axiom refl : forall A, forall (x:A), (((eq) (A)) (x)) (x).
Axiom eq_ind : forall A, forall (x:A), forall (P:(A) -> Prop), ((P) (x)) -> forall (y:A), ((((eq) (A)) (x)) (y)) -> (P) (y).
Definition eq_rect_r : forall A, forall (a:A), forall (x:A), ((((eq) (A)) (x)) (a)) -> forall (P:(A) -> Prop), ((P) (a)) -> (P) (x) := fun (A:Type) => fun (a:A) => fun (x:A) => fun (p:(((eq) (A)) (x)) (a)) => (((((((eq_ind) (A)) (x)) (fun (__:A) => forall (P:(A) -> Prop), ((P) (__)) -> (P) (x))) (fun (P:(A) -> Prop) => fun (auto:(P) (x)) => (auto))) (a)) (p)).
Definition eq_ind_r : forall A, forall (a:A), forall (P:(A) -> Prop), ((P) (a)) -> forall (x:A), ((((eq) (A)) (x)) (a)) -> (P) (x) := fun (A:Type) => fun (a:A) => fun (P:(A) -> Prop) => fun (p:(P) (a)) => (fun (x0:A) => fun (p0:(((eq) (A)) (x0)) (a)) => (((((((eq_rect_r) (A)) (a)) (x0)) (p0)) (fun (x01:A) => (P) (x01))) (p))).
Definition rewrite_l : forall A, forall (x:A), forall (P:(A) -> Prop), ((P) (x)) -> forall (y:A), ((((eq) (A)) (x)) (y)) -> (P) (y) := fun (A:Type) => fun (x:A) => fun (P:(A) -> Prop) => fun (Hx:(P) (x)) => (fun (y:A) => fun (Heq:(((eq) (A)) (x)) (y)) => (((((((eq_ind) (A)) (x)) (fun (__:A) => (P) (__))) (Hx)) (y)) (Heq))).
Definition sym_eq : forall A, forall (x:A), forall (y:A), ((((eq) (A)) (x)) (y)) -> (((eq) (A)) (y)) (x) := fun (A:Type) => fun (x:A) => fun (y:A) => fun (Heq:(((eq) (A)) (x)) (y)) => (((((((rewrite_l) (A)) (x)) (fun (__:A) => (((eq) (A)) (__)) (x))) (((refl) (A)) (x))) (y)) (((((((rewrite_l) (A)) (x)) (fun (__:A) => (((eq) (A)) (x)) (__))) (((refl) (A)) (x))) (y)) (Heq))).
Definition rewrite_r : forall A, forall (x:A), forall (P:(A) -> Prop), ((P) (x)) -> forall (y:A), ((((eq) (A)) (y)) (x)) -> (P) (y) := fun (A:Type) => fun (x:A) => fun (P:(A) -> Prop) => fun (Hx:(P) (x)) => (fun (y:A) => fun (Heq:(((eq) (A)) (y)) (x)) => (((((((eq_ind) (A)) (x)) (fun (__:A) => (P) (__))) (Hx)) (y)) (((((sym_eq) (A)) (y)) (x)) (Heq)))).
Definition eq_coerc : forall (A:Prop), forall (B:Prop), (A) -> ((((eq) (Prop)) (A)) (B)) -> B := fun (A:Prop) => fun (B:Prop) => fun (Ha:A) => (fun (Heq:(((eq) (Prop)) (A)) (B)) => (((((((eq_ind) (Prop)) (A)) (fun (x_19:Prop) => x_19)) (Ha)) (B)) (Heq))).
Definition trans_eq : forall A, forall (x:A), forall (y:A), forall (z:A), ((((eq) (A)) (x)) (y)) -> ((((eq) (A)) (y)) (z)) -> (((eq) (A)) (x)) (z) := fun (A:Type) => fun (x:A) => fun (y:A) => fun (z:A) => fun (H1:(((eq) (A)) (x)) (y)) => (fun (H2:(((eq) (A)) (y)) (z)) => (((((((eq_ind_r) (A)) (y)) (fun (x0:A) => (((eq) (A)) (x0)) (z))) (((((((rewrite_l) (A)) (x)) (fun (__:A) => (((eq) (A)) (__)) (z))) (((((((rewrite_l) (A)) (x)) (fun (__:A) => (((eq) (A)) (x)) (__))) (((refl) (A)) (x))) (z)) (((((((rewrite_r) (A)) (y)) (fun (__:A) => (((eq) (A)) (__)) (z))) (H2)) (x)) (H1)))) (y)) (H1))) (x)) (H1))).
Definition eq_f : forall A, forall B, forall (f:(A) -> B), forall (x:A), forall (y:A), ((((eq) (A)) (x)) (y)) -> (((eq) (B)) ((f) (x))) ((f) (y)) := fun (A:Type) => fun (B:Type) => fun (f:(A) -> B) => fun (x:A) => fun (y:A) => fun (H:(((eq) (A)) (x)) (y)) => (((((((eq_ind_r) (A)) (y)) (fun (x0:A) => (((eq) (B)) ((f) (x0))) ((f) (y)))) (((((((rewrite_l) (A)) (x)) (fun (__:A) => (((eq) (B)) ((f) (__))) ((f) (y)))) (((((((rewrite_l) (A)) (x)) (fun (__:A) => (((eq) (B)) ((f) (x))) ((f) (__)))) (((refl) (B)) ((f) (x)))) (y)) (H))) (y)) (H))) (x)) (H)).
Definition eq_f2 : forall A, forall B, forall C, forall (f:(A) -> (B) -> C), forall (x1:A), forall (x2:A), forall (y1:B), forall (y2:B), ((((eq) (A)) (x1)) (x2)) -> ((((eq) (B)) (y1)) (y2)) -> (((eq) (C)) (((f) (x1)) (y1))) (((f) (x2)) (y2)) := fun (A:Type) => fun (B:Type) => fun (C:Type) => fun (f:(A) -> (B) -> C) => fun (x1:A) => fun (x2:A) => fun (y1:B) => fun (y2:B) => fun (E1:(((eq) (A)) (x1)) (x2)) => (fun (E2:(((eq) (B)) (y1)) (y2)) => (((((((eq_ind_r) (A)) (x2)) (fun (x:A) => (((eq) (C)) (((f) (x)) (y1))) (((f) (x2)) (y2)))) (((((((eq_ind_r) (B)) (y2)) (fun (x:B) => (((eq) (C)) (((f) (x2)) (x))) (((f) (x2)) (y2)))) (((((((rewrite_l) (A)) (x1)) (fun (__:A) => (((eq) (C)) (((f) (__)) (y2))) (((f) (x2)) (y2)))) (((((((rewrite_l) (B)) (y1)) (fun (__:B) => (((eq) (C)) (((f) (x1)) (__))) (((f) (x2)) (y2)))) (((((((rewrite_l) (A)) (x1)) (fun (__:A) => (((eq) (C)) (((f) (x1)) (y1))) (((f) (__)) (y2)))) (((((((rewrite_l) (B)) (y1)) (fun (__:B) => (((eq) (C)) (((f) (x1)) (y1))) (((f) (x1)) (__)))) (((refl) (C)) (((f) (x1)) (y1)))) (y2)) (E2))) (x2)) (E1))) (y2)) (E2))) (x2)) (E1))) (y1)) (E2))) (x1)) (E1))).
Definition absurd : forall (A:Prop), (A) -> (((connectives.Not) ) (A)) -> (connectives.False)  := fun (A:Prop) => fun (H:A) => (fun (Hn:((connectives.Not) ) (A)) => (((((connectives.Not_ind) (A)) ((connectives.False) )) (fun (_x_80:(A) -> (connectives.False) ) => ((_x_80) (H)))) (Hn))).
Definition not_to_not : forall (A:Prop), forall (B:Prop), ((A) -> B) -> (((connectives.Not) ) (B)) -> ((connectives.Not) ) (A) := fun (A:Prop) => fun (B:Prop) => fun (auto:(A) -> B) => (fun (auto':((connectives.Not) ) (B)) => (((connectives.nmk) (A)) (fun (auto'':A) => ((((absurd) (B)) ((auto) (auto''))) (auto'))))).
Definition sym_not_eq : forall A, forall (x:A), forall (y:A), (((connectives.Not) ) ((((eq) (A)) (x)) (y))) -> ((connectives.Not) ) ((((eq) (A)) (y)) (x)) := fun (A:Type) => fun (x:A) => fun (y:A) => fun (auto:((connectives.Not) ) ((((eq) (A)) (x)) (y))) => (((connectives.nmk) ((((eq) (A)) (y)) (x))) (fun (auto':(((eq) (A)) (y)) (x)) => ((((absurd) ((((eq) (A)) (x)) (y))) (((((((rewrite_r) (A)) (x)) (fun (__:A) => (((eq) (A)) (x)) (__))) (((refl) (A)) (x))) (y)) (auto'))) (auto)))).
Definition proj1 : forall (A:Prop), forall (B:Prop), ((((connectives.And) ) (A)) (B)) -> A := fun (A:Prop) => fun (B:Prop) => fun (AB:(((connectives.And) ) (A)) (B)) => ((((((connectives.match_And_prop) (A)) (B)) (A)) (fun (_x_120:A) => (fun (_x_119:B) => (_x_120)))) (AB)).
Definition proj2 : forall (A:Prop), forall (B:Prop), ((((connectives.And) ) (A)) (B)) -> B := fun (A:Prop) => fun (B:Prop) => fun (AB:(((connectives.And) ) (A)) (B)) => ((((((connectives.match_And_prop) (A)) (B)) (B)) (fun (_x_120:A) => (fun (_x_119:B) => (_x_119)))) (AB)).
Definition decidable : (Prop) -> Prop := fun (A:Prop) => (((connectives.Or) ) (A)) (((connectives.Not) ) (A)).
