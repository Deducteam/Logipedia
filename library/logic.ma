include "basics/pts.ma".
include "connectives.ma".
axiom eq : \forall A : Type[0] . (A) -> (A) -> Prop.
axiom refl : \forall A. \forall (x:A). (((eq) (A)) (x)) (x).
axiom eq_ind : \forall A. \forall (x:A). \forall (P:(A) -> Prop). ((P) (x)) -> \forall (y:A). ((((eq) (A)) (x)) (y)) -> (P) (y).
definition eq_rect_r : \forall A. \forall (a:A). \forall (x:A). ((((eq) (A)) (x)) (a)) -> \forall (P:(A) -> Prop). ((P) (a)) -> (P) (x) := \lambda A : Type[0]. \lambda a : A. \lambda x : A. \lambda p : (((eq) (A)) (x)) (a). (((((((eq_ind) (A)) (x)) (\lambda j__ : A. \forall (P:(A) -> Prop). ((P) (j__)) -> (P) (x))) (\lambda P : (A) -> Prop. \lambda auto : (P) (x). (auto))) (a)) (p)).
definition eq_ind_r : \forall A. \forall (a:A). \forall (P:(A) -> Prop). ((P) (a)) -> \forall (x:A). ((((eq) (A)) (x)) (a)) -> (P) (x) := \lambda A : Type[0]. \lambda a : A. \lambda P : (A) -> Prop. \lambda p : (P) (a). (\lambda x0 : A. \lambda p0 : (((eq) (A)) (x0)) (a). (((((((eq_rect_r) (A)) (a)) (x0)) (p0)) (\lambda x01 : A. (P) (x01))) (p))).
definition rewrite_l : \forall A. \forall (x:A). \forall (P:(A) -> Prop). ((P) (x)) -> \forall (y:A). ((((eq) (A)) (x)) (y)) -> (P) (y) := \lambda A : Type[0]. \lambda x : A. \lambda P : (A) -> Prop. \lambda Hx : (P) (x). (\lambda y : A. \lambda Heq : (((eq) (A)) (x)) (y). (((((((eq_ind) (A)) (x)) (\lambda j__ : A. (P) (j__))) (Hx)) (y)) (Heq))).
definition sym_eq : \forall A. \forall (x:A). \forall (y:A). ((((eq) (A)) (x)) (y)) -> (((eq) (A)) (y)) (x) := \lambda A : Type[0]. \lambda x : A. \lambda y : A. \lambda Heq : (((eq) (A)) (x)) (y). (((((((rewrite_l) (A)) (x)) (\lambda j__ : A. (((eq) (A)) (j__)) (x))) (((refl) (A)) (x))) (y)) (((((((rewrite_l) (A)) (x)) (\lambda j__ : A. (((eq) (A)) (x)) (j__))) (((refl) (A)) (x))) (y)) (Heq))).
definition rewrite_r : \forall A. \forall (x:A). \forall (P:(A) -> Prop). ((P) (x)) -> \forall (y:A). ((((eq) (A)) (y)) (x)) -> (P) (y) := \lambda A : Type[0]. \lambda x : A. \lambda P : (A) -> Prop. \lambda Hx : (P) (x). (\lambda y : A. \lambda Heq : (((eq) (A)) (y)) (x). (((((((eq_ind) (A)) (x)) (\lambda j__ : A. (P) (j__))) (Hx)) (y)) (((((sym_eq) (A)) (y)) (x)) (Heq)))).
definition eq_coerc : \forall (A:Prop). \forall (B:Prop). (A) -> ((((eq) (Prop)) (A)) (B)) -> B := \lambda A : Prop. \lambda B : Prop. \lambda Ha : A. (\lambda Heq : (((eq) (Prop)) (A)) (B). (((((((eq_ind) (Prop)) (A)) (\lambda x_19 : Prop. x_19)) (Ha)) (B)) (Heq))).
definition trans_eq : \forall A. \forall (x:A). \forall (y:A). \forall (z:A). ((((eq) (A)) (x)) (y)) -> ((((eq) (A)) (y)) (z)) -> (((eq) (A)) (x)) (z) := \lambda A : Type[0]. \lambda x : A. \lambda y : A. \lambda z : A. \lambda H1 : (((eq) (A)) (x)) (y). (\lambda H2 : (((eq) (A)) (y)) (z). (((((((eq_ind_r) (A)) (y)) (\lambda x0 : A. (((eq) (A)) (x0)) (z))) (((((((rewrite_l) (A)) (x)) (\lambda j__ : A. (((eq) (A)) (j__)) (z))) (((((((rewrite_l) (A)) (x)) (\lambda j__ : A. (((eq) (A)) (x)) (j__))) (((refl) (A)) (x))) (z)) (((((((rewrite_r) (A)) (y)) (\lambda j__ : A. (((eq) (A)) (j__)) (z))) (H2)) (x)) (H1)))) (y)) (H1))) (x)) (H1))).
definition eq_f : \forall A. \forall B. \forall (f:(A) -> B). \forall (x:A). \forall (y:A). ((((eq) (A)) (x)) (y)) -> (((eq) (B)) ((f) (x))) ((f) (y)) := \lambda A : Type[0]. \lambda B : Type[0]. \lambda f : (A) -> B. \lambda x : A. \lambda y : A. \lambda H : (((eq) (A)) (x)) (y). (((((((eq_ind_r) (A)) (y)) (\lambda x0 : A. (((eq) (B)) ((f) (x0))) ((f) (y)))) (((((((rewrite_l) (A)) (x)) (\lambda j__ : A. (((eq) (B)) ((f) (j__))) ((f) (y)))) (((((((rewrite_l) (A)) (x)) (\lambda j__ : A. (((eq) (B)) ((f) (x))) ((f) (j__)))) (((refl) (B)) ((f) (x)))) (y)) (H))) (y)) (H))) (x)) (H)).
definition eq_f2 : \forall A. \forall B. \forall C. \forall (f:(A) -> (B) -> C). \forall (x1:A). \forall (x2:A). \forall (y1:B). \forall (y2:B). ((((eq) (A)) (x1)) (x2)) -> ((((eq) (B)) (y1)) (y2)) -> (((eq) (C)) (((f) (x1)) (y1))) (((f) (x2)) (y2)) := \lambda A : Type[0]. \lambda B : Type[0]. \lambda C : Type[0]. \lambda f : (A) -> (B) -> C. \lambda x1 : A. \lambda x2 : A. \lambda y1 : B. \lambda y2 : B. \lambda E1 : (((eq) (A)) (x1)) (x2). (\lambda E2 : (((eq) (B)) (y1)) (y2). (((((((eq_ind_r) (A)) (x2)) (\lambda x : A. (((eq) (C)) (((f) (x)) (y1))) (((f) (x2)) (y2)))) (((((((eq_ind_r) (B)) (y2)) (\lambda x : B. (((eq) (C)) (((f) (x2)) (x))) (((f) (x2)) (y2)))) (((((((rewrite_l) (A)) (x1)) (\lambda j__ : A. (((eq) (C)) (((f) (j__)) (y2))) (((f) (x2)) (y2)))) (((((((rewrite_l) (B)) (y1)) (\lambda j__ : B. (((eq) (C)) (((f) (x1)) (j__))) (((f) (x2)) (y2)))) (((((((rewrite_l) (A)) (x1)) (\lambda j__ : A. (((eq) (C)) (((f) (x1)) (y1))) (((f) (j__)) (y2)))) (((((((rewrite_l) (B)) (y1)) (\lambda j__ : B. (((eq) (C)) (((f) (x1)) (y1))) (((f) (x1)) (j__)))) (((refl) (C)) (((f) (x1)) (y1)))) (y2)) (E2))) (x2)) (E1))) (y2)) (E2))) (x2)) (E1))) (y1)) (E2))) (x1)) (E1))).
definition absurd : \forall (A:Prop). (A) -> (((Not) ) (A)) -> (False)  := \lambda A : Prop. \lambda H : A. (\lambda Hn : ((Not) ) (A). (((((Not_ind) (A)) ((False) )) (\lambda j_x_80 : (A) -> (False) . ((j_x_80) (H)))) (Hn))).
definition not_to_not : \forall (A:Prop). \forall (B:Prop). ((A) -> B) -> (((Not) ) (B)) -> ((Not) ) (A) := \lambda A : Prop. \lambda B : Prop. \lambda auto : (A) -> B. (\lambda auto' : ((Not) ) (B). (((nmk) (A)) (\lambda auto'' : A. ((((absurd) (B)) ((auto) (auto''))) (auto'))))).
definition sym_not_eq : \forall A. \forall (x:A). \forall (y:A). (((Not) ) ((((eq) (A)) (x)) (y))) -> ((Not) ) ((((eq) (A)) (y)) (x)) := \lambda A : Type[0]. \lambda x : A. \lambda y : A. \lambda auto : ((Not) ) ((((eq) (A)) (x)) (y)). (((nmk) ((((eq) (A)) (y)) (x))) (\lambda auto' : (((eq) (A)) (y)) (x). ((((absurd) ((((eq) (A)) (x)) (y))) (((((((rewrite_r) (A)) (x)) (\lambda j__ : A. (((eq) (A)) (x)) (j__))) (((refl) (A)) (x))) (y)) (auto'))) (auto)))).
definition proj1 : \forall (A:Prop). \forall (B:Prop). ((((And) ) (A)) (B)) -> A := \lambda A : Prop. \lambda B : Prop. \lambda AB : (((And) ) (A)) (B). ((((((match_And_prop) (A)) (B)) (A)) (\lambda j_x_120 : A. (\lambda j_x_119 : B. (j_x_120)))) (AB)).
definition proj2 : \forall (A:Prop). \forall (B:Prop). ((((And) ) (A)) (B)) -> B := \lambda A : Prop. \lambda B : Prop. \lambda AB : (((And) ) (A)) (B). ((((((match_And_prop) (A)) (B)) (B)) (\lambda j_x_120 : A. (\lambda j_x_119 : B. (j_x_119)))) (AB)).
definition decidable : (Prop) -> Prop := \lambda A : Prop. (((Or) ) (A)) (((Not) ) (A)).
