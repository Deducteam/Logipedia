Require Import bool.
Require Import connectives.
Require Import div_mod.
Require Import logic.
Require Import nat.
Require Import relations.
Parameter divides : ((nat.nat) ) -> ((nat.nat) ) -> Prop.
Axiom quotient : forall (n:(nat.nat) ), forall (m:(nat.nat) ), forall (q:(nat.nat) ), ((((logic.eq) ((nat.nat) )) (m)) ((((nat.times) ) (n)) (q))) -> (((divides) ) (n)) (m).
Axiom match_divides_prop : forall (n:(nat.nat) ), forall (m:(nat.nat) ), forall (return_type:Prop), (forall (q:(nat.nat) ), ((((logic.eq) ((nat.nat) )) (m)) ((((nat.times) ) (n)) (q))) -> return_type) -> ((((divides) ) (n)) (m)) -> return_type.
Definition reflexive_divides : ((relations.reflexive) ((nat.nat) )) ((divides) ) := fun (x:(nat.nat) ) => ((((quotient) (x)) (x)) (((nat.S) ) ((nat.O) ))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (x)) (((nat.S) ) ((nat.O) )))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__)) ((((nat.times) ) (x)) (((nat.S) ) ((nat.O) ))))) (((logic.refl) ((nat.nat) )) ((((nat.times) ) (x)) (((nat.S) ) ((nat.O) ))))) (x)) ((nat.times_n_1) (x))).
Definition divides_to_div_mod_spec : forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((((nat.lt) ) ((nat.O) )) (n)) -> ((((divides) ) (n)) (m)) -> (((((div_mod.div_mod_spec) ) (m)) (n)) ((((div_mod.div) ) (m)) (n))) ((nat.O) ) := fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => fun (posn:(((nat.lt) ) ((nat.O) )) (n)) => (fun (_clearme:(((divides) ) (n)) (m)) => ((((((match_divides_prop) (n)) (m)) ((((((div_mod.div_mod_spec) ) (m)) (n)) ((((div_mod.div) ) (m)) (n))) ((nat.O) ))) (fun (q:(nat.nat) ) => fun (eqm:(((logic.eq) ((nat.nat) )) (m)) ((((nat.times) ) (n)) (q))) => (((((((div_mod.div_mod_spec_intro) (m)) (n)) ((((div_mod.div) ) (m)) (n))) ((nat.O) )) (posn)) (((((((logic.eq_ind_r) ((nat.nat) )) ((((nat.times) ) (n)) (q))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (x)) ((((nat.plus) ) ((((nat.times) ) ((((div_mod.div) ) (x)) (n))) (n))) ((nat.O) )))) (((((((logic.eq_ind_r) ((nat.nat) )) ((((nat.times) ) (q)) (n))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (x)) ((((nat.plus) ) ((((nat.times) ) ((((div_mod.div) ) (x)) (n))) (n))) ((nat.O) )))) (((((((logic.eq_ind_r) ((nat.nat) )) (q)) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.times) ) (q)) (n))) ((((nat.plus) ) ((((nat.times) ) (x)) (n))) ((nat.O) )))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (n)) (q))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__)) ((((nat.plus) ) ((((nat.times) ) (q)) (n))) ((nat.O) )))) (((((((logic.rewrite_l) ((nat.nat) )) (m)) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__)) ((((nat.plus) ) ((((nat.times) ) (q)) (n))) ((nat.O) )))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (n)) (q))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (m)) ((((nat.plus) ) (__)) ((nat.O) )))) (((((((logic.rewrite_l) ((nat.nat) )) (m)) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (m)) ((((nat.plus) ) (__)) ((nat.O) )))) (((((((logic.rewrite_l) ((nat.nat) )) (m)) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (m)) (__))) (((logic.refl) ((nat.nat) )) (m))) ((((nat.plus) ) (m)) ((nat.O) ))) ((nat.plus_n_O) (m)))) ((((nat.times) ) (n)) (q))) (eqm))) ((((nat.times) ) (q)) (n))) (((nat.commutative_times) (q)) (n)))) ((((nat.times) ) (n)) (q))) (eqm))) ((((nat.times) ) (q)) (n))) (((nat.commutative_times) (q)) (n)))) ((((div_mod.div) ) ((((nat.times) ) (q)) (n))) (n))) ((((div_mod.div_times) (q)) (n)) (posn)))) ((((nat.times) ) (n)) (q))) (((nat.commutative_times) (n)) (q)))) (m)) (eqm))))) (_clearme))).
Definition divides_to_mod_O : forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((((nat.lt) ) ((nat.O) )) (n)) -> ((((divides) ) (n)) (m)) -> (((logic.eq) ((nat.nat) )) ((((div_mod.mod) ) (m)) (n))) ((nat.O) ) := fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => fun (posn:(((nat.lt) ) ((nat.O) )) (n)) => (fun (divnm:(((divides) ) (n)) (m)) => (((((((((div_mod.div_mod_spec_to_eq2) (m)) (n)) ((((div_mod.div) ) (m)) (n))) ((((div_mod.mod) ) (m)) (n))) ((((div_mod.div) ) (m)) (n))) ((nat.O) )) ((((div_mod.div_mod_spec_div_mod) (m)) (n)) (posn))) (((((divides_to_div_mod_spec) (n)) (m)) (posn)) (divnm)))).
Definition mod_O_to_divides : forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((((nat.lt) ) ((nat.O) )) (n)) -> ((((logic.eq) ((nat.nat) )) ((((div_mod.mod) ) (m)) (n))) ((nat.O) )) -> (((divides) ) (n)) (m) := fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => fun (auto:(((nat.lt) ) ((nat.O) )) (n)) => (fun (auto':(((logic.eq) ((nat.nat) )) ((((div_mod.mod) ) (m)) (n))) ((nat.O) )) => (((((quotient) (n)) (m)) ((((div_mod.div) ) (m)) (n))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.times) ) (n)) ((((div_mod.div) ) (m)) (n)))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__)) ((((nat.times) ) (n)) ((((div_mod.div) ) (m)) (n))))) (((logic.refl) ((nat.nat) )) ((((nat.times) ) (n)) ((((div_mod.div) ) (m)) (n))))) (m)) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.minus) ) (m)) ((nat.O) ))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.times) ) (n)) ((((div_mod.div) ) (m)) (n)))) (__))) (((((((logic.rewrite_l) ((nat.nat) )) ((((div_mod.mod) ) (m)) (n))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.times) ) (n)) ((((div_mod.div) ) (m)) (n)))) ((((nat.minus) ) (m)) (__)))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.times) ) ((((div_mod.div) ) (m)) (n))) (n))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__)) ((((nat.minus) ) (m)) ((((div_mod.mod) ) (m)) (n))))) (((div_mod.eq_times_div_minus_mod) (m)) (n))) ((((nat.times) ) (n)) ((((div_mod.div) ) (m)) (n)))) (((nat.commutative_times) ((((div_mod.div) ) (m)) (n))) (n)))) ((nat.O) )) (auto'))) (m)) ((nat.minus_n_O) (m)))))).
Definition divides_n_O : forall (n:(nat.nat) ), (((divides) ) (n)) ((nat.O) ) := fun (n:(nat.nat) ) => ((((quotient) (n)) ((nat.O) )) ((nat.O) )) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (n)) ((nat.O) ))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__)) ((((nat.times) ) (n)) ((nat.O) )))) (((logic.refl) ((nat.nat) )) ((((nat.times) ) (n)) ((nat.O) )))) ((nat.O) )) ((nat.times_n_O) (n))).
Definition divides_n_n : forall (n:(nat.nat) ), (((divides) ) (n)) (n) := fun (n:(nat.nat) ) => (reflexive_divides) (n).
Definition eq_mod_to_divides : forall (n:(nat.nat) ), forall (m:(nat.nat) ), forall (q:(nat.nat) ), ((((nat.lt) ) ((nat.O) )) (q)) -> ((((logic.eq) ((nat.nat) )) ((((div_mod.mod) ) (n)) (q))) ((((div_mod.mod) ) (m)) (q))) -> (((divides) ) (q)) ((((nat.minus) ) (n)) (m)) := fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => fun (q:(nat.nat) ) => fun (posq:(((nat.lt) ) ((nat.O) )) (q)) => (fun (eqmod:(((logic.eq) ((nat.nat) )) ((((div_mod.mod) ) (n)) (q))) ((((div_mod.mod) ) (m)) (q))) => ((((((nat.leb_elim) (n)) (m)) (fun (__:(bool.bool) ) => (((divides) ) (q)) ((((nat.minus) ) (n)) (m)))) (fun (nm:(((nat.le) ) (n)) (m)) => (((((logic.eq_coerc) ((((divides) ) (q)) ((nat.O) ))) ((((divides) ) (q)) ((((nat.minus) ) (n)) (m)))) ((divides_n_O) (q))) (((((((logic.rewrite_r) ((nat.nat) )) ((nat.O) )) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((divides) ) (q)) ((nat.O) ))) ((((divides) ) (q)) (__)))) (((logic.refl) (Prop)) ((((divides) ) (q)) ((nat.O) )))) ((((nat.minus) ) (n)) (m))) (((((logic.sym_eq) ((nat.nat) )) ((nat.O) )) ((((nat.minus) ) (n)) (m))) (((((logic.eq_coerc) ((((logic.eq) ((nat.nat) )) ((((nat.minus) ) ((nat.O) )) ((((nat.minus) ) (m)) (n)))) ((((nat.minus) ) ((((nat.plus) ) ((nat.O) )) (n))) (m)))) ((((logic.eq) ((nat.nat) )) ((nat.O) )) ((((nat.minus) ) (n)) (m)))) (((((nat.minus_le_minus_minus_comm) (m)) (n)) ((nat.O) )) (nm))) (((((((logic.rewrite_l) ((nat.nat) )) ((nat.O) )) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((logic.eq) ((nat.nat) )) (__)) ((((nat.minus) ) ((((nat.plus) ) ((nat.O) )) (n))) (m)))) ((((logic.eq) ((nat.nat) )) ((nat.O) )) ((((nat.minus) ) (n)) (m))))) (((((((logic.rewrite_l) ((nat.nat) )) (n)) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((logic.eq) ((nat.nat) )) ((nat.O) )) ((((nat.minus) ) (__)) (m)))) ((((logic.eq) ((nat.nat) )) ((nat.O) )) ((((nat.minus) ) (n)) (m))))) (((logic.refl) (Prop)) ((((logic.eq) ((nat.nat) )) ((nat.O) )) ((((nat.minus) ) (n)) (m))))) ((((nat.plus) ) ((nat.O) )) (n))) ((nat.plus_O_n) (n)))) ((((nat.minus) ) ((nat.O) )) ((((nat.minus) ) (m)) (n)))) ((nat.minus_O_n) ((((nat.minus) ) (m)) (n)))))))))) (fun (nm:((connectives.Not) ) ((((nat.le) ) (n)) (m))) => (((((quotient) (q)) ((((nat.minus) ) (n)) (m))) ((((nat.minus) ) ((((div_mod.div) ) (n)) (q))) ((((div_mod.div) ) (m)) (q)))) (((((((logic.eq_ind_r) ((nat.nat) )) ((((nat.minus) ) ((((nat.times) ) (q)) ((((div_mod.div) ) (n)) (q)))) ((((nat.times) ) (q)) ((((div_mod.div) ) (m)) (q))))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.minus) ) (n)) (m))) (x))) (((((((logic.eq_ind_r) ((nat.nat) )) ((((nat.times) ) ((((div_mod.div) ) (n)) (q))) (q))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.minus) ) (n)) (m))) ((((nat.minus) ) (x)) ((((nat.times) ) (q)) ((((div_mod.div) ) (m)) (q)))))) (((((((logic.eq_ind_r) ((nat.nat) )) ((((nat.times) ) ((((div_mod.div) ) (m)) (q))) (q))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.minus) ) (n)) (m))) ((((nat.minus) ) ((((nat.times) ) ((((div_mod.div) ) (n)) (q))) (q))) (x)))) (((((((logic.eq_ind_r) ((nat.nat) )) ((((nat.minus) ) (n)) ((((div_mod.mod) ) (n)) (q)))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.minus) ) (n)) (m))) ((((nat.minus) ) (x)) ((((nat.times) ) ((((div_mod.div) ) (m)) (q))) (q))))) (((((((logic.eq_ind_r) ((nat.nat) )) ((((nat.minus) ) (n)) ((((nat.plus) ) ((((div_mod.mod) ) (n)) (q))) ((((nat.times) ) ((((div_mod.div) ) (m)) (q))) (q))))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.minus) ) (n)) (m))) (x))) (((((((logic.eq_ind_r) ((nat.nat) )) ((((div_mod.mod) ) (m)) (q))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.minus) ) (n)) (m))) ((((nat.minus) ) (n)) ((((nat.plus) ) (x)) ((((nat.times) ) ((((div_mod.div) ) (m)) (q))) (q)))))) (((((((logic.eq_ind_r) ((nat.nat) )) ((((nat.plus) ) ((((nat.times) ) ((((div_mod.div) ) (m)) (q))) (q))) ((((div_mod.mod) ) (m)) (q)))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.minus) ) (n)) (m))) ((((nat.minus) ) (n)) (x)))) (((((((logic.eq_ind) ((nat.nat) )) (m)) (fun (x_1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.minus) ) (n)) (m))) ((((nat.minus) ) (n)) (x_1)))) (((logic.refl) ((nat.nat) )) ((((nat.minus) ) (n)) (m)))) ((((nat.plus) ) ((((nat.times) ) ((((div_mod.div) ) (m)) (q))) (q))) ((((div_mod.mod) ) (m)) (q)))) (((div_mod.div_mod) (m)) (q)))) ((((nat.plus) ) ((((div_mod.mod) ) (m)) (q))) ((((nat.times) ) ((((div_mod.div) ) (m)) (q))) (q)))) (((nat.commutative_plus) ((((div_mod.mod) ) (m)) (q))) ((((nat.times) ) ((((div_mod.div) ) (m)) (q))) (q))))) ((((div_mod.mod) ) (n)) (q))) (eqmod))) ((((nat.minus) ) ((((nat.minus) ) (n)) ((((div_mod.mod) ) (n)) (q)))) ((((nat.times) ) ((((div_mod.div) ) (m)) (q))) (q)))) ((((nat.minus_plus) (n)) ((((div_mod.mod) ) (n)) (q))) ((((nat.times) ) ((((div_mod.div) ) (m)) (q))) (q))))) ((((nat.times) ) ((((div_mod.div) ) (n)) (q))) (q))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (q)) ((((div_mod.div) ) (n)) (q)))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__)) ((((nat.minus) ) (n)) ((((div_mod.mod) ) (n)) (q))))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.times) ) (q)) ((((div_mod.div) ) (n)) (q)))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.times) ) (q)) ((((div_mod.div) ) (n)) (q)))) (__))) (((logic.refl) ((nat.nat) )) ((((nat.times) ) (q)) ((((div_mod.div) ) (n)) (q))))) ((((nat.minus) ) (n)) ((((div_mod.mod) ) (n)) (q)))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.times) ) ((((div_mod.div) ) (n)) (q))) (q))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__)) ((((nat.minus) ) (n)) ((((div_mod.mod) ) (n)) (q))))) (((div_mod.eq_times_div_minus_mod) (n)) (q))) ((((nat.times) ) (q)) ((((div_mod.div) ) (n)) (q)))) (((nat.commutative_times) ((((div_mod.div) ) (n)) (q))) (q))))) ((((nat.times) ) ((((div_mod.div) ) (n)) (q))) (q))) (((nat.commutative_times) ((((div_mod.div) ) (n)) (q))) (q))))) ((((nat.times) ) (q)) ((((div_mod.div) ) (m)) (q)))) (((nat.commutative_times) (q)) ((((div_mod.div) ) (m)) (q))))) ((((nat.times) ) (q)) ((((div_mod.div) ) (n)) (q)))) (((nat.commutative_times) (q)) ((((div_mod.div) ) (n)) (q))))) ((((nat.times) ) (q)) ((((nat.minus) ) ((((div_mod.div) ) (n)) (q))) ((((div_mod.div) ) (m)) (q))))) ((((nat.distributive_times_minus) (q)) ((((div_mod.div) ) (n)) (q))) ((((div_mod.div) ) (m)) (q)))))))).
Definition let_clause_1531 : forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((((nat.lt) ) ((nat.O) )) (m)) -> ((((divides) ) (n)) (m)) -> forall (d:(nat.nat) ), ((((logic.eq) ((nat.nat) )) (m)) ((((nat.times) ) (n)) ((nat.O) ))) -> (((logic.eq) ((nat.nat) )) (m)) ((nat.O) ) := fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => fun (posm:(((nat.lt) ) ((nat.O) )) (m)) => (fun (_clearme:(((divides) ) (n)) (m)) => (fun (d:(nat.nat) ) => fun (eqm:(((logic.eq) ((nat.nat) )) (m)) ((((nat.times) ) (n)) ((nat.O) ))) => (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (n)) ((nat.O) ))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (m)) (__))) (eqm)) ((nat.O) )) ((nat.times_n_O) (n))))).
Definition let_clause_15311 : forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((((nat.lt) ) ((nat.O) )) (m)) -> ((((divides) ) (n)) (m)) -> forall (d:(nat.nat) ), forall (p:(nat.nat) ), ((((logic.eq) ((nat.nat) )) (m)) ((((nat.times) ) (n)) (((nat.S) ) (p)))) -> (((logic.eq) ((nat.nat) )) (m)) ((((nat.plus) ) (n)) ((((nat.times) ) (n)) (p))) := fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => fun (posm:(((nat.lt) ) ((nat.O) )) (m)) => (fun (_clearme:(((divides) ) (n)) (m)) => (fun (d:(nat.nat) ) => fun (p:(nat.nat) ) => fun (eqm:(((logic.eq) ((nat.nat) )) (m)) ((((nat.times) ) (n)) (((nat.S) ) (p)))) => (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (n)) (((nat.S) ) (p)))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (m)) (__))) (eqm)) ((((nat.plus) ) (n)) ((((nat.times) ) (n)) (p)))) (((nat.times_n_Sm) (n)) (p))))).
Definition divides_to_le : forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((((nat.lt) ) ((nat.O) )) (m)) -> ((((divides) ) (n)) (m)) -> (((nat.le) ) (n)) (m) := fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => fun (posm:(((nat.lt) ) ((nat.O) )) (m)) => (fun (_clearme:(((divides) ) (n)) (m)) => ((((((match_divides_prop) (n)) (m)) ((((nat.le) ) (n)) (m))) (fun (d:(nat.nat) ) => ((((nat.match_nat_prop) (fun (__:(nat.nat) ) => ((((logic.eq) ((nat.nat) )) (m)) ((((nat.times) ) (n)) (__))) -> (((nat.le) ) (n)) (m))) (fun (eqm:(((logic.eq) ((nat.nat) )) (m)) ((((nat.times) ) (n)) ((nat.O) ))) => (((connectives.falsity) ((((nat.le) ) (n)) (m))) ((((logic.absurd) ((((nat.le) ) (((nat.S) ) (m))) ((nat.O) ))) (((((logic.eq_coerc) ((((nat.le) ) (((nat.S) ) ((nat.O) ))) (m))) ((((nat.le) ) (((nat.S) ) (m))) ((nat.O) ))) (posm)) (((((((logic.rewrite_l) ((nat.nat) )) (m)) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) (((nat.S) ) (__))) (m))) ((((nat.le) ) (((nat.S) ) (m))) ((nat.O) )))) (((((((logic.rewrite_l) ((nat.nat) )) (m)) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) (((nat.S) ) (m))) (m))) ((((nat.le) ) (((nat.S) ) (m))) (__)))) (((logic.refl) (Prop)) ((((nat.le) ) (((nat.S) ) (m))) (m)))) ((nat.O) )) (((((((let_clause_1531) (n)) (m)) (posm)) (_clearme)) (d)) (eqm)))) ((nat.O) )) (((((((let_clause_1531) (n)) (m)) (posm)) (_clearme)) (d)) (eqm))))) ((nat.not_le_Sn_O) (m)))))) (fun (p:(nat.nat) ) => fun (eqm:(((logic.eq) ((nat.nat) )) (m)) ((((nat.times) ) (n)) (((nat.S) ) (p)))) => (((((((logic.eq_ind_r) ((nat.nat) )) ((((nat.times) ) (n)) (((nat.S) ) (p)))) (fun (x:(nat.nat) ) => (((nat.le) ) (n)) (x))) (((((logic.eq_coerc) ((((nat.le) ) (n)) ((((nat.plus) ) (n)) ((((nat.times) ) (n)) (p))))) ((((nat.le) ) (n)) ((((nat.times) ) (n)) (((nat.S) ) (p))))) (((nat.le_plus_n_r) ((((nat.times) ) (n)) (p))) (n))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.plus) ) (n)) ((((nat.times) ) (n)) (p)))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) (n)) ((((nat.plus) ) (n)) ((((nat.times) ) (n)) (p))))) ((((nat.le) ) (n)) (__)))) (((((((logic.rewrite_l) ((nat.nat) )) (m)) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) (n)) ((((nat.plus) ) (n)) ((((nat.times) ) (n)) (p))))) ((((nat.le) ) (n)) (__)))) (((((((logic.rewrite_l) ((nat.nat) )) (m)) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) (n)) (__))) ((((nat.le) ) (n)) (m)))) (((logic.refl) (Prop)) ((((nat.le) ) (n)) (m)))) ((((nat.plus) ) (n)) ((((nat.times) ) (n)) (p)))) ((((((((let_clause_15311) (n)) (m)) (posm)) (_clearme)) (d)) (p)) (eqm)))) ((((nat.plus) ) (n)) ((((nat.times) ) (n)) (p)))) ((((((((let_clause_15311) (n)) (m)) (posm)) (_clearme)) (d)) (p)) (eqm)))) ((((nat.times) ) (n)) (((nat.S) ) (p)))) (((nat.times_n_Sm) (n)) (p))))) (m)) (eqm)))) (d))) (_clearme))).
Definition dividesb : ((nat.nat) ) -> ((nat.nat) ) -> (bool.bool)  := fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => (((nat.eqb) ) ((((div_mod.mod) ) (m)) (n))) ((nat.O) ).
Definition dividesb_true_to_divides : forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((((logic.eq) ((bool.bool) )) ((((dividesb) ) (n)) (m))) ((bool.true) )) -> (((divides) ) (n)) (m) := fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => ((((((connectives.match_Or_prop) ((((nat.lt) ) ((nat.O) )) (n))) ((((logic.eq) ((nat.nat) )) ((nat.O) )) (n))) (((((logic.eq) ((bool.bool) )) ((((dividesb) ) (n)) (m))) ((bool.true) )) -> (((divides) ) (n)) (m))) (fun (posn:(((nat.lt) ) ((nat.O) )) (n)) => (fun (divbnm:(((logic.eq) ((bool.bool) )) ((((dividesb) ) (n)) (m))) ((bool.true) )) => (((((mod_O_to_divides) (n)) (m)) (posn)) ((((nat.eqb_true_to_eq) ((((div_mod.mod) ) (m)) (n))) ((nat.O) )) (divbnm)))))) (fun (eqnO:(((logic.eq) ((nat.nat) )) ((nat.O) )) (n)) => (((((((logic.eq_ind) ((nat.nat) )) ((nat.O) )) (fun (x_1:(nat.nat) ) => ((((logic.eq) ((bool.bool) )) ((((dividesb) ) (x_1)) (m))) ((bool.true) )) -> (((divides) ) (x_1)) (m))) ((((((nat.sym_eq_match_nat_type_O) ((nat.nat) )) (m)) (fun (p:(nat.nat) ) => ((((div_mod.mod_aux) ) (m)) (m)) (p))) (fun (y:(nat.nat) ) => ((((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (y)) ((nat.O) ))) ((bool.true) )) -> (((divides) ) ((nat.O) )) (m))) (fun (eqbmO:(((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (m)) ((nat.O) ))) ((bool.true) )) => (((((((logic.eq_ind_r) ((nat.nat) )) ((nat.O) )) (fun (x:(nat.nat) ) => (((divides) ) ((nat.O) )) (x))) ((divides_n_n) ((nat.O) ))) (m)) ((((nat.eqb_true_to_eq) (m)) ((nat.O) )) (eqbmO)))))) (n)) (eqnO)))) ((((nat.le_to_or_lt_eq) ((nat.O) )) (n)) ((nat.le_O_n) (n))).
Definition dividesb_false_to_not_divides : forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((((logic.eq) ((bool.bool) )) ((((dividesb) ) (n)) (m))) ((bool.false) )) -> ((connectives.Not) ) ((((divides) ) (n)) (m)) := fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => ((((((connectives.match_Or_prop) ((((nat.lt) ) ((nat.O) )) (n))) ((((logic.eq) ((nat.nat) )) ((nat.O) )) (n))) (((((logic.eq) ((bool.bool) )) ((((dividesb) ) (n)) (m))) ((bool.false) )) -> ((connectives.Not) ) ((((divides) ) (n)) (m)))) (fun (posn:(((nat.lt) ) ((nat.O) )) (n)) => (fun (ndivbnm:(((logic.eq) ((bool.bool) )) ((((dividesb) ) (n)) (m))) ((bool.false) )) => (((((logic.not_to_not) ((((divides) ) (n)) (m))) ((((logic.eq) ((nat.nat) )) ((((div_mod.mod) ) (m)) (n))) ((nat.O) ))) ((((divides_to_mod_O) (n)) (m)) (posn))) ((((nat.eqb_false_to_not_eq) ((((div_mod.mod) ) (m)) (n))) ((nat.O) )) (ndivbnm)))))) (fun (eqnO:(((logic.eq) ((nat.nat) )) ((nat.O) )) (n)) => (((((((logic.eq_ind) ((nat.nat) )) ((nat.O) )) (fun (x_1:(nat.nat) ) => ((((logic.eq) ((bool.bool) )) ((((dividesb) ) (x_1)) (m))) ((bool.false) )) -> ((connectives.Not) ) ((((divides) ) (x_1)) (m)))) ((((((nat.sym_eq_match_nat_type_O) ((nat.nat) )) (m)) (fun (p:(nat.nat) ) => ((((div_mod.mod_aux) ) (m)) (m)) (p))) (fun (y:(nat.nat) ) => ((((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (y)) ((nat.O) ))) ((bool.false) )) -> ((connectives.Not) ) ((((divides) ) ((nat.O) )) (m)))) (((((nat.nat_case) (m)) (fun (__:(nat.nat) ) => ((((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (__)) ((nat.O) ))) ((bool.false) )) -> ((connectives.Not) ) ((((divides) ) ((nat.O) )) (__)))) ((((nat.sym_eq_eqb) ((nat.O) )) (fun (y:((nat.nat) ) -> (bool.bool) ) => ((((logic.eq) ((nat.nat) )) (m)) ((nat.O) )) -> ((((logic.eq) ((bool.bool) )) ((y) ((nat.O) ))) ((bool.false) )) -> ((connectives.Not) ) ((((divides) ) ((nat.O) )) ((nat.O) )))) (((((nat.sym_eq_filter_nat_type_O) (((nat.nat) ) -> (bool.bool) )) ((nat.eqb_body) )) (fun (y:((nat.nat) ) -> (bool.bool) ) => ((((logic.eq) ((nat.nat) )) (m)) ((nat.O) )) -> ((((logic.eq) ((bool.bool) )) ((y) ((nat.O) ))) ((bool.false) )) -> ((connectives.Not) ) ((((divides) ) ((nat.O) )) ((nat.O) )))) (((nat.sym_eq_eqb_body_O) (fun (y:((nat.nat) ) -> (bool.bool) ) => ((((logic.eq) ((nat.nat) )) (m)) ((nat.O) )) -> ((((logic.eq) ((bool.bool) )) ((y) ((nat.O) ))) ((bool.false) )) -> ((connectives.Not) ) ((((divides) ) ((nat.O) )) ((nat.O) )))) ((((((nat.sym_eq_match_nat_type_O) ((bool.bool) )) ((bool.true) )) (fun (q:(nat.nat) ) => (bool.false) )) (fun (y:(bool.bool) ) => ((((logic.eq) ((nat.nat) )) (m)) ((nat.O) )) -> ((((logic.eq) ((bool.bool) )) (y)) ((bool.false) )) -> ((connectives.Not) ) ((((divides) ) ((nat.O) )) ((nat.O) )))) (fun (auto:(((logic.eq) ((nat.nat) )) (m)) ((nat.O) )) => (fun (auto':(((logic.eq) ((bool.bool) )) ((bool.true) )) ((bool.false) )) => (((((logic.not_to_not) ((((divides) ) ((nat.O) )) ((nat.O) ))) ((((logic.eq) ((bool.bool) )) ((bool.true) )) ((bool.false) ))) (fun (auto'':(((divides) ) ((nat.O) )) ((nat.O) )) => (((((((logic.rewrite_l) ((bool.bool) )) ((bool.true) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) ((bool.true) )) (__))) (((logic.refl) ((bool.bool) )) ((bool.true) ))) ((bool.false) )) (auto')))) (bool.not_eq_true_false))))))))) (fun (a:(nat.nat) ) => fun (__:(((logic.eq) ((nat.nat) )) (m)) (((nat.S) ) (a))) => (fun (_0:(((logic.eq) ((bool.bool) )) ((((nat.eqb) ) (((nat.S) ) (a))) ((nat.O) ))) ((bool.false) )) => (((connectives.nmk) ((((divides) ) ((nat.O) )) (((nat.S) ) (a)))) (fun (_clearme:(((divides) ) ((nat.O) )) (((nat.S) ) (a))) => ((((((match_divides_prop) ((nat.O) )) (((nat.S) ) (a))) ((connectives.False) )) (fun (q:(nat.nat) ) => fun (auto:(((logic.eq) ((nat.nat) )) (((nat.S) ) (a))) ((((nat.times) ) ((nat.O) )) (q))) => ((((logic.absurd) ((((logic.eq) ((nat.nat) )) ((nat.O) )) (((nat.S) ) (a)))) (((((((logic.rewrite_r) ((nat.nat) )) (n)) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__1)) (((nat.S) ) (a)))) (((((((logic.rewrite_l) ((nat.nat) )) (((nat.S) ) (a))) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__1)) (((nat.S) ) (a)))) (((logic.refl) ((nat.nat) )) (((nat.S) ) (a)))) (n)) (((((((logic.rewrite_l) ((nat.nat) )) ((nat.O) )) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((nat.S) ) (a))) (__1))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (q)) ((nat.O) ))) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((nat.S) ) (a))) (__1))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.times) ) ((nat.O) )) (q))) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((nat.S) ) (a))) (__1))) (auto)) ((((nat.times) ) (q)) ((nat.O) ))) (((nat.commutative_times) ((nat.O) )) (q)))) ((nat.O) )) ((nat.times_n_O) (q)))) (n)) (eqnO)))) ((nat.O) )) (eqnO))) ((nat.not_eq_O_S) (a))))) (_clearme))))))))) (n)) (eqnO)))) ((((nat.le_to_or_lt_eq) ((nat.O) )) (n)) ((nat.le_O_n) (n))).
Definition decidable_divides : forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((logic.decidable) ) ((((divides) ) (n)) (m)) := fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => ((((((connectives.match_Or_prop) ((((logic.eq) ((bool.bool) )) ((((dividesb) ) (n)) (m))) ((bool.true) ))) ((((logic.eq) ((bool.bool) )) ((((dividesb) ) (n)) (m))) ((bool.false) ))) (((logic.decidable) ) ((((divides) ) (n)) (m)))) (fun (auto:(((logic.eq) ((bool.bool) )) ((((dividesb) ) (n)) (m))) ((bool.true) )) => ((((connectives.or_introl) ((((divides) ) (n)) (m))) (((connectives.Not) ) ((((divides) ) (n)) (m)))) ((((dividesb_true_to_divides) (n)) (m)) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.true) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.true) ))) (((logic.refl) ((bool.bool) )) ((bool.true) ))) ((((dividesb) ) (n)) (m))) (auto)))))) (fun (auto:(((logic.eq) ((bool.bool) )) ((((dividesb) ) (n)) (m))) ((bool.false) )) => ((((connectives.or_intror) ((((divides) ) (n)) (m))) (((connectives.Not) ) ((((divides) ) (n)) (m)))) ((((dividesb_false_to_not_divides) (n)) (m)) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.false) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.false) ))) (((logic.refl) ((bool.bool) )) ((bool.false) ))) ((((dividesb) ) (n)) (m))) (auto)))))) ((bool.true_or_false) ((((dividesb) ) (n)) (m))).
Definition divides_to_dividesb_true : forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((((nat.lt) ) ((nat.O) )) (n)) -> ((((divides) ) (n)) (m)) -> (((logic.eq) ((bool.bool) )) ((((dividesb) ) (n)) (m))) ((bool.true) ) := fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => fun (posn:(((nat.lt) ) ((nat.O) )) (n)) => (fun (divnm:(((divides) ) (n)) (m)) => (((((((connectives.match_Or_prop) ((((logic.eq) ((bool.bool) )) ((((dividesb) ) (n)) (m))) ((bool.true) ))) ((((logic.eq) ((bool.bool) )) ((((dividesb) ) (n)) (m))) ((bool.false) ))) ((((logic.eq) ((bool.bool) )) ((((dividesb) ) (n)) (m))) ((bool.true) ))) (fun (auto:(((logic.eq) ((bool.bool) )) ((((dividesb) ) (n)) (m))) ((bool.true) )) => (((((((logic.rewrite_r) ((bool.bool) )) ((bool.true) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.true) ))) (((logic.refl) ((bool.bool) )) ((bool.true) ))) ((((dividesb) ) (n)) (m))) (auto)))) (fun (ndivbnm:(((logic.eq) ((bool.bool) )) ((((dividesb) ) (n)) (m))) ((bool.false) )) => (((connectives.falsity) ((((logic.eq) ((bool.bool) )) ((((dividesb) ) (n)) (m))) ((bool.true) ))) ((((logic.absurd) ((((divides) ) (n)) (m))) (divnm)) ((((dividesb_false_to_not_divides) (n)) (m)) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.false) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.false) ))) (((logic.refl) ((bool.bool) )) ((bool.false) ))) ((((dividesb) ) (n)) (m))) (ndivbnm))))))) ((bool.true_or_false) ((((dividesb) ) (n)) (m))))).
Definition not_divides_to_dividesb_false : forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((((nat.lt) ) ((nat.O) )) (n)) -> (((connectives.Not) ) ((((divides) ) (n)) (m))) -> (((logic.eq) ((bool.bool) )) ((((dividesb) ) (n)) (m))) ((bool.false) ) := fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => fun (posn:(((nat.lt) ) ((nat.O) )) (n)) => (((((((connectives.match_Or_prop) ((((logic.eq) ((bool.bool) )) ((((dividesb) ) (n)) (m))) ((bool.true) ))) ((((logic.eq) ((bool.bool) )) ((((dividesb) ) (n)) (m))) ((bool.false) ))) ((((connectives.Not) ) ((((divides) ) (n)) (m))) -> (((logic.eq) ((bool.bool) )) ((((dividesb) ) (n)) (m))) ((bool.false) ))) (fun (divbnm:(((logic.eq) ((bool.bool) )) ((((dividesb) ) (n)) (m))) ((bool.true) )) => (fun (ndivnm:((connectives.Not) ) ((((divides) ) (n)) (m))) => (((connectives.falsity) ((((logic.eq) ((bool.bool) )) ((((dividesb) ) (n)) (m))) ((bool.false) ))) ((((logic.absurd) ((((divides) ) (n)) (m))) ((((dividesb_true_to_divides) (n)) (m)) (((((((logic.rewrite_r) ((bool.bool) )) ((bool.true) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.true) ))) (((logic.refl) ((bool.bool) )) ((bool.true) ))) ((((dividesb) ) (n)) (m))) (divbnm)))) (ndivnm)))))) (fun (auto:(((logic.eq) ((bool.bool) )) ((((dividesb) ) (n)) (m))) ((bool.false) )) => (fun (auto':((connectives.Not) ) ((((divides) ) (n)) (m))) => (((((((logic.rewrite_r) ((bool.bool) )) ((bool.false) )) (fun (__:(bool.bool) ) => (((logic.eq) ((bool.bool) )) (__)) ((bool.false) ))) (((logic.refl) ((bool.bool) )) ((bool.false) ))) ((((dividesb) ) (n)) (m))) (auto))))) ((bool.true_or_false) ((((dividesb) ) (n)) (m)))).
Definition prime : ((nat.nat) ) -> Prop := fun (n:(nat.nat) ) => (((connectives.And) ) ((((nat.lt) ) (((nat.S) ) ((nat.O) ))) (n))) (forall (m:(nat.nat) ), ((((divides) ) (m)) (n)) -> ((((nat.lt) ) (((nat.S) ) ((nat.O) ))) (m)) -> (((logic.eq) ((nat.nat) )) (m)) (n)).
Definition prime_to_lt_O : forall (p:(nat.nat) ), (((prime) ) (p)) -> (((nat.lt) ) ((nat.O) )) (p) := fun (p:(nat.nat) ) => fun (_clearme:((prime) ) (p)) => ((((((connectives.match_And_prop) ((((nat.lt) ) (((nat.S) ) ((nat.O) ))) (p))) (forall (m:(nat.nat) ), ((((divides) ) (m)) (p)) -> ((((nat.lt) ) (((nat.S) ) ((nat.O) ))) (m)) -> (((logic.eq) ((nat.nat) )) (m)) (p))) ((((nat.lt) ) ((nat.O) )) (p))) (fun (lt1p:(((nat.lt) ) (((nat.S) ) ((nat.O) ))) (p)) => (fun (auto:forall (m:(nat.nat) ), ((((divides) ) (m)) (p)) -> ((((nat.lt) ) (((nat.S) ) ((nat.O) ))) (m)) -> (((logic.eq) ((nat.nat) )) (m)) (p)) => ((((nat.lt_S_to_lt) ((nat.O) )) (p)) (lt1p))))) (_clearme)).
Definition prime_to_lt_SO : forall (p:(nat.nat) ), (((prime) ) (p)) -> (((nat.lt) ) (((nat.S) ) ((nat.O) ))) (p) := fun (p:(nat.nat) ) => fun (_clearme:((prime) ) (p)) => ((((((connectives.match_And_prop) ((((nat.lt) ) (((nat.S) ) ((nat.O) ))) (p))) (forall (m:(nat.nat) ), ((((divides) ) (m)) (p)) -> ((((nat.lt) ) (((nat.S) ) ((nat.O) ))) (m)) -> (((logic.eq) ((nat.nat) )) (m)) (p))) ((((nat.lt) ) (((nat.S) ) ((nat.O) ))) (p))) (fun (lt1p:(((nat.lt) ) (((nat.S) ) ((nat.O) ))) (p)) => (fun (auto:forall (m:(nat.nat) ), ((((divides) ) (m)) (p)) -> ((((nat.lt) ) (((nat.S) ) ((nat.O) ))) (m)) -> (((logic.eq) ((nat.nat) )) (m)) (p)) => (lt1p)))) (_clearme)).
