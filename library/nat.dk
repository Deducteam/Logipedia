#NAME nat.

nat : sttfa.type.

O : sttfa.etap (sttfa.p nat.nat).

S : sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat)).

match_nat_prop :
  sttfa.eps 
    (sttfa.forall (sttfa.arrow nat.nat sttfa.bool) 
       (return:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat sttfa.bool))) =>
        sttfa.impl (return nat.O) 
          (sttfa.impl 
             (sttfa.forall nat.nat 
                (n:(sttfa.etap (sttfa.p nat.nat)) => return (nat.S n))) 
             (sttfa.forall nat.nat 
                (z:(sttfa.etap (sttfa.p nat.nat)) => return z))))).

match_nat_type :
  sttfa.etap 
    (sttfa.forallK 
       (return:sttfa.type =>
        sttfa.p 
          (sttfa.arrow return 
             (sttfa.arrow (sttfa.arrow nat.nat return) 
                (sttfa.arrow nat.nat return))))).

eq_match_nat_type_O :
  sttfa.eps 
    (sttfa.forallP 
       (return_type:sttfa.type =>
        sttfa.forall return_type 
          (case_O:(sttfa.etap (sttfa.p return_type)) =>
           sttfa.forall (sttfa.arrow nat.nat return_type) 
             (case_S:
              (sttfa.etap (sttfa.p (sttfa.arrow nat.nat return_type))) =>
              sttfa.leibniz return_type 
                (nat.match_nat_type return_type case_O case_S nat.O) case_O)))).

def sym_eq_match_nat_type_O :
  sttfa.eps 
    (sttfa.forallP 
       (return_type:sttfa.type =>
        sttfa.forall return_type 
          (case_O:(sttfa.etap (sttfa.p return_type)) =>
           sttfa.forall (sttfa.arrow nat.nat return_type) 
             (case_S:
              (sttfa.etap (sttfa.p (sttfa.arrow nat.nat return_type))) =>
              sttfa.leibniz return_type case_O 
                (nat.match_nat_type return_type case_O case_S nat.O)))))
  :=
  return_type:sttfa.type =>
  case_O:(sttfa.etap (sttfa.p return_type)) =>
  case_S:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat return_type))) =>
  sttfa.sym_leibniz return_type 
    (nat.match_nat_type return_type case_O case_S nat.O) case_O 
    (nat.eq_match_nat_type_O return_type case_O case_S).

eq_match_nat_type_S :
  sttfa.eps 
    (sttfa.forallP 
       (return_type:sttfa.type =>
        sttfa.forall return_type 
          (case_O:(sttfa.etap (sttfa.p return_type)) =>
           sttfa.forall (sttfa.arrow nat.nat return_type) 
             (case_S:
              (sttfa.etap (sttfa.p (sttfa.arrow nat.nat return_type))) =>
              sttfa.forall nat.nat 
                (n:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.leibniz return_type 
                   (nat.match_nat_type return_type case_O case_S (nat.S n)) 
                   (case_S n)))))).

def sym_eq_match_nat_type_S :
  sttfa.eps 
    (sttfa.forallP 
       (return_type:sttfa.type =>
        sttfa.forall return_type 
          (case_O:(sttfa.etap (sttfa.p return_type)) =>
           sttfa.forall (sttfa.arrow nat.nat return_type) 
             (case_S:
              (sttfa.etap (sttfa.p (sttfa.arrow nat.nat return_type))) =>
              sttfa.forall nat.nat 
                (n:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.leibniz return_type (case_S n) 
                   (nat.match_nat_type return_type case_O case_S (nat.S n)))))))
  :=
  return_type:sttfa.type =>
  case_O:(sttfa.etap (sttfa.p return_type)) =>
  case_S:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat return_type))) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  sttfa.sym_leibniz return_type 
    (nat.match_nat_type return_type case_O case_S (nat.S n)) (case_S n) 
    (nat.eq_match_nat_type_S return_type case_O case_S n).

filter_nat_type :
  sttfa.etap 
    (sttfa.forallK 
       (return:sttfa.type =>
        sttfa.p 
          (sttfa.arrow (sttfa.arrow nat.nat return) 
             (sttfa.arrow nat.nat return)))).

eq_filter_nat_type_O :
  sttfa.eps 
    (sttfa.forallP 
       (return_type:sttfa.type =>
        sttfa.forall (sttfa.arrow nat.nat return_type) 
          (return:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat return_type))) =>
           sttfa.leibniz return_type 
             (nat.filter_nat_type return_type return nat.O) (return nat.O)))).

def sym_eq_filter_nat_type_O :
  sttfa.eps 
    (sttfa.forallP 
       (return_type:sttfa.type =>
        sttfa.forall (sttfa.arrow nat.nat return_type) 
          (return:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat return_type))) =>
           sttfa.leibniz return_type (return nat.O) 
             (nat.filter_nat_type return_type return nat.O))))
  :=
  return_type:sttfa.type =>
  return:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat return_type))) =>
  sttfa.sym_leibniz return_type 
    (nat.filter_nat_type return_type return nat.O) (return nat.O) 
    (nat.eq_filter_nat_type_O return_type return).

eq_filter_nat_type_S :
  sttfa.eps 
    (sttfa.forallP 
       (return_type:sttfa.type =>
        sttfa.forall (sttfa.arrow nat.nat return_type) 
          (return:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat return_type))) =>
           sttfa.forall nat.nat 
             (n:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.leibniz return_type 
                (nat.filter_nat_type return_type return (nat.S n)) 
                (return (nat.S n)))))).

def sym_eq_filter_nat_type_S :
  sttfa.eps 
    (sttfa.forallP 
       (return_type:sttfa.type =>
        sttfa.forall (sttfa.arrow nat.nat return_type) 
          (return:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat return_type))) =>
           sttfa.forall nat.nat 
             (n:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.leibniz return_type (return (nat.S n)) 
                (nat.filter_nat_type return_type return (nat.S n))))))
  :=
  return_type:sttfa.type =>
  return:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat return_type))) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  sttfa.sym_leibniz return_type 
    (nat.filter_nat_type return_type return (nat.S n)) (return (nat.S n)) 
    (nat.eq_filter_nat_type_S return_type return n).

nat_ind :
  sttfa.eps 
    (sttfa.forall (sttfa.arrow nat.nat sttfa.bool) 
       (Q:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat sttfa.bool))) =>
        sttfa.impl (Q nat.O) 
          (sttfa.impl 
             (sttfa.forall nat.nat 
                (x:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (Q x) (Q (nat.S x)))) 
             (sttfa.forall nat.nat (x:(sttfa.etap (sttfa.p nat.nat)) => Q x))))).

def pred :
  sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.match_nat_type nat.nat nat.O (p:(sttfa.etap (sttfa.p nat.nat)) => p) n.

def not_zero :
  sttfa.etap (sttfa.p (sttfa.arrow nat.nat sttfa.bool))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.match_nat_type sttfa.bool connectives.False 
    (p:(sttfa.etap (sttfa.p nat.nat)) => connectives.True) n.

le :
  sttfa.etap (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat sttfa.bool))).

le_n :
  sttfa.eps 
    (sttfa.forall nat.nat (n:(sttfa.etap (sttfa.p nat.nat)) => nat.le n n)).

le_S :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.le n m) (nat.le n (nat.S m))))).

match_le_prop :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall (sttfa.arrow nat.nat sttfa.bool) 
          (return:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat sttfa.bool))) =>
           sttfa.impl (return n) 
             (sttfa.impl 
                (sttfa.forall nat.nat 
                   (m:(sttfa.etap (sttfa.p nat.nat)) => return (nat.S m))) 
                (sttfa.forall nat.nat 
                   (m:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (nat.le n m) (return m))))))).

le_ind :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall (sttfa.arrow nat.nat sttfa.bool) 
          (Q:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat sttfa.bool))) =>
           sttfa.impl (Q n) 
             (sttfa.impl 
                (sttfa.forall nat.nat 
                   (m:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (nat.le n m) (sttfa.impl (Q m) (Q (nat.S m))))) 
                (sttfa.forall nat.nat 
                   (m:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (nat.le n m) (Q m))))))).

def lt :
  sttfa.etap (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat sttfa.bool)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) => nat.le (nat.S n) m.

plus :
  sttfa.etap (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))).

plus_body :
  sttfa.etap (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))).

eq_plus :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat nat.nat) (nat.plus n) 
          (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) nat.plus_body n))).

def sym_eq_plus :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat nat.nat) 
          (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) nat.plus_body n) 
          (nat.plus n)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  sttfa.sym_leibniz (sttfa.arrow nat.nat nat.nat) (nat.plus n) 
    (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) nat.plus_body n) 
    (nat.eq_plus n).

eq_plus_body_O :
  sttfa.eps 
    (sttfa.leibniz (sttfa.arrow nat.nat nat.nat) (nat.plus_body nat.O) 
       (m:(sttfa.etap (sttfa.p nat.nat)) => m)).

def sym_eq_plus_body_O :
  sttfa.eps 
    (sttfa.leibniz (sttfa.arrow nat.nat nat.nat) 
       (m:(sttfa.etap (sttfa.p nat.nat)) => m) (nat.plus_body nat.O))
  :=
  sttfa.sym_leibniz (sttfa.arrow nat.nat nat.nat) (nat.plus_body nat.O) 
    (m:(sttfa.etap (sttfa.p nat.nat)) => m) nat.eq_plus_body_O.

eq_plus_body_S :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat nat.nat) 
          (nat.plus_body (nat.S n)) 
          (m:(sttfa.etap (sttfa.p nat.nat)) => nat.S (nat.plus n m)))).

def sym_eq_plus_body_S :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat nat.nat) 
          (m:(sttfa.etap (sttfa.p nat.nat)) => nat.S (nat.plus n m)) 
          (nat.plus_body (nat.S n))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  sttfa.sym_leibniz (sttfa.arrow nat.nat nat.nat) (nat.plus_body (nat.S n)) 
    (m:(sttfa.etap (sttfa.p nat.nat)) => nat.S (nat.plus n m)) 
    (nat.eq_plus_body_S n).

times :
  sttfa.etap (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))).

times_body :
  sttfa.etap (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))).

eq_times :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat nat.nat) (nat.times n) 
          (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) nat.times_body n))).

def sym_eq_times :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat nat.nat) 
          (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) nat.times_body n) 
          (nat.times n)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  sttfa.sym_leibniz (sttfa.arrow nat.nat nat.nat) (nat.times n) 
    (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) nat.times_body n) 
    (nat.eq_times n).

eq_times_body_O :
  sttfa.eps 
    (sttfa.leibniz (sttfa.arrow nat.nat nat.nat) (nat.times_body nat.O) 
       (m:(sttfa.etap (sttfa.p nat.nat)) => nat.O)).

def sym_eq_times_body_O :
  sttfa.eps 
    (sttfa.leibniz (sttfa.arrow nat.nat nat.nat) 
       (m:(sttfa.etap (sttfa.p nat.nat)) => nat.O) (nat.times_body nat.O))
  :=
  sttfa.sym_leibniz (sttfa.arrow nat.nat nat.nat) (nat.times_body nat.O) 
    (m:(sttfa.etap (sttfa.p nat.nat)) => nat.O) nat.eq_times_body_O.

eq_times_body_S :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat nat.nat) 
          (nat.times_body (nat.S n)) 
          (m:(sttfa.etap (sttfa.p nat.nat)) => nat.plus m (nat.times n m)))).

def sym_eq_times_body_S :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat nat.nat) 
          (m:(sttfa.etap (sttfa.p nat.nat)) => nat.plus m (nat.times n m)) 
          (nat.times_body (nat.S n))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  sttfa.sym_leibniz (sttfa.arrow nat.nat nat.nat) (nat.times_body (nat.S n)) 
    (m:(sttfa.etap (sttfa.p nat.nat)) => nat.plus m (nat.times n m)) 
    (nat.eq_times_body_S n).

minus :
  sttfa.etap (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))).

minus_body :
  sttfa.etap (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))).

eq_minus :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat nat.nat) (nat.minus n) 
          (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) nat.minus_body n))).

def sym_eq_minus :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat nat.nat) 
          (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) nat.minus_body n) 
          (nat.minus n)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  sttfa.sym_leibniz (sttfa.arrow nat.nat nat.nat) (nat.minus n) 
    (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) nat.minus_body n) 
    (nat.eq_minus n).

eq_minus_body_O :
  sttfa.eps 
    (sttfa.leibniz (sttfa.arrow nat.nat nat.nat) (nat.minus_body nat.O) 
       (m:(sttfa.etap (sttfa.p nat.nat)) => nat.O)).

def sym_eq_minus_body_O :
  sttfa.eps 
    (sttfa.leibniz (sttfa.arrow nat.nat nat.nat) 
       (m:(sttfa.etap (sttfa.p nat.nat)) => nat.O) (nat.minus_body nat.O))
  :=
  sttfa.sym_leibniz (sttfa.arrow nat.nat nat.nat) (nat.minus_body nat.O) 
    (m:(sttfa.etap (sttfa.p nat.nat)) => nat.O) nat.eq_minus_body_O.

eq_minus_body_S :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat nat.nat) 
          (nat.minus_body (nat.S n)) 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           nat.match_nat_type nat.nat (nat.S n) 
             (q:(sttfa.etap (sttfa.p nat.nat)) => nat.minus n q) m))).

def sym_eq_minus_body_S :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat nat.nat) 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           nat.match_nat_type nat.nat (nat.S n) 
             (q:(sttfa.etap (sttfa.p nat.nat)) => nat.minus n q) m) 
          (nat.minus_body (nat.S n))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  sttfa.sym_leibniz (sttfa.arrow nat.nat nat.nat) (nat.minus_body (nat.S n)) 
    (m:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.match_nat_type nat.nat (nat.S n) 
       (q:(sttfa.etap (sttfa.p nat.nat)) => nat.minus n q) m) 
    (nat.eq_minus_body_S n).

def nat_case :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall (sttfa.arrow nat.nat sttfa.bool) 
          (P:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat sttfa.bool))) =>
           sttfa.impl (sttfa.impl (logic.eq nat.nat n nat.O) (P nat.O)) 
             (sttfa.impl 
                (sttfa.forall nat.nat 
                   (m:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (logic.eq nat.nat n (nat.S m)) (P (nat.S m)))) 
                (P n)))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  P:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat sttfa.bool))) =>
  nat.nat_ind 
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.impl (sttfa.impl (logic.eq nat.nat _x_365 nat.O) (P nat.O)) 
       (sttfa.impl 
          (sttfa.forall nat.nat 
             (m:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (logic.eq nat.nat _x_365 (nat.S m)) (P (nat.S m)))) 
          (P _x_365))) 
    (auto:
     (sttfa.eps (sttfa.impl (logic.eq nat.nat nat.O nat.O) (P nat.O))) =>
     auto':
     (sttfa.eps 
        (sttfa.forall nat.nat 
           (m:(sttfa.etap (sttfa.p nat.nat)) =>
            sttfa.impl (logic.eq nat.nat nat.O (nat.S m)) (P (nat.S m))))) =>
     auto (logic.refl nat.nat nat.O)) 
    (x_366:(sttfa.etap (sttfa.p nat.nat)) =>
     _x_368:
     (sttfa.eps 
        (sttfa.impl (sttfa.impl (logic.eq nat.nat x_366 nat.O) (P nat.O)) 
           (sttfa.impl 
              (sttfa.forall nat.nat 
                 (m:(sttfa.etap (sttfa.p nat.nat)) =>
                  sttfa.impl (logic.eq nat.nat x_366 (nat.S m)) (P (nat.S m)))) 
              (P x_366)))) =>
     auto:
     (sttfa.eps (sttfa.impl (logic.eq nat.nat (nat.S x_366) nat.O) (P nat.O))) =>
     auto':
     (sttfa.eps 
        (sttfa.forall nat.nat 
           (m:(sttfa.etap (sttfa.p nat.nat)) =>
            sttfa.impl (logic.eq nat.nat (nat.S x_366) (nat.S m)) 
              (P (nat.S m))))) =>
     auto' x_366 (logic.refl nat.nat (nat.S x_366))) n.

def nat_elim2 :
  sttfa.eps 
    (sttfa.forall (sttfa.arrow nat.nat (sttfa.arrow nat.nat sttfa.bool)) 
       (R:
        (sttfa.etap 
           (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat sttfa.bool)))) =>
        sttfa.impl 
          (sttfa.forall nat.nat 
             (n:(sttfa.etap (sttfa.p nat.nat)) => R nat.O n)) 
          (sttfa.impl 
             (sttfa.forall nat.nat 
                (n:(sttfa.etap (sttfa.p nat.nat)) => R (nat.S n) nat.O)) 
             (sttfa.impl 
                (sttfa.forall nat.nat 
                   (n:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.forall nat.nat 
                      (m:(sttfa.etap (sttfa.p nat.nat)) =>
                       sttfa.impl (R n m) (R (nat.S n) (nat.S m))))) 
                (sttfa.forall nat.nat 
                   (n:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.forall nat.nat 
                      (m:(sttfa.etap (sttfa.p nat.nat)) => R n m)))))))
  :=
  R:
  (sttfa.etap 
     (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat sttfa.bool)))) =>
  ROn:
  (sttfa.eps 
     (sttfa.forall nat.nat (n:(sttfa.etap (sttfa.p nat.nat)) => R nat.O n))) =>
  RSO:
  (sttfa.eps 
     (sttfa.forall nat.nat 
        (n:(sttfa.etap (sttfa.p nat.nat)) => R (nat.S n) nat.O))) =>
  RSS:
  (sttfa.eps 
     (sttfa.forall nat.nat 
        (n:(sttfa.etap (sttfa.p nat.nat)) =>
         sttfa.forall nat.nat 
           (m:(sttfa.etap (sttfa.p nat.nat)) =>
            sttfa.impl (R n m) (R (nat.S n) (nat.S m)))))) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind 
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.forall nat.nat (m:(sttfa.etap (sttfa.p nat.nat)) => R _x_365 m)) 
    (m:(sttfa.etap (sttfa.p nat.nat)) => ROn m) 
    (n0:(sttfa.etap (sttfa.p nat.nat)) =>
     Rn0m:
     (sttfa.eps 
        (sttfa.forall nat.nat (m:(sttfa.etap (sttfa.p nat.nat)) => R n0 m))) =>
     m:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.match_nat_prop 
       (__:(sttfa.etap (sttfa.p nat.nat)) => R (nat.S n0) __) (RSO n0) 
       (auto:(sttfa.etap (sttfa.p nat.nat)) => RSS n0 auto (Rn0m auto)) m) n.

def le_gen :
  sttfa.eps 
    (sttfa.forall (sttfa.arrow nat.nat sttfa.bool) 
       (P:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat sttfa.bool))) =>
        sttfa.forall nat.nat 
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl 
             (sttfa.forall nat.nat 
                (i:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (nat.le i n) (P i))) (P n))))
  :=
  P:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat sttfa.bool))) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  auto:
  (sttfa.eps 
     (sttfa.forall nat.nat 
        (i:(sttfa.etap (sttfa.p nat.nat)) => sttfa.impl (nat.le i n) (P i)))) =>
  auto n (nat.le_n n).

def pred_Sn :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat n (nat.pred (nat.S n))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.sym_eq_match_nat_type_S nat.nat nat.O 
    (p:(sttfa.etap (sttfa.p nat.nat)) => p) n 
    (y:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat n y) 
    (logic.refl nat.nat n).

def injective_S :
  sttfa.eps (relations.injective nat.nat nat.nat nat.S)
  :=
  x:(sttfa.etap (sttfa.p nat.nat)) =>
  y:(sttfa.etap (sttfa.p nat.nat)) =>
  auto:(sttfa.eps (logic.eq nat.nat (nat.S x) (nat.S y))) =>
  logic.rewrite_l nat.nat y 
    (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat __ y) 
    (logic.refl nat.nat y) x 
    (logic.rewrite_r nat.nat (nat.pred (nat.S x)) 
       (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat y __) 
       (logic.rewrite_r nat.nat (nat.S y) 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat y (nat.pred __)) (nat.pred_Sn y) (nat.S x) auto) 
       x (nat.pred_Sn x)).

def S_pred :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.impl (nat.lt nat.O n) (logic.eq nat.nat (nat.S (nat.pred n)) n)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  posn:(sttfa.eps (nat.lt nat.O n)) =>
  nat.match_le_prop (nat.S nat.O) 
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq nat.nat (nat.S (nat.pred __)) __) 
    (logic.rewrite_l nat.nat nat.O 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat (nat.S __) (nat.S nat.O)) 
       (logic.refl nat.nat (nat.S nat.O)) (nat.pred (nat.S nat.O)) 
       (nat.pred_Sn nat.O)) 
    (m:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.rewrite_l nat.nat m 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat (nat.S __) (nat.S m)) 
       (logic.refl nat.nat (nat.S m)) (nat.pred (nat.S m)) (nat.pred_Sn m)) 
    n posn.

def plus_O_n :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat n (nat.plus nat.O n)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.sym_eq_plus nat.O 
    (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
     logic.eq nat.nat n (y n)) 
    (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
       nat.plus_body 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        logic.eq nat.nat n (y n)) 
       (nat.sym_eq_plus_body_O 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           logic.eq nat.nat n (y n)) (logic.refl nat.nat n))).

def plus_n_O :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat n (nat.plus n nat.O)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind 
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq nat.nat _x_365 (nat.plus _x_365 nat.O)) 
    (nat.sym_eq_plus nat.O 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        logic.eq nat.nat nat.O (y nat.O)) 
       (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
          nat.plus_body 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           logic.eq nat.nat nat.O (y nat.O)) 
          (nat.sym_eq_plus_body_O 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              logic.eq nat.nat nat.O (y nat.O)) (logic.refl nat.nat nat.O)))) 
    (x_366:(sttfa.etap (sttfa.p nat.nat)) =>
     _x_368:(sttfa.eps (logic.eq nat.nat x_366 (nat.plus x_366 nat.O))) =>
     nat.sym_eq_plus (nat.S x_366) 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        logic.eq nat.nat (nat.S x_366) (y nat.O)) 
       (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
          nat.plus_body x_366 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           logic.eq nat.nat (nat.S x_366) (y nat.O)) 
          (nat.sym_eq_plus_body_S x_366 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              logic.eq nat.nat (nat.S x_366) (y nat.O)) 
             (logic.rewrite_l nat.nat x_366 
                (__:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat (nat.S x_366) (nat.S __)) 
                (logic.refl nat.nat (nat.S x_366)) (nat.plus x_366 nat.O) 
                _x_368)))) n.

def plus_n_Sm :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat (nat.S (nat.plus n m)) (nat.plus n (nat.S m)))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind 
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.forall nat.nat 
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat (nat.S (nat.plus _x_365 m)) 
          (nat.plus _x_365 (nat.S m)))) 
    (m:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_plus nat.O 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        logic.eq nat.nat (nat.S (y m)) (nat.plus nat.O (nat.S m))) 
       (nat.sym_eq_plus nat.O 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           logic.eq nat.nat 
             (nat.S 
                (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                   nat.plus_body nat.O m)) (y (nat.S m))) 
          (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
             nat.plus_body 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              logic.eq nat.nat 
                (nat.S 
                   (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                      nat.plus_body nat.O m)) (y (nat.S m))) 
             (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
                nat.plus_body 
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 logic.eq nat.nat (nat.S (y m)) 
                   (nat.plus_body nat.O (nat.S m))) 
                (nat.sym_eq_plus_body_O 
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                    logic.eq nat.nat (nat.S (y m)) 
                      (nat.plus_body nat.O (nat.S m))) 
                   (nat.sym_eq_plus_body_O 
                      (y:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       logic.eq nat.nat (nat.S m) (y (nat.S m))) 
                      (logic.refl nat.nat (nat.S m)))))))) 
    (x_366:(sttfa.etap (sttfa.p nat.nat)) =>
     _x_368:
     (sttfa.eps 
        (sttfa.forall nat.nat 
           (m:(sttfa.etap (sttfa.p nat.nat)) =>
            logic.eq nat.nat (nat.S (nat.plus x_366 m)) 
              (nat.plus x_366 (nat.S m))))) =>
     m:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_plus (nat.S x_366) 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        logic.eq nat.nat (nat.S (y m)) (nat.plus (nat.S x_366) (nat.S m))) 
       (nat.sym_eq_plus (nat.S x_366) 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           logic.eq nat.nat 
             (nat.S 
                (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                   nat.plus_body (nat.S x_366) m)) (y (nat.S m))) 
          (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
             nat.plus_body x_366 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              logic.eq nat.nat 
                (nat.S 
                   (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                      nat.plus_body (nat.S x_366) m)) (y (nat.S m))) 
             (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
                nat.plus_body x_366 
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 logic.eq nat.nat (nat.S (y m)) 
                   (nat.plus_body (nat.S x_366) (nat.S m))) 
                (nat.sym_eq_plus_body_S x_366 
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                    logic.eq nat.nat (nat.S (y m)) 
                      (nat.plus_body (nat.S x_366) (nat.S m))) 
                   (nat.sym_eq_plus_body_S x_366 
                      (y:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       logic.eq nat.nat (nat.S (nat.S (nat.plus x_366 m))) 
                         (y (nat.S m))) 
                      (logic.rewrite_r nat.nat (nat.plus x_366 (nat.S m)) 
                         (__:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat (nat.S __) 
                            (nat.S (nat.plus x_366 (nat.S m)))) 
                         (logic.rewrite_r nat.nat 
                            (nat.plus x_366 (nat.S (nat.S m))) 
                            (__:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq nat.nat __ 
                               (nat.S (nat.plus x_366 (nat.S m)))) 
                            (logic.rewrite_r nat.nat 
                               (nat.plus x_366 (nat.S (nat.S m))) 
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq nat.nat 
                                  (nat.plus x_366 (nat.S (nat.S m))) __) 
                               (logic.refl nat.nat 
                                  (nat.plus x_366 (nat.S (nat.S m)))) 
                               (nat.S (nat.plus x_366 (nat.S m))) 
                               (_x_368 (nat.S m))) 
                            (nat.S (nat.plus x_366 (nat.S m))) 
                            (_x_368 (nat.S m))) (nat.S (nat.plus x_366 m)) 
                         (_x_368 m)))))))) n.

def commutative_plus :
  sttfa.eps (relations.commutative nat.nat nat.plus)
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind 
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.forall nat.nat 
       (y:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat (nat.plus _x_365 y) (nat.plus y _x_365))) 
    (y:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_plus nat.O 
       (z:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        logic.eq nat.nat (z y) (nat.plus y nat.O)) 
       (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
          nat.plus_body 
          (z:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           logic.eq nat.nat (z y) (nat.plus y nat.O)) 
          (nat.sym_eq_plus_body_O 
             (z:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              logic.eq nat.nat (z y) (nat.plus y nat.O)) 
             (logic.rewrite_l nat.nat y 
                (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat y __) 
                (logic.refl nat.nat y) (nat.plus y nat.O) (nat.plus_n_O y))))) 
    (x_366:(sttfa.etap (sttfa.p nat.nat)) =>
     _x_368:
     (sttfa.eps 
        (sttfa.forall nat.nat 
           (y:(sttfa.etap (sttfa.p nat.nat)) =>
            logic.eq nat.nat (nat.plus x_366 y) (nat.plus y x_366)))) =>
     y:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_plus (nat.S x_366) 
       (z:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        logic.eq nat.nat (z y) (nat.plus y (nat.S x_366))) 
       (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
          nat.plus_body x_366 
          (z:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           logic.eq nat.nat (z y) (nat.plus y (nat.S x_366))) 
          (nat.sym_eq_plus_body_S x_366 
             (z:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              logic.eq nat.nat (z y) (nat.plus y (nat.S x_366))) 
             (logic.rewrite_r nat.nat (nat.plus x_366 (nat.S y)) 
                (__:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat __ (nat.plus y (nat.S x_366))) 
                (logic.rewrite_r nat.nat (nat.plus y (nat.S x_366)) 
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat __ (nat.plus y (nat.S x_366))) 
                   (logic.refl nat.nat (nat.plus y (nat.S x_366))) 
                   (nat.plus x_366 (nat.S y)) 
                   (logic.rewrite_l nat.nat (nat.S (nat.plus x_366 y)) 
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat __ (nat.plus y (nat.S x_366))) 
                      (logic.rewrite_r nat.nat (nat.plus y x_366) 
                         (__:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat (nat.S __) 
                            (nat.plus y (nat.S x_366))) 
                         (nat.plus_n_Sm y x_366) (nat.plus x_366 y) 
                         (_x_368 y)) (nat.plus x_366 (nat.S y)) 
                      (nat.plus_n_Sm x_366 y))) (nat.S (nat.plus x_366 y)) 
                (nat.plus_n_Sm x_366 y))))) n.

def associative_plus :
  sttfa.eps (relations.associative nat.nat nat.plus)
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind 
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.forall nat.nat 
       (y:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (z:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat (nat.plus (nat.plus _x_365 y) z) 
             (nat.plus _x_365 (nat.plus y z))))) 
    (y:(sttfa.etap (sttfa.p nat.nat)) =>
     z:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_plus nat.O 
       (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        logic.eq nat.nat (nat.plus (nat.plus nat.O y) z) (x (nat.plus y z))) 
       (nat.sym_eq_plus nat.O 
          (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           logic.eq nat.nat (nat.plus (x y) z) 
             (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                nat.plus_body nat.O (nat.plus y z))) 
          (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
             nat.plus_body 
             (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              logic.eq nat.nat (nat.plus (x y) z) 
                (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                   nat.plus_body nat.O (nat.plus y z))) 
             (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
                nat.plus_body 
                (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 logic.eq nat.nat (nat.plus (nat.plus_body nat.O y) z) 
                   (x (nat.plus y z))) 
                (nat.sym_eq_plus_body_O 
                   (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                    logic.eq nat.nat (nat.plus (nat.plus_body nat.O y) z) 
                      (x (nat.plus y z))) 
                   (nat.sym_eq_plus_body_O 
                      (x:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       logic.eq nat.nat (nat.plus (x y) z) (nat.plus y z)) 
                      (logic.refl nat.nat (nat.plus y z)))))))) 
    (x_366:(sttfa.etap (sttfa.p nat.nat)) =>
     _x_368:
     (sttfa.eps 
        (sttfa.forall nat.nat 
           (y:(sttfa.etap (sttfa.p nat.nat)) =>
            sttfa.forall nat.nat 
              (z:(sttfa.etap (sttfa.p nat.nat)) =>
               logic.eq nat.nat (nat.plus (nat.plus x_366 y) z) 
                 (nat.plus x_366 (nat.plus y z)))))) =>
     y:(sttfa.etap (sttfa.p nat.nat)) =>
     z:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_plus (nat.S x_366) 
       (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        logic.eq nat.nat (nat.plus (nat.plus (nat.S x_366) y) z) 
          (x (nat.plus y z))) 
       (nat.sym_eq_plus (nat.S x_366) 
          (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           logic.eq nat.nat (nat.plus (x y) z) 
             (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                nat.plus_body (nat.S x_366) (nat.plus y z))) 
          (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
             nat.plus_body x_366 
             (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              logic.eq nat.nat (nat.plus (x y) z) 
                (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                   nat.plus_body (nat.S x_366) (nat.plus y z))) 
             (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
                nat.plus_body x_366 
                (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 logic.eq nat.nat 
                   (nat.plus (nat.plus_body (nat.S x_366) y) z) 
                   (x (nat.plus y z))) 
                (nat.sym_eq_plus_body_S x_366 
                   (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                    logic.eq nat.nat 
                      (nat.plus (nat.plus_body (nat.S x_366) y) z) 
                      (x (nat.plus y z))) 
                   (nat.sym_eq_plus_body_S x_366 
                      (x:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       logic.eq nat.nat (nat.plus (x y) z) 
                         (nat.S (nat.plus x_366 (nat.plus y z)))) 
                      (nat.sym_eq_plus (nat.S (nat.plus x_366 y)) 
                         (x:
                          (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                          logic.eq nat.nat (x z) 
                            (nat.S (nat.plus x_366 (nat.plus y z)))) 
                         (nat.sym_eq_filter_nat_type_S 
                            (sttfa.arrow nat.nat nat.nat) nat.plus_body 
                            (nat.plus x_366 y) 
                            (x:
                             (sttfa.etap 
                                (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                             logic.eq nat.nat (x z) 
                               (nat.S (nat.plus x_366 (nat.plus y z)))) 
                            (nat.sym_eq_plus_body_S (nat.plus x_366 y) 
                               (x:
                                (sttfa.etap 
                                   (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                                logic.eq nat.nat (x z) 
                                  (nat.S (nat.plus x_366 (nat.plus y z)))) 
                               (logic.rewrite_r nat.nat 
                                  (nat.plus x_366 (nat.plus y z)) 
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq nat.nat (nat.S __) 
                                     (nat.S (nat.plus x_366 (nat.plus y z)))) 
                                  (logic.refl nat.nat 
                                     (nat.S (nat.plus x_366 (nat.plus y z)))) 
                                  (nat.plus (nat.plus x_366 y) z) 
                                  (_x_368 y z))))))))))) n.

def assoc_plus1 :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (a:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (b:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (c:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat (nat.plus c (nat.plus b a)) 
                (nat.plus (nat.plus b c) a)))))
  :=
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  c:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.rewrite_r nat.nat (nat.plus a b) 
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq nat.nat (nat.plus c __) (nat.plus (nat.plus b c) a)) 
    (logic.rewrite_r nat.nat (nat.plus a (nat.plus b c)) 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat (nat.plus c (nat.plus a b)) __) 
       (logic.rewrite_r nat.nat (nat.plus a (nat.plus b c)) 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat __ (nat.plus a (nat.plus b c))) 
          (logic.refl nat.nat (nat.plus a (nat.plus b c))) 
          (nat.plus c (nat.plus a b)) 
          (logic.rewrite_l nat.nat (nat.plus (nat.plus a b) c) 
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat (nat.plus c (nat.plus a b)) __) 
             (nat.commutative_plus c (nat.plus a b)) 
             (nat.plus a (nat.plus b c)) (nat.associative_plus a b c))) 
       (nat.plus (nat.plus b c) a) (nat.commutative_plus (nat.plus b c) a)) 
    (nat.plus b a) (nat.commutative_plus b a).

def injective_plus_r :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        relations.injective nat.nat nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) => nat.plus n m)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind 
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     relations.injective nat.nat nat.nat 
       (m:(sttfa.etap (sttfa.p nat.nat)) => nat.plus _x_365 m)) 
    (nat.sym_eq_plus nat.O 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        relations.injective nat.nat nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) => y m)) 
       (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
          nat.plus_body 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           relations.injective nat.nat nat.nat 
             (m:(sttfa.etap (sttfa.p nat.nat)) => y m)) 
          (nat.sym_eq_plus_body_O 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              relations.injective nat.nat nat.nat 
                (m:(sttfa.etap (sttfa.p nat.nat)) => y m)) 
             (x:(sttfa.etap (sttfa.p nat.nat)) =>
              y:(sttfa.etap (sttfa.p nat.nat)) =>
              auto:(sttfa.eps (logic.eq nat.nat x y)) =>
              logic.rewrite_l nat.nat x 
                (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat x __) 
                (logic.refl nat.nat x) y auto)))) 
    (x_366:(sttfa.etap (sttfa.p nat.nat)) =>
     _x_368:
     (sttfa.eps 
        (sttfa.forall nat.nat 
           (x:(sttfa.etap (sttfa.p nat.nat)) =>
            sttfa.forall nat.nat 
              (y:(sttfa.etap (sttfa.p nat.nat)) =>
               sttfa.impl 
                 (logic.eq nat.nat (nat.plus x_366 x) (nat.plus x_366 y)) 
                 (logic.eq nat.nat x y))))) =>
     nat.sym_eq_plus (nat.S x_366) 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        relations.injective nat.nat nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) => y m)) 
       (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
          nat.plus_body x_366 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           relations.injective nat.nat nat.nat 
             (m:(sttfa.etap (sttfa.p nat.nat)) => y m)) 
          (nat.sym_eq_plus_body_S x_366 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              relations.injective nat.nat nat.nat 
                (m:(sttfa.etap (sttfa.p nat.nat)) => y m)) 
             (x:(sttfa.etap (sttfa.p nat.nat)) =>
              y:(sttfa.etap (sttfa.p nat.nat)) =>
              auto:
              (sttfa.eps 
                 (logic.eq nat.nat (nat.S (nat.plus x_366 x)) 
                    (nat.S (nat.plus x_366 y)))) =>
              _x_368 x y 
                (nat.injective_S (nat.plus x_366 x) (nat.plus x_366 y) 
                   (logic.rewrite_r nat.nat (nat.plus x_366 (nat.S x)) 
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat __ (nat.S (nat.plus x_366 y))) 
                      (logic.rewrite_r nat.nat (nat.plus x_366 (nat.S y)) 
                         (__:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat (nat.plus x_366 (nat.S x)) __) 
                         (logic.rewrite_l nat.nat (nat.plus x_366 (nat.S x)) 
                            (__:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq nat.nat (nat.plus x_366 (nat.S x)) __) 
                            (logic.refl nat.nat (nat.plus x_366 (nat.S x))) 
                            (nat.plus x_366 (nat.S y)) 
                            (logic.rewrite_l nat.nat 
                               (nat.S (nat.plus x_366 y)) 
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq nat.nat (nat.plus x_366 (nat.S x)) 
                                  __) 
                               (logic.rewrite_l nat.nat 
                                  (nat.S (nat.plus x_366 x)) 
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq nat.nat __ 
                                     (nat.S (nat.plus x_366 y))) auto 
                                  (nat.plus x_366 (nat.S x)) 
                                  (nat.plus_n_Sm x_366 x)) 
                               (nat.plus x_366 (nat.S y)) 
                               (nat.plus_n_Sm x_366 y))) 
                         (nat.S (nat.plus x_366 y)) (nat.plus_n_Sm x_366 y)) 
                      (nat.S (nat.plus x_366 x)) (nat.plus_n_Sm x_366 x))))))) 
    n.

def times_Sn_m :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat (nat.plus m (nat.times n m)) 
             (nat.times (nat.S n) m))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.sym_eq_times (nat.S n) 
    (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
     logic.eq nat.nat (nat.plus m (nat.times n m)) (y m)) 
    (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
       nat.times_body n 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        logic.eq nat.nat (nat.plus m (nat.times n m)) (y m)) 
       (nat.sym_eq_times_body_S n 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           logic.eq nat.nat (nat.plus m (nat.times n m)) (y m)) 
          (logic.refl nat.nat (nat.plus m (nat.times n m))))).

def times_O_n :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat nat.O (nat.times nat.O n)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.sym_eq_times nat.O 
    (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
     logic.eq nat.nat nat.O (y n)) 
    (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
       nat.times_body 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        logic.eq nat.nat nat.O (y n)) 
       (nat.sym_eq_times_body_O 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           logic.eq nat.nat nat.O (y n)) (logic.refl nat.nat nat.O))).

def times_n_O :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat nat.O (nat.times n nat.O)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind 
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq nat.nat nat.O (nat.times _x_365 nat.O)) 
    (logic.rewrite_l nat.nat nat.O 
       (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat nat.O __) 
       (logic.refl nat.nat nat.O) (nat.times nat.O nat.O) 
       (nat.times_O_n nat.O)) 
    (x_366:(sttfa.etap (sttfa.p nat.nat)) =>
     _x_368:(sttfa.eps (logic.eq nat.nat nat.O (nat.times x_366 nat.O))) =>
     logic.rewrite_l nat.nat (nat.plus nat.O (nat.times x_366 nat.O)) 
       (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat nat.O __) 
       (logic.rewrite_l nat.nat nat.O 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat nat.O (nat.plus nat.O __)) 
          (logic.rewrite_l nat.nat nat.O 
             (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat nat.O __) 
             (logic.refl nat.nat nat.O) (nat.plus nat.O nat.O) 
             (nat.plus_O_n nat.O)) (nat.times x_366 nat.O) _x_368) 
       (nat.times (nat.S x_366) nat.O) (nat.times_Sn_m x_366 nat.O)) n.

def times_n_Sm :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat (nat.plus n (nat.times n m)) 
             (nat.times n (nat.S m)))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind 
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.forall nat.nat 
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat (nat.plus _x_365 (nat.times _x_365 m)) 
          (nat.times _x_365 (nat.S m)))) 
    (nat.sym_eq_times nat.O 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat (nat.plus nat.O (nat.times nat.O m)) 
             (y (nat.S m)))) 
       (nat.sym_eq_times nat.O 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           sttfa.forall nat.nat 
             (m:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat (nat.plus nat.O (y m)) 
                (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                   nat.times_body nat.O (nat.S m)))) 
          (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
             nat.times_body 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              sttfa.forall nat.nat 
                (m:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat (nat.plus nat.O (y m)) 
                   (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                      nat.times_body nat.O (nat.S m)))) 
             (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
                nat.times_body 
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 sttfa.forall nat.nat 
                   (m:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat 
                      (nat.plus nat.O (nat.times_body nat.O m)) (y (nat.S m)))) 
                (nat.sym_eq_times_body_O 
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                    sttfa.forall nat.nat 
                      (m:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat 
                         (nat.plus nat.O (nat.times_body nat.O m)) 
                         (y (nat.S m)))) 
                   (nat.sym_eq_times_body_O 
                      (y:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       sttfa.forall nat.nat 
                         (m:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat (nat.plus nat.O (y m)) nat.O)) 
                      (nat.sym_eq_plus nat.O 
                         (y:
                          (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                          sttfa.forall nat.nat 
                            (m:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq nat.nat (y nat.O) nat.O)) 
                         (nat.sym_eq_filter_nat_type_O 
                            (sttfa.arrow nat.nat nat.nat) nat.plus_body 
                            (y:
                             (sttfa.etap 
                                (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                             sttfa.forall nat.nat 
                               (m:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq nat.nat (y nat.O) nat.O)) 
                            (nat.sym_eq_plus_body_O 
                               (y:
                                (sttfa.etap 
                                   (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                                sttfa.forall nat.nat 
                                  (m:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq nat.nat (y nat.O) nat.O)) 
                               (_m:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.refl nat.nat nat.O)))))))))) 
    (x_366:(sttfa.etap (sttfa.p nat.nat)) =>
     _x_368:
     (sttfa.eps 
        (sttfa.forall nat.nat 
           (m:(sttfa.etap (sttfa.p nat.nat)) =>
            logic.eq nat.nat (nat.plus x_366 (nat.times x_366 m)) 
              (nat.times x_366 (nat.S m))))) =>
     m:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_times (nat.S x_366) 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        logic.eq nat.nat 
          (nat.plus (nat.S x_366) (nat.times (nat.S x_366) m)) (y (nat.S m))) 
       (nat.sym_eq_times (nat.S x_366) 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           logic.eq nat.nat (nat.plus (nat.S x_366) (y m)) 
             (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                nat.times_body (nat.S x_366) (nat.S m))) 
          (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
             nat.times_body x_366 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              logic.eq nat.nat (nat.plus (nat.S x_366) (y m)) 
                (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                   nat.times_body (nat.S x_366) (nat.S m))) 
             (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
                nat.times_body x_366 
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 logic.eq nat.nat 
                   (nat.plus (nat.S x_366) (nat.times_body (nat.S x_366) m)) 
                   (y (nat.S m))) 
                (nat.sym_eq_times_body_S x_366 
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                    logic.eq nat.nat 
                      (nat.plus (nat.S x_366) 
                         (nat.times_body (nat.S x_366) m)) (y (nat.S m))) 
                   (nat.sym_eq_times_body_S x_366 
                      (y:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       logic.eq nat.nat (nat.plus (nat.S x_366) (y m)) 
                         (nat.plus (nat.S m) (nat.times x_366 (nat.S m)))) 
                      (nat.sym_eq_plus (nat.S x_366) 
                         (y:
                          (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                          logic.eq nat.nat 
                            (y (nat.plus m (nat.times x_366 m))) 
                            (nat.plus (nat.S m) (nat.times x_366 (nat.S m)))) 
                         (nat.sym_eq_filter_nat_type_S 
                            (sttfa.arrow nat.nat nat.nat) nat.plus_body 
                            x_366 
                            (y:
                             (sttfa.etap 
                                (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                             logic.eq nat.nat 
                               (y (nat.plus m (nat.times x_366 m))) 
                               (nat.plus (nat.S m) 
                                  (nat.times x_366 (nat.S m)))) 
                            (nat.sym_eq_plus_body_S x_366 
                               (y:
                                (sttfa.etap 
                                   (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                                logic.eq nat.nat 
                                  (y (nat.plus m (nat.times x_366 m))) 
                                  (nat.plus (nat.S m) 
                                     (nat.times x_366 (nat.S m)))) 
                               (nat.sym_eq_plus (nat.S m) 
                                  (y:
                                   (sttfa.etap 
                                      (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                                   logic.eq nat.nat 
                                     (nat.S 
                                        (nat.plus x_366 
                                           (nat.plus m (nat.times x_366 m)))) 
                                     (y (nat.times x_366 (nat.S m)))) 
                                  (nat.sym_eq_filter_nat_type_S 
                                     (sttfa.arrow nat.nat nat.nat) 
                                     nat.plus_body m 
                                     (y:
                                      (sttfa.etap 
                                         (sttfa.p 
                                            (sttfa.arrow nat.nat nat.nat))) =>
                                      logic.eq nat.nat 
                                        (nat.S 
                                           (nat.plus x_366 
                                              (nat.plus m (nat.times x_366 m)))) 
                                        (y (nat.times x_366 (nat.S m)))) 
                                     (nat.sym_eq_plus_body_S m 
                                        (y:
                                         (sttfa.etap 
                                            (sttfa.p 
                                               (sttfa.arrow nat.nat nat.nat))) =>
                                         logic.eq nat.nat 
                                           (nat.S 
                                              (nat.plus x_366 
                                                 (nat.plus m 
                                                    (nat.times x_366 m)))) 
                                           (y (nat.times x_366 (nat.S m)))) 
                                        (logic.rewrite_r nat.nat 
                                           (nat.plus x_366 
                                              (nat.S 
                                                 (nat.plus m 
                                                    (nat.times x_366 m)))) 
                                           (__:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq nat.nat __ 
                                              (nat.S 
                                                 (nat.plus m 
                                                    (nat.times x_366 
                                                       (nat.S m))))) 
                                           (logic.rewrite_r nat.nat 
                                              (nat.plus m 
                                                 (nat.S (nat.times x_366 m))) 
                                              (__:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq nat.nat 
                                                 (nat.plus x_366 __) 
                                                 (nat.S 
                                                    (nat.plus m 
                                                       (nat.times x_366 
                                                          (nat.S m))))) 
                                              (logic.rewrite_l nat.nat 
                                                 (nat.plus x_366 
                                                    (nat.times x_366 m)) 
                                                 (__:
                                                  (sttfa.etap 
                                                     (sttfa.p nat.nat)) =>
                                                  logic.eq nat.nat 
                                                    (nat.plus x_366 
                                                       (nat.plus m 
                                                          (nat.S 
                                                             (nat.times 
                                                                x_366 m)))) 
                                                    (nat.S (nat.plus m __))) 
                                                 (logic.rewrite_r nat.nat 
                                                    (nat.plus x_366 
                                                       (nat.plus m 
                                                          (nat.times x_366 m))) 
                                                    (__:
                                                     (sttfa.etap 
                                                        (sttfa.p nat.nat)) =>
                                                     logic.eq nat.nat 
                                                       (nat.plus x_366 
                                                          (nat.plus m 
                                                             (nat.S 
                                                                (nat.times 
                                                                   x_366 m)))) 
                                                       (nat.S __)) 
                                                    (logic.rewrite_r nat.nat 
                                                       (nat.plus x_366 
                                                          (nat.S 
                                                             (nat.plus m 
                                                                (nat.times 
                                                                   x_366 m)))) 
                                                       (__:
                                                        (sttfa.etap 
                                                           (sttfa.p nat.nat)) =>
                                                        logic.eq nat.nat 
                                                          (nat.plus x_366 
                                                             (nat.plus m 
                                                                (nat.S 
                                                                   (nat.times 
                                                                    x_366 m)))) 
                                                          __) 
                                                       (logic.rewrite_r 
                                                          nat.nat 
                                                          (nat.plus m 
                                                             (nat.S 
                                                                (nat.times 
                                                                   x_366 m))) 
                                                          (__:
                                                           (sttfa.etap 
                                                              (sttfa.p 
                                                                 nat.nat)) =>
                                                           logic.eq nat.nat 
                                                             (nat.plus x_366 
                                                                (nat.plus m 
                                                                   (nat.S 
                                                                    (nat.times 
                                                                    x_366 m)))) 
                                                             (nat.plus x_366 
                                                                __)) 
                                                          (logic.refl 
                                                             nat.nat 
                                                             (nat.plus x_366 
                                                                (nat.plus m 
                                                                   (nat.S 
                                                                    (nat.times 
                                                                    x_366 m))))) 
                                                          (nat.S 
                                                             (nat.plus m 
                                                                (nat.times 
                                                                   x_366 m))) 
                                                          (nat.plus_n_Sm m 
                                                             (nat.times 
                                                                x_366 m))) 
                                                       (nat.S 
                                                          (nat.plus x_366 
                                                             (nat.plus m 
                                                                (nat.times 
                                                                   x_366 m)))) 
                                                       (nat.plus_n_Sm x_366 
                                                          (nat.plus m 
                                                             (nat.times 
                                                                x_366 m)))) 
                                                    (nat.plus m 
                                                       (nat.plus x_366 
                                                          (nat.times x_366 m))) 
                                                    (logic.rewrite_l nat.nat 
                                                       (nat.plus 
                                                          (nat.plus x_366 m) 
                                                          (nat.times x_366 m)) 
                                                       (__:
                                                        (sttfa.etap 
                                                           (sttfa.p nat.nat)) =>
                                                        logic.eq nat.nat 
                                                          (nat.plus m 
                                                             (nat.plus x_366 
                                                                (nat.times 
                                                                   x_366 m))) 
                                                          __) 
                                                       (nat.assoc_plus1 
                                                          (nat.times x_366 m) 
                                                          x_366 m) 
                                                       (nat.plus x_366 
                                                          (nat.plus m 
                                                             (nat.times 
                                                                x_366 m))) 
                                                       (nat.associative_plus 
                                                          x_366 m 
                                                          (nat.times x_366 m)))) 
                                                 (nat.times x_366 (nat.S m)) 
                                                 (_x_368 m)) 
                                              (nat.S 
                                                 (nat.plus m 
                                                    (nat.times x_366 m))) 
                                              (nat.plus_n_Sm m 
                                                 (nat.times x_366 m))) 
                                           (nat.S 
                                              (nat.plus x_366 
                                                 (nat.plus m 
                                                    (nat.times x_366 m)))) 
                                           (nat.plus_n_Sm x_366 
                                              (nat.plus m (nat.times x_366 m)))))))))))))))) 
    n.

def commutative_times :
  sttfa.eps (relations.commutative nat.nat nat.times)
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind 
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.forall nat.nat 
       (y:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat (nat.times _x_365 y) (nat.times y _x_365))) 
    (nat.sym_eq_times nat.O 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        sttfa.forall nat.nat 
          (z:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat (y z) (nat.times z nat.O))) 
       (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
          nat.times_body 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           sttfa.forall nat.nat 
             (z:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat (y z) (nat.times z nat.O))) 
          (nat.sym_eq_times_body_O 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              sttfa.forall nat.nat 
                (z:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat (y z) (nat.times z nat.O))) 
             (y:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.rewrite_l nat.nat nat.O 
                (__:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat nat.O __) (logic.refl nat.nat nat.O) 
                (nat.times y nat.O) (nat.times_n_O y))))) 
    (x_366:(sttfa.etap (sttfa.p nat.nat)) =>
     _x_368:
     (sttfa.eps 
        (sttfa.forall nat.nat 
           (y:(sttfa.etap (sttfa.p nat.nat)) =>
            logic.eq nat.nat (nat.times x_366 y) (nat.times y x_366)))) =>
     y:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_times (nat.S x_366) 
       (z:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        logic.eq nat.nat (z y) (nat.times y (nat.S x_366))) 
       (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
          nat.times_body x_366 
          (z:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           logic.eq nat.nat (z y) (nat.times y (nat.S x_366))) 
          (nat.sym_eq_times_body_S x_366 
             (z:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              logic.eq nat.nat (z y) (nat.times y (nat.S x_366))) 
             (logic.rewrite_l nat.nat (nat.plus y (nat.times y x_366)) 
                (__:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat (nat.plus y (nat.times x_366 y)) __) 
                (logic.rewrite_l nat.nat (nat.times x_366 y) 
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat (nat.plus y (nat.times x_366 y)) 
                      (nat.plus y __)) 
                   (logic.refl nat.nat (nat.plus y (nat.times x_366 y))) 
                   (nat.times y x_366) (_x_368 y)) 
                (nat.times y (nat.S x_366)) (nat.times_n_Sm y x_366))))) n.

def distributive_times_plus :
  sttfa.eps (relations.distributive nat.nat nat.times nat.plus)
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind 
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.forall nat.nat 
       (y:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (z:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat (nat.times _x_365 (nat.plus y z)) 
             (nat.plus (nat.times _x_365 y) (nat.times _x_365 z))))) 
    (nat.sym_eq_times nat.O 
       (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        sttfa.forall nat.nat 
          (y:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (z:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat (nat.times nat.O (nat.plus y z)) 
                (nat.plus (nat.times nat.O y) (x z))))) 
       (nat.sym_eq_times nat.O 
          (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           sttfa.forall nat.nat 
             (y:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat 
                (z:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat (nat.times nat.O (nat.plus y z)) 
                   (nat.plus (x y) 
                      (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                         nat.times_body nat.O z))))) 
          (nat.sym_eq_times nat.O 
             (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              sttfa.forall nat.nat 
                (y:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall nat.nat 
                   (z:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat (x (nat.plus y z)) 
                      (nat.plus 
                         (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                            nat.times_body nat.O y) 
                         (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                            nat.times_body nat.O z))))) 
             (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
                nat.times_body 
                (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 sttfa.forall nat.nat 
                   (y:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.forall nat.nat 
                      (z:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat (x (nat.plus y z)) 
                         (nat.plus 
                            (nat.filter_nat_type 
                               (sttfa.arrow nat.nat nat.nat) nat.times_body 
                               nat.O y) 
                            (nat.filter_nat_type 
                               (sttfa.arrow nat.nat nat.nat) nat.times_body 
                               nat.O z))))) 
                (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
                   nat.times_body 
                   (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                    sttfa.forall nat.nat 
                      (y:(sttfa.etap (sttfa.p nat.nat)) =>
                       sttfa.forall nat.nat 
                         (z:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat 
                            (nat.times_body nat.O (nat.plus y z)) 
                            (nat.plus (x y) 
                               (nat.filter_nat_type 
                                  (sttfa.arrow nat.nat nat.nat) 
                                  nat.times_body nat.O z))))) 
                   (nat.sym_eq_filter_nat_type_O 
                      (sttfa.arrow nat.nat nat.nat) nat.times_body 
                      (x:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       sttfa.forall nat.nat 
                         (y:(sttfa.etap (sttfa.p nat.nat)) =>
                          sttfa.forall nat.nat 
                            (z:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq nat.nat 
                               (nat.times_body nat.O (nat.plus y z)) 
                               (nat.plus (nat.times_body nat.O y) (x z))))) 
                      (nat.sym_eq_times_body_O 
                         (x:
                          (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                          sttfa.forall nat.nat 
                            (y:(sttfa.etap (sttfa.p nat.nat)) =>
                             sttfa.forall nat.nat 
                               (z:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq nat.nat 
                                  (nat.times_body nat.O (nat.plus y z)) 
                                  (nat.plus (nat.times_body nat.O y) (x z))))) 
                         (nat.sym_eq_times_body_O 
                            (x:
                             (sttfa.etap 
                                (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                             sttfa.forall nat.nat 
                               (y:(sttfa.etap (sttfa.p nat.nat)) =>
                                sttfa.forall nat.nat 
                                  (z:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq nat.nat 
                                     (nat.times_body nat.O (nat.plus y z)) 
                                     (nat.plus (x y) nat.O)))) 
                            (nat.sym_eq_times_body_O 
                               (x:
                                (sttfa.etap 
                                   (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                                sttfa.forall nat.nat 
                                  (y:(sttfa.etap (sttfa.p nat.nat)) =>
                                   sttfa.forall nat.nat 
                                     (z:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq nat.nat (x (nat.plus y z)) 
                                        (nat.plus nat.O nat.O)))) 
                               (nat.sym_eq_plus nat.O 
                                  (x:
                                   (sttfa.etap 
                                      (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                                   sttfa.forall nat.nat 
                                     (y:(sttfa.etap (sttfa.p nat.nat)) =>
                                      sttfa.forall nat.nat 
                                        (z:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq nat.nat nat.O (x nat.O)))) 
                                  (nat.sym_eq_filter_nat_type_O 
                                     (sttfa.arrow nat.nat nat.nat) 
                                     nat.plus_body 
                                     (x:
                                      (sttfa.etap 
                                         (sttfa.p 
                                            (sttfa.arrow nat.nat nat.nat))) =>
                                      sttfa.forall nat.nat 
                                        (y:(sttfa.etap (sttfa.p nat.nat)) =>
                                         sttfa.forall nat.nat 
                                           (z:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq nat.nat nat.O (x nat.O)))) 
                                     (nat.sym_eq_plus_body_O 
                                        (x:
                                         (sttfa.etap 
                                            (sttfa.p 
                                               (sttfa.arrow nat.nat nat.nat))) =>
                                         sttfa.forall nat.nat 
                                           (y:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            sttfa.forall nat.nat 
                                              (z:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq nat.nat nat.O 
                                                 (x nat.O)))) 
                                        (_y:(sttfa.etap (sttfa.p nat.nat)) =>
                                         _z:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.refl nat.nat nat.O))))))))))))) 
    (x_366:(sttfa.etap (sttfa.p nat.nat)) =>
     _x_368:
     (sttfa.eps 
        (sttfa.forall nat.nat 
           (y:(sttfa.etap (sttfa.p nat.nat)) =>
            sttfa.forall nat.nat 
              (z:(sttfa.etap (sttfa.p nat.nat)) =>
               logic.eq nat.nat (nat.times x_366 (nat.plus y z)) 
                 (nat.plus (nat.times x_366 y) (nat.times x_366 z)))))) =>
     y:(sttfa.etap (sttfa.p nat.nat)) =>
     z:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_times (nat.S x_366) 
       (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        logic.eq nat.nat (nat.times (nat.S x_366) (nat.plus y z)) 
          (nat.plus (nat.times (nat.S x_366) y) (x z))) 
       (nat.sym_eq_times (nat.S x_366) 
          (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           logic.eq nat.nat (nat.times (nat.S x_366) (nat.plus y z)) 
             (nat.plus (x y) 
                (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                   nat.times_body (nat.S x_366) z))) 
          (nat.sym_eq_times (nat.S x_366) 
             (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              logic.eq nat.nat (x (nat.plus y z)) 
                (nat.plus 
                   (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                      nat.times_body (nat.S x_366) y) 
                   (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                      nat.times_body (nat.S x_366) z))) 
             (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
                nat.times_body x_366 
                (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 logic.eq nat.nat (x (nat.plus y z)) 
                   (nat.plus 
                      (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                         nat.times_body (nat.S x_366) y) 
                      (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                         nat.times_body (nat.S x_366) z))) 
                (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
                   nat.times_body x_366 
                   (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                    logic.eq nat.nat 
                      (nat.times_body (nat.S x_366) (nat.plus y z)) 
                      (nat.plus (x y) 
                         (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                            nat.times_body (nat.S x_366) z))) 
                   (nat.sym_eq_filter_nat_type_S 
                      (sttfa.arrow nat.nat nat.nat) nat.times_body x_366 
                      (x:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       logic.eq nat.nat 
                         (nat.times_body (nat.S x_366) (nat.plus y z)) 
                         (nat.plus (nat.times_body (nat.S x_366) y) (x z))) 
                      (nat.sym_eq_times_body_S x_366 
                         (x:
                          (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                          logic.eq nat.nat 
                            (nat.times_body (nat.S x_366) (nat.plus y z)) 
                            (nat.plus (nat.times_body (nat.S x_366) y) (x z))) 
                         (nat.sym_eq_times_body_S x_366 
                            (x:
                             (sttfa.etap 
                                (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                             logic.eq nat.nat 
                               (nat.times_body (nat.S x_366) (nat.plus y z)) 
                               (nat.plus (x y) 
                                  (nat.plus z (nat.times x_366 z)))) 
                            (nat.sym_eq_times_body_S x_366 
                               (x:
                                (sttfa.etap 
                                   (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                                logic.eq nat.nat (x (nat.plus y z)) 
                                  (nat.plus (nat.plus y (nat.times x_366 y)) 
                                     (nat.plus z (nat.times x_366 z)))) 
                               (logic.rewrite_r nat.nat 
                                  (nat.plus y 
                                     (nat.plus z 
                                        (nat.times x_366 (nat.plus y z)))) 
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq nat.nat __ 
                                     (nat.plus 
                                        (nat.plus y (nat.times x_366 y)) 
                                        (nat.plus z (nat.times x_366 z)))) 
                                  (logic.rewrite_r nat.nat 
                                     (nat.plus y 
                                        (nat.plus (nat.times x_366 y) 
                                           (nat.plus z (nat.times x_366 z)))) 
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq nat.nat 
                                        (nat.plus y 
                                           (nat.plus z 
                                              (nat.times x_366 (nat.plus y z)))) 
                                        __) 
                                     (logic.rewrite_r nat.nat 
                                        (nat.plus z 
                                           (nat.plus (nat.times x_366 y) 
                                              (nat.times x_366 z))) 
                                        (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq nat.nat 
                                           (nat.plus y 
                                              (nat.plus z 
                                                 (nat.times x_366 
                                                    (nat.plus y z)))) 
                                           (nat.plus y __)) 
                                        (logic.rewrite_l nat.nat 
                                           (nat.times x_366 (nat.plus y z)) 
                                           (__:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq nat.nat 
                                              (nat.plus y 
                                                 (nat.plus z 
                                                    (nat.times x_366 
                                                       (nat.plus y z)))) 
                                              (nat.plus y (nat.plus z __))) 
                                           (logic.refl nat.nat 
                                              (nat.plus y 
                                                 (nat.plus z 
                                                    (nat.times x_366 
                                                       (nat.plus y z))))) 
                                           (nat.plus (nat.times x_366 y) 
                                              (nat.times x_366 z)) 
                                           (_x_368 y z)) 
                                        (nat.plus (nat.times x_366 y) 
                                           (nat.plus z (nat.times x_366 z))) 
                                        (logic.rewrite_l nat.nat 
                                           (nat.plus 
                                              (nat.plus z (nat.times x_366 y)) 
                                              (nat.times x_366 z)) 
                                           (__:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq nat.nat 
                                              (nat.plus (nat.times x_366 y) 
                                                 (nat.plus z 
                                                    (nat.times x_366 z))) __) 
                                           (nat.assoc_plus1 
                                              (nat.times x_366 z) z 
                                              (nat.times x_366 y)) 
                                           (nat.plus z 
                                              (nat.plus (nat.times x_366 y) 
                                                 (nat.times x_366 z))) 
                                           (nat.associative_plus z 
                                              (nat.times x_366 y) 
                                              (nat.times x_366 z)))) 
                                     (nat.plus 
                                        (nat.plus y (nat.times x_366 y)) 
                                        (nat.plus z (nat.times x_366 z))) 
                                     (nat.associative_plus y 
                                        (nat.times x_366 y) 
                                        (nat.plus z (nat.times x_366 z)))) 
                                  (nat.plus (nat.plus y z) 
                                     (nat.times x_366 (nat.plus y z))) 
                                  (nat.associative_plus y z 
                                     (nat.times x_366 (nat.plus y z))))))))))))) 
    n.

def distributive_times_plus_r :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (a:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (b:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (c:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat (nat.times (nat.plus b c) a) 
                (nat.plus (nat.times b a) (nat.times c a))))))
  :=
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  c:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.rewrite_r nat.nat (nat.times a (nat.plus b c)) 
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq nat.nat __ (nat.plus (nat.times b a) (nat.times c a))) 
    (logic.rewrite_r nat.nat (nat.times a b) 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat (nat.times a (nat.plus b c)) 
          (nat.plus __ (nat.times c a))) 
       (logic.rewrite_r nat.nat (nat.times a c) 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat (nat.times a (nat.plus b c)) 
             (nat.plus (nat.times a b) __)) 
          (logic.rewrite_l nat.nat (nat.times a (nat.plus b c)) 
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat (nat.times a (nat.plus b c)) __) 
             (logic.refl nat.nat (nat.times a (nat.plus b c))) 
             (nat.plus (nat.times a b) (nat.times a c)) 
             (nat.distributive_times_plus a b c)) (nat.times c a) 
          (nat.commutative_times c a)) (nat.times b a) 
       (nat.commutative_times b a)) (nat.times (nat.plus b c) a) 
    (nat.commutative_times (nat.plus b c) a).

def associative_times :
  sttfa.eps (relations.associative nat.nat nat.times)
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind 
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.forall nat.nat 
       (y:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (z:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat (nat.times (nat.times _x_365 y) z) 
             (nat.times _x_365 (nat.times y z))))) 
    (nat.sym_eq_times nat.O 
       (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        sttfa.forall nat.nat 
          (y:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (z:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat (nat.times (nat.times nat.O y) z) 
                (x (nat.times y z))))) 
       (nat.sym_eq_times nat.O 
          (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           sttfa.forall nat.nat 
             (y:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat 
                (z:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat (nat.times (x y) z) 
                   (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                      nat.times_body nat.O (nat.times y z))))) 
          (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
             nat.times_body 
             (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              sttfa.forall nat.nat 
                (y:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall nat.nat 
                   (z:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat (nat.times (x y) z) 
                      (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                         nat.times_body nat.O (nat.times y z))))) 
             (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
                nat.times_body 
                (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 sttfa.forall nat.nat 
                   (y:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.forall nat.nat 
                      (z:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat 
                         (nat.times (nat.times_body nat.O y) z) 
                         (x (nat.times y z))))) 
                (nat.sym_eq_times_body_O 
                   (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                    sttfa.forall nat.nat 
                      (y:(sttfa.etap (sttfa.p nat.nat)) =>
                       sttfa.forall nat.nat 
                         (z:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat 
                            (nat.times (nat.times_body nat.O y) z) 
                            (x (nat.times y z))))) 
                   (nat.sym_eq_times_body_O 
                      (x:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       sttfa.forall nat.nat 
                         (y:(sttfa.etap (sttfa.p nat.nat)) =>
                          sttfa.forall nat.nat 
                            (z:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq nat.nat (nat.times (x y) z) nat.O))) 
                      (nat.sym_eq_times nat.O 
                         (x:
                          (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                          sttfa.forall nat.nat 
                            (y:(sttfa.etap (sttfa.p nat.nat)) =>
                             sttfa.forall nat.nat 
                               (z:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq nat.nat (x z) nat.O))) 
                         (nat.sym_eq_filter_nat_type_O 
                            (sttfa.arrow nat.nat nat.nat) nat.times_body 
                            (x:
                             (sttfa.etap 
                                (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                             sttfa.forall nat.nat 
                               (y:(sttfa.etap (sttfa.p nat.nat)) =>
                                sttfa.forall nat.nat 
                                  (z:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq nat.nat (x z) nat.O))) 
                            (nat.sym_eq_times_body_O 
                               (x:
                                (sttfa.etap 
                                   (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                                sttfa.forall nat.nat 
                                  (y:(sttfa.etap (sttfa.p nat.nat)) =>
                                   sttfa.forall nat.nat 
                                     (z:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq nat.nat (x z) nat.O))) 
                               (_y:(sttfa.etap (sttfa.p nat.nat)) =>
                                _z:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.refl nat.nat nat.O)))))))))) 
    (x_366:(sttfa.etap (sttfa.p nat.nat)) =>
     _x_368:
     (sttfa.eps 
        (sttfa.forall nat.nat 
           (y:(sttfa.etap (sttfa.p nat.nat)) =>
            sttfa.forall nat.nat 
              (z:(sttfa.etap (sttfa.p nat.nat)) =>
               logic.eq nat.nat (nat.times (nat.times x_366 y) z) 
                 (nat.times x_366 (nat.times y z)))))) =>
     y:(sttfa.etap (sttfa.p nat.nat)) =>
     z:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_times (nat.S x_366) 
       (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        logic.eq nat.nat (nat.times (nat.times (nat.S x_366) y) z) 
          (x (nat.times y z))) 
       (nat.sym_eq_times (nat.S x_366) 
          (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           logic.eq nat.nat (nat.times (x y) z) 
             (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                nat.times_body (nat.S x_366) (nat.times y z))) 
          (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
             nat.times_body x_366 
             (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              logic.eq nat.nat (nat.times (x y) z) 
                (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                   nat.times_body (nat.S x_366) (nat.times y z))) 
             (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
                nat.times_body x_366 
                (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 logic.eq nat.nat 
                   (nat.times (nat.times_body (nat.S x_366) y) z) 
                   (x (nat.times y z))) 
                (nat.sym_eq_times_body_S x_366 
                   (x:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                    logic.eq nat.nat 
                      (nat.times (nat.times_body (nat.S x_366) y) z) 
                      (x (nat.times y z))) 
                   (nat.sym_eq_times_body_S x_366 
                      (x:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       logic.eq nat.nat (nat.times (x y) z) 
                         (nat.plus (nat.times y z) 
                            (nat.times x_366 (nat.times y z)))) 
                      (logic.rewrite_r nat.nat 
                         (nat.plus (nat.times y z) 
                            (nat.times x_366 (nat.times y z))) 
                         (__:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat __ 
                            (nat.plus (nat.times y z) 
                               (nat.times x_366 (nat.times y z)))) 
                         (logic.refl nat.nat 
                            (nat.plus (nat.times y z) 
                               (nat.times x_366 (nat.times y z)))) 
                         (nat.times (nat.plus y (nat.times x_366 y)) z) 
                         (logic.rewrite_l nat.nat 
                            (nat.times (nat.times x_366 y) z) 
                            (__:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq nat.nat 
                               (nat.times (nat.plus y (nat.times x_366 y)) z) 
                               (nat.plus (nat.times y z) __)) 
                            (nat.distributive_times_plus_r z y 
                               (nat.times x_366 y)) 
                            (nat.times x_366 (nat.times y z)) (_x_368 y z))))))))) 
    n.

def times_times :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (x:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (y:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (z:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat (nat.times x (nat.times y z)) 
                (nat.times y (nat.times x z))))))
  :=
  x:(sttfa.etap (sttfa.p nat.nat)) =>
  y:(sttfa.etap (sttfa.p nat.nat)) =>
  z:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.rewrite_r nat.nat (nat.times y (nat.times x z)) 
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq nat.nat __ (nat.times y (nat.times x z))) 
    (logic.refl nat.nat (nat.times y (nat.times x z))) 
    (nat.times x (nat.times y z)) 
    (logic.rewrite_l nat.nat (nat.times (nat.times x y) z) 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat __ (nat.times y (nat.times x z))) 
       (logic.rewrite_l nat.nat (nat.times y x) 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat (nat.times __ z) (nat.times y (nat.times x z))) 
          (nat.associative_times y x z) (nat.times x y) 
          (nat.commutative_times y x)) (nat.times x (nat.times y z)) 
       (nat.associative_times x y z)).

def times_n_1 :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat n (nat.times n (nat.S nat.O))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.rewrite_l nat.nat (nat.plus n (nat.times n nat.O)) 
    (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat n __) 
    (logic.rewrite_l nat.nat nat.O 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat n (nat.plus n __)) 
       (logic.rewrite_l nat.nat n 
          (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat n __) 
          (logic.refl nat.nat n) (nat.plus n nat.O) (nat.plus_n_O n)) 
       (nat.times n nat.O) (nat.times_n_O n)) (nat.times n (nat.S nat.O)) 
    (nat.times_n_Sm n nat.O).

def minus_S_S :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat (nat.minus (nat.S n) (nat.S m)) (nat.minus n m))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.eq_match_nat_type_S nat.nat (nat.S n) 
    (q:(sttfa.etap (sttfa.p nat.nat)) => nat.minus n q) m 
    (y:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq nat.nat (nat.minus (nat.S n) (nat.S m)) y) 
    (nat.eq_minus_body_S n 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        logic.eq nat.nat (nat.minus (nat.S n) (nat.S m)) (y (nat.S m))) 
       (nat.eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
          nat.minus_body n 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           logic.eq nat.nat (nat.minus (nat.S n) (nat.S m)) (y (nat.S m))) 
          (nat.eq_minus (nat.S n) 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              logic.eq nat.nat (nat.minus (nat.S n) (nat.S m)) (y (nat.S m))) 
             (logic.refl nat.nat (nat.minus (nat.S n) (nat.S m)))))).

def minus_O_n :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat nat.O (nat.minus nat.O n)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.match_nat_prop 
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq nat.nat nat.O (nat.minus nat.O __)) 
    (nat.sym_eq_minus nat.O 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        logic.eq nat.nat nat.O (y nat.O)) 
       (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
          nat.minus_body 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           logic.eq nat.nat nat.O (y nat.O)) 
          (nat.sym_eq_minus_body_O 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              logic.eq nat.nat nat.O (y nat.O)) (logic.refl nat.nat nat.O)))) 
    (nat.sym_eq_minus nat.O 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        sttfa.forall nat.nat 
          (n0:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat nat.O (y (nat.S n0)))) 
       (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
          nat.minus_body 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           sttfa.forall nat.nat 
             (n0:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat nat.O (y (nat.S n0)))) 
          (nat.sym_eq_minus_body_O 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              sttfa.forall nat.nat 
                (n0:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat nat.O (y (nat.S n0)))) 
             (auto:(sttfa.etap (sttfa.p nat.nat)) => logic.refl nat.nat nat.O)))) 
    n.

def minus_n_O :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat n (nat.minus n nat.O)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.match_nat_prop 
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq nat.nat __ (nat.minus __ nat.O)) 
    (logic.rewrite_l nat.nat nat.O 
       (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat nat.O __) 
       (logic.refl nat.nat nat.O) (nat.minus nat.O nat.O) 
       (nat.minus_O_n nat.O)) 
    (auto:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_minus (nat.S auto) 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        logic.eq nat.nat (nat.S auto) (y nat.O)) 
       (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
          nat.minus_body auto 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           logic.eq nat.nat (nat.S auto) (y nat.O)) 
          (nat.sym_eq_minus_body_S auto 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              logic.eq nat.nat (nat.S auto) (y nat.O)) 
             (nat.sym_eq_match_nat_type_O nat.nat (nat.S auto) 
                (q:(sttfa.etap (sttfa.p nat.nat)) => nat.minus auto q) 
                (y:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat (nat.S auto) y) 
                (logic.refl nat.nat (nat.S auto)))))) n.

def minus_n_n :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat nat.O (nat.minus n n)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind 
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq nat.nat nat.O (nat.minus _x_365 _x_365)) 
    (logic.rewrite_l nat.nat nat.O 
       (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat nat.O __) 
       (logic.refl nat.nat nat.O) (nat.minus nat.O nat.O) 
       (nat.minus_O_n nat.O)) 
    (x_366:(sttfa.etap (sttfa.p nat.nat)) =>
     _x_368:(sttfa.eps (logic.eq nat.nat nat.O (nat.minus x_366 x_366))) =>
     logic.rewrite_r nat.nat (nat.minus x_366 x_366) 
       (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat nat.O __) 
       (logic.rewrite_l nat.nat nat.O 
          (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat nat.O __) 
          (logic.refl nat.nat nat.O) (nat.minus x_366 x_366) _x_368) 
       (nat.minus (nat.S x_366) (nat.S x_366)) (nat.minus_S_S x_366 x_366)) n.

def eq_minus_S_pred :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat (nat.minus n (nat.S m)) 
             (nat.pred (nat.minus n m)))))
  :=
  nat.nat_elim2 
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     _0:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq nat.nat (nat.minus __ (nat.S _0)) (nat.pred (nat.minus __ _0))) 
    (_n:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_minus nat.O 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        logic.eq nat.nat (nat.minus nat.O (nat.S _n)) (nat.pred (y _n))) 
       (nat.sym_eq_minus nat.O 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           logic.eq nat.nat (y (nat.S _n)) 
             (nat.pred 
                (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                   nat.minus_body nat.O _n))) 
          (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
             nat.minus_body 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              logic.eq nat.nat (y (nat.S _n)) 
                (nat.pred 
                   (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                      nat.minus_body nat.O _n))) 
             (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
                nat.minus_body 
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 logic.eq nat.nat (nat.minus_body nat.O (nat.S _n)) 
                   (nat.pred (y _n))) 
                (nat.sym_eq_minus_body_O 
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                    logic.eq nat.nat (nat.minus_body nat.O (nat.S _n)) 
                      (nat.pred (y _n))) 
                   (nat.sym_eq_minus_body_O 
                      (y:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       logic.eq nat.nat (y (nat.S _n)) 
                         (nat.match_nat_type nat.nat nat.O 
                            (p:(sttfa.etap (sttfa.p nat.nat)) => p) nat.O)) 
                      (nat.sym_eq_match_nat_type_O nat.nat nat.O 
                         (p:(sttfa.etap (sttfa.p nat.nat)) => p) 
                         (y:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat nat.O y) 
                         (logic.refl nat.nat nat.O)))))))) 
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_minus (nat.S n) 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        logic.eq nat.nat (nat.minus (nat.S n) (nat.S nat.O)) 
          (nat.pred (y nat.O))) 
       (nat.sym_eq_minus (nat.S n) 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           logic.eq nat.nat (y (nat.S nat.O)) 
             (nat.pred 
                (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                   nat.minus_body (nat.S n) nat.O))) 
          (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
             nat.minus_body n 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              logic.eq nat.nat (y (nat.S nat.O)) 
                (nat.pred 
                   (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                      nat.minus_body (nat.S n) nat.O))) 
             (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
                nat.minus_body n 
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 logic.eq nat.nat (nat.minus_body (nat.S n) (nat.S nat.O)) 
                   (nat.pred (y nat.O))) 
                (nat.sym_eq_minus_body_S n 
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                    logic.eq nat.nat 
                      (nat.minus_body (nat.S n) (nat.S nat.O)) 
                      (nat.pred (y nat.O))) 
                   (nat.sym_eq_minus_body_S n 
                      (y:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       logic.eq nat.nat (y (nat.S nat.O)) 
                         (nat.pred 
                            (nat.match_nat_type nat.nat (nat.S n) 
                               (q:(sttfa.etap (sttfa.p nat.nat)) =>
                                nat.minus n q) nat.O))) 
                      (nat.sym_eq_match_nat_type_S nat.nat (nat.S n) 
                         (q:(sttfa.etap (sttfa.p nat.nat)) => nat.minus n q) 
                         nat.O 
                         (y:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat y 
                            (nat.match_nat_type nat.nat nat.O 
                               (p:(sttfa.etap (sttfa.p nat.nat)) => p) 
                               (nat.match_nat_type nat.nat (nat.S n) 
                                  (q:(sttfa.etap (sttfa.p nat.nat)) =>
                                   nat.minus n q) nat.O))) 
                         (nat.sym_eq_match_nat_type_O nat.nat (nat.S n) 
                            (q:(sttfa.etap (sttfa.p nat.nat)) =>
                             nat.minus n q) 
                            (y:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq nat.nat (nat.minus n nat.O) 
                               (nat.match_nat_type nat.nat nat.O 
                                  (p:(sttfa.etap (sttfa.p nat.nat)) => p) y)) 
                            (nat.sym_eq_match_nat_type_S nat.nat nat.O 
                               (q:(sttfa.etap (sttfa.p nat.nat)) => q) n 
                               (y:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq nat.nat (nat.minus n nat.O) y) 
                               (logic.rewrite_l nat.nat n 
                                  (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq nat.nat __ n) 
                                  (logic.refl nat.nat n) (nat.minus n nat.O) 
                                  (nat.minus_n_O n))))))))))) 
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     m:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_minus (nat.S n) 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        sttfa.impl 
          (logic.eq nat.nat (nat.minus n (nat.S m)) 
             (nat.pred (nat.minus n m))) 
          (logic.eq nat.nat (nat.minus (nat.S n) (nat.S (nat.S m))) 
             (nat.pred (y (nat.S m))))) 
       (nat.sym_eq_minus (nat.S n) 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           sttfa.impl 
             (logic.eq nat.nat (nat.minus n (nat.S m)) 
                (nat.pred (nat.minus n m))) 
             (logic.eq nat.nat (y (nat.S (nat.S m))) 
                (nat.pred 
                   (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                      nat.minus_body (nat.S n) (nat.S m))))) 
          (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
             nat.minus_body n 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              sttfa.impl 
                (logic.eq nat.nat (nat.minus n (nat.S m)) 
                   (nat.pred (nat.minus n m))) 
                (logic.eq nat.nat (y (nat.S (nat.S m))) 
                   (nat.pred 
                      (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                         nat.minus_body (nat.S n) (nat.S m))))) 
             (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
                nat.minus_body n 
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 sttfa.impl 
                   (logic.eq nat.nat (nat.minus n (nat.S m)) 
                      (nat.pred (nat.minus n m))) 
                   (logic.eq nat.nat 
                      (nat.minus_body (nat.S n) (nat.S (nat.S m))) 
                      (nat.pred (y (nat.S m))))) 
                (nat.sym_eq_minus_body_S n 
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                    sttfa.impl 
                      (logic.eq nat.nat (nat.minus n (nat.S m)) 
                         (nat.pred (nat.minus n m))) 
                      (logic.eq nat.nat 
                         (nat.minus_body (nat.S n) (nat.S (nat.S m))) 
                         (nat.pred (y (nat.S m))))) 
                   (nat.sym_eq_minus_body_S n 
                      (y:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       sttfa.impl 
                         (logic.eq nat.nat (nat.minus n (nat.S m)) 
                            (nat.pred (nat.minus n m))) 
                         (logic.eq nat.nat (y (nat.S (nat.S m))) 
                            (nat.pred 
                               (nat.match_nat_type nat.nat (nat.S n) 
                                  (q:(sttfa.etap (sttfa.p nat.nat)) =>
                                   nat.minus n q) (nat.S m))))) 
                      (nat.sym_eq_match_nat_type_S nat.nat (nat.S n) 
                         (q:(sttfa.etap (sttfa.p nat.nat)) => nat.minus n q) 
                         (nat.S m) 
                         (y:(sttfa.etap (sttfa.p nat.nat)) =>
                          sttfa.impl 
                            (logic.eq nat.nat (nat.minus n (nat.S m)) 
                               (nat.pred (nat.minus n m))) 
                            (logic.eq nat.nat y 
                               (nat.match_nat_type nat.nat nat.O 
                                  (p:(sttfa.etap (sttfa.p nat.nat)) => p) 
                                  (nat.match_nat_type nat.nat (nat.S n) 
                                     (q:(sttfa.etap (sttfa.p nat.nat)) =>
                                      nat.minus n q) (nat.S m))))) 
                         (nat.sym_eq_match_nat_type_S nat.nat (nat.S n) 
                            (q:(sttfa.etap (sttfa.p nat.nat)) =>
                             nat.minus n q) m 
                            (y:(sttfa.etap (sttfa.p nat.nat)) =>
                             sttfa.impl 
                               (logic.eq nat.nat (nat.minus n (nat.S m)) 
                                  (nat.pred (nat.minus n m))) 
                               (logic.eq nat.nat (nat.minus n (nat.S m)) 
                                  (nat.match_nat_type nat.nat nat.O 
                                     (p:(sttfa.etap (sttfa.p nat.nat)) => p) 
                                     y))) 
                            (auto:
                             (sttfa.eps 
                                (logic.eq nat.nat (nat.minus n (nat.S m)) 
                                   (nat.match_nat_type nat.nat nat.O 
                                      (p:(sttfa.etap (sttfa.p nat.nat)) => p) 
                                      (nat.minus n m)))) =>
                             logic.rewrite_r nat.nat 
                               (nat.match_nat_type nat.nat nat.O 
                                  (p:(sttfa.etap (sttfa.p nat.nat)) => p) 
                                  (nat.minus n m)) 
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq nat.nat __ 
                                  (nat.match_nat_type nat.nat nat.O 
                                     (p:(sttfa.etap (sttfa.p nat.nat)) => p) 
                                     (nat.minus n m))) 
                               (logic.refl nat.nat 
                                  (nat.match_nat_type nat.nat nat.O 
                                     (p:(sttfa.etap (sttfa.p nat.nat)) => p) 
                                     (nat.minus n m))) 
                               (nat.minus n (nat.S m)) auto))))))))).

def not_eq_S :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (connectives.Not (logic.eq nat.nat n m)) 
             (connectives.Not (logic.eq nat.nat (nat.S n) (nat.S m))))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  auto:(sttfa.eps (connectives.Not (logic.eq nat.nat n m))) =>
  logic.not_to_not (logic.eq nat.nat (nat.S n) (nat.S m)) 
    (logic.eq nat.nat n m) 
    (auto':(sttfa.eps (logic.eq nat.nat (nat.S n) (nat.S m))) =>
     logic.rewrite_l nat.nat m 
       (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat __ m) 
       (logic.refl nat.nat m) n 
       (logic.rewrite_r nat.nat (nat.pred (nat.S n)) 
          (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat m __) 
          (logic.rewrite_r nat.nat (nat.S m) 
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat m (nat.pred __)) (nat.pred_Sn m) (nat.S n) 
             auto') n (nat.pred_Sn n))) auto.

def not_eq_O_S :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        connectives.Not (logic.eq nat.nat nat.O (nat.S n))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  eqOS:(sttfa.eps (logic.eq nat.nat nat.O (nat.S n))) =>
  nat.eq_match_nat_type_O sttfa.bool connectives.False 
    (p:(sttfa.etap (sttfa.p nat.nat)) => connectives.True) 
    (y:(sttfa.etap (sttfa.p sttfa.bool)) => y) 
    (logic.eq_ind_r nat.nat (nat.S n) 
       (x:(sttfa.etap (sttfa.p nat.nat)) => nat.not_zero x) 
       (nat.sym_eq_match_nat_type_S sttfa.bool connectives.False 
          (p:(sttfa.etap (sttfa.p nat.nat)) => connectives.True) n 
          (y:(sttfa.etap (sttfa.p sttfa.bool)) => y) connectives.I) nat.O 
       eqOS).

def lt_to_not_zero :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.lt n m) (nat.not_zero m))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  Hlt:(sttfa.eps (nat.lt n m)) =>
  nat.le_ind (nat.S n) 
    (x_417:(sttfa.etap (sttfa.p nat.nat)) => nat.not_zero x_417) 
    (nat.sym_eq_match_nat_type_S sttfa.bool connectives.False 
       (p:(sttfa.etap (sttfa.p nat.nat)) => connectives.True) n 
       (y:(sttfa.etap (sttfa.p sttfa.bool)) => y) connectives.I) 
    (m0:(sttfa.etap (sttfa.p nat.nat)) =>
     _x_419:(sttfa.eps (nat.le (nat.S n) m0)) =>
     _x_421:(sttfa.eps (nat.not_zero m0)) =>
     nat.sym_eq_match_nat_type_S sttfa.bool connectives.False 
       (p:(sttfa.etap (sttfa.p nat.nat)) => connectives.True) m0 
       (y:(sttfa.etap (sttfa.p sttfa.bool)) => y) connectives.I) m Hlt.

def le_S_S :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.le n m) (nat.le (nat.S n) (nat.S m)))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  lenm:(sttfa.eps (nat.le n m)) =>
  nat.le_ind n 
    (x_417:(sttfa.etap (sttfa.p nat.nat)) => nat.le (nat.S n) (nat.S x_417)) 
    (nat.le_n (nat.S n)) 
    (m0:(sttfa.etap (sttfa.p nat.nat)) =>
     _x_419:(sttfa.eps (nat.le n m0)) =>
     _x_421:(sttfa.eps (nat.le (nat.S n) (nat.S m0))) =>
     nat.le_S (nat.S n) (nat.S m0) _x_421) m lenm.

def le_O_n :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) => nat.le nat.O n))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind (nat.le nat.O) (nat.le_n nat.O) 
    (x_366:(sttfa.etap (sttfa.p nat.nat)) =>
     _x_368:(sttfa.eps (nat.le nat.O x_366)) => nat.le_S nat.O x_366 _x_368) 
    n.

def le_n_Sn :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) => nat.le n (nat.S n)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) => nat.le_S n n (nat.le_n n).

def transitive_le :
  sttfa.eps (relations.transitive nat.nat nat.le)
  :=
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  c:(sttfa.etap (sttfa.p nat.nat)) =>
  leab:(sttfa.eps (nat.le a b)) =>
  lebc:(sttfa.eps (nat.le b c)) =>
  nat.le_ind b (x_417:(sttfa.etap (sttfa.p nat.nat)) => nat.le a x_417) leab 
    (m:(sttfa.etap (sttfa.p nat.nat)) =>
     _x_419:(sttfa.eps (nat.le b m)) =>
     _x_421:(sttfa.eps (nat.le a m)) => nat.le_S a m _x_421) c lebc.

def le_pred_n :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) => nat.le (nat.pred n) n))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind 
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) => nat.le (nat.pred _x_365) _x_365) 
    (nat.eq_match_nat_type_O nat.nat nat.O 
       (p:(sttfa.etap (sttfa.p nat.nat)) => p) 
       (y:(sttfa.etap (sttfa.p nat.nat)) =>
        nat.le 
          (nat.match_nat_type nat.nat nat.O 
             (p:(sttfa.etap (sttfa.p nat.nat)) => p) nat.O) y) 
       (nat.le_n (nat.pred nat.O))) 
    (x_366:(sttfa.etap (sttfa.p nat.nat)) =>
     _x_368:(sttfa.eps (nat.le (nat.pred x_366) x_366)) =>
     nat.eq_match_nat_type_S nat.nat nat.O 
       (p:(sttfa.etap (sttfa.p nat.nat)) => p) x_366 
       (y:(sttfa.etap (sttfa.p nat.nat)) =>
        nat.le (nat.pred (nat.S x_366)) (nat.S y)) 
       (nat.le_n_Sn (nat.pred (nat.S x_366)))) n.

def monotonic_pred :
  sttfa.eps (relations.monotonic nat.nat nat.le nat.pred)
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  lenm:(sttfa.eps (nat.le n m)) =>
  nat.le_ind n 
    (x_417:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.le (nat.pred n) (nat.pred x_417)) (nat.le_n (nat.pred n)) 
    (m0:(sttfa.etap (sttfa.p nat.nat)) =>
     _x_419:(sttfa.eps (nat.le n m0)) =>
     _x_421:(sttfa.eps (nat.le (nat.pred n) (nat.pred m0))) =>
     nat.transitive_le (nat.pred n) n (nat.pred (nat.S m0)) 
       (nat.le_pred_n n) 
       (nat.sym_eq_match_nat_type_S nat.nat nat.O 
          (p:(sttfa.etap (sttfa.p nat.nat)) => p) m0 
          (y:(sttfa.etap (sttfa.p nat.nat)) => nat.le n y) _x_419)) m lenm.

def le_S_S_to_le :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.le (nat.S n) (nat.S m)) (nat.le n m))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  auto:(sttfa.eps (nat.le (nat.S n) (nat.S m))) =>
  nat.eq_match_nat_type_S nat.nat nat.O 
    (p:(sttfa.etap (sttfa.p nat.nat)) => p) m 
    (y:(sttfa.etap (sttfa.p nat.nat)) => nat.le n y) 
    (nat.eq_match_nat_type_S nat.nat nat.O 
       (p:(sttfa.etap (sttfa.p nat.nat)) => p) n 
       (y:(sttfa.etap (sttfa.p nat.nat)) =>
        nat.le y 
          (nat.match_nat_type nat.nat nat.O 
             (p:(sttfa.etap (sttfa.p nat.nat)) => p) (nat.S m))) 
       (nat.monotonic_pred (nat.S n) (nat.S m) auto)).

def monotonic_le_plus_r :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        relations.monotonic nat.nat nat.le 
          (m:(sttfa.etap (sttfa.p nat.nat)) => nat.plus n m)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind 
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.impl (nat.le a b) (nat.le (nat.plus _x_365 a) (nat.plus _x_365 b))) 
    (nat.sym_eq_plus nat.O 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        sttfa.impl (nat.le a b) (nat.le (nat.plus nat.O a) (y b))) 
       (nat.sym_eq_plus nat.O 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           sttfa.impl (nat.le a b) 
             (nat.le (y a) 
                (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                   nat.plus_body nat.O b))) 
          (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
             nat.plus_body 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              sttfa.impl (nat.le a b) 
                (nat.le (y a) 
                   (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                      nat.plus_body nat.O b))) 
             (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
                nat.plus_body 
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 sttfa.impl (nat.le a b) 
                   (nat.le (nat.plus_body nat.O a) (y b))) 
                (nat.sym_eq_plus_body_O 
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                    sttfa.impl (nat.le a b) 
                      (nat.le (nat.plus_body nat.O a) (y b))) 
                   (nat.sym_eq_plus_body_O 
                      (y:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       sttfa.impl (nat.le a b) (nat.le (y a) b)) 
                      (auto:(sttfa.eps (nat.le a b)) => auto))))))) 
    (m:(sttfa.etap (sttfa.p nat.nat)) =>
     H:
     (sttfa.eps 
        (sttfa.impl (nat.le a b) (nat.le (nat.plus m a) (nat.plus m b)))) =>
     leab:(sttfa.eps (nat.le a b)) =>
     nat.sym_eq_plus (nat.S m) 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        nat.le (nat.plus (nat.S m) a) (y b)) 
       (nat.sym_eq_plus (nat.S m) 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           nat.le (y a) 
             (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                nat.plus_body (nat.S m) b)) 
          (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
             nat.plus_body m 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              nat.le (y a) 
                (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                   nat.plus_body (nat.S m) b)) 
             (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
                nat.plus_body m 
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 nat.le (nat.plus_body (nat.S m) a) (y b)) 
                (nat.sym_eq_plus_body_S m 
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                    nat.le (nat.plus_body (nat.S m) a) (y b)) 
                   (nat.sym_eq_plus_body_S m 
                      (y:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       nat.le (y a) (nat.S (nat.plus m b))) 
                      (nat.le_S_S (nat.plus m a) (nat.plus m b) (H leab)))))))) 
    n.

def monotonic_le_plus_l :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        relations.monotonic nat.nat nat.le 
          (n:(sttfa.etap (sttfa.p nat.nat)) => nat.plus n m)))
  :=
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  x:(sttfa.etap (sttfa.p nat.nat)) =>
  y:(sttfa.etap (sttfa.p nat.nat)) =>
  auto:(sttfa.eps (nat.le x y)) =>
  logic.eq_coerc (nat.le (nat.plus m x) (nat.plus m y)) 
    (nat.le (nat.plus x m) (nat.plus y m)) 
    (nat.monotonic_le_plus_r m x y auto) 
    (logic.rewrite_r nat.nat (nat.plus m x) 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq sttfa.bool (nat.le (nat.plus m x) (nat.plus m y)) 
          (nat.le __ (nat.plus y m))) 
       (logic.rewrite_r nat.nat (nat.plus m y) 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq sttfa.bool (nat.le (nat.plus m x) (nat.plus m y)) 
             (nat.le (nat.plus m x) __)) 
          (logic.refl sttfa.bool (nat.le (nat.plus m x) (nat.plus m y))) 
          (nat.plus y m) (nat.commutative_plus y m)) (nat.plus x m) 
       (nat.commutative_plus x m)).

def le_plus :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n1:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (n2:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (m1:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat 
                (m2:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (nat.le n1 n2) 
                   (sttfa.impl (nat.le m1 m2) 
                      (nat.le (nat.plus n1 m1) (nat.plus n2 m2))))))))
  :=
  n1:(sttfa.etap (sttfa.p nat.nat)) =>
  n2:(sttfa.etap (sttfa.p nat.nat)) =>
  m1:(sttfa.etap (sttfa.p nat.nat)) =>
  m2:(sttfa.etap (sttfa.p nat.nat)) =>
  len:(sttfa.eps (nat.le n1 n2)) =>
  lem:(sttfa.eps (nat.le m1 m2)) =>
  nat.transitive_le (nat.plus n1 m1) (nat.plus n1 m2) (nat.plus n2 m2) 
    (nat.monotonic_le_plus_r n1 m1 m2 lem) 
    (nat.monotonic_le_plus_l m2 n1 n2 len).

def le_plus_n :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) => nat.le m (nat.plus n m))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.eq_coerc (nat.le (nat.plus nat.O m) (nat.plus n m)) 
    (nat.le m (nat.plus n m)) 
    (nat.monotonic_le_plus_l m nat.O n (nat.le_O_n n)) 
    (logic.rewrite_l nat.nat m 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq sttfa.bool (nat.le __ (nat.plus n m)) 
          (nat.le m (nat.plus n m))) 
       (logic.refl sttfa.bool (nat.le m (nat.plus n m))) (nat.plus nat.O m) 
       (nat.plus_O_n m)).

def le_plus_b :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (b:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (m:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.le (nat.plus n b) m) (nat.le n m)))))
  :=
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  auto:(sttfa.eps (nat.le (nat.plus n b) m)) =>
  nat.transitive_le n (nat.plus n b) m 
    (logic.eq_coerc (nat.le n (nat.plus b n)) (nat.le n (nat.plus n b)) 
       (nat.le_plus_n b n) 
       (logic.rewrite_r nat.nat (nat.plus b n) 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq sttfa.bool (nat.le n (nat.plus b n)) (nat.le n __)) 
          (logic.refl sttfa.bool (nat.le n (nat.plus b n))) (nat.plus n b) 
          (nat.commutative_plus n b))) auto.

def le_plus_n_r :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) => nat.le m (nat.plus m n))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.eq_coerc (nat.le m (nat.plus n m)) (nat.le m (nat.plus m n)) 
    (nat.le_plus_n n m) 
    (logic.rewrite_r nat.nat (nat.plus n m) 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq sttfa.bool (nat.le m (nat.plus n m)) (nat.le m __)) 
       (logic.refl sttfa.bool (nat.le m (nat.plus n m))) (nat.plus m n) 
       (nat.commutative_plus m n)).

def le_plus_to_le :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (a:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (m:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.le (nat.plus a n) (nat.plus a m)) (nat.le n m)))))
  :=
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind 
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.le (nat.plus _x_365 n) (nat.plus _x_365 m)) 
             (nat.le n m)))) 
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     m:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_plus nat.O 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        sttfa.impl (nat.le (nat.plus nat.O n) (y m)) (nat.le n m)) 
       (nat.sym_eq_plus nat.O 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           sttfa.impl 
             (nat.le (y n) 
                (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                   nat.plus_body nat.O m)) (nat.le n m)) 
          (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
             nat.plus_body 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              sttfa.impl 
                (nat.le (y n) 
                   (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                      nat.plus_body nat.O m)) (nat.le n m)) 
             (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
                nat.plus_body 
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 sttfa.impl (nat.le (nat.plus_body nat.O n) (y m)) 
                   (nat.le n m)) 
                (nat.sym_eq_plus_body_O 
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                    sttfa.impl (nat.le (nat.plus_body nat.O n) (y m)) 
                      (nat.le n m)) 
                   (nat.sym_eq_plus_body_O 
                      (y:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       sttfa.impl (nat.le (y n) m) (nat.le n m)) 
                      (auto:(sttfa.eps (nat.le n m)) => auto))))))) 
    (x_366:(sttfa.etap (sttfa.p nat.nat)) =>
     _x_368:
     (sttfa.eps 
        (sttfa.forall nat.nat 
           (n:(sttfa.etap (sttfa.p nat.nat)) =>
            sttfa.forall nat.nat 
              (m:(sttfa.etap (sttfa.p nat.nat)) =>
               sttfa.impl (nat.le (nat.plus x_366 n) (nat.plus x_366 m)) 
                 (nat.le n m))))) =>
     n:(sttfa.etap (sttfa.p nat.nat)) =>
     m:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_plus (nat.S x_366) 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        sttfa.impl (nat.le (nat.plus (nat.S x_366) n) (y m)) (nat.le n m)) 
       (nat.sym_eq_plus (nat.S x_366) 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           sttfa.impl 
             (nat.le (y n) 
                (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                   nat.plus_body (nat.S x_366) m)) (nat.le n m)) 
          (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
             nat.plus_body x_366 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              sttfa.impl 
                (nat.le (y n) 
                   (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                      nat.plus_body (nat.S x_366) m)) (nat.le n m)) 
             (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
                nat.plus_body x_366 
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 sttfa.impl (nat.le (nat.plus_body (nat.S x_366) n) (y m)) 
                   (nat.le n m)) 
                (nat.sym_eq_plus_body_S x_366 
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                    sttfa.impl 
                      (nat.le (nat.plus_body (nat.S x_366) n) (y m)) 
                      (nat.le n m)) 
                   (nat.sym_eq_plus_body_S x_366 
                      (y:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       sttfa.impl (nat.le (y n) (nat.S (nat.plus x_366 m))) 
                         (nat.le n m)) 
                      (auto:
                       (sttfa.eps 
                          (nat.le (nat.S (nat.plus x_366 n)) 
                             (nat.S (nat.plus x_366 m)))) =>
                       logic.eq_coerc 
                         (nat.le (nat.pred (nat.S n)) (nat.pred (nat.S m))) 
                         (nat.le n m) 
                         (nat.monotonic_pred (nat.S n) (nat.S m) 
                            (_x_368 (nat.S n) (nat.S m) 
                               (logic.eq_coerc 
                                  (nat.le (nat.S (nat.plus x_366 n)) 
                                     (nat.S (nat.plus x_366 m))) 
                                  (nat.le (nat.plus x_366 (nat.S n)) 
                                     (nat.plus x_366 (nat.S m))) auto 
                                  (logic.rewrite_r nat.nat 
                                     (nat.plus x_366 (nat.S n)) 
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq sttfa.bool 
                                        (nat.le __ (nat.S (nat.plus x_366 m))) 
                                        (nat.le (nat.plus x_366 (nat.S n)) 
                                           (nat.plus x_366 (nat.S m)))) 
                                     (logic.rewrite_r nat.nat 
                                        (nat.plus x_366 (nat.S m)) 
                                        (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq sttfa.bool 
                                           (nat.le 
                                              (nat.plus x_366 (nat.S n)) __) 
                                           (nat.le 
                                              (nat.plus x_366 (nat.S n)) 
                                              (nat.plus x_366 (nat.S m)))) 
                                        (logic.refl sttfa.bool 
                                           (nat.le 
                                              (nat.plus x_366 (nat.S n)) 
                                              (nat.plus x_366 (nat.S m)))) 
                                        (nat.S (nat.plus x_366 m)) 
                                        (nat.plus_n_Sm x_366 m)) 
                                     (nat.S (nat.plus x_366 n)) 
                                     (nat.plus_n_Sm x_366 n))))) 
                         (logic.rewrite_l nat.nat n 
                            (__:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq sttfa.bool 
                               (nat.le __ (nat.pred (nat.S m))) (nat.le n m)) 
                            (logic.rewrite_l nat.nat m 
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq sttfa.bool (nat.le n __) 
                                  (nat.le n m)) 
                               (logic.refl sttfa.bool (nat.le n m)) 
                               (nat.pred (nat.S m)) (nat.pred_Sn m)) 
                            (nat.pred (nat.S n)) (nat.pred_Sn n))))))))) a.

def le_plus_to_le_r :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (a:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (m:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.le (nat.plus n a) (nat.plus m a)) (nat.le n m)))))
  :=
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  auto:(sttfa.eps (nat.le (nat.plus n a) (nat.plus m a))) =>
  nat.le_plus_to_le a n m 
    (logic.eq_coerc (nat.le (nat.plus n a) (nat.plus m a)) 
       (nat.le (nat.plus a n) (nat.plus a m)) auto 
       (logic.rewrite_r nat.nat (nat.plus a n) 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq sttfa.bool (nat.le __ (nat.plus m a)) 
             (nat.le (nat.plus a n) (nat.plus a m))) 
          (logic.rewrite_r nat.nat (nat.plus a m) 
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq sttfa.bool (nat.le (nat.plus a n) __) 
                (nat.le (nat.plus a n) (nat.plus a m))) 
             (logic.refl sttfa.bool (nat.le (nat.plus a n) (nat.plus a m))) 
             (nat.plus m a) (nat.commutative_plus m a)) (nat.plus n a) 
          (nat.commutative_plus n a))).

def monotonic_le_times_r :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        relations.monotonic nat.nat nat.le 
          (m:(sttfa.etap (sttfa.p nat.nat)) => nat.times n m)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  x:(sttfa.etap (sttfa.p nat.nat)) =>
  y:(sttfa.etap (sttfa.p nat.nat)) =>
  lexy:(sttfa.eps (nat.le x y)) =>
  nat.nat_ind 
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.le (nat.times _x_365 x) (nat.times _x_365 y)) 
    (nat.sym_eq_times nat.O 
       (z:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        nat.le (nat.times nat.O x) (z y)) 
       (nat.sym_eq_times nat.O 
          (z:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           nat.le (z x) 
             (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                nat.times_body nat.O y)) 
          (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
             nat.times_body 
             (z:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              nat.le (z x) 
                (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                   nat.times_body nat.O y)) 
             (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
                nat.times_body 
                (z:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 nat.le (nat.times_body nat.O x) (z y)) 
                (nat.sym_eq_times_body_O 
                   (z:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                    nat.le (nat.times_body nat.O x) (z y)) 
                   (nat.sym_eq_times_body_O 
                      (z:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       nat.le (z x) nat.O) (nat.le_O_n nat.O))))))) 
    (a:(sttfa.etap (sttfa.p nat.nat)) =>
     lea:(sttfa.eps (nat.le (nat.times a x) (nat.times a y))) =>
     nat.sym_eq_times (nat.S a) 
       (z:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        nat.le (nat.times (nat.S a) x) (z y)) 
       (nat.sym_eq_times (nat.S a) 
          (z:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           nat.le (z x) 
             (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                nat.times_body (nat.S a) y)) 
          (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
             nat.times_body a 
             (z:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              nat.le (z x) 
                (nat.filter_nat_type (sttfa.arrow nat.nat nat.nat) 
                   nat.times_body (nat.S a) y)) 
             (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
                nat.times_body a 
                (z:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 nat.le (nat.times_body (nat.S a) x) (z y)) 
                (nat.sym_eq_times_body_S a 
                   (z:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                    nat.le (nat.times_body (nat.S a) x) (z y)) 
                   (nat.sym_eq_times_body_S a 
                      (z:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       nat.le (z x) (nat.plus y (nat.times a y))) 
                      (nat.le_plus x y (nat.times a x) (nat.times a y) lexy 
                         lea))))))) n.

def le_times :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n1:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (n2:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (m1:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat 
                (m2:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (nat.le n1 n2) 
                   (sttfa.impl (nat.le m1 m2) 
                      (nat.le (nat.times n1 m1) (nat.times n2 m2))))))))
  :=
  n1:(sttfa.etap (sttfa.p nat.nat)) =>
  n2:(sttfa.etap (sttfa.p nat.nat)) =>
  m1:(sttfa.etap (sttfa.p nat.nat)) =>
  m2:(sttfa.etap (sttfa.p nat.nat)) =>
  len:(sttfa.eps (nat.le n1 n2)) =>
  lem:(sttfa.eps (nat.le m1 m2)) =>
  nat.transitive_le (nat.times n1 m1) (nat.times n1 m2) (nat.times n2 m2) 
    (nat.monotonic_le_times_r n1 m1 m2 lem) 
    (logic.eq_coerc (nat.le (nat.times m2 n1) (nat.times m2 n2)) 
       (nat.le (nat.times n1 m2) (nat.times n2 m2)) 
       (nat.monotonic_le_times_r m2 n1 n2 len) 
       (logic.rewrite_r nat.nat (nat.times n1 m2) 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq sttfa.bool (nat.le __ (nat.times m2 n2)) 
             (nat.le (nat.times n1 m2) (nat.times n2 m2))) 
          (logic.rewrite_r nat.nat (nat.times n2 m2) 
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq sttfa.bool (nat.le (nat.times n1 m2) __) 
                (nat.le (nat.times n1 m2) (nat.times n2 m2))) 
             (logic.refl sttfa.bool 
                (nat.le (nat.times n1 m2) (nat.times n2 m2))) 
             (nat.times m2 n2) (nat.commutative_times m2 n2)) 
          (nat.times m2 n1) (nat.commutative_times m2 n1))).

def le_plus_minus_m_m :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           nat.le n (nat.plus (nat.minus n m) m))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind 
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.forall nat.nat 
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        nat.le _x_365 (nat.plus (nat.minus _x_365 m) m))) 
    (nat.sym_eq_minus nat.O 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           nat.le nat.O (nat.plus (y m) m))) 
       (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
          nat.minus_body 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           sttfa.forall nat.nat 
             (m:(sttfa.etap (sttfa.p nat.nat)) =>
              nat.le nat.O (nat.plus (y m) m))) 
          (nat.sym_eq_minus_body_O 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              sttfa.forall nat.nat 
                (m:(sttfa.etap (sttfa.p nat.nat)) =>
                 nat.le nat.O (nat.plus (y m) m))) 
             (m:(sttfa.etap (sttfa.p nat.nat)) => nat.le_plus_n_r m nat.O)))) 
    (a:(sttfa.etap (sttfa.p nat.nat)) =>
     Hind:
     (sttfa.eps 
        (sttfa.forall nat.nat 
           (m:(sttfa.etap (sttfa.p nat.nat)) =>
            nat.le a (nat.plus (nat.minus a m) m)))) =>
     m:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.match_nat_prop 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        nat.le (nat.S a) (nat.plus (nat.minus (nat.S a) __) __)) 
       (nat.sym_eq_minus (nat.S a) 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           nat.le (nat.S a) (nat.plus (y nat.O) nat.O)) 
          (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
             nat.minus_body a 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              nat.le (nat.S a) (nat.plus (y nat.O) nat.O)) 
             (nat.sym_eq_minus_body_S a 
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 nat.le (nat.S a) (nat.plus (y nat.O) nat.O)) 
                (nat.sym_eq_match_nat_type_O nat.nat (nat.S a) 
                   (q:(sttfa.etap (sttfa.p nat.nat)) => nat.minus a q) 
                   (y:(sttfa.etap (sttfa.p nat.nat)) =>
                    nat.le (nat.S a) (nat.plus y nat.O)) 
                   (nat.le_plus_n_r nat.O (nat.S a)))))) 
       (n0:(sttfa.etap (sttfa.p nat.nat)) =>
        nat.sym_eq_minus (nat.S a) 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           nat.le (nat.S a) (nat.plus (y (nat.S n0)) (nat.S n0))) 
          (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
             nat.minus_body a 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              nat.le (nat.S a) (nat.plus (y (nat.S n0)) (nat.S n0))) 
             (nat.sym_eq_minus_body_S a 
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 nat.le (nat.S a) (nat.plus (y (nat.S n0)) (nat.S n0))) 
                (nat.sym_eq_match_nat_type_S nat.nat (nat.S a) 
                   (q:(sttfa.etap (sttfa.p nat.nat)) => nat.minus a q) n0 
                   (y:(sttfa.etap (sttfa.p nat.nat)) =>
                    nat.le (nat.S a) (nat.plus y (nat.S n0))) 
                   (logic.eq_coerc 
                      (nat.le (nat.S a) 
                         (nat.S (nat.plus (nat.minus a n0) n0))) 
                      (nat.le (nat.S a) 
                         (nat.plus (nat.minus a n0) (nat.S n0))) 
                      (nat.le_S_S a (nat.plus (nat.minus a n0) n0) (Hind n0)) 
                      (logic.rewrite_r nat.nat 
                         (nat.plus (nat.minus a n0) (nat.S n0)) 
                         (__:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq sttfa.bool (nat.le (nat.S a) __) 
                            (nat.le (nat.S a) 
                               (nat.plus (nat.minus a n0) (nat.S n0)))) 
                         (logic.refl sttfa.bool 
                            (nat.le (nat.S a) 
                               (nat.plus (nat.minus a n0) (nat.S n0)))) 
                         (nat.S (nat.plus (nat.minus a n0) n0)) 
                         (nat.plus_n_Sm (nat.minus a n0) n0))))))) m) n.

def le_plus_to_minus_r :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (a:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (b:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (c:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.le (nat.plus a b) c) (nat.le a (nat.minus c b))))))
  :=
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  c:(sttfa.etap (sttfa.p nat.nat)) =>
  H:(sttfa.eps (nat.le (nat.plus a b) c)) =>
  nat.le_plus_to_le_r b a (nat.minus c b) 
    (nat.transitive_le (nat.plus a b) c (nat.plus (nat.minus c b) b) H 
       (nat.le_plus_minus_m_m c b)).

def lt_to_le :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (x:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (y:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.lt x y) (nat.le x y))))
  :=
  x:(sttfa.etap (sttfa.p nat.nat)) =>
  y:(sttfa.etap (sttfa.p nat.nat)) =>
  auto:(sttfa.eps (nat.lt x y)) =>
  nat.le_plus_b (nat.S nat.O) x y 
    (logic.eq_coerc (nat.le (nat.S x) y) 
       (nat.le (nat.plus x (nat.S nat.O)) y) auto 
       (logic.rewrite_r nat.nat (nat.plus x (nat.S nat.O)) 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq sttfa.bool (nat.le __ y) 
             (nat.le (nat.plus x (nat.S nat.O)) y)) 
          (logic.refl sttfa.bool (nat.le (nat.plus x (nat.S nat.O)) y)) 
          (nat.S x) 
          (logic.rewrite_r nat.nat (nat.plus x nat.O) 
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat (nat.S __) (nat.plus x (nat.S nat.O))) 
             (nat.plus_n_Sm x nat.O) x (nat.plus_n_O x)))).

def transitive_lt :
  sttfa.eps (relations.transitive nat.nat nat.lt)
  :=
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  c:(sttfa.etap (sttfa.p nat.nat)) =>
  ltab:(sttfa.eps (nat.lt a b)) =>
  ltbc:(sttfa.eps (nat.lt b c)) =>
  nat.le_ind (nat.S b) 
    (x_417:(sttfa.etap (sttfa.p nat.nat)) => nat.lt a x_417) 
    (nat.le_S (nat.S a) b ltab) 
    (m:(sttfa.etap (sttfa.p nat.nat)) =>
     _x_419:(sttfa.eps (nat.le (nat.S b) m)) =>
     _x_421:(sttfa.eps (nat.lt a m)) => nat.le_S (nat.S a) m _x_421) c ltbc.

def lt_to_le_to_lt :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (p:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.lt n m) (sttfa.impl (nat.le m p) (nat.lt n p))))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  H:(sttfa.eps (nat.lt n m)) =>
  H1:(sttfa.eps (nat.le m p)) =>
  nat.le_ind m (x_417:(sttfa.etap (sttfa.p nat.nat)) => nat.lt n x_417) H 
    (m0:(sttfa.etap (sttfa.p nat.nat)) =>
     _x_419:(sttfa.eps (nat.le m m0)) =>
     _x_421:(sttfa.eps (nat.lt n m0)) =>
     nat.transitive_lt n m0 (nat.S m0) _x_421 
       (logic.eq_coerc (nat.le (nat.S m0) (nat.plus nat.O (nat.S m0))) 
          (nat.le (nat.S m0) (nat.S m0)) (nat.le_plus_n nat.O (nat.S m0)) 
          (logic.rewrite_l nat.nat (nat.S m0) 
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq sttfa.bool (nat.le (nat.S m0) __) 
                (nat.le (nat.S m0) (nat.S m0))) 
             (logic.refl sttfa.bool (nat.le (nat.S m0) (nat.S m0))) 
             (nat.plus nat.O (nat.S m0)) (nat.plus_O_n (nat.S m0))))) p H1.

def le_to_lt_to_lt :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (p:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.le n m) (sttfa.impl (nat.lt m p) (nat.lt n p))))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  H:(sttfa.eps (nat.le n m)) =>
  nat.le_ind n 
    (x_417:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.impl (nat.lt x_417 p) (nat.lt n p)) 
    (auto:(sttfa.eps (nat.lt n p)) => auto) 
    (m0:(sttfa.etap (sttfa.p nat.nat)) =>
     _x_419:(sttfa.eps (nat.le n m0)) =>
     _x_421:(sttfa.eps (sttfa.impl (nat.lt m0 p) (nat.lt n p))) =>
     auto:(sttfa.eps (nat.lt (nat.S m0) p)) =>
     _x_421 
       (nat.transitive_lt m0 (nat.S m0) p 
          (logic.eq_coerc (nat.le (nat.S m0) (nat.plus nat.O (nat.S m0))) 
             (nat.le (nat.S m0) (nat.S m0)) (nat.le_plus_n nat.O (nat.S m0)) 
             (logic.rewrite_l nat.nat (nat.S m0) 
                (__:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq sttfa.bool (nat.le (nat.S m0) __) 
                   (nat.le (nat.S m0) (nat.S m0))) 
                (logic.refl sttfa.bool (nat.le (nat.S m0) (nat.S m0))) 
                (nat.plus nat.O (nat.S m0)) (nat.plus_O_n (nat.S m0)))) auto)) 
    m H.

def lt_S_to_lt :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.lt (nat.S n) m) (nat.lt n m))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  auto:(sttfa.eps (nat.lt (nat.S n) m)) =>
  nat.transitive_lt n (nat.S n) m 
    (logic.eq_coerc (nat.le (nat.S n) (nat.plus nat.O (nat.S n))) 
       (nat.le (nat.S n) (nat.S n)) (nat.le_plus_n nat.O (nat.S n)) 
       (logic.rewrite_l nat.nat (nat.S n) 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq sttfa.bool (nat.le (nat.S n) __) 
             (nat.le (nat.S n) (nat.S n))) 
          (logic.refl sttfa.bool (nat.le (nat.S n) (nat.S n))) 
          (nat.plus nat.O (nat.S n)) (nat.plus_O_n (nat.S n)))) auto.

def ltn_to_ltO :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.lt n m) (nat.lt nat.O m))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  auto:(sttfa.eps (nat.lt n m)) =>
  nat.lt_to_le_to_lt nat.O (nat.S n) m 
    (logic.eq_coerc (nat.le (nat.S nat.O) (nat.plus n (nat.S nat.O))) 
       (nat.le (nat.S nat.O) (nat.S n)) (nat.le_plus_n n (nat.S nat.O)) 
       (logic.rewrite_l nat.nat (nat.S n) 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq sttfa.bool (nat.le (nat.S nat.O) __) 
             (nat.le (nat.S nat.O) (nat.S n))) 
          (logic.refl sttfa.bool (nat.le (nat.S nat.O) (nat.S n))) 
          (nat.plus n (nat.S nat.O)) 
          (logic.rewrite_r nat.nat (nat.plus n nat.O) 
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat (nat.S __) (nat.plus n (nat.S nat.O))) 
             (nat.plus_n_Sm n nat.O) n (nat.plus_n_O n)))) auto.

def lt_O_S :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) => nat.lt nat.O (nat.S n)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.ltn_to_ltO n (nat.S n) 
    (logic.eq_coerc (nat.le (nat.S n) (nat.plus nat.O (nat.S n))) 
       (nat.le (nat.S n) (nat.S n)) (nat.le_plus_n nat.O (nat.S n)) 
       (logic.rewrite_l nat.nat (nat.S n) 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq sttfa.bool (nat.le (nat.S n) __) 
             (nat.le (nat.S n) (nat.S n))) 
          (logic.refl sttfa.bool (nat.le (nat.S n) (nat.S n))) 
          (nat.plus nat.O (nat.S n)) (nat.plus_O_n (nat.S n)))).

def monotonic_lt_plus_r :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        relations.monotonic nat.nat nat.lt 
          (m:(sttfa.etap (sttfa.p nat.nat)) => nat.plus n m)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  x:(sttfa.etap (sttfa.p nat.nat)) =>
  y:(sttfa.etap (sttfa.p nat.nat)) =>
  auto:(sttfa.eps (nat.lt x y)) =>
  logic.eq_coerc (nat.le (nat.plus n (nat.S x)) (nat.plus n y)) 
    (nat.le (nat.S (nat.plus n x)) (nat.plus n y)) 
    (nat.monotonic_le_plus_r n (nat.S x) y auto) 
    (logic.rewrite_r nat.nat (nat.plus n (nat.S x)) 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq sttfa.bool (nat.le (nat.plus n (nat.S x)) (nat.plus n y)) 
          (nat.le __ (nat.plus n y))) 
       (logic.refl sttfa.bool (nat.le (nat.plus n (nat.S x)) (nat.plus n y))) 
       (nat.S (nat.plus n x)) (nat.plus_n_Sm n x)).

def monotonic_lt_plus_l :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        relations.monotonic nat.nat nat.lt 
          (m:(sttfa.etap (sttfa.p nat.nat)) => nat.plus m n)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  x:(sttfa.etap (sttfa.p nat.nat)) =>
  y:(sttfa.etap (sttfa.p nat.nat)) =>
  auto:(sttfa.eps (nat.lt x y)) =>
  logic.eq_coerc (nat.le (nat.plus n (nat.S x)) (nat.plus n y)) 
    (nat.le (nat.S (nat.plus x n)) (nat.plus y n)) 
    (nat.monotonic_le_plus_r n (nat.S x) y auto) 
    (logic.rewrite_r nat.nat (nat.plus n x) 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq sttfa.bool (nat.le (nat.plus n (nat.S x)) (nat.plus n y)) 
          (nat.le (nat.S __) (nat.plus y n))) 
       (logic.rewrite_r nat.nat (nat.plus n (nat.S x)) 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq sttfa.bool 
             (nat.le (nat.plus n (nat.S x)) (nat.plus n y)) 
             (nat.le __ (nat.plus y n))) 
          (logic.rewrite_r nat.nat (nat.plus n y) 
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq sttfa.bool 
                (nat.le (nat.plus n (nat.S x)) (nat.plus n y)) 
                (nat.le (nat.plus n (nat.S x)) __)) 
             (logic.refl sttfa.bool 
                (nat.le (nat.plus n (nat.S x)) (nat.plus n y))) 
             (nat.plus y n) (nat.commutative_plus y n)) 
          (nat.S (nat.plus n x)) (nat.plus_n_Sm n x)) (nat.plus x n) 
       (nat.commutative_plus x n)).

def monotonic_lt_times_r :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (c:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.impl (nat.lt nat.O c) 
          (relations.monotonic nat.nat nat.lt 
             (t:(sttfa.etap (sttfa.p nat.nat)) => nat.times c t))))
  :=
  c:(sttfa.etap (sttfa.p nat.nat)) =>
  posc:(sttfa.eps (nat.lt nat.O c)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  ltnm:(sttfa.eps (nat.lt n m)) =>
  nat.le_ind (nat.S n) 
    (x_417:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.lt (nat.times c n) (nat.times c x_417)) 
    (logic.eq_coerc 
       (nat.le (nat.S (nat.plus nat.O (nat.times c n))) 
          (nat.plus c (nat.times c n))) 
       (nat.le (nat.S (nat.times c n)) (nat.times c (nat.S n))) 
       (nat.monotonic_lt_plus_l (nat.times c n) nat.O c posc) 
       (logic.rewrite_r nat.nat (nat.plus nat.O (nat.S (nat.times c n))) 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq sttfa.bool (nat.le __ (nat.plus c (nat.times c n))) 
             (nat.le (nat.S (nat.times c n)) (nat.times c (nat.S n)))) 
          (logic.rewrite_l nat.nat (nat.plus c (nat.times c n)) 
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq sttfa.bool 
                (nat.le (nat.plus nat.O (nat.S (nat.times c n))) 
                   (nat.plus c (nat.times c n))) 
                (nat.le (nat.S (nat.times c n)) __)) 
             (logic.rewrite_l nat.nat (nat.S (nat.times c n)) 
                (__:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq sttfa.bool 
                   (nat.le __ (nat.plus c (nat.times c n))) 
                   (nat.le (nat.S (nat.times c n)) 
                      (nat.plus c (nat.times c n)))) 
                (logic.refl sttfa.bool 
                   (nat.le (nat.S (nat.times c n)) 
                      (nat.plus c (nat.times c n)))) 
                (nat.plus nat.O (nat.S (nat.times c n))) 
                (nat.plus_O_n (nat.S (nat.times c n)))) 
             (nat.times c (nat.S n)) (nat.times_n_Sm c n)) 
          (nat.S (nat.plus nat.O (nat.times c n))) 
          (nat.plus_n_Sm nat.O (nat.times c n)))) 
    (a:(sttfa.etap (sttfa.p nat.nat)) =>
     __:(sttfa.eps (nat.le (nat.S n) a)) =>
     lt1:(sttfa.eps (nat.le (nat.S (nat.times c n)) (nat.times c a))) =>
     nat.transitive_le (nat.S (nat.times c n)) (nat.times c a) 
       (nat.times c (nat.S a)) lt1 
       (logic.eq_coerc (nat.le (nat.times c a) (nat.plus (nat.times c a) c)) 
          (nat.le (nat.times c a) (nat.times c (nat.S a))) 
          (nat.le_plus_n_r c (nat.times c a)) 
          (logic.rewrite_l nat.nat (nat.plus c (nat.times c a)) 
             (__1:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq sttfa.bool 
                (nat.le (nat.times c a) (nat.plus (nat.times c a) c)) 
                (nat.le (nat.times c a) __1)) 
             (logic.rewrite_r nat.nat (nat.plus c (nat.times c a)) 
                (__1:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq sttfa.bool (nat.le (nat.times c a) __1) 
                   (nat.le (nat.times c a) (nat.plus c (nat.times c a)))) 
                (logic.refl sttfa.bool 
                   (nat.le (nat.times c a) (nat.plus c (nat.times c a)))) 
                (nat.plus (nat.times c a) c) 
                (nat.commutative_plus (nat.times c a) c)) 
             (nat.times c (nat.S a)) (nat.times_n_Sm c a)))) m ltnm.

def monotonic_lt_times_l :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (c:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.impl (nat.lt nat.O c) 
          (relations.monotonic nat.nat nat.lt 
             (t:(sttfa.etap (sttfa.p nat.nat)) => nat.times t c))))
  :=
  c:(sttfa.etap (sttfa.p nat.nat)) =>
  auto:(sttfa.eps (nat.lt nat.O c)) =>
  x:(sttfa.etap (sttfa.p nat.nat)) =>
  y:(sttfa.etap (sttfa.p nat.nat)) =>
  auto':(sttfa.eps (nat.lt x y)) =>
  logic.eq_coerc (nat.le (nat.S (nat.times c x)) (nat.times c y)) 
    (nat.le (nat.S (nat.times x c)) (nat.times y c)) 
    (nat.monotonic_lt_times_r c auto x y auto') 
    (logic.rewrite_r nat.nat (nat.times c x) 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq sttfa.bool (nat.le (nat.S (nat.times c x)) (nat.times c y)) 
          (nat.le (nat.S __) (nat.times y c))) 
       (logic.rewrite_r nat.nat (nat.times c y) 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq sttfa.bool 
             (nat.le (nat.S (nat.times c x)) (nat.times c y)) 
             (nat.le (nat.S (nat.times c x)) __)) 
          (logic.refl sttfa.bool 
             (nat.le (nat.S (nat.times c x)) (nat.times c y))) 
          (nat.times y c) (nat.commutative_times y c)) (nat.times x c) 
       (nat.commutative_times x c)).

def lt_to_le_to_lt_times :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (p:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat 
                (q:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (nat.lt n m) 
                   (sttfa.impl (nat.le p q) 
                      (sttfa.impl (nat.lt nat.O q) 
                         (nat.lt (nat.times n p) (nat.times m q)))))))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  q:(sttfa.etap (sttfa.p nat.nat)) =>
  ltnm:(sttfa.eps (nat.lt n m)) =>
  lepq:(sttfa.eps (nat.le p q)) =>
  posq:(sttfa.eps (nat.lt nat.O q)) =>
  nat.le_to_lt_to_lt (nat.times n p) (nat.times n q) (nat.times m q) 
    (nat.monotonic_le_times_r n p q lepq) 
    (nat.monotonic_lt_times_l q posq n m ltnm).

def lt_times :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (p:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat 
                (q:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (nat.lt n m) 
                   (sttfa.impl (nat.lt p q) 
                      (nat.lt (nat.times n p) (nat.times m q))))))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  q:(sttfa.etap (sttfa.p nat.nat)) =>
  ltnm:(sttfa.eps (nat.lt n m)) =>
  ltpq:(sttfa.eps (nat.lt p q)) =>
  nat.lt_to_le_to_lt_times n m p q ltnm (nat.lt_to_le p q ltpq) 
    (nat.ltn_to_ltO p q ltpq).

def lt_plus_to_minus_r :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (a:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (b:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (c:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.lt (nat.plus a b) c) (nat.lt a (nat.minus c b))))))
  :=
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  c:(sttfa.etap (sttfa.p nat.nat)) =>
  H:(sttfa.eps (nat.lt (nat.plus a b) c)) =>
  nat.le_plus_to_minus_r (nat.S a) b c 
    (nat.sym_eq_plus (nat.S a) 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        nat.le (y b) c) 
       (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
          nat.plus_body a 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           nat.le (y b) c) 
          (nat.sym_eq_plus_body_S a 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              nat.le (y b) c) H))).

def lt_plus_Sn_r :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (a:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (x:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (n:(sttfa.etap (sttfa.p nat.nat)) =>
              nat.lt a (nat.plus (nat.plus a x) (nat.S n))))))
  :=
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  x:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.eq_coerc (nat.le (nat.S a) (nat.S (nat.plus (nat.plus a x) n))) 
    (nat.le (nat.S a) (nat.plus (nat.plus a x) (nat.S n))) 
    (nat.le_S_S a (nat.plus (nat.plus a x) n) 
       (logic.eq_coerc (nat.le a (nat.plus a (nat.plus x n))) 
          (nat.le a (nat.plus (nat.plus a x) n)) 
          (nat.le_plus_n_r (nat.plus x n) a) 
          (logic.rewrite_r nat.nat (nat.plus n (nat.plus a x)) 
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq sttfa.bool (nat.le a (nat.plus a (nat.plus x n))) 
                (nat.le a __)) 
             (logic.rewrite_r nat.nat (nat.plus a (nat.plus n x)) 
                (__:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq sttfa.bool (nat.le a (nat.plus a (nat.plus x n))) 
                   (nat.le a __)) 
                (logic.rewrite_r nat.nat (nat.plus x n) 
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq sttfa.bool 
                      (nat.le a (nat.plus a (nat.plus x n))) 
                      (nat.le a (nat.plus a __))) 
                   (logic.refl sttfa.bool 
                      (nat.le a (nat.plus a (nat.plus x n)))) (nat.plus n x) 
                   (nat.commutative_plus n x)) (nat.plus n (nat.plus a x)) 
                (logic.rewrite_l nat.nat (nat.plus (nat.plus a n) x) 
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat (nat.plus n (nat.plus a x)) __) 
                   (nat.assoc_plus1 x a n) (nat.plus a (nat.plus n x)) 
                   (nat.associative_plus a n x))) 
             (nat.plus (nat.plus a x) n) 
             (nat.commutative_plus (nat.plus a x) n)))) 
    (logic.rewrite_r nat.nat (nat.plus a (nat.plus x (nat.S n))) 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq sttfa.bool 
          (nat.le (nat.S a) (nat.S (nat.plus (nat.plus a x) n))) 
          (nat.le (nat.S a) __)) 
       (logic.rewrite_r nat.nat (nat.plus (nat.plus a x) (nat.S n)) 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq sttfa.bool (nat.le (nat.S a) __) 
             (nat.le (nat.S a) (nat.plus a (nat.plus x (nat.S n))))) 
          (logic.rewrite_r nat.nat (nat.plus a (nat.plus x (nat.S n))) 
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq sttfa.bool (nat.le (nat.S a) __) 
                (nat.le (nat.S a) (nat.plus a (nat.plus x (nat.S n))))) 
             (logic.refl sttfa.bool 
                (nat.le (nat.S a) (nat.plus a (nat.plus x (nat.S n))))) 
             (nat.plus (nat.plus a x) (nat.S n)) 
             (nat.associative_plus a x (nat.S n))) 
          (nat.S (nat.plus (nat.plus a x) n)) 
          (nat.plus_n_Sm (nat.plus a x) n)) 
       (nat.plus (nat.plus a x) (nat.S n)) 
       (nat.associative_plus a x (nat.S n))).

def not_le_Sn_O :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        connectives.Not (nat.le (nat.S n) nat.O)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  Hlen0:(sttfa.eps (nat.le (nat.S n) nat.O)) =>
  nat.eq_match_nat_type_O sttfa.bool connectives.False 
    (p:(sttfa.etap (sttfa.p nat.nat)) => connectives.True) 
    (y:(sttfa.etap (sttfa.p sttfa.bool)) => y) 
    (nat.lt_to_not_zero n nat.O Hlen0).

def not_le_to_not_le_S_S :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (connectives.Not (nat.le n m)) 
             (connectives.Not (nat.le (nat.S n) (nat.S m))))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  auto:(sttfa.eps (connectives.Not (nat.le n m))) =>
  logic.not_to_not (nat.le (nat.S n) (nat.S m)) (nat.le n m) 
    (auto':(sttfa.eps (nat.le (nat.S n) (nat.S m))) =>
     logic.eq_coerc (nat.le (nat.pred (nat.S n)) (nat.pred (nat.S m))) 
       (nat.le n m) (nat.monotonic_pred (nat.S n) (nat.S m) auto') 
       (logic.rewrite_l nat.nat n 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq sttfa.bool (nat.le __ (nat.pred (nat.S m))) (nat.le n m)) 
          (logic.rewrite_l nat.nat m 
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq sttfa.bool (nat.le n __) (nat.le n m)) 
             (logic.refl sttfa.bool (nat.le n m)) (nat.pred (nat.S m)) 
             (nat.pred_Sn m)) (nat.pred (nat.S n)) (nat.pred_Sn n))) auto.

def not_le_S_S_to_not_le :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (connectives.Not (nat.le (nat.S n) (nat.S m))) 
             (connectives.Not (nat.le n m)))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  auto:(sttfa.eps (connectives.Not (nat.le (nat.S n) (nat.S m)))) =>
  logic.not_to_not (nat.le n m) (nat.le (nat.S n) (nat.S m)) 
    (auto':(sttfa.eps (nat.le n m)) => nat.le_S_S n m auto') auto.

def not_le_Sn_n :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        connectives.Not (nat.le (nat.S n) n)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind 
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     connectives.Not (nat.le (nat.S _x_365) _x_365)) (nat.not_le_Sn_O nat.O) 
    (x_366:(sttfa.etap (sttfa.p nat.nat)) =>
     _x_368:(sttfa.eps (connectives.Not (nat.le (nat.S x_366) x_366))) =>
     nat.not_le_to_not_le_S_S (nat.S x_366) x_366 _x_368) n.

def lt_to_not_le :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.lt n m) (connectives.Not (nat.le m n)))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  Hltnm:(sttfa.eps (nat.lt n m)) =>
  nat.le_ind (nat.S n) 
    (x_417:(sttfa.etap (sttfa.p nat.nat)) => connectives.Not (nat.le x_417 n)) 
    (nat.not_le_Sn_n n) 
    (m0:(sttfa.etap (sttfa.p nat.nat)) =>
     _x_419:(sttfa.eps (nat.le (nat.S n) m0)) =>
     _x_421:(sttfa.eps (connectives.Not (nat.le m0 n))) =>
     logic.not_to_not (nat.le (nat.S m0) n) (nat.le m0 n) 
       (auto:(sttfa.eps (nat.le (nat.S m0) n)) => nat.lt_to_le m0 n auto) 
       _x_421) m Hltnm.

def not_le_to_lt :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (connectives.Not (nat.le n m)) (nat.lt m n))))
  :=
  nat.nat_elim2 
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     _0:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.impl (connectives.Not (nat.le __ _0)) (nat.lt _0 __)) 
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     abs:(sttfa.eps (connectives.Not (nat.le nat.O n))) =>
     logic.falsity (nat.lt n nat.O) 
       (logic.absurd (nat.le nat.O n) 
          (logic.eq_coerc (nat.le nat.O (nat.plus n nat.O)) (nat.le nat.O n) 
             (nat.le_plus_n n nat.O) 
             (logic.rewrite_l nat.nat n 
                (__:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq sttfa.bool (nat.le nat.O __) (nat.le nat.O n)) 
                (logic.refl sttfa.bool (nat.le nat.O n)) (nat.plus n nat.O) 
                (nat.plus_n_O n))) abs)) 
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     auto:(sttfa.eps (connectives.Not (nat.le (nat.S n) nat.O))) =>
     nat.lt_O_S n) 
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     m:(sttfa.etap (sttfa.p nat.nat)) =>
     Hind:
     (sttfa.eps (sttfa.impl (connectives.Not (nat.le n m)) (nat.lt m n))) =>
     HnotleSS:(sttfa.eps (connectives.Not (nat.le (nat.S n) (nat.S m)))) =>
     nat.le_S_S (nat.S m) n (Hind (nat.not_le_S_S_to_not_le n m HnotleSS))).

def not_lt_to_le :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (connectives.Not (nat.lt n m)) (nat.le m n))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  H:(sttfa.eps (connectives.Not (nat.lt n m))) =>
  nat.le_S_S_to_le m n 
    (nat.not_le_to_lt (nat.S n) m 
       (logic.not_to_not (nat.le (nat.S n) m) (nat.lt n m) 
          (auto:(sttfa.eps (nat.le (nat.S n) m)) => auto) H)).

def le_to_not_lt :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.le n m) (connectives.Not (nat.lt m n)))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  H:(sttfa.eps (nat.le n m)) =>
  nat.lt_to_not_le n (nat.S m) 
    (nat.le_to_lt_to_lt n m (nat.S m) H 
       (logic.eq_coerc (nat.le (nat.S m) (nat.plus nat.O (nat.S m))) 
          (nat.le (nat.S m) (nat.S m)) (nat.le_plus_n nat.O (nat.S m)) 
          (logic.rewrite_l nat.nat (nat.S m) 
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq sttfa.bool (nat.le (nat.S m) __) 
                (nat.le (nat.S m) (nat.S m))) 
             (logic.refl sttfa.bool (nat.le (nat.S m) (nat.S m))) 
             (nat.plus nat.O (nat.S m)) (nat.plus_O_n (nat.S m))))).

def decidable_le :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) => logic.decidable (nat.le n m))))
  :=
  nat.nat_elim2 
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     _0:(sttfa.etap (sttfa.p nat.nat)) => logic.decidable (nat.le __ _0)) 
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     z:(sttfa.etap (sttfa.p sttfa.bool)) =>
     l:(sttfa.eps (sttfa.impl (nat.le nat.O n) z)) =>
     r:(sttfa.eps (sttfa.impl (connectives.Not (nat.le nat.O n)) z)) =>
     l (nat.le_O_n n)) 
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     z:(sttfa.etap (sttfa.p sttfa.bool)) =>
     l:(sttfa.eps (sttfa.impl (nat.le (nat.S n) nat.O) z)) =>
     r:
     (sttfa.eps (sttfa.impl (connectives.Not (nat.le (nat.S n) nat.O)) z)) =>
     r (nat.not_le_Sn_O n)) 
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     m:(sttfa.etap (sttfa.p nat.nat)) =>
     _clearme:(sttfa.eps (logic.decidable (nat.le n m))) =>
     logic.match_Or_prop (nat.le n m) (connectives.Not (nat.le n m)) 
       (logic.decidable (nat.le (nat.S n) (nat.S m))) 
       (auto:(sttfa.eps (nat.le n m)) =>
        z:(sttfa.etap (sttfa.p sttfa.bool)) =>
        l:(sttfa.eps (sttfa.impl (nat.le (nat.S n) (nat.S m)) z)) =>
        r:
        (sttfa.eps 
           (sttfa.impl (connectives.Not (nat.le (nat.S n) (nat.S m))) z)) =>
        l (nat.le_S_S n m auto)) 
       (auto:(sttfa.eps (connectives.Not (nat.le n m))) =>
        z:(sttfa.etap (sttfa.p sttfa.bool)) =>
        l:(sttfa.eps (sttfa.impl (nat.le (nat.S n) (nat.S m)) z)) =>
        r:
        (sttfa.eps 
           (sttfa.impl (connectives.Not (nat.le (nat.S n) (nat.S m))) z)) =>
        r (nat.not_le_to_not_le_S_S n m auto)) _clearme).

def decidable_lt :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) => logic.decidable (nat.lt n m))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) => nat.decidable_le (nat.S n) m.

def le_to_or_lt_eq :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.le n m) 
             (connectives.Or (nat.lt n m) (logic.eq nat.nat n m)))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  lenm:(sttfa.eps (nat.le n m)) =>
  nat.le_ind n 
    (x_417:(sttfa.etap (sttfa.p nat.nat)) =>
     connectives.Or (nat.lt n x_417) (logic.eq nat.nat n x_417)) 
    (relations.RC_reflexive nat.nat nat.lt n) 
    (m0:(sttfa.etap (sttfa.p nat.nat)) =>
     _x_419:(sttfa.eps (nat.le n m0)) =>
     _x_421:
     (sttfa.eps (connectives.Or (nat.lt n m0) (logic.eq nat.nat n m0))) =>
     z:(sttfa.etap (sttfa.p sttfa.bool)) =>
     l:(sttfa.eps (sttfa.impl (nat.lt n (nat.S m0)) z)) =>
     r:(sttfa.eps (sttfa.impl (logic.eq nat.nat n (nat.S m0)) z)) =>
     l 
       (nat.le_to_lt_to_lt n m0 (nat.S m0) _x_419 
          (logic.eq_coerc (nat.le (nat.S m0) (nat.plus nat.O (nat.S m0))) 
             (nat.le (nat.S m0) (nat.S m0)) (nat.le_plus_n nat.O (nat.S m0)) 
             (logic.rewrite_l nat.nat (nat.S m0) 
                (__:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq sttfa.bool (nat.le (nat.S m0) __) 
                   (nat.le (nat.S m0) (nat.S m0))) 
                (logic.refl sttfa.bool (nat.le (nat.S m0) (nat.S m0))) 
                (nat.plus nat.O (nat.S m0)) (nat.plus_O_n (nat.S m0)))))) m 
    lenm.

def lt_O_n_elim :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.impl (nat.lt nat.O n) 
          (sttfa.forall (sttfa.arrow nat.nat sttfa.bool) 
             (P:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat sttfa.bool))) =>
              sttfa.impl 
                (sttfa.forall nat.nat 
                   (m:(sttfa.etap (sttfa.p nat.nat)) => P (nat.S m))) (
                P n)))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind 
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.impl (nat.lt nat.O _x_365) 
       (sttfa.forall (sttfa.arrow nat.nat sttfa.bool) 
          (P:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat sttfa.bool))) =>
           sttfa.impl 
             (sttfa.forall nat.nat 
                (m:(sttfa.etap (sttfa.p nat.nat)) => P (nat.S m))) (P _x_365)))) 
    (abs:(sttfa.eps (nat.lt nat.O nat.O)) =>
     logic.falsity 
       (sttfa.forall (sttfa.arrow nat.nat sttfa.bool) 
          (P:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat sttfa.bool))) =>
           sttfa.impl 
             (sttfa.forall nat.nat 
                (m:(sttfa.etap (sttfa.p nat.nat)) => P (nat.S m))) (P nat.O))) 
       (logic.absurd (nat.le (nat.S nat.O) nat.O) abs (nat.not_le_Sn_O nat.O))) 
    (x_366:(sttfa.etap (sttfa.p nat.nat)) =>
     _x_368:
     (sttfa.eps 
        (sttfa.impl (nat.lt nat.O x_366) 
           (sttfa.forall (sttfa.arrow nat.nat sttfa.bool) 
              (P:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat sttfa.bool))) =>
               sttfa.impl 
                 (sttfa.forall nat.nat 
                    (m:(sttfa.etap (sttfa.p nat.nat)) => P (nat.S m))) 
                 (P x_366))))) =>
     auto:(sttfa.eps (nat.lt nat.O (nat.S x_366))) =>
     P:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat sttfa.bool))) =>
     auto':
     (sttfa.eps 
        (sttfa.forall nat.nat 
           (m:(sttfa.etap (sttfa.p nat.nat)) => P (nat.S m)))) =>
     auto' x_366) n.

def le_n_O_elim :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.impl (nat.le n nat.O) 
          (sttfa.forall (sttfa.arrow nat.nat sttfa.bool) 
             (P:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat sttfa.bool))) =>
              sttfa.impl (P nat.O) (P n)))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.match_nat_prop 
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.impl (nat.le __ nat.O) 
       (sttfa.forall (sttfa.arrow nat.nat sttfa.bool) 
          (P:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat sttfa.bool))) =>
           sttfa.impl (P nat.O) (P __)))) 
    (auto:(sttfa.eps (nat.le nat.O nat.O)) =>
     P:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat sttfa.bool))) =>
     auto':(sttfa.eps (P nat.O)) => auto') 
    (a:(sttfa.etap (sttfa.p nat.nat)) =>
     abs:(sttfa.eps (nat.le (nat.S a) nat.O)) =>
     logic.falsity 
       (sttfa.forall (sttfa.arrow nat.nat sttfa.bool) 
          (P:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat sttfa.bool))) =>
           sttfa.impl (P nat.O) (P (nat.S a)))) 
       (logic.absurd (nat.le (nat.S a) nat.O) abs (nat.not_le_Sn_O a))) n.

def lt_to_not_eq :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.lt n m) (connectives.Not (logic.eq nat.nat n m)))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  H:(sttfa.eps (nat.lt n m)) =>
  logic.not_to_not (logic.eq nat.nat n m) connectives.False 
    (auto:(sttfa.eps (logic.eq nat.nat n m)) =>
     logic.absurd (nat.le (nat.S n) n) 
       (logic.eq_coerc (nat.le (nat.S n) m) (nat.le (nat.S n) n) H 
          (logic.rewrite_l nat.nat n 
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq sttfa.bool (nat.le (nat.S n) __) (nat.le (nat.S n) n)) 
             (logic.refl sttfa.bool (nat.le (nat.S n) n)) m auto)) 
       (nat.not_le_Sn_n n)) (auto:(sttfa.eps connectives.False) => auto).

def le_n_O_to_eq :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.impl (nat.le n nat.O) (logic.eq nat.nat nat.O n)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.match_nat_prop 
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.impl (nat.le __ nat.O) (logic.eq nat.nat nat.O __)) 
    (auto:(sttfa.eps (nat.le nat.O nat.O)) => logic.refl nat.nat nat.O) 
    (a:(sttfa.etap (sttfa.p nat.nat)) =>
     abs:(sttfa.eps (nat.le (nat.S a) nat.O)) =>
     logic.falsity (logic.eq nat.nat nat.O (nat.S a)) 
       (logic.absurd (nat.le (nat.S a) nat.O) abs (nat.not_le_Sn_O a))) n.

def le_to_le_to_eq :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.le n m) 
             (sttfa.impl (nat.le m n) (logic.eq nat.nat n m)))))
  :=
  nat.nat_elim2 
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     _0:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.impl (nat.le __ _0) 
       (sttfa.impl (nat.le _0 __) (logic.eq nat.nat __ _0))) 
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     auto:(sttfa.eps (nat.le nat.O n)) =>
     auto':(sttfa.eps (nat.le n nat.O)) =>
     logic.sym_eq nat.nat n nat.O 
       (logic.sym_eq nat.nat nat.O n 
          (logic.eq_coerc (logic.eq nat.nat nat.O n) 
             (logic.eq nat.nat nat.O n) (nat.le_n_O_to_eq n auto') 
             (logic.refl sttfa.bool (logic.eq nat.nat nat.O n))))) 
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     auto:(sttfa.eps (nat.le (nat.S n) nat.O)) =>
     auto':(sttfa.eps (nat.le nat.O (nat.S n))) =>
     logic.sym_eq nat.nat nat.O (nat.S n) (nat.le_n_O_to_eq (nat.S n) auto)) 
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     m:(sttfa.etap (sttfa.p nat.nat)) =>
     auto:
     (sttfa.eps 
        (sttfa.impl (nat.le n m) 
           (sttfa.impl (nat.le m n) (logic.eq nat.nat n m)))) =>
     auto':(sttfa.eps (nat.le (nat.S n) (nat.S m))) =>
     auto'':(sttfa.eps (nat.le (nat.S m) (nat.S n))) =>
     logic.eq_f nat.nat nat.nat nat.S n m 
       (auto 
          (logic.eq_coerc (nat.le (nat.pred (nat.S n)) (nat.pred (nat.S m))) 
             (nat.le n m) (nat.monotonic_pred (nat.S n) (nat.S m) auto') 
             (logic.rewrite_l nat.nat n 
                (__:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq sttfa.bool (nat.le __ (nat.pred (nat.S m))) 
                   (nat.le n m)) 
                (logic.rewrite_l nat.nat m 
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq sttfa.bool (nat.le n __) (nat.le n m)) 
                   (logic.refl sttfa.bool (nat.le n m)) (nat.pred (nat.S m)) 
                   (nat.pred_Sn m)) (nat.pred (nat.S n)) (nat.pred_Sn n))) 
          (logic.eq_coerc (nat.le (nat.pred (nat.S m)) (nat.pred (nat.S n))) 
             (nat.le m n) (nat.monotonic_pred (nat.S m) (nat.S n) auto'') 
             (logic.rewrite_l nat.nat m 
                (__:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq sttfa.bool (nat.le __ (nat.pred (nat.S n))) 
                   (nat.le m n)) 
                (logic.rewrite_l nat.nat n 
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq sttfa.bool (nat.le m __) (nat.le m n)) 
                   (logic.refl sttfa.bool (nat.le m n)) (nat.pred (nat.S n)) 
                   (nat.pred_Sn n)) (nat.pred (nat.S m)) (nat.pred_Sn m))))).

def plus_minus :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (p:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.le m n) 
                (logic.eq nat.nat (nat.plus (nat.minus n m) p) 
                   (nat.minus (nat.plus n p) m))))))
  :=
  nat.nat_elim2 
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     _0:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.forall nat.nat 
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.impl (nat.le __ _0) 
          (logic.eq nat.nat (nat.plus (nat.minus _0 __) p) 
             (nat.minus (nat.plus _0 p) __)))) 
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     p:(sttfa.etap (sttfa.p nat.nat)) =>
     auto:(sttfa.eps (nat.le nat.O n)) =>
     logic.rewrite_l nat.nat n 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat (nat.plus __ p) (nat.minus (nat.plus n p) nat.O)) 
       (logic.rewrite_l nat.nat (nat.plus n p) 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat (nat.plus n p) __) 
          (logic.refl nat.nat (nat.plus n p)) 
          (nat.minus (nat.plus n p) nat.O) (nat.minus_n_O (nat.plus n p))) 
       (nat.minus n nat.O) (nat.minus_n_O n)) 
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     p:(sttfa.etap (sttfa.p nat.nat)) =>
     abs:(sttfa.eps (nat.le (nat.S n) nat.O)) =>
     logic.falsity 
       (logic.eq nat.nat (nat.plus (nat.minus nat.O (nat.S n)) p) 
          (nat.minus (nat.plus nat.O p) (nat.S n))) 
       (logic.absurd (nat.le (nat.S n) nat.O) abs (nat.not_le_Sn_O n))) 
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     m:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_minus (nat.S m) 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        sttfa.impl 
          (sttfa.forall nat.nat 
             (p:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.le n m) 
                (logic.eq nat.nat (nat.plus (nat.minus m n) p) 
                   (nat.minus (nat.plus m p) n)))) 
          (sttfa.forall nat.nat 
             (p:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.le (nat.S n) (nat.S m)) 
                (logic.eq nat.nat (nat.plus (y (nat.S n)) p) 
                   (nat.minus (nat.plus (nat.S m) p) (nat.S n)))))) 
       (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
          nat.minus_body m 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           sttfa.impl 
             (sttfa.forall nat.nat 
                (p:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (nat.le n m) 
                   (logic.eq nat.nat (nat.plus (nat.minus m n) p) 
                      (nat.minus (nat.plus m p) n)))) 
             (sttfa.forall nat.nat 
                (p:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (nat.le (nat.S n) (nat.S m)) 
                   (logic.eq nat.nat (nat.plus (y (nat.S n)) p) 
                      (nat.minus (nat.plus (nat.S m) p) (nat.S n)))))) 
          (nat.sym_eq_minus_body_S m 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              sttfa.impl 
                (sttfa.forall nat.nat 
                   (p:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (nat.le n m) 
                      (logic.eq nat.nat (nat.plus (nat.minus m n) p) 
                         (nat.minus (nat.plus m p) n)))) 
                (sttfa.forall nat.nat 
                   (p:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (nat.le (nat.S n) (nat.S m)) 
                      (logic.eq nat.nat (nat.plus (y (nat.S n)) p) 
                         (nat.minus (nat.plus (nat.S m) p) (nat.S n)))))) 
             (auto:
              (sttfa.eps 
                 (sttfa.forall nat.nat 
                    (p:(sttfa.etap (sttfa.p nat.nat)) =>
                     sttfa.impl (nat.le n m) 
                       (logic.eq nat.nat (nat.plus (nat.minus m n) p) 
                          (nat.minus (nat.plus m p) n))))) =>
              p:(sttfa.etap (sttfa.p nat.nat)) =>
              nat.sym_eq_match_nat_type_S nat.nat (nat.S m) 
                (q:(sttfa.etap (sttfa.p nat.nat)) => nat.minus m q) n 
                (y:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (nat.le (nat.S n) (nat.S m)) 
                   (logic.eq nat.nat (nat.plus y p) 
                      (nat.minus (nat.plus (nat.S m) p) (nat.S n)))) 
                (nat.sym_eq_minus (nat.plus (nat.S m) p) 
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                    sttfa.impl (nat.le (nat.S n) (nat.S m)) 
                      (logic.eq nat.nat (nat.plus (nat.minus m n) p) 
                         (y (nat.S n)))) 
                   (nat.sym_eq_plus (nat.S m) 
                      (y:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       sttfa.impl (nat.le (nat.S n) (nat.S m)) 
                         (logic.eq nat.nat (nat.plus (nat.minus m n) p) 
                            (nat.filter_nat_type 
                               (sttfa.arrow nat.nat nat.nat) nat.minus_body 
                               (y p) (nat.S n)))) 
                      (nat.sym_eq_filter_nat_type_S 
                         (sttfa.arrow nat.nat nat.nat) nat.plus_body m 
                         (y:
                          (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                          sttfa.impl (nat.le (nat.S n) (nat.S m)) 
                            (logic.eq nat.nat (nat.plus (nat.minus m n) p) 
                               (nat.filter_nat_type 
                                  (sttfa.arrow nat.nat nat.nat) 
                                  nat.minus_body (y p) (nat.S n)))) 
                         (nat.sym_eq_plus_body_S m 
                            (y:
                             (sttfa.etap 
                                (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                             sttfa.impl (nat.le (nat.S n) (nat.S m)) 
                               (logic.eq nat.nat 
                                  (nat.plus (nat.minus m n) p) 
                                  (nat.filter_nat_type 
                                     (sttfa.arrow nat.nat nat.nat) 
                                     nat.minus_body (y p) (nat.S n)))) 
                            (nat.sym_eq_filter_nat_type_S 
                               (sttfa.arrow nat.nat nat.nat) nat.minus_body 
                               (nat.plus m p) 
                               (y:
                                (sttfa.etap 
                                   (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                                sttfa.impl (nat.le (nat.S n) (nat.S m)) 
                                  (logic.eq nat.nat 
                                     (nat.plus (nat.minus m n) p) 
                                     (y (nat.S n)))) 
                               (nat.eq_plus_body_S m 
                                  (y:
                                   (sttfa.etap 
                                      (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                                   sttfa.impl (nat.le (nat.S n) (nat.S m)) 
                                     (logic.eq nat.nat 
                                        (nat.plus (nat.minus m n) p) 
                                        (nat.minus_body (y p) (nat.S n)))) 
                                  (nat.eq_filter_nat_type_S 
                                     (sttfa.arrow nat.nat nat.nat) 
                                     nat.plus_body m 
                                     (y:
                                      (sttfa.etap 
                                         (sttfa.p 
                                            (sttfa.arrow nat.nat nat.nat))) =>
                                      sttfa.impl 
                                        (nat.le (nat.S n) (nat.S m)) 
                                        (logic.eq nat.nat 
                                           (nat.plus (nat.minus m n) p) 
                                           (nat.minus_body (y p) (nat.S n)))) 
                                     (nat.eq_plus (nat.S m) 
                                        (y:
                                         (sttfa.etap 
                                            (sttfa.p 
                                               (sttfa.arrow nat.nat nat.nat))) =>
                                         sttfa.impl 
                                           (nat.le (nat.S n) (nat.S m)) 
                                           (logic.eq nat.nat 
                                              (nat.plus (nat.minus m n) p) 
                                              (nat.minus_body (y p) (nat.S n)))) 
                                        (nat.sym_eq_plus (nat.S m) 
                                           (y:
                                            (sttfa.etap 
                                               (sttfa.p 
                                                  (sttfa.arrow nat.nat 
                                                     nat.nat))) =>
                                            sttfa.impl 
                                              (nat.le (nat.S n) (nat.S m)) 
                                              (logic.eq nat.nat 
                                                 (nat.plus (nat.minus m n) p) 
                                                 (nat.minus_body (y p) 
                                                    (nat.S n)))) 
                                           (nat.sym_eq_filter_nat_type_S 
                                              (sttfa.arrow nat.nat nat.nat) 
                                              nat.plus_body m 
                                              (y:
                                               (sttfa.etap 
                                                  (sttfa.p 
                                                     (sttfa.arrow nat.nat 
                                                        nat.nat))) =>
                                               sttfa.impl 
                                                 (nat.le (nat.S n) (nat.S m)) 
                                                 (logic.eq nat.nat 
                                                    (nat.plus 
                                                       (nat.minus m n) p) 
                                                    (nat.minus_body (
                                                       y p) (nat.S n)))) 
                                              (nat.sym_eq_plus_body_S m 
                                                 (y:
                                                  (sttfa.etap 
                                                     (sttfa.p 
                                                        (sttfa.arrow nat.nat 
                                                           nat.nat))) =>
                                                  sttfa.impl 
                                                    (nat.le (nat.S n) 
                                                       (nat.S m)) 
                                                    (logic.eq nat.nat 
                                                       (nat.plus 
                                                          (nat.minus m n) p) 
                                                       (nat.minus_body (
                                                          y p) (nat.S n)))) 
                                                 (nat.sym_eq_minus_body_S 
                                                    (nat.plus m p) 
                                                    (y:
                                                     (sttfa.etap 
                                                        (sttfa.p 
                                                           (sttfa.arrow 
                                                              nat.nat nat.nat))) =>
                                                     sttfa.impl 
                                                       (nat.le (nat.S n) 
                                                          (nat.S m)) 
                                                       (logic.eq nat.nat 
                                                          (nat.plus 
                                                             (nat.minus m n) 
                                                             p) (y (nat.S n)))) 
                                                    (nat.sym_eq_match_nat_type_S 
                                                       nat.nat 
                                                       (nat.S (nat.plus m p)) 
                                                       (q:
                                                        (sttfa.etap 
                                                           (sttfa.p nat.nat)) =>
                                                        nat.minus 
                                                          (nat.plus m p) q) 
                                                       n 
                                                       (y:
                                                        (sttfa.etap 
                                                           (sttfa.p nat.nat)) =>
                                                        sttfa.impl 
                                                          (nat.le (nat.S n) 
                                                             (nat.S m)) 
                                                          (logic.eq nat.nat 
                                                             (nat.plus 
                                                                (nat.minus m 
                                                                   n) p) y)) 
                                                       (auto':
                                                        (sttfa.eps 
                                                           (nat.le (nat.S n) 
                                                              (nat.S m))) =>
                                                        auto p 
                                                          (logic.eq_coerc 
                                                             (nat.le 
                                                                (nat.pred 
                                                                   (nat.S n)) 
                                                                (nat.pred 
                                                                   (nat.S m))) 
                                                             (nat.le n m) 
                                                             (nat.monotonic_pred 
                                                                (nat.S n) 
                                                                (nat.S m) 
                                                                auto') 
                                                             (logic.rewrite_l 
                                                                nat.nat n 
                                                                (__:
                                                                 (sttfa.etap 
                                                                    (
                                                                    sttfa.p 
                                                                    nat.nat)) =>
                                                                 logic.eq 
                                                                   sttfa.bool 
                                                                   (nat.le 
                                                                    __ 
                                                                    (nat.pred 
                                                                    (nat.S m))) 
                                                                   (nat.le n 
                                                                    m)) 
                                                                (logic.rewrite_l 
                                                                   nat.nat m 
                                                                   (__:
                                                                    (
                                                                    sttfa.etap 
                                                                    (sttfa.p 
                                                                    nat.nat)) =>
                                                                    logic.eq 
                                                                    sttfa.bool 
                                                                    (nat.le 
                                                                    n __) 
                                                                    (nat.le 
                                                                    n m)) 
                                                                   (logic.refl 
                                                                    sttfa.bool 
                                                                    (nat.le 
                                                                    n m)) 
                                                                   (nat.pred 
                                                                    (nat.S m)) 
                                                                   (nat.pred_Sn 
                                                                    m)) 
                                                                (nat.pred 
                                                                   (nat.S n)) 
                                                                (nat.pred_Sn 
                                                                   n))))))))))))))))))))).

def minus_plus_m_m :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat n (nat.minus (nat.plus n m) m))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.eq_coerc 
    (logic.eq nat.nat (nat.plus (nat.minus m m) n) 
       (nat.minus (nat.plus m n) m)) 
    (logic.eq nat.nat n (nat.minus (nat.plus n m) m)) 
    (nat.plus_minus m m n (nat.le_n m)) 
    (logic.rewrite_l nat.nat nat.O 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq sttfa.bool 
          (logic.eq nat.nat (nat.plus __ n) (nat.minus (nat.plus m n) m)) 
          (logic.eq nat.nat n (nat.minus (nat.plus n m) m))) 
       (logic.rewrite_l nat.nat n 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq sttfa.bool 
             (logic.eq nat.nat __ (nat.minus (nat.plus m n) m)) 
             (logic.eq nat.nat n (nat.minus (nat.plus n m) m))) 
          (logic.rewrite_r nat.nat (nat.plus n m) 
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq sttfa.bool (logic.eq nat.nat n (nat.minus __ m)) 
                (logic.eq nat.nat n (nat.minus (nat.plus n m) m))) 
             (logic.refl sttfa.bool 
                (logic.eq nat.nat n (nat.minus (nat.plus n m) m))) 
             (nat.plus m n) (nat.commutative_plus m n)) (nat.plus nat.O n) 
          (nat.plus_O_n n)) (nat.minus m m) (nat.minus_n_n m)).

def plus_minus_m_m :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.le m n) 
             (logic.eq nat.nat n (nat.plus (nat.minus n m) m)))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  lemn:(sttfa.eps (nat.le m n)) =>
  logic.sym_eq nat.nat (nat.plus (nat.minus n m) m) n 
    (logic.eq_coerc 
       (logic.eq nat.nat (nat.plus (nat.minus n m) m) 
          (nat.minus (nat.plus n m) m)) 
       (logic.eq nat.nat (nat.plus (nat.minus n m) m) n) 
       (nat.plus_minus m n m lemn) 
       (logic.rewrite_r nat.nat (nat.plus m (nat.minus n m)) 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq sttfa.bool 
             (logic.eq nat.nat (nat.plus (nat.minus n m) m) 
                (nat.minus (nat.plus n m) m)) (logic.eq nat.nat __ n)) 
          (logic.rewrite_r nat.nat (nat.plus m (nat.minus n m)) 
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq sttfa.bool 
                (logic.eq nat.nat __ (nat.minus (nat.plus n m) m)) 
                (logic.eq nat.nat (nat.plus m (nat.minus n m)) n)) 
             (logic.rewrite_l nat.nat n 
                (__:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq sttfa.bool 
                   (logic.eq nat.nat (nat.plus m (nat.minus n m)) __) 
                   (logic.eq nat.nat (nat.plus m (nat.minus n m)) n)) 
                (logic.refl sttfa.bool 
                   (logic.eq nat.nat (nat.plus m (nat.minus n m)) n)) 
                (nat.minus (nat.plus n m) m) (nat.minus_plus_m_m n m)) 
             (nat.plus (nat.minus n m) m) 
             (nat.commutative_plus (nat.minus n m) m)) 
          (nat.plus (nat.minus n m) m) 
          (nat.commutative_plus (nat.minus n m) m))).

def minus_to_plus :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (p:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.le m n) 
                (sttfa.impl (logic.eq nat.nat (nat.minus n m) p) 
                   (logic.eq nat.nat n (nat.plus m p)))))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  lemn:(sttfa.eps (nat.le m n)) =>
  eqp:(sttfa.eps (logic.eq nat.nat (nat.minus n m) p)) =>
  logic.eq_coerc (logic.eq nat.nat n (nat.plus (nat.minus n m) m)) 
    (logic.eq nat.nat n (nat.plus m p)) (nat.plus_minus_m_m n m lemn) 
    (logic.rewrite_r nat.nat (nat.plus m (nat.minus n m)) 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq sttfa.bool (logic.eq nat.nat n __) 
          (logic.eq nat.nat n (nat.plus m p))) 
       (logic.rewrite_r nat.nat p 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq sttfa.bool (logic.eq nat.nat n (nat.plus m __)) 
             (logic.eq nat.nat n (nat.plus m p))) 
          (logic.refl sttfa.bool (logic.eq nat.nat n (nat.plus m p))) 
          (nat.minus n m) eqp) (nat.plus (nat.minus n m) m) 
       (nat.commutative_plus (nat.minus n m) m)).

def plus_to_minus :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (p:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (logic.eq nat.nat n (nat.plus m p)) 
                (logic.eq nat.nat (nat.minus n m) p)))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  eqp:(sttfa.eps (logic.eq nat.nat n (nat.plus m p))) =>
  logic.sym_eq nat.nat p (nat.minus n m) 
    (logic.eq_coerc (logic.eq nat.nat p (nat.minus (nat.plus p m) m)) 
       (logic.eq nat.nat p (nat.minus n m)) (nat.minus_plus_m_m p m) 
       (logic.rewrite_r nat.nat (nat.plus m p) 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq sttfa.bool (logic.eq nat.nat p (nat.minus __ m)) 
             (logic.eq nat.nat p (nat.minus n m))) 
          (logic.rewrite_l nat.nat n 
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq sttfa.bool (logic.eq nat.nat p (nat.minus __ m)) 
                (logic.eq nat.nat p (nat.minus n m))) 
             (logic.refl sttfa.bool (logic.eq nat.nat p (nat.minus n m))) 
             (nat.plus m p) eqp) (nat.plus p m) (nat.commutative_plus p m))).

def monotonic_le_minus_l :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (q:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (n:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.le q p) 
                (nat.le (nat.minus q n) (nat.minus p n))))))
  :=
  nat.nat_elim2 
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     _0:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.impl (nat.le _0 __) (nat.le (nat.minus _0 n) (nat.minus __ n)))) 
    (p:(sttfa.etap (sttfa.p nat.nat)) =>
     q:(sttfa.etap (sttfa.p nat.nat)) =>
     lePO:(sttfa.eps (nat.le p nat.O)) =>
     nat.le_n_O_elim p lePO 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        nat.le (nat.minus __ q) (nat.minus nat.O q)) 
       (nat.le_n (nat.minus nat.O q))) 
    (p:(sttfa.etap (sttfa.p nat.nat)) =>
     q:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_minus (nat.S p) 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        sttfa.impl (nat.le nat.O (nat.S p)) 
          (nat.le (nat.minus nat.O q) (y q))) 
       (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
          nat.minus_body p 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           sttfa.impl (nat.le nat.O (nat.S p)) 
             (nat.le (nat.minus nat.O q) (y q))) 
          (nat.sym_eq_minus_body_S p 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              sttfa.impl (nat.le nat.O (nat.S p)) 
                (nat.le (nat.minus nat.O q) (y q))) 
             (nat.eq_plus_body_O 
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 sttfa.impl (nat.le nat.O (nat.S p)) 
                   (nat.le (nat.minus nat.O q) 
                      (y 
                         (nat.match_nat_type nat.nat (nat.S p) 
                            (q0:(sttfa.etap (sttfa.p nat.nat)) =>
                             nat.minus p q0) q)))) 
                (nat.eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat) 
                   nat.plus_body 
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                    sttfa.impl (nat.le nat.O (nat.S p)) 
                      (nat.le (nat.minus nat.O q) 
                         (y 
                            (nat.match_nat_type nat.nat (nat.S p) 
                               (q0:(sttfa.etap (sttfa.p nat.nat)) =>
                                nat.minus p q0) q)))) 
                   (nat.eq_plus nat.O 
                      (y:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       sttfa.impl (nat.le nat.O (nat.S p)) 
                         (nat.le (nat.minus nat.O q) 
                            (y 
                               (nat.match_nat_type nat.nat (nat.S p) 
                                  (q0:(sttfa.etap (sttfa.p nat.nat)) =>
                                   nat.minus p q0) q)))) 
                      (nat.eq_minus_body_O 
                         (y:
                          (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                          sttfa.impl (nat.le nat.O (nat.S p)) 
                            (nat.le (nat.minus nat.O q) 
                               (nat.plus 
                                  (y 
                                     (nat.match_nat_type nat.nat (nat.S p) 
                                        (q0:(sttfa.etap (sttfa.p nat.nat)) =>
                                         nat.minus p q0) q)) 
                                  (nat.match_nat_type nat.nat (nat.S p) 
                                     (q0:(sttfa.etap (sttfa.p nat.nat)) =>
                                      nat.minus p q0) q)))) 
                         (nat.eq_filter_nat_type_O 
                            (sttfa.arrow nat.nat nat.nat) nat.minus_body 
                            (y:
                             (sttfa.etap 
                                (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                             sttfa.impl (nat.le nat.O (nat.S p)) 
                               (nat.le (nat.minus nat.O q) 
                                  (nat.plus 
                                     (y 
                                        (nat.match_nat_type nat.nat 
                                           (nat.S p) 
                                           (q0:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            nat.minus p q0) q)) 
                                     (nat.match_nat_type nat.nat (nat.S p) 
                                        (q0:(sttfa.etap (sttfa.p nat.nat)) =>
                                         nat.minus p q0) q)))) 
                            (nat.eq_minus nat.O 
                               (y:
                                (sttfa.etap 
                                   (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                                sttfa.impl (nat.le nat.O (nat.S p)) 
                                  (nat.le (nat.minus nat.O q) 
                                     (nat.plus 
                                        (y 
                                           (nat.match_nat_type nat.nat 
                                              (nat.S p) 
                                              (q0:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               nat.minus p q0) q)) 
                                        (nat.match_nat_type nat.nat 
                                           (nat.S p) 
                                           (q0:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            nat.minus p q0) q)))) 
                               (nat.eq_minus_body_O 
                                  (y:
                                   (sttfa.etap 
                                      (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                                   sttfa.impl (nat.le nat.O (nat.S p)) 
                                     (nat.le (nat.minus nat.O q) 
                                        (nat.plus 
                                           (nat.minus (y q) 
                                              (nat.match_nat_type nat.nat 
                                                 (nat.S p) 
                                                 (q0:
                                                  (sttfa.etap 
                                                     (sttfa.p nat.nat)) =>
                                                  nat.minus p q0) q)) 
                                           (nat.match_nat_type nat.nat 
                                              (nat.S p) 
                                              (q0:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               nat.minus p q0) q)))) 
                                  (nat.eq_filter_nat_type_O 
                                     (sttfa.arrow nat.nat nat.nat) 
                                     nat.minus_body 
                                     (y:
                                      (sttfa.etap 
                                         (sttfa.p 
                                            (sttfa.arrow nat.nat nat.nat))) =>
                                      sttfa.impl (nat.le nat.O (nat.S p)) 
                                        (nat.le (nat.minus nat.O q) 
                                           (nat.plus 
                                              (nat.minus (y q) 
                                                 (nat.match_nat_type nat.nat 
                                                    (nat.S p) 
                                                    (q0:
                                                     (sttfa.etap 
                                                        (sttfa.p nat.nat)) =>
                                                     nat.minus p q0) q)) 
                                              (nat.match_nat_type nat.nat 
                                                 (nat.S p) 
                                                 (q0:
                                                  (sttfa.etap 
                                                     (sttfa.p nat.nat)) =>
                                                  nat.minus p q0) q)))) 
                                     (nat.eq_minus nat.O 
                                        (y:
                                         (sttfa.etap 
                                            (sttfa.p 
                                               (sttfa.arrow nat.nat nat.nat))) =>
                                         sttfa.impl (nat.le nat.O (nat.S p)) 
                                           (nat.le (nat.minus nat.O q) 
                                              (nat.plus 
                                                 (nat.minus (y q) 
                                                    (nat.match_nat_type 
                                                       nat.nat (nat.S p) 
                                                       (q0:
                                                        (sttfa.etap 
                                                           (sttfa.p nat.nat)) =>
                                                        nat.minus p q0) q)) 
                                                 (nat.match_nat_type nat.nat 
                                                    (nat.S p) 
                                                    (q0:
                                                     (sttfa.etap 
                                                        (sttfa.p nat.nat)) =>
                                                     nat.minus p q0) q)))) 
                                        (auto:
                                         (sttfa.eps (nat.le nat.O (nat.S p))) =>
                                         nat.le_plus_minus_m_m 
                                           (nat.minus nat.O q) 
                                           (nat.match_nat_type nat.nat 
                                              (nat.S p) 
                                              (q0:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               nat.minus p q0) q)))))))))))))) 
    (p:(sttfa.etap (sttfa.p nat.nat)) =>
     q:(sttfa.etap (sttfa.p nat.nat)) =>
     Hind:
     (sttfa.eps 
        (sttfa.forall nat.nat 
           (n0:(sttfa.etap (sttfa.p nat.nat)) =>
            sttfa.impl (nat.le q p) 
              (nat.le (nat.minus q n0) (nat.minus p n0))))) =>
     n:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.match_nat_prop 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.impl (nat.le (nat.S q) (nat.S p)) 
          (nat.le (nat.minus (nat.S q) __) (nat.minus (nat.S p) __))) 
       (nat.sym_eq_minus (nat.S q) 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           sttfa.impl (nat.le (nat.S q) (nat.S p)) 
             (nat.le (y nat.O) (nat.minus (nat.S p) nat.O))) 
          (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
             nat.minus_body q 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              sttfa.impl (nat.le (nat.S q) (nat.S p)) 
                (nat.le (y nat.O) (nat.minus (nat.S p) nat.O))) 
             (nat.sym_eq_minus_body_S q 
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 sttfa.impl (nat.le (nat.S q) (nat.S p)) 
                   (nat.le (y nat.O) (nat.minus (nat.S p) nat.O))) 
                (nat.sym_eq_match_nat_type_O nat.nat (nat.S q) 
                   (z:(sttfa.etap (sttfa.p nat.nat)) => nat.minus q z) 
                   (y:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (nat.le (nat.S q) (nat.S p)) 
                      (nat.le y (nat.minus (nat.S p) nat.O))) 
                   (nat.sym_eq_minus (nat.S p) 
                      (y:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       sttfa.impl (nat.le (nat.S q) (nat.S p)) 
                         (nat.le (nat.S q) (y nat.O))) 
                      (nat.sym_eq_filter_nat_type_S 
                         (sttfa.arrow nat.nat nat.nat) nat.minus_body p 
                         (y:
                          (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                          sttfa.impl (nat.le (nat.S q) (nat.S p)) 
                            (nat.le (nat.S q) (y nat.O))) 
                         (nat.sym_eq_minus_body_S p 
                            (y:
                             (sttfa.etap 
                                (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                             sttfa.impl (nat.le (nat.S q) (nat.S p)) 
                               (nat.le (nat.S q) (y nat.O))) 
                            (nat.sym_eq_match_nat_type_O nat.nat (nat.S p) 
                               (q0:(sttfa.etap (sttfa.p nat.nat)) =>
                                nat.minus p q0) 
                               (y:(sttfa.etap (sttfa.p nat.nat)) =>
                                sttfa.impl (nat.le (nat.S q) (nat.S p)) 
                                  (nat.le (nat.S q) y)) 
                               (auto:
                                (sttfa.eps (nat.le (nat.S q) (nat.S p))) =>
                                auto))))))))) 
       (nat.sym_eq_minus (nat.S q) 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           sttfa.forall nat.nat 
             (a:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.le (nat.S q) (nat.S p)) 
                (nat.le (y (nat.S a)) (nat.minus (nat.S p) (nat.S a))))) 
          (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat) 
             nat.minus_body q 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              sttfa.forall nat.nat 
                (a:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (nat.le (nat.S q) (nat.S p)) 
                   (nat.le (y (nat.S a)) (nat.minus (nat.S p) (nat.S a))))) 
             (nat.sym_eq_minus_body_S q 
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 sttfa.forall nat.nat 
                   (a:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (nat.le (nat.S q) (nat.S p)) 
                      (nat.le (y (nat.S a)) (nat.minus (nat.S p) (nat.S a))))) 
                (a:(sttfa.etap (sttfa.p nat.nat)) =>
                 nat.sym_eq_match_nat_type_S nat.nat (nat.S q) 
                   (z:(sttfa.etap (sttfa.p nat.nat)) => nat.minus q z) a 
                   (y:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (nat.le (nat.S q) (nat.S p)) 
                      (nat.le y (nat.minus (nat.S p) (nat.S a)))) 
                   (nat.sym_eq_minus (nat.S p) 
                      (y:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       sttfa.impl (nat.le (nat.S q) (nat.S p)) 
                         (nat.le (nat.minus q a) (y (nat.S a)))) 
                      (nat.sym_eq_filter_nat_type_S 
                         (sttfa.arrow nat.nat nat.nat) nat.minus_body p 
                         (y:
                          (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                          sttfa.impl (nat.le (nat.S q) (nat.S p)) 
                            (nat.le (nat.minus q a) (y (nat.S a)))) 
                         (nat.sym_eq_minus_body_S p 
                            (y:
                             (sttfa.etap 
                                (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                             sttfa.impl (nat.le (nat.S q) (nat.S p)) 
                               (nat.le (nat.minus q a) (y (nat.S a)))) 
                            (nat.sym_eq_match_nat_type_S nat.nat (nat.S p) 
                               (q0:(sttfa.etap (sttfa.p nat.nat)) =>
                                nat.minus p q0) a 
                               (y:(sttfa.etap (sttfa.p nat.nat)) =>
                                sttfa.impl (nat.le (nat.S q) (nat.S p)) 
                                  (nat.le (nat.minus q a) y)) 
                               (leSS:
                                (sttfa.eps (nat.le (nat.S q) (nat.S p))) =>
                                Hind a 
                                  (logic.eq_coerc 
                                     (nat.le (nat.pred (nat.S q)) 
                                        (nat.pred (nat.S p))) (nat.le q p) 
                                     (nat.monotonic_pred (nat.S q) (nat.S p) 
                                        leSS) 
                                     (logic.rewrite_l nat.nat q 
                                        (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq sttfa.bool 
                                           (nat.le __ (nat.pred (nat.S p))) 
                                           (nat.le q p)) 
                                        (logic.rewrite_l nat.nat p 
                                           (__:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq sttfa.bool 
                                              (nat.le q __) (nat.le q p)) 
                                           (logic.refl sttfa.bool 
                                              (nat.le q p)) 
                                           (nat.pred (nat.S p)) 
                                           (nat.pred_Sn p)) 
                                        (nat.pred (nat.S q)) (nat.pred_Sn q)))))))))))) 
       n).

def le_plus_to_minus :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (p:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.le n (nat.plus p m)) (nat.le (nat.minus n m) p)))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  lep:(sttfa.eps (nat.le n (nat.plus p m))) =>
  logic.eq_coerc (nat.le (nat.minus n m) (nat.minus (nat.plus p m) m)) 
    (nat.le (nat.minus n m) p) 
    (nat.monotonic_le_minus_l (nat.plus p m) n m lep) 
    (logic.rewrite_l nat.nat p 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq sttfa.bool (nat.le (nat.minus n m) __) 
          (nat.le (nat.minus n m) p)) 
       (logic.refl sttfa.bool (nat.le (nat.minus n m) p)) 
       (nat.minus (nat.plus p m) m) (nat.minus_plus_m_m p m)).

def monotonic_le_minus_r :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (p:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (q:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (n:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.le q p) 
                (nat.le (nat.minus n p) (nat.minus n q))))))
  :=
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  q:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  lepq:(sttfa.eps (nat.le q p)) =>
  nat.le_plus_to_minus n p (nat.minus n q) 
    (nat.transitive_le n (nat.plus (nat.minus n q) q) 
       (nat.plus (nat.minus n q) p) (nat.le_plus_minus_m_m n q) 
       (nat.monotonic_le_plus_r (nat.minus n q) q p lepq)).

def minus_le :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (x:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (y:(sttfa.etap (sttfa.p nat.nat)) => nat.le (nat.minus x y) x)))
  :=
  x:(sttfa.etap (sttfa.p nat.nat)) =>
  y:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.eq_coerc (nat.le (nat.minus x y) (nat.minus (nat.plus x y) y)) 
    (nat.le (nat.minus x y) x) 
    (nat.monotonic_le_minus_l (nat.plus x y) x y (nat.le_plus_n_r y x)) 
    (logic.rewrite_l nat.nat x 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq sttfa.bool (nat.le (nat.minus x y) __) 
          (nat.le (nat.minus x y) x)) 
       (logic.refl sttfa.bool (nat.le (nat.minus x y) x)) 
       (nat.minus (nat.plus x y) y) (nat.minus_plus_m_m x y)).

def not_eq_to_le_to_lt :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (connectives.Not (logic.eq nat.nat n m)) 
             (sttfa.impl (nat.le n m) (nat.lt n m)))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  Hneq:(sttfa.eps (connectives.Not (logic.eq nat.nat n m))) =>
  Hle:(sttfa.eps (nat.le n m)) =>
  logic.match_Or_prop (nat.lt n m) (logic.eq nat.nat n m) (nat.lt n m) 
    (auto:(sttfa.eps (nat.lt n m)) => auto) 
    (Heq:(sttfa.eps (logic.eq nat.nat n m)) =>
     nat.not_le_to_lt m n 
       (logic.not_to_not (nat.le m n) (logic.eq nat.nat n m) 
          (auto:(sttfa.eps (nat.le m n)) =>
           logic.rewrite_l nat.nat n 
             (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat n __) 
             (logic.refl nat.nat n) m Heq) Hneq)) 
    (nat.le_to_or_lt_eq n m Hle).

def eq_minus_O :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.le n m) (logic.eq nat.nat (nat.minus n m) nat.O))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  lenm:(sttfa.eps (nat.le n m)) =>
  nat.le_n_O_elim (nat.minus n m) 
    (logic.eq_coerc (nat.le (nat.minus n m) (nat.minus n n)) 
       (nat.le (nat.minus n m) nat.O) (nat.monotonic_le_minus_r m n n lenm) 
       (logic.rewrite_l nat.nat nat.O 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq sttfa.bool (nat.le (nat.minus n m) __) 
             (nat.le (nat.minus n m) nat.O)) 
          (logic.refl sttfa.bool (nat.le (nat.minus n m) nat.O)) 
          (nat.minus n n) (nat.minus_n_n n))) 
    (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat __ nat.O) 
    (logic.refl nat.nat nat.O).

def distributive_times_minus :
  sttfa.eps (relations.distributive nat.nat nat.times nat.minus)
  :=
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  c:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.match_Or_prop (nat.lt b c) (connectives.Not (nat.lt b c)) 
    (logic.eq nat.nat (nat.times a (nat.minus b c)) 
       (nat.minus (nat.times a b) (nat.times a c))) 
    (Hbc:(sttfa.eps (nat.lt b c)) =>
     logic.eq_ind_r nat.nat nat.O 
       (x:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat (nat.times a x) 
          (nat.minus (nat.times a b) (nat.times a c))) 
       (logic.eq_ind_r nat.nat nat.O 
          (x:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat (nat.times a nat.O) x) 
          (logic.rewrite_l nat.nat nat.O 
             (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat __ nat.O) 
             (logic.refl nat.nat nat.O) (nat.times a nat.O) (nat.times_n_O a)) 
          (nat.minus (nat.times a b) (nat.times a c)) 
          (nat.eq_minus_O (nat.times a b) (nat.times a c) 
             (nat.monotonic_le_times_r a b c (nat.lt_to_le b c Hbc)))) 
       (nat.minus b c) (nat.eq_minus_O b c (nat.lt_to_le b c Hbc))) 
    (Hbc:(sttfa.eps (connectives.Not (nat.lt b c))) =>
     logic.sym_eq nat.nat (nat.minus (nat.times a b) (nat.times a c)) 
       (nat.times a (nat.minus b c)) 
       (logic.eq_coerc 
          (logic.eq nat.nat (nat.minus (nat.times a b) (nat.times a c)) 
             (nat.times a (nat.minus b c))) 
          (logic.eq nat.nat (nat.minus (nat.times a b) (nat.times a c)) 
             (nat.times a (nat.minus b c))) 
          (nat.plus_to_minus (nat.times a b) (nat.times a c) 
             (nat.times a (nat.minus b c)) 
             (logic.eq_ind nat.nat 
                (nat.times a (nat.plus c (nat.minus b c))) 
                (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat (nat.times a b) x_1) 
                (logic.eq_f nat.nat nat.nat (nat.times a) b 
                   (nat.plus c (nat.minus b c)) 
                   (logic.eq_coerc 
                      (logic.eq nat.nat b (nat.plus (nat.minus b c) c)) 
                      (logic.eq nat.nat b (nat.plus c (nat.minus b c))) 
                      (nat.plus_minus_m_m b c (nat.not_lt_to_le b c Hbc)) 
                      (logic.rewrite_r nat.nat (nat.plus c (nat.minus b c)) 
                         (__:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq sttfa.bool (logic.eq nat.nat b __) 
                            (logic.eq nat.nat b (nat.plus c (nat.minus b c)))) 
                         (logic.refl sttfa.bool 
                            (logic.eq nat.nat b (nat.plus c (nat.minus b c)))) 
                         (nat.plus (nat.minus b c) c) 
                         (nat.commutative_plus (nat.minus b c) c)))) 
                (nat.plus (nat.times a c) (nat.times a (nat.minus b c))) 
                (nat.distributive_times_plus a c (nat.minus b c)))) 
          (logic.refl sttfa.bool 
             (logic.eq nat.nat (nat.minus (nat.times a b) (nat.times a c)) 
                (nat.times a (nat.minus b c)))))) (nat.decidable_lt b c).

def minus_plus :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (p:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat (nat.minus (nat.minus n m) p) 
                (nat.minus n (nat.plus m p))))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.match_Or_prop (nat.le (nat.plus m p) n) 
    (connectives.Not (nat.le (nat.plus m p) n)) 
    (logic.eq nat.nat (nat.minus (nat.minus n m) p) 
       (nat.minus n (nat.plus m p))) 
    (Hlt:(sttfa.eps (nat.le (nat.plus m p) n)) =>
     nat.plus_to_minus (nat.minus n m) p (nat.minus n (nat.plus m p)) 
       (nat.plus_to_minus n m (nat.plus p (nat.minus n (nat.plus m p))) 
          (logic.eq_ind nat.nat 
             (nat.plus (nat.plus m p) (nat.minus n (nat.plus m p))) 
             (x_1:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat n x_1) 
             (nat.minus_to_plus n (nat.plus m p) 
                (nat.minus n (nat.plus m p)) Hlt 
                (logic.refl nat.nat (nat.minus n (nat.plus m p)))) 
             (nat.plus m (nat.plus p (nat.minus n (nat.plus m p)))) 
             (nat.associative_plus m p (nat.minus n (nat.plus m p)))))) 
    (Hlt:(sttfa.eps (connectives.Not (nat.le (nat.plus m p) n))) =>
     logic.eq_ind_r nat.nat nat.O 
       (x:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat x (nat.minus n (nat.plus m p))) 
       (logic.sym_eq nat.nat (nat.minus n (nat.plus m p)) nat.O 
          (logic.eq_coerc 
             (logic.eq nat.nat (nat.minus n (nat.plus m p)) nat.O) 
             (logic.eq nat.nat (nat.minus n (nat.plus m p)) nat.O) 
             (nat.eq_minus_O n (nat.plus m p) 
                (nat.transitive_le n (nat.S n) (nat.plus m p) 
                   (nat.le_n_Sn n) (nat.not_le_to_lt (nat.plus m p) n Hlt))) 
             (logic.refl sttfa.bool 
                (logic.eq nat.nat (nat.minus n (nat.plus m p)) nat.O)))) 
       (nat.minus (nat.minus n m) p) 
       (nat.eq_minus_O (nat.minus n m) p 
          (logic.eq_coerc 
             (nat.le (nat.minus n m) (nat.minus (nat.plus p m) m)) 
             (nat.le (nat.minus n m) p) 
             (nat.monotonic_le_minus_l (nat.plus p m) n m 
                (logic.eq_coerc (nat.le n (nat.plus m p)) 
                   (nat.le n (nat.plus p m)) 
                   (nat.transitive_le n (nat.S n) (nat.plus m p) 
                      (nat.le_n_Sn n) (nat.not_le_to_lt (nat.plus m p) n Hlt)) 
                   (logic.rewrite_r nat.nat (nat.plus m p) 
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq sttfa.bool (nat.le n (nat.plus m p)) 
                         (nat.le n __)) 
                      (logic.refl sttfa.bool (nat.le n (nat.plus m p))) 
                      (nat.plus p m) (nat.commutative_plus p m)))) 
             (logic.rewrite_l nat.nat p 
                (__:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq sttfa.bool (nat.le (nat.minus n m) __) 
                   (nat.le (nat.minus n m) p)) 
                (logic.refl sttfa.bool (nat.le (nat.minus n m) p)) 
                (nat.minus (nat.plus p m) m) (nat.minus_plus_m_m p m))))) 
    (nat.decidable_le (nat.plus m p) n).

def minus_minus :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (p:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.le p m) 
                (sttfa.impl (nat.le m n) 
                   (logic.eq nat.nat (nat.plus p (nat.minus n m)) 
                      (nat.minus n (nat.minus m p))))))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  p:(sttfa.etap (sttfa.p nat.nat)) =>
  lepm:(sttfa.eps (nat.le p m)) =>
  lemn:(sttfa.eps (nat.le m n)) =>
  logic.sym_eq nat.nat (nat.minus n (nat.minus m p)) 
    (nat.plus p (nat.minus n m)) 
    (nat.plus_to_minus n (nat.minus m p) (nat.plus p (nat.minus n m)) 
       (logic.eq_ind nat.nat 
          (nat.plus (nat.plus (nat.minus m p) p) (nat.minus n m)) 
          (x_1:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat n x_1) 
          (logic.eq_ind nat.nat m 
             (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat n (nat.plus x_1 (nat.minus n m))) 
             (logic.eq_ind nat.nat (nat.plus (nat.minus n m) m) 
                (x_1:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat n x_1) 
                (logic.eq_ind nat.nat n 
                   (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat n x_1) (logic.refl nat.nat n) 
                   (nat.plus (nat.minus n m) m) (nat.plus_minus_m_m n m lemn)) 
                (nat.plus m (nat.minus n m)) 
                (nat.commutative_plus (nat.minus n m) m)) 
             (nat.plus (nat.minus m p) p) (nat.plus_minus_m_m m p lepm)) 
          (nat.plus (nat.minus m p) (nat.plus p (nat.minus n m))) 
          (nat.associative_plus (nat.minus m p) p (nat.minus n m)))).

def minus_minus_comm :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (a:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (b:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (c:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat (nat.minus (nat.minus a b) c) 
                (nat.minus (nat.minus a c) b)))))
  :=
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  c:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.le_to_le_to_eq (nat.minus (nat.minus a b) c) 
    (nat.minus (nat.minus a c) b) 
    (logic.eq_coerc 
       (nat.le (nat.minus (nat.minus a b) c) 
          (nat.minus (nat.plus (nat.minus (nat.minus a c) b) c) c)) 
       (nat.le (nat.minus (nat.minus a b) c) (nat.minus (nat.minus a c) b)) 
       (nat.monotonic_le_minus_l (nat.plus (nat.minus (nat.minus a c) b) c) 
          (nat.minus a b) c 
          (logic.eq_coerc 
             (nat.le (nat.minus a b) 
                (nat.plus (nat.minus (nat.minus a b) c) c)) 
             (nat.le (nat.minus a b) 
                (nat.plus (nat.minus (nat.minus a c) b) c)) 
             (nat.le_plus_minus_m_m (nat.minus a b) c) 
             (logic.rewrite_r nat.nat (nat.minus a (nat.plus b c)) 
                (__:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq sttfa.bool 
                   (nat.le (nat.minus a b) (nat.plus __ c)) 
                   (nat.le (nat.minus a b) 
                      (nat.plus (nat.minus (nat.minus a c) b) c))) 
                (logic.rewrite_r nat.nat 
                   (nat.plus c (nat.minus a (nat.plus b c))) 
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq sttfa.bool (nat.le (nat.minus a b) __) 
                      (nat.le (nat.minus a b) 
                         (nat.plus (nat.minus (nat.minus a c) b) c))) 
                   (logic.rewrite_r nat.nat 
                      (nat.plus c (nat.minus (nat.minus a c) b)) 
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq sttfa.bool 
                         (nat.le (nat.minus a b) 
                            (nat.plus c (nat.minus a (nat.plus b c)))) 
                         (nat.le (nat.minus a b) __)) 
                      (logic.rewrite_l nat.nat (nat.minus (nat.minus a c) b) 
                         (__:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq sttfa.bool 
                            (nat.le (nat.minus a b) (nat.plus c __)) 
                            (nat.le (nat.minus a b) 
                               (nat.plus c (nat.minus (nat.minus a c) b)))) 
                         (logic.refl sttfa.bool 
                            (nat.le (nat.minus a b) 
                               (nat.plus c (nat.minus (nat.minus a c) b)))) 
                         (nat.minus a (nat.plus b c)) 
                         (logic.rewrite_l nat.nat (nat.plus c b) 
                            (__:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq nat.nat (nat.minus (nat.minus a c) b) 
                               (nat.minus a __)) (nat.minus_plus a c b) 
                            (nat.plus b c) (nat.commutative_plus c b))) 
                      (nat.plus (nat.minus (nat.minus a c) b) c) 
                      (nat.commutative_plus (nat.minus (nat.minus a c) b) c)) 
                   (nat.plus (nat.minus a (nat.plus b c)) c) 
                   (nat.commutative_plus (nat.minus a (nat.plus b c)) c)) 
                (nat.minus (nat.minus a b) c) (nat.minus_plus a b c)))) 
       (logic.rewrite_l nat.nat (nat.minus (nat.minus a c) b) 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq sttfa.bool (nat.le (nat.minus (nat.minus a b) c) __) 
             (nat.le (nat.minus (nat.minus a b) c) 
                (nat.minus (nat.minus a c) b))) 
          (logic.refl sttfa.bool 
             (nat.le (nat.minus (nat.minus a b) c) 
                (nat.minus (nat.minus a c) b))) 
          (nat.minus (nat.plus (nat.minus (nat.minus a c) b) c) c) 
          (nat.minus_plus_m_m (nat.minus (nat.minus a c) b) c))) 
    (logic.eq_coerc 
       (nat.le (nat.minus (nat.minus a c) b) 
          (nat.minus (nat.plus (nat.minus (nat.minus a b) c) b) b)) 
       (nat.le (nat.minus (nat.minus a c) b) (nat.minus (nat.minus a b) c)) 
       (nat.monotonic_le_minus_l (nat.plus (nat.minus (nat.minus a b) c) b) 
          (nat.minus a c) b 
          (logic.eq_coerc 
             (nat.le (nat.minus a c) 
                (nat.plus (nat.minus (nat.minus a c) b) b)) 
             (nat.le (nat.minus a c) 
                (nat.plus (nat.minus (nat.minus a b) c) b)) 
             (nat.le_plus_minus_m_m (nat.minus a c) b) 
             (logic.rewrite_r nat.nat (nat.minus a (nat.plus c b)) 
                (__:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq sttfa.bool 
                   (nat.le (nat.minus a c) (nat.plus __ b)) 
                   (nat.le (nat.minus a c) 
                      (nat.plus (nat.minus (nat.minus a b) c) b))) 
                (logic.rewrite_r nat.nat 
                   (nat.plus b (nat.minus a (nat.plus c b))) 
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq sttfa.bool (nat.le (nat.minus a c) __) 
                      (nat.le (nat.minus a c) 
                         (nat.plus (nat.minus (nat.minus a b) c) b))) 
                   (logic.rewrite_r nat.nat 
                      (nat.plus b (nat.minus (nat.minus a b) c)) 
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq sttfa.bool 
                         (nat.le (nat.minus a c) 
                            (nat.plus b (nat.minus a (nat.plus c b)))) 
                         (nat.le (nat.minus a c) __)) 
                      (logic.rewrite_l nat.nat (nat.minus (nat.minus a b) c) 
                         (__:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq sttfa.bool 
                            (nat.le (nat.minus a c) (nat.plus b __)) 
                            (nat.le (nat.minus a c) 
                               (nat.plus b (nat.minus (nat.minus a b) c)))) 
                         (logic.refl sttfa.bool 
                            (nat.le (nat.minus a c) 
                               (nat.plus b (nat.minus (nat.minus a b) c)))) 
                         (nat.minus a (nat.plus c b)) 
                         (logic.rewrite_l nat.nat (nat.plus b c) 
                            (__:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq nat.nat (nat.minus (nat.minus a b) c) 
                               (nat.minus a __)) (nat.minus_plus a b c) 
                            (nat.plus c b) (nat.commutative_plus b c))) 
                      (nat.plus (nat.minus (nat.minus a b) c) b) 
                      (nat.commutative_plus (nat.minus (nat.minus a b) c) b)) 
                   (nat.plus (nat.minus a (nat.plus c b)) b) 
                   (nat.commutative_plus (nat.minus a (nat.plus c b)) b)) 
                (nat.minus (nat.minus a c) b) (nat.minus_plus a c b)))) 
       (logic.rewrite_l nat.nat (nat.minus (nat.minus a b) c) 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq sttfa.bool (nat.le (nat.minus (nat.minus a c) b) __) 
             (nat.le (nat.minus (nat.minus a c) b) 
                (nat.minus (nat.minus a b) c))) 
          (logic.refl sttfa.bool 
             (nat.le (nat.minus (nat.minus a c) b) 
                (nat.minus (nat.minus a b) c))) 
          (nat.minus (nat.plus (nat.minus (nat.minus a b) c) b) b) 
          (nat.minus_plus_m_m (nat.minus (nat.minus a b) c) b))).

def minus_le_minus_minus_comm :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (b:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (c:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (a:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.impl (nat.le c b) 
                (logic.eq nat.nat (nat.minus a (nat.minus b c)) 
                   (nat.minus (nat.plus a c) b))))))
  :=
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  c:(sttfa.etap (sttfa.p nat.nat)) =>
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  H:(sttfa.eps (nat.le c b)) =>
  logic.eq_ind_r nat.nat (nat.plus (nat.minus b c) c) 
    (x:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq nat.nat (nat.minus a (nat.minus b c)) 
       (nat.minus (nat.plus a c) x)) 
    (logic.rewrite_r nat.nat (nat.plus c a) 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat (nat.minus a (nat.minus b c)) 
          (nat.minus __ (nat.plus (nat.minus b c) c))) 
       (logic.rewrite_r nat.nat (nat.plus c (nat.minus b c)) 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat (nat.minus a (nat.minus b c)) 
             (nat.minus (nat.plus c a) __)) 
          (logic.rewrite_l nat.nat 
             (nat.minus (nat.minus (nat.plus c a) c) (nat.minus b c)) 
             (__:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat (nat.minus a (nat.minus b c)) __) 
             (logic.rewrite_r nat.nat (nat.minus (nat.plus c a) c) 
                (__:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat (nat.minus __ (nat.minus b c)) 
                   (nat.minus (nat.minus (nat.plus c a) c) (nat.minus b c))) 
                (logic.refl nat.nat 
                   (nat.minus (nat.minus (nat.plus c a) c) (nat.minus b c))) 
                a 
                (logic.rewrite_l nat.nat (nat.plus a c) 
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat a (nat.minus __ c)) 
                   (nat.minus_plus_m_m a c) (nat.plus c a) 
                   (nat.commutative_plus a c))) 
             (nat.minus (nat.plus c a) (nat.plus c (nat.minus b c))) 
             (nat.minus_plus (nat.plus c a) c (nat.minus b c))) 
          (nat.plus (nat.minus b c) c) 
          (nat.commutative_plus (nat.minus b c) c)) (nat.plus a c) 
       (nat.commutative_plus a c)) b (nat.plus_minus_m_m b c H).

def minus_plus_plus_l :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (x:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (y:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat 
             (h:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat (nat.minus (nat.plus x h) (nat.plus y h)) 
                (nat.minus x y)))))
  :=
  x:(sttfa.etap (sttfa.p nat.nat)) =>
  y:(sttfa.etap (sttfa.p nat.nat)) =>
  h:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.rewrite_l nat.nat (nat.minus (nat.minus (nat.plus x h) y) h) 
    (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat __ (nat.minus x y)) 
    (logic.rewrite_r nat.nat (nat.minus x y) 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq nat.nat __ (nat.minus x y)) 
       (logic.refl nat.nat (nat.minus x y)) 
       (nat.minus (nat.minus (nat.plus x h) y) h) 
       (logic.rewrite_r nat.nat (nat.minus (nat.plus x h) h) 
          (__:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat (nat.minus (nat.minus (nat.plus x h) y) h) 
             (nat.minus __ y)) (nat.minus_minus_comm (nat.plus x h) y h) x 
          (nat.minus_plus_m_m x h))) 
    (nat.minus (nat.plus x h) (nat.plus y h)) 
    (nat.minus_plus (nat.plus x h) y h).

eqb :
  sttfa.etap (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat bool.bool))).

eqb_body :
  sttfa.etap (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat bool.bool))).

eq_eqb :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat bool.bool) (nat.eqb n) 
          (nat.filter_nat_type (sttfa.arrow nat.nat bool.bool) nat.eqb_body n))).

def sym_eq_eqb :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat bool.bool) 
          (nat.filter_nat_type (sttfa.arrow nat.nat bool.bool) nat.eqb_body n) 
          (nat.eqb n)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  sttfa.sym_leibniz (sttfa.arrow nat.nat bool.bool) (nat.eqb n) 
    (nat.filter_nat_type (sttfa.arrow nat.nat bool.bool) nat.eqb_body n) 
    (nat.eq_eqb n).

eq_eqb_body_O :
  sttfa.eps 
    (sttfa.leibniz (sttfa.arrow nat.nat bool.bool) (nat.eqb_body nat.O) 
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        nat.match_nat_type bool.bool bool.true 
          (q:(sttfa.etap (sttfa.p nat.nat)) => bool.false) m)).

def sym_eq_eqb_body_O :
  sttfa.eps 
    (sttfa.leibniz (sttfa.arrow nat.nat bool.bool) 
       (m:(sttfa.etap (sttfa.p nat.nat)) =>
        nat.match_nat_type bool.bool bool.true 
          (q:(sttfa.etap (sttfa.p nat.nat)) => bool.false) m) 
       (nat.eqb_body nat.O))
  :=
  sttfa.sym_leibniz (sttfa.arrow nat.nat bool.bool) (nat.eqb_body nat.O) 
    (m:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.match_nat_type bool.bool bool.true 
       (q:(sttfa.etap (sttfa.p nat.nat)) => bool.false) m) nat.eq_eqb_body_O.

eq_eqb_body_S :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat bool.bool) 
          (nat.eqb_body (nat.S n)) 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           nat.match_nat_type bool.bool bool.false 
             (q:(sttfa.etap (sttfa.p nat.nat)) => nat.eqb n q) m))).

def sym_eq_eqb_body_S :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat bool.bool) 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           nat.match_nat_type bool.bool bool.false 
             (q:(sttfa.etap (sttfa.p nat.nat)) => nat.eqb n q) m) 
          (nat.eqb_body (nat.S n))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  sttfa.sym_leibniz (sttfa.arrow nat.nat bool.bool) (nat.eqb_body (nat.S n)) 
    (m:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.match_nat_type bool.bool bool.false 
       (q:(sttfa.etap (sttfa.p nat.nat)) => nat.eqb n q) m) 
    (nat.eq_eqb_body_S n).

def eqb_elim :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
             (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
              sttfa.impl (sttfa.impl (logic.eq nat.nat n m) (P bool.true)) 
                (sttfa.impl 
                   (sttfa.impl (connectives.Not (logic.eq nat.nat n m)) 
                      (P bool.false)) (P (nat.eqb n m)))))))
  :=
  nat.nat_elim2 
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     _0:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
       (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
        sttfa.impl (sttfa.impl (logic.eq nat.nat __ _0) (P bool.true)) 
          (sttfa.impl 
             (sttfa.impl (connectives.Not (logic.eq nat.nat __ _0)) 
                (P bool.false)) (P (nat.eqb __ _0))))) 
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.match_nat_prop 
       (__:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
          (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
           sttfa.impl (sttfa.impl (logic.eq nat.nat nat.O __) (P bool.true)) 
             (sttfa.impl 
                (sttfa.impl (connectives.Not (logic.eq nat.nat nat.O __)) 
                   (P bool.false)) (P (nat.eqb nat.O __))))) 
       (nat.sym_eq_eqb nat.O 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
           sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
             (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
              sttfa.impl 
                (sttfa.impl (logic.eq nat.nat nat.O nat.O) (P bool.true)) 
                (sttfa.impl 
                   (sttfa.impl 
                      (connectives.Not (logic.eq nat.nat nat.O nat.O)) 
                      (P bool.false)) (P (y nat.O))))) 
          (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat bool.bool) 
             nat.eqb_body 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
              sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
                (P:
                 (sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                 sttfa.impl 
                   (sttfa.impl (logic.eq nat.nat nat.O nat.O) (P bool.true)) 
                   (sttfa.impl 
                      (sttfa.impl 
                         (connectives.Not (logic.eq nat.nat nat.O nat.O)) 
                         (P bool.false)) (P (y nat.O))))) 
             (nat.sym_eq_eqb_body_O 
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
                 sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
                   (P:
                    (sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                    sttfa.impl 
                      (sttfa.impl (logic.eq nat.nat nat.O nat.O) 
                         (P bool.true)) 
                      (sttfa.impl 
                         (sttfa.impl 
                            (connectives.Not (logic.eq nat.nat nat.O nat.O)) 
                            (P bool.false)) (P (y nat.O))))) 
                (nat.sym_eq_match_nat_type_O bool.bool bool.true 
                   (q:(sttfa.etap (sttfa.p nat.nat)) => bool.false) 
                   (y:(sttfa.etap (sttfa.p bool.bool)) =>
                    sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
                      (P:
                       (sttfa.etap 
                          (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                       sttfa.impl 
                         (sttfa.impl (logic.eq nat.nat nat.O nat.O) 
                            (P bool.true)) 
                         (sttfa.impl 
                            (sttfa.impl 
                               (connectives.Not 
                                  (logic.eq nat.nat nat.O nat.O)) 
                               (P bool.false)) (P y)))) 
                   (P:
                    (sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                    auto:
                    (sttfa.eps 
                       (sttfa.impl (logic.eq nat.nat nat.O nat.O) 
                          (P bool.true))) =>
                    auto':
                    (sttfa.eps 
                       (sttfa.impl 
                          (connectives.Not (logic.eq nat.nat nat.O nat.O)) 
                          (P bool.false))) =>
                    auto (logic.refl nat.nat nat.O)))))) 
       (auto:(sttfa.etap (sttfa.p nat.nat)) =>
        nat.sym_eq_eqb nat.O 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
           sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
             (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
              sttfa.impl 
                (sttfa.impl (logic.eq nat.nat nat.O (nat.S auto)) 
                   (P bool.true)) 
                (sttfa.impl 
                   (sttfa.impl 
                      (connectives.Not (logic.eq nat.nat nat.O (nat.S auto))) 
                      (P bool.false)) (P (y (nat.S auto)))))) 
          (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat bool.bool) 
             nat.eqb_body 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
              sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
                (P:
                 (sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                 sttfa.impl 
                   (sttfa.impl (logic.eq nat.nat nat.O (nat.S auto)) 
                      (P bool.true)) 
                   (sttfa.impl 
                      (sttfa.impl 
                         (connectives.Not 
                            (logic.eq nat.nat nat.O (nat.S auto))) 
                         (P bool.false)) (P (y (nat.S auto)))))) 
             (nat.sym_eq_eqb_body_O 
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
                 sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
                   (P:
                    (sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                    sttfa.impl 
                      (sttfa.impl (logic.eq nat.nat nat.O (nat.S auto)) 
                         (P bool.true)) 
                      (sttfa.impl 
                         (sttfa.impl 
                            (connectives.Not 
                               (logic.eq nat.nat nat.O (nat.S auto))) 
                            (P bool.false)) (P (y (nat.S auto)))))) 
                (nat.sym_eq_match_nat_type_S bool.bool bool.true 
                   (q:(sttfa.etap (sttfa.p nat.nat)) => bool.false) auto 
                   (y:(sttfa.etap (sttfa.p bool.bool)) =>
                    sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
                      (P:
                       (sttfa.etap 
                          (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                       sttfa.impl 
                         (sttfa.impl (logic.eq nat.nat nat.O (nat.S auto)) 
                            (P bool.true)) 
                         (sttfa.impl 
                            (sttfa.impl 
                               (connectives.Not 
                                  (logic.eq nat.nat nat.O (nat.S auto))) 
                               (P bool.false)) (P y)))) 
                   (P:
                    (sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                    auto':
                    (sttfa.eps 
                       (sttfa.impl (logic.eq nat.nat nat.O (nat.S auto)) 
                          (P bool.true))) =>
                    auto'':
                    (sttfa.eps 
                       (sttfa.impl 
                          (connectives.Not 
                             (logic.eq nat.nat nat.O (nat.S auto))) 
                          (P bool.false))) =>
                    auto'' (nat.not_eq_O_S auto)))))) n) 
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_eqb (nat.S n) 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
        sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
          (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
           sttfa.impl 
             (sttfa.impl (logic.eq nat.nat (nat.S n) nat.O) (P bool.true)) 
             (sttfa.impl 
                (sttfa.impl 
                   (connectives.Not (logic.eq nat.nat (nat.S n) nat.O)) 
                   (P bool.false)) (P (y nat.O))))) 
       (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat bool.bool) 
          nat.eqb_body n 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
           sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
             (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
              sttfa.impl 
                (sttfa.impl (logic.eq nat.nat (nat.S n) nat.O) (P bool.true)) 
                (sttfa.impl 
                   (sttfa.impl 
                      (connectives.Not (logic.eq nat.nat (nat.S n) nat.O)) 
                      (P bool.false)) (P (y nat.O))))) 
          (nat.sym_eq_eqb_body_S n 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
              sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
                (P:
                 (sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                 sttfa.impl 
                   (sttfa.impl (logic.eq nat.nat (nat.S n) nat.O) 
                      (P bool.true)) 
                   (sttfa.impl 
                      (sttfa.impl 
                         (connectives.Not (logic.eq nat.nat (nat.S n) nat.O)) 
                         (P bool.false)) (P (y nat.O))))) 
             (nat.sym_eq_match_nat_type_O bool.bool bool.false 
                (q:(sttfa.etap (sttfa.p nat.nat)) => nat.eqb n q) 
                (y:(sttfa.etap (sttfa.p bool.bool)) =>
                 sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
                   (P:
                    (sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                    sttfa.impl 
                      (sttfa.impl (logic.eq nat.nat (nat.S n) nat.O) 
                         (P bool.true)) 
                      (sttfa.impl 
                         (sttfa.impl 
                            (connectives.Not 
                               (logic.eq nat.nat (nat.S n) nat.O)) 
                            (P bool.false)) (P y)))) 
                (P:
                 (sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                 auto:
                 (sttfa.eps 
                    (sttfa.impl (logic.eq nat.nat (nat.S n) nat.O) 
                       (P bool.true))) =>
                 auto':
                 (sttfa.eps 
                    (sttfa.impl 
                       (connectives.Not (logic.eq nat.nat (nat.S n) nat.O)) 
                       (P bool.false))) =>
                 auto' 
                   (logic.sym_not_eq nat.nat nat.O (nat.S n) 
                      (nat.not_eq_O_S n))))))) 
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     m:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_eqb (nat.S n) 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
        sttfa.impl 
          (sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
             (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
              sttfa.impl (sttfa.impl (logic.eq nat.nat n m) (P bool.true)) 
                (sttfa.impl 
                   (sttfa.impl (connectives.Not (logic.eq nat.nat n m)) 
                      (P bool.false)) (P (nat.eqb n m))))) 
          (sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
             (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
              sttfa.impl 
                (sttfa.impl (logic.eq nat.nat (nat.S n) (nat.S m)) 
                   (P bool.true)) 
                (sttfa.impl 
                   (sttfa.impl 
                      (connectives.Not (logic.eq nat.nat (nat.S n) (nat.S m))) 
                      (P bool.false)) (P (y (nat.S m))))))) 
       (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat bool.bool) 
          nat.eqb_body n 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
           sttfa.impl 
             (sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
                (P:
                 (sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                 sttfa.impl 
                   (sttfa.impl (logic.eq nat.nat n m) (P bool.true)) 
                   (sttfa.impl 
                      (sttfa.impl (connectives.Not (logic.eq nat.nat n m)) 
                         (P bool.false)) (P (nat.eqb n m))))) 
             (sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
                (P:
                 (sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                 sttfa.impl 
                   (sttfa.impl (logic.eq nat.nat (nat.S n) (nat.S m)) 
                      (P bool.true)) 
                   (sttfa.impl 
                      (sttfa.impl 
                         (connectives.Not 
                            (logic.eq nat.nat (nat.S n) (nat.S m))) 
                         (P bool.false)) (P (y (nat.S m))))))) 
          (nat.sym_eq_eqb_body_S n 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
              sttfa.impl 
                (sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
                   (P:
                    (sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                    sttfa.impl 
                      (sttfa.impl (logic.eq nat.nat n m) (P bool.true)) 
                      (sttfa.impl 
                         (sttfa.impl 
                            (connectives.Not (logic.eq nat.nat n m)) 
                            (P bool.false)) (P (nat.eqb n m))))) 
                (sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
                   (P:
                    (sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                    sttfa.impl 
                      (sttfa.impl (logic.eq nat.nat (nat.S n) (nat.S m)) 
                         (P bool.true)) 
                      (sttfa.impl 
                         (sttfa.impl 
                            (connectives.Not 
                               (logic.eq nat.nat (nat.S n) (nat.S m))) 
                            (P bool.false)) (P (y (nat.S m))))))) 
             (nat.sym_eq_match_nat_type_S bool.bool bool.false 
                (q:(sttfa.etap (sttfa.p nat.nat)) => nat.eqb n q) m 
                (y:(sttfa.etap (sttfa.p bool.bool)) =>
                 sttfa.impl 
                   (sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
                      (P:
                       (sttfa.etap 
                          (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                       sttfa.impl 
                         (sttfa.impl (logic.eq nat.nat n m) (P bool.true)) 
                         (sttfa.impl 
                            (sttfa.impl 
                               (connectives.Not (logic.eq nat.nat n m)) 
                               (P bool.false)) (P (nat.eqb n m))))) 
                   (sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
                      (P:
                       (sttfa.etap 
                          (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                       sttfa.impl 
                         (sttfa.impl (logic.eq nat.nat (nat.S n) (nat.S m)) 
                            (P bool.true)) 
                         (sttfa.impl 
                            (sttfa.impl 
                               (connectives.Not 
                                  (logic.eq nat.nat (nat.S n) (nat.S m))) 
                               (P bool.false)) (P y))))) 
                (auto:
                 (sttfa.eps 
                    (sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
                       (P:
                        (sttfa.etap 
                           (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                        sttfa.impl 
                          (sttfa.impl (logic.eq nat.nat n m) (P bool.true)) 
                          (sttfa.impl 
                             (sttfa.impl 
                                (connectives.Not (logic.eq nat.nat n m)) 
                                (P bool.false)) (P (nat.eqb n m)))))) =>
                 P:
                 (sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                 auto':
                 (sttfa.eps 
                    (sttfa.impl (logic.eq nat.nat (nat.S n) (nat.S m)) 
                       (P bool.true))) =>
                 auto'':
                 (sttfa.eps 
                    (sttfa.impl 
                       (connectives.Not 
                          (logic.eq nat.nat (nat.S n) (nat.S m))) 
                       (P bool.false))) =>
                 auto P 
                   (auto''':(sttfa.eps (logic.eq nat.nat n m)) =>
                    auto' 
                      (logic.rewrite_l nat.nat n 
                         (__:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat (nat.S n) (nat.S __)) 
                         (logic.refl nat.nat (nat.S n)) m auto''')) 
                   (auto''':
                    (sttfa.eps (connectives.Not (logic.eq nat.nat n m))) =>
                    auto'' (nat.not_eq_S n m auto'''))))))).

def eqb_n_n :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        logic.eq bool.bool (nat.eqb n n) bool.true))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind 
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq bool.bool (nat.eqb _x_365 _x_365) bool.true) 
    (nat.sym_eq_eqb nat.O 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
        logic.eq bool.bool (y nat.O) bool.true) 
       (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat bool.bool) 
          nat.eqb_body 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
           logic.eq bool.bool (y nat.O) bool.true) 
          (nat.sym_eq_eqb_body_O 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
              logic.eq bool.bool (y nat.O) bool.true) 
             (nat.sym_eq_match_nat_type_O bool.bool bool.true 
                (q:(sttfa.etap (sttfa.p nat.nat)) => bool.false) 
                (y:(sttfa.etap (sttfa.p bool.bool)) =>
                 logic.eq bool.bool y bool.true) 
                (logic.refl bool.bool bool.true))))) 
    (x_366:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_eqb (nat.S x_366) 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
        sttfa.impl (logic.eq bool.bool (nat.eqb x_366 x_366) bool.true) 
          (logic.eq bool.bool (y (nat.S x_366)) bool.true)) 
       (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat bool.bool) 
          nat.eqb_body x_366 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
           sttfa.impl (logic.eq bool.bool (nat.eqb x_366 x_366) bool.true) 
             (logic.eq bool.bool (y (nat.S x_366)) bool.true)) 
          (nat.sym_eq_eqb_body_S x_366 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
              sttfa.impl 
                (logic.eq bool.bool (nat.eqb x_366 x_366) bool.true) 
                (logic.eq bool.bool (y (nat.S x_366)) bool.true)) 
             (nat.sym_eq_match_nat_type_S bool.bool bool.false 
                (q:(sttfa.etap (sttfa.p nat.nat)) => nat.eqb x_366 q) x_366 
                (y:(sttfa.etap (sttfa.p bool.bool)) =>
                 sttfa.impl 
                   (logic.eq bool.bool (nat.eqb x_366 x_366) bool.true) 
                   (logic.eq bool.bool y bool.true)) 
                (_x_368:
                 (sttfa.eps 
                    (logic.eq bool.bool (nat.eqb x_366 x_366) bool.true)) =>
                 logic.rewrite_r bool.bool bool.true 
                   (__:(sttfa.etap (sttfa.p bool.bool)) =>
                    logic.eq bool.bool __ bool.true) 
                   (logic.refl bool.bool bool.true) (nat.eqb x_366 x_366) 
                   _x_368))))) n.

def eqb_true_to_eq :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (logic.eq bool.bool (nat.eqb n m) bool.true) 
             (logic.eq nat.nat n m))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.eqb_elim n m 
    (__:(sttfa.etap (sttfa.p bool.bool)) =>
     sttfa.impl (logic.eq bool.bool __ bool.true) (logic.eq nat.nat n m)) 
    (auto:(sttfa.eps (logic.eq nat.nat n m)) =>
     auto':(sttfa.eps (logic.eq bool.bool bool.true bool.true)) =>
     logic.rewrite_l nat.nat n 
       (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat n __) 
       (logic.refl nat.nat n) m auto) 
    (__:(sttfa.eps (connectives.Not (logic.eq nat.nat n m))) =>
     abs:(sttfa.eps (logic.eq bool.bool bool.false bool.true)) =>
     logic.falsity (logic.eq nat.nat n m) 
       (logic.absurd (logic.eq bool.bool bool.true bool.false) 
          (logic.rewrite_r bool.bool bool.true 
             (__1:(sttfa.etap (sttfa.p bool.bool)) =>
              logic.eq bool.bool bool.true __1) 
             (logic.refl bool.bool bool.true) bool.false abs) 
          bool.not_eq_true_false)).

def eqb_false_to_not_eq :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (logic.eq bool.bool (nat.eqb n m) bool.false) 
             (connectives.Not (logic.eq nat.nat n m)))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.eqb_elim n m 
    (__:(sttfa.etap (sttfa.p bool.bool)) =>
     sttfa.impl (logic.eq bool.bool __ bool.false) 
       (connectives.Not (logic.eq nat.nat n m))) 
    (auto:(sttfa.eps (logic.eq nat.nat n m)) =>
     auto':(sttfa.eps (logic.eq bool.bool bool.true bool.false)) =>
     logic.not_to_not (logic.eq nat.nat n m) 
       (logic.eq bool.bool bool.true bool.false) 
       (auto'':(sttfa.eps (logic.eq nat.nat n m)) =>
        logic.rewrite_l bool.bool bool.true 
          (__:(sttfa.etap (sttfa.p bool.bool)) =>
           logic.eq bool.bool bool.true __) (logic.refl bool.bool bool.true) 
          bool.false auto') bool.not_eq_true_false) 
    (auto:(sttfa.eps (connectives.Not (logic.eq nat.nat n m))) =>
     auto':(sttfa.eps (logic.eq bool.bool bool.false bool.false)) => auto).

def eq_to_eqb_true :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (logic.eq nat.nat n m) 
             (logic.eq bool.bool (nat.eqb n m) bool.true))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  auto:(sttfa.eps (logic.eq nat.nat n m)) =>
  logic.rewrite_l nat.nat n 
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq bool.bool (nat.eqb n __) bool.true) 
    (logic.rewrite_r bool.bool bool.true 
       (__:(sttfa.etap (sttfa.p bool.bool)) =>
        logic.eq bool.bool __ bool.true) (logic.refl bool.bool bool.true) 
       (nat.eqb n n) (nat.eqb_n_n n)) m auto.

def not_eq_to_eqb_false :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (connectives.Not (logic.eq nat.nat n m)) 
             (logic.eq bool.bool (nat.eqb n m) bool.false))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  noteq:(sttfa.eps (connectives.Not (logic.eq nat.nat n m))) =>
  nat.eqb_elim n m 
    (__:(sttfa.etap (sttfa.p bool.bool)) => logic.eq bool.bool __ bool.false) 
    (Heq:(sttfa.eps (logic.eq nat.nat n m)) =>
     logic.falsity (logic.eq bool.bool bool.true bool.false) 
       (logic.absurd (logic.eq nat.nat n m) 
          (logic.rewrite_l nat.nat n 
             (__:(sttfa.etap (sttfa.p nat.nat)) => logic.eq nat.nat n __) 
             (logic.refl nat.nat n) m Heq) noteq)) 
    (auto:(sttfa.eps (connectives.Not (logic.eq nat.nat n m))) =>
     logic.refl bool.bool bool.false).

leb :
  sttfa.etap (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat bool.bool))).

leb_body :
  sttfa.etap (sttfa.p (sttfa.arrow nat.nat (sttfa.arrow nat.nat bool.bool))).

eq_leb :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat bool.bool) (nat.leb n) 
          (nat.filter_nat_type (sttfa.arrow nat.nat bool.bool) nat.leb_body n))).

def sym_eq_leb :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat bool.bool) 
          (nat.filter_nat_type (sttfa.arrow nat.nat bool.bool) nat.leb_body n) 
          (nat.leb n)))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  sttfa.sym_leibniz (sttfa.arrow nat.nat bool.bool) (nat.leb n) 
    (nat.filter_nat_type (sttfa.arrow nat.nat bool.bool) nat.leb_body n) 
    (nat.eq_leb n).

eq_leb_body_O :
  sttfa.eps 
    (sttfa.leibniz (sttfa.arrow nat.nat bool.bool) (nat.leb_body nat.O) 
       (m:(sttfa.etap (sttfa.p nat.nat)) => bool.true)).

def sym_eq_leb_body_O :
  sttfa.eps 
    (sttfa.leibniz (sttfa.arrow nat.nat bool.bool) 
       (m:(sttfa.etap (sttfa.p nat.nat)) => bool.true) (nat.leb_body nat.O))
  :=
  sttfa.sym_leibniz (sttfa.arrow nat.nat bool.bool) (nat.leb_body nat.O) 
    (m:(sttfa.etap (sttfa.p nat.nat)) => bool.true) nat.eq_leb_body_O.

eq_leb_body_S :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat bool.bool) 
          (nat.leb_body (nat.S n)) 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           nat.match_nat_type bool.bool bool.false 
             (q:(sttfa.etap (sttfa.p nat.nat)) => nat.leb n q) m))).

def sym_eq_leb_body_S :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.leibniz (sttfa.arrow nat.nat bool.bool) 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           nat.match_nat_type bool.bool bool.false 
             (q:(sttfa.etap (sttfa.p nat.nat)) => nat.leb n q) m) 
          (nat.leb_body (nat.S n))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  sttfa.sym_leibniz (sttfa.arrow nat.nat bool.bool) (nat.leb_body (nat.S n)) 
    (m:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.match_nat_type bool.bool bool.false 
       (q:(sttfa.etap (sttfa.p nat.nat)) => nat.leb n q) m) 
    (nat.eq_leb_body_S n).

def leb_elim :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
             (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
              sttfa.impl (sttfa.impl (nat.le n m) (P bool.true)) 
                (sttfa.impl 
                   (sttfa.impl (connectives.Not (nat.le n m)) (P bool.false)) 
                   (P (nat.leb n m)))))))
  :=
  nat.nat_elim2 
    (__:(sttfa.etap (sttfa.p nat.nat)) =>
     _0:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
       (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
        sttfa.impl (sttfa.impl (nat.le __ _0) (P bool.true)) 
          (sttfa.impl 
             (sttfa.impl (connectives.Not (nat.le __ _0)) (P bool.false)) 
             (P (nat.leb __ _0))))) 
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_leb nat.O 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
        sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
          (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
           sttfa.impl (sttfa.impl (nat.le nat.O n) (P bool.true)) 
             (sttfa.impl 
                (sttfa.impl (connectives.Not (nat.le nat.O n)) (P bool.false)) 
                (P (y n))))) 
       (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat bool.bool) 
          nat.leb_body 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
           sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
             (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
              sttfa.impl (sttfa.impl (nat.le nat.O n) (P bool.true)) 
                (sttfa.impl 
                   (sttfa.impl (connectives.Not (nat.le nat.O n)) 
                      (P bool.false)) (P (y n))))) 
          (nat.sym_eq_leb_body_O 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
              sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
                (P:
                 (sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                 sttfa.impl (sttfa.impl (nat.le nat.O n) (P bool.true)) 
                   (sttfa.impl 
                      (sttfa.impl (connectives.Not (nat.le nat.O n)) 
                         (P bool.false)) (P (y n))))) 
             (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
              auto:(sttfa.eps (sttfa.impl (nat.le nat.O n) (P bool.true))) =>
              auto':
              (sttfa.eps 
                 (sttfa.impl (connectives.Not (nat.le nat.O n)) 
                    (P bool.false))) =>
              auto (nat.le_O_n n))))) 
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_leb (nat.S n) 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
        sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
          (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
           sttfa.impl (sttfa.impl (nat.le (nat.S n) nat.O) (P bool.true)) 
             (sttfa.impl 
                (sttfa.impl (connectives.Not (nat.le (nat.S n) nat.O)) 
                   (P bool.false)) (P (y nat.O))))) 
       (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat bool.bool) 
          nat.leb_body n 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
           sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
             (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
              sttfa.impl (sttfa.impl (nat.le (nat.S n) nat.O) (P bool.true)) 
                (sttfa.impl 
                   (sttfa.impl (connectives.Not (nat.le (nat.S n) nat.O)) 
                      (P bool.false)) (P (y nat.O))))) 
          (nat.sym_eq_leb_body_S n 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
              sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
                (P:
                 (sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                 sttfa.impl 
                   (sttfa.impl (nat.le (nat.S n) nat.O) (P bool.true)) 
                   (sttfa.impl 
                      (sttfa.impl (connectives.Not (nat.le (nat.S n) nat.O)) 
                         (P bool.false)) (P (y nat.O))))) 
             (nat.sym_eq_match_nat_type_O bool.bool bool.false 
                (q:(sttfa.etap (sttfa.p nat.nat)) => nat.leb n q) 
                (y:(sttfa.etap (sttfa.p bool.bool)) =>
                 sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
                   (P:
                    (sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                    sttfa.impl 
                      (sttfa.impl (nat.le (nat.S n) nat.O) (P bool.true)) 
                      (sttfa.impl 
                         (sttfa.impl 
                            (connectives.Not (nat.le (nat.S n) nat.O)) 
                            (P bool.false)) (P y)))) 
                (P:
                 (sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                 auto:
                 (sttfa.eps 
                    (sttfa.impl (nat.le (nat.S n) nat.O) (P bool.true))) =>
                 auto':
                 (sttfa.eps 
                    (sttfa.impl (connectives.Not (nat.le (nat.S n) nat.O)) 
                       (P bool.false))) =>
                 auto' (nat.not_le_Sn_O n)))))) 
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     m:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_leb (nat.S n) 
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
        sttfa.impl 
          (sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
             (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
              sttfa.impl (sttfa.impl (nat.le n m) (P bool.true)) 
                (sttfa.impl 
                   (sttfa.impl (connectives.Not (nat.le n m)) (P bool.false)) 
                   (P (nat.leb n m))))) 
          (sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
             (P:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
              sttfa.impl 
                (sttfa.impl (nat.le (nat.S n) (nat.S m)) (P bool.true)) 
                (sttfa.impl 
                   (sttfa.impl 
                      (connectives.Not (nat.le (nat.S n) (nat.S m))) 
                      (P bool.false)) (P (y (nat.S m))))))) 
       (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat bool.bool) 
          nat.leb_body n 
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
           sttfa.impl 
             (sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
                (P:
                 (sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                 sttfa.impl (sttfa.impl (nat.le n m) (P bool.true)) 
                   (sttfa.impl 
                      (sttfa.impl (connectives.Not (nat.le n m)) 
                         (P bool.false)) (P (nat.leb n m))))) 
             (sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
                (P:
                 (sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                 sttfa.impl 
                   (sttfa.impl (nat.le (nat.S n) (nat.S m)) (P bool.true)) 
                   (sttfa.impl 
                      (sttfa.impl 
                         (connectives.Not (nat.le (nat.S n) (nat.S m))) 
                         (P bool.false)) (P (y (nat.S m))))))) 
          (nat.sym_eq_leb_body_S n 
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
              sttfa.impl 
                (sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
                   (P:
                    (sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                    sttfa.impl (sttfa.impl (nat.le n m) (P bool.true)) 
                      (sttfa.impl 
                         (sttfa.impl (connectives.Not (nat.le n m)) 
                            (P bool.false)) (P (nat.leb n m))))) 
                (sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
                   (P:
                    (sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                    sttfa.impl 
                      (sttfa.impl (nat.le (nat.S n) (nat.S m)) (P bool.true)) 
                      (sttfa.impl 
                         (sttfa.impl 
                            (connectives.Not (nat.le (nat.S n) (nat.S m))) 
                            (P bool.false)) (P (y (nat.S m))))))) 
             (nat.sym_eq_match_nat_type_S bool.bool bool.false 
                (q:(sttfa.etap (sttfa.p nat.nat)) => nat.leb n q) m 
                (y:(sttfa.etap (sttfa.p bool.bool)) =>
                 sttfa.impl 
                   (sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
                      (P:
                       (sttfa.etap 
                          (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                       sttfa.impl (sttfa.impl (nat.le n m) (P bool.true)) 
                         (sttfa.impl 
                            (sttfa.impl (connectives.Not (nat.le n m)) 
                               (P bool.false)) (P (nat.leb n m))))) 
                   (sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
                      (P:
                       (sttfa.etap 
                          (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                       sttfa.impl 
                         (sttfa.impl (nat.le (nat.S n) (nat.S m)) 
                            (P bool.true)) 
                         (sttfa.impl 
                            (sttfa.impl 
                               (connectives.Not (nat.le (nat.S n) (nat.S m))) 
                               (P bool.false)) (P y))))) 
                (Hind:
                 (sttfa.eps 
                    (sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
                       (P:
                        (sttfa.etap 
                           (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                        sttfa.impl (sttfa.impl (nat.le n m) (P bool.true)) 
                          (sttfa.impl 
                             (sttfa.impl (connectives.Not (nat.le n m)) 
                                (P bool.false)) (P (nat.leb n m)))))) =>
                 P:
                 (sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
                 Pt:
                 (sttfa.eps 
                    (sttfa.impl (nat.le (nat.S n) (nat.S m)) (P bool.true))) =>
                 Pf:
                 (sttfa.eps 
                    (sttfa.impl 
                       (connectives.Not (nat.le (nat.S n) (nat.S m))) 
                       (P bool.false))) =>
                 Hind P 
                   (lenm:(sttfa.eps (nat.le n m)) => Pt (nat.le_S_S n m lenm)) 
                   (nlenm:(sttfa.eps (connectives.Not (nat.le n m))) =>
                    Pf (nat.not_le_to_not_le_S_S n m nlenm))))))).

def leb_true_to_le :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (logic.eq bool.bool (nat.leb n m) bool.true) 
             (nat.le n m))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.leb_elim n m 
    (__:(sttfa.etap (sttfa.p bool.bool)) =>
     sttfa.impl (logic.eq bool.bool __ bool.true) (nat.le n m)) 
    (auto:(sttfa.eps (nat.le n m)) =>
     auto':(sttfa.eps (logic.eq bool.bool bool.true bool.true)) => auto) 
    (__:(sttfa.eps (connectives.Not (nat.le n m))) =>
     abs:(sttfa.eps (logic.eq bool.bool bool.false bool.true)) =>
     logic.falsity (nat.le n m) 
       (logic.absurd (logic.eq bool.bool bool.true bool.false) 
          (logic.rewrite_r bool.bool bool.true 
             (__1:(sttfa.etap (sttfa.p bool.bool)) =>
              logic.eq bool.bool bool.true __1) 
             (logic.refl bool.bool bool.true) bool.false abs) 
          bool.not_eq_true_false)).

def le_to_leb_true :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (nat.le n m) 
             (logic.eq bool.bool (nat.leb n m) bool.true))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.leb_elim n m 
    (__:(sttfa.etap (sttfa.p bool.bool)) =>
     sttfa.impl (nat.le n m) (logic.eq bool.bool __ bool.true)) 
    (auto:(sttfa.eps (nat.le n m)) =>
     auto':(sttfa.eps (nat.le n m)) => logic.refl bool.bool bool.true) 
    (H:(sttfa.eps (connectives.Not (nat.le n m))) =>
     H1:(sttfa.eps (nat.le n m)) =>
     logic.falsity (logic.eq bool.bool bool.false bool.true) 
       (logic.absurd (nat.le n m) H1 H)).

def not_le_to_leb_false :
  sttfa.eps 
    (sttfa.forall nat.nat 
       (n:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat 
          (m:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.impl (connectives.Not (nat.le n m)) 
             (logic.eq bool.bool (nat.leb n m) bool.false))))
  :=
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.leb_elim n m 
    (__:(sttfa.etap (sttfa.p bool.bool)) =>
     sttfa.impl (connectives.Not (nat.le n m)) 
       (logic.eq bool.bool __ bool.false)) 
    (H:(sttfa.eps (nat.le n m)) =>
     H1:(sttfa.eps (connectives.Not (nat.le n m))) =>
     logic.falsity (logic.eq bool.bool bool.true bool.false) 
       (logic.absurd (nat.le n m) H H1)) 
    (auto:(sttfa.eps (connectives.Not (nat.le n m))) =>
     auto':(sttfa.eps (connectives.Not (nat.le n m))) =>
     logic.refl bool.bool bool.false).

