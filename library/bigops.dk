def sameF_upto :
  sttfa.etap
    (sttfa.forallK
       (A:sttfa.type =>
        sttfa.p
          (sttfa.arrow nat.nat
             (sttfa.arrow (sttfa.arrow nat.nat A)
                (sttfa.arrow (sttfa.arrow nat.nat A) sttfa.bool)))))
  :=
  A:sttfa.type =>
  k:(sttfa.etap (sttfa.p nat.nat)) =>
  f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat A))) =>
  g:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat A))) =>
  sttfa.forall nat.nat
    (i:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.impl (nat.lt i k) (logic.eq A (f i) (g i))).

def sameF_p :
  sttfa.etap
    (sttfa.forallK
       (A:sttfa.type =>
        sttfa.p
          (sttfa.arrow nat.nat
             (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                (sttfa.arrow (sttfa.arrow nat.nat A)
                   (sttfa.arrow (sttfa.arrow nat.nat A) sttfa.bool))))))
  :=
  A:sttfa.type =>
  k:(sttfa.etap (sttfa.p nat.nat)) =>
  p:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
  f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat A))) =>
  g:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat A))) =>
  sttfa.forall nat.nat
    (i:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.impl (nat.lt i k)
       (sttfa.impl (logic.eq bool.bool (p i) bool.true)
          (logic.eq A (f i) (g i)))).

def sameF_upto_le :
  sttfa.eps
    (sttfa.forallP
       (A:sttfa.type =>
        sttfa.forall (sttfa.arrow nat.nat A)
          (f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat A))) =>
           sttfa.forall (sttfa.arrow nat.nat A)
             (g:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat A))) =>
              sttfa.forall nat.nat
                (n:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall nat.nat
                   (m:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (nat.le n m)
                      (sttfa.impl (bigops.sameF_upto A m f g)
                         (bigops.sameF_upto A n f g))))))))
  :=
  A:sttfa.type =>
  f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat A))) =>
  g:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat A))) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  lenm:(sttfa.eps (nat.le n m)) =>
  samef:(sttfa.eps (bigops.sameF_upto A m f g)) =>
  i:(sttfa.etap (sttfa.p nat.nat)) =>
  ltin:(sttfa.eps (nat.lt i n)) =>
  samef i (nat.lt_to_le_to_lt i n m ltin lenm).

def sameF_p_le :
  sttfa.eps
    (sttfa.forallP
       (A:sttfa.type =>
        sttfa.forall (sttfa.arrow nat.nat bool.bool)
          (p:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
           sttfa.forall (sttfa.arrow nat.nat A)
             (f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat A))) =>
              sttfa.forall (sttfa.arrow nat.nat A)
                (g:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat A))) =>
                 sttfa.forall nat.nat
                   (n:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.forall nat.nat
                      (m:(sttfa.etap (sttfa.p nat.nat)) =>
                       sttfa.impl (nat.le n m)
                         (sttfa.impl (bigops.sameF_p A m p f g)
                            (bigops.sameF_p A n p f g)))))))))
  :=
  A:sttfa.type =>
  p:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
  f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat A))) =>
  g:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat A))) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  lenm:(sttfa.eps (nat.le n m)) =>
  samef:(sttfa.eps (bigops.sameF_p A m p f g)) =>
  i:(sttfa.etap (sttfa.p nat.nat)) =>
  ltin:(sttfa.eps (nat.lt i n)) =>
  pi:(sttfa.eps (logic.eq bool.bool (p i) bool.true)) =>
  samef i (nat.lt_to_le_to_lt i n m ltin lenm)
    (logic.rewrite_r bool.bool bool.true
       (__:(sttfa.etap (sttfa.p bool.bool)) =>
        logic.eq bool.bool __ bool.true) (logic.refl bool.bool bool.true)
       (p i) pi).

bigop :
  sttfa.etap
    (sttfa.forallK
       (H:sttfa.type =>
        sttfa.p
          (sttfa.arrow nat.nat
             (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                (sttfa.arrow H
                   (sttfa.arrow (sttfa.arrow H (sttfa.arrow H H))
                      (sttfa.arrow (sttfa.arrow nat.nat H) H))))))).

bigop_body :
  sttfa.etap
    (sttfa.forallK
       (H:sttfa.type =>
        sttfa.p
          (sttfa.arrow nat.nat
             (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                (sttfa.arrow H
                   (sttfa.arrow (sttfa.arrow H (sttfa.arrow H H))
                      (sttfa.arrow (sttfa.arrow nat.nat H) H))))))).

axiom_bigop_O :
  sttfa.eps
    (sttfa.forallP
       (H:sttfa.type =>
        connectives.equal
          (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
             (sttfa.arrow H
                (sttfa.arrow (sttfa.arrow H (sttfa.arrow H H))
                   (sttfa.arrow (sttfa.arrow nat.nat H) H))))
          (bigops.bigop H nat.O) (bigops.bigop_body H nat.O))).

def eq_bigop_O :
  sttfa.eps
    (sttfa.forallP
       (H:sttfa.type =>
        leibniz.leibniz
          (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
             (sttfa.arrow H
                (sttfa.arrow (sttfa.arrow H (sttfa.arrow H H))
                   (sttfa.arrow (sttfa.arrow nat.nat H) H))))
          (bigops.bigop H nat.O) (bigops.bigop_body H nat.O))) :=
H:sttfa.type =>
        connectives.equal_leibniz
          (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
             (sttfa.arrow H
                (sttfa.arrow (sttfa.arrow H (sttfa.arrow H H))
                   (sttfa.arrow (sttfa.arrow nat.nat H) H))))
          (bigops.bigop H nat.O) (bigops.bigop_body H nat.O) (axiom_bigop_O H).

def sym_eq_bigop_O :
  sttfa.eps
    (sttfa.forallP
       (H:sttfa.type =>
        leibniz.leibniz
          (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
             (sttfa.arrow H
                (sttfa.arrow (sttfa.arrow H (sttfa.arrow H H))
                   (sttfa.arrow (sttfa.arrow nat.nat H) H))))
          (bigops.bigop_body H nat.O) (bigops.bigop H nat.O)))
  :=
  H:sttfa.type =>
  leibniz.sym_leibniz
    (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
       (sttfa.arrow H
          (sttfa.arrow (sttfa.arrow H (sttfa.arrow H H))
             (sttfa.arrow (sttfa.arrow nat.nat H) H))))
    (bigops.bigop H nat.O) (bigops.bigop_body H nat.O) (bigops.eq_bigop_O H).

axiom_bigop_S :
  sttfa.eps
    (sttfa.forallP
       (H:sttfa.type =>
        sttfa.forall nat.nat
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.equal
             (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                (sttfa.arrow H
                   (sttfa.arrow (sttfa.arrow H (sttfa.arrow H H))
                      (sttfa.arrow (sttfa.arrow nat.nat H) H))))
             (bigops.bigop H (nat.S n)) (bigops.bigop_body H (nat.S n))))).

def eq_bigop_S :
  sttfa.eps
    (sttfa.forallP
       (H:sttfa.type =>
        sttfa.forall nat.nat
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           leibniz.leibniz
             (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                (sttfa.arrow H
                   (sttfa.arrow (sttfa.arrow H (sttfa.arrow H H))
                      (sttfa.arrow (sttfa.arrow nat.nat H) H))))
             (bigops.bigop H (nat.S n)) (bigops.bigop_body H (nat.S n))))) :=
H:sttfa.type =>
n:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.equal_leibniz
             (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                (sttfa.arrow H
                   (sttfa.arrow (sttfa.arrow H (sttfa.arrow H H))
                      (sttfa.arrow (sttfa.arrow nat.nat H) H))))
             (bigops.bigop H (nat.S n)) (bigops.bigop_body H (nat.S n)) (axiom_bigop_S H n).

def sym_eq_bigop_S :
  sttfa.eps
    (sttfa.forallP
       (H:sttfa.type =>
        sttfa.forall nat.nat
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           leibniz.leibniz
             (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                (sttfa.arrow H
                   (sttfa.arrow (sttfa.arrow H (sttfa.arrow H H))
                      (sttfa.arrow (sttfa.arrow nat.nat H) H))))
             (bigops.bigop_body H (nat.S n)) (bigops.bigop H (nat.S n)))))
  :=
  H:sttfa.type =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  leibniz.sym_leibniz
    (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
       (sttfa.arrow H
          (sttfa.arrow (sttfa.arrow H (sttfa.arrow H H))
             (sttfa.arrow (sttfa.arrow nat.nat H) H))))
    (bigops.bigop H (nat.S n)) (bigops.bigop_body H (nat.S n))
    (bigops.eq_bigop_S H n).

axiom_bigop_body_O :
  sttfa.eps
    (sttfa.forallP
       (H:sttfa.type =>
        connectives.equal
          (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
             (sttfa.arrow H
                (sttfa.arrow (sttfa.arrow H (sttfa.arrow H H))
                   (sttfa.arrow (sttfa.arrow nat.nat H) H))))
          (bigops.bigop_body H nat.O)
          (p:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
           nil:(sttfa.etap (sttfa.p H)) =>
           op:(sttfa.etap (sttfa.p (sttfa.arrow H (sttfa.arrow H H)))) =>
           f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat H))) => nil))).

def eq_bigop_body_O :
  sttfa.eps
    (sttfa.forallP
       (H:sttfa.type =>
        leibniz.leibniz
          (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
             (sttfa.arrow H
                (sttfa.arrow (sttfa.arrow H (sttfa.arrow H H))
                   (sttfa.arrow (sttfa.arrow nat.nat H) H))))
          (bigops.bigop_body H nat.O)
          (p:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
           nil:(sttfa.etap (sttfa.p H)) =>
           op:(sttfa.etap (sttfa.p (sttfa.arrow H (sttfa.arrow H H)))) =>
           f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat H))) => nil))) :=
H:sttfa.type =>
        connectives.equal_leibniz
          (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
             (sttfa.arrow H
                (sttfa.arrow (sttfa.arrow H (sttfa.arrow H H))
                   (sttfa.arrow (sttfa.arrow nat.nat H) H))))
          (bigops.bigop_body H nat.O)
          (p:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
           nil:(sttfa.etap (sttfa.p H)) =>
           op:(sttfa.etap (sttfa.p (sttfa.arrow H (sttfa.arrow H H)))) =>
           f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat H))) => nil) (axiom_bigop_body_O H).


def sym_eq_bigop_body_O :
  sttfa.eps
    (sttfa.forallP
       (H:sttfa.type =>
        leibniz.leibniz
          (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
             (sttfa.arrow H
                (sttfa.arrow (sttfa.arrow H (sttfa.arrow H H))
                   (sttfa.arrow (sttfa.arrow nat.nat H) H))))
          (p:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
           nil:(sttfa.etap (sttfa.p H)) =>
           op:(sttfa.etap (sttfa.p (sttfa.arrow H (sttfa.arrow H H)))) =>
           f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat H))) => nil)
          (bigops.bigop_body H nat.O)))
  :=
  H:sttfa.type =>
  leibniz.sym_leibniz
    (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
       (sttfa.arrow H
          (sttfa.arrow (sttfa.arrow H (sttfa.arrow H H))
             (sttfa.arrow (sttfa.arrow nat.nat H) H))))
    (bigops.bigop_body H nat.O)
    (p:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
     nil:(sttfa.etap (sttfa.p H)) =>
     op:(sttfa.etap (sttfa.p (sttfa.arrow H (sttfa.arrow H H)))) =>
     f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat H))) => nil)
    (bigops.eq_bigop_body_O H).

axiom_bigop_body_S :
  sttfa.eps
    (sttfa.forallP
       (H:sttfa.type =>
        sttfa.forall nat.nat
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.equal
             (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                (sttfa.arrow H
                   (sttfa.arrow (sttfa.arrow H (sttfa.arrow H H))
                      (sttfa.arrow (sttfa.arrow nat.nat H) H))))
             (bigops.bigop_body H (nat.S n))
             (p:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
              nil:(sttfa.etap (sttfa.p H)) =>
              op:(sttfa.etap (sttfa.p (sttfa.arrow H (sttfa.arrow H H)))) =>
              f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat H))) =>
              bool.match_bool_type H
                (op (f n) (bigops.bigop H n p nil op f))
                (bigops.bigop H n p nil op f) (p n))))).

def eq_bigop_body_S :
  sttfa.eps
    (sttfa.forallP
       (H:sttfa.type =>
        sttfa.forall nat.nat
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           leibniz.leibniz
             (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                (sttfa.arrow H
                   (sttfa.arrow (sttfa.arrow H (sttfa.arrow H H))
                      (sttfa.arrow (sttfa.arrow nat.nat H) H))))
             (bigops.bigop_body H (nat.S n))
             (p:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
              nil:(sttfa.etap (sttfa.p H)) =>
              op:(sttfa.etap (sttfa.p (sttfa.arrow H (sttfa.arrow H H)))) =>
              f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat H))) =>
              bool.match_bool_type H
                (op (f n) (bigops.bigop H n p nil op f))
                (bigops.bigop H n p nil op f) (p n))))) :=
H:sttfa.type =>
n:(sttfa.etap (sttfa.p nat.nat)) =>
           connectives.equal_leibniz
             (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                (sttfa.arrow H
                   (sttfa.arrow (sttfa.arrow H (sttfa.arrow H H))
                      (sttfa.arrow (sttfa.arrow nat.nat H) H))))
             (bigops.bigop_body H (nat.S n))
             (p:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
              nil:(sttfa.etap (sttfa.p H)) =>
              op:(sttfa.etap (sttfa.p (sttfa.arrow H (sttfa.arrow H H)))) =>
              f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat H))) =>
              bool.match_bool_type H
                (op (f n) (bigops.bigop H n p nil op f))
                (bigops.bigop H n p nil op f) (p n)) (axiom_bigop_body_S H n).

def sym_eq_bigop_body_S :
  sttfa.eps
    (sttfa.forallP
       (H:sttfa.type =>
        sttfa.forall nat.nat
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           leibniz.leibniz
             (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                (sttfa.arrow H
                   (sttfa.arrow (sttfa.arrow H (sttfa.arrow H H))
                      (sttfa.arrow (sttfa.arrow nat.nat H) H))))
             (p:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
              nil:(sttfa.etap (sttfa.p H)) =>
              op:(sttfa.etap (sttfa.p (sttfa.arrow H (sttfa.arrow H H)))) =>
              f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat H))) =>
              bool.match_bool_type H
                (op (f n) (bigops.bigop H n p nil op f))
                (bigops.bigop H n p nil op f) (p n))
             (bigops.bigop_body H (nat.S n)))))
  :=
  H:sttfa.type =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  leibniz.sym_leibniz
    (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
       (sttfa.arrow H
          (sttfa.arrow (sttfa.arrow H (sttfa.arrow H H))
             (sttfa.arrow (sttfa.arrow nat.nat H) H))))
    (bigops.bigop_body H (nat.S n))
    (p:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
     nil:(sttfa.etap (sttfa.p H)) =>
     op:(sttfa.etap (sttfa.p (sttfa.arrow H (sttfa.arrow H H)))) =>
     f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat H))) =>
     bool.match_bool_type H (op (f n) (bigops.bigop H n p nil op f))
       (bigops.bigop H n p nil op f) (p n)) (bigops.eq_bigop_body_S H n).

def bigop_Strue :
  sttfa.eps
    (sttfa.forallP
       (B:sttfa.type =>
        sttfa.forall nat.nat
          (k:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall (sttfa.arrow nat.nat bool.bool)
             (p:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
              sttfa.forall B
                (nil:(sttfa.etap (sttfa.p B)) =>
                 sttfa.forall (sttfa.arrow B (sttfa.arrow B B))
                   (op:
                    (sttfa.etap (sttfa.p (sttfa.arrow B (sttfa.arrow B B)))) =>
                    sttfa.forall (sttfa.arrow nat.nat B)
                      (f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat B))) =>
                       sttfa.impl (logic.eq bool.bool (p k) bool.true)
                         (logic.eq B
                            (bigops.bigop B (nat.S k)
                               (i:(sttfa.etap (sttfa.p nat.nat)) => p i) nil
                               op (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
                            (op (f k)
                               (bigops.bigop B k
                                  (i:(sttfa.etap (sttfa.p nat.nat)) => p i)
                                  nil op
                                  (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))))))))))
  :=
  B:sttfa.type =>
  k:(sttfa.etap (sttfa.p nat.nat)) =>
  p:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
  nil:(sttfa.etap (sttfa.p B)) =>
  op:(sttfa.etap (sttfa.p (sttfa.arrow B (sttfa.arrow B B)))) =>
  f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat B))) =>
  bigops.sym_eq_bigop_S B k
    (y:
     (sttfa.etap
        (sttfa.p
           (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
              (sttfa.arrow B
                 (sttfa.arrow (sttfa.arrow B (sttfa.arrow B B))
                    (sttfa.arrow (sttfa.arrow nat.nat B) B)))))) =>
     sttfa.impl (logic.eq bool.bool (p k) bool.true)
       (logic.eq B
          (y (i:(sttfa.etap (sttfa.p nat.nat)) => p i) nil op
             (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
          (op (f k)
             (bigops.bigop B k (i:(sttfa.etap (sttfa.p nat.nat)) => p i) nil
                op (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))))
    (bigops.sym_eq_bigop_body_S B k
       (y:
        (sttfa.etap
           (sttfa.p
              (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                 (sttfa.arrow B
                    (sttfa.arrow (sttfa.arrow B (sttfa.arrow B B))
                       (sttfa.arrow (sttfa.arrow nat.nat B) B)))))) =>
        sttfa.impl (logic.eq bool.bool (p k) bool.true)
          (logic.eq B
             (y (i:(sttfa.etap (sttfa.p nat.nat)) => p i) nil op
                (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
             (op (f k)
                (bigops.bigop B k (i:(sttfa.etap (sttfa.p nat.nat)) => p i)
                   nil op (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))))
       (H:(sttfa.eps (logic.eq bool.bool (p k) bool.true)) =>
        logic.eq_ind_r bool.bool bool.true
          (x:(sttfa.etap (sttfa.p bool.bool)) =>
           logic.eq B
             (bool.match_bool_type B
                (op (f k)
                   (bigops.bigop B k
                      (i:(sttfa.etap (sttfa.p nat.nat)) => p i) nil op
                      (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))
                (bigops.bigop B k (i:(sttfa.etap (sttfa.p nat.nat)) => p i)
                   nil op (i:(sttfa.etap (sttfa.p nat.nat)) => f i)) x)
             (op (f k)
                (bigops.bigop B k (i:(sttfa.etap (sttfa.p nat.nat)) => p i)
                   nil op (i:(sttfa.etap (sttfa.p nat.nat)) => f i))))
          (bool.eq_match_bool_type_true B
             (op (f k)
                (bigops.bigop B k (i:(sttfa.etap (sttfa.p nat.nat)) => p i)
                   nil op (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))
             (bigops.bigop B k (i:(sttfa.etap (sttfa.p nat.nat)) => p i) nil
                op (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
             (y:(sttfa.etap (sttfa.p B)) =>
              logic.eq B
                (bool.match_bool_type B
                   (op (f k)
                      (bigops.bigop B k
                         (i:(sttfa.etap (sttfa.p nat.nat)) => p i) nil op
                         (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))
                   (bigops.bigop B k
                      (i:(sttfa.etap (sttfa.p nat.nat)) => p i) nil op
                      (i:(sttfa.etap (sttfa.p nat.nat)) => f i)) bool.true) y)
             (logic.refl B
                (bool.match_bool_type B
                   (op (f k)
                      (bigops.bigop B k
                         (i:(sttfa.etap (sttfa.p nat.nat)) => p i) nil op
                         (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))
                   (bigops.bigop B k
                      (i:(sttfa.etap (sttfa.p nat.nat)) => p i) nil op
                      (i:(sttfa.etap (sttfa.p nat.nat)) => f i)) bool.true)))
          (p k) H)).

def bigop_Sfalse :
  sttfa.eps
    (sttfa.forallP
       (B:sttfa.type =>
        sttfa.forall nat.nat
          (k:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall (sttfa.arrow nat.nat bool.bool)
             (p:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
              sttfa.forall B
                (nil:(sttfa.etap (sttfa.p B)) =>
                 sttfa.forall (sttfa.arrow B (sttfa.arrow B B))
                   (op:
                    (sttfa.etap (sttfa.p (sttfa.arrow B (sttfa.arrow B B)))) =>
                    sttfa.forall (sttfa.arrow nat.nat B)
                      (f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat B))) =>
                       sttfa.impl (logic.eq bool.bool (p k) bool.false)
                         (logic.eq B
                            (bigops.bigop B (nat.S k)
                               (i:(sttfa.etap (sttfa.p nat.nat)) => p i) nil
                               op (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
                            (bigops.bigop B k
                               (i:(sttfa.etap (sttfa.p nat.nat)) => p i) nil
                               op (i:(sttfa.etap (sttfa.p nat.nat)) => f i))))))))))
  :=
  B:sttfa.type =>
  k:(sttfa.etap (sttfa.p nat.nat)) =>
  p:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
  nil:(sttfa.etap (sttfa.p B)) =>
  op:(sttfa.etap (sttfa.p (sttfa.arrow B (sttfa.arrow B B)))) =>
  f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat B))) =>
  bigops.sym_eq_bigop_S B k
    (y:
     (sttfa.etap
        (sttfa.p
           (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
              (sttfa.arrow B
                 (sttfa.arrow (sttfa.arrow B (sttfa.arrow B B))
                    (sttfa.arrow (sttfa.arrow nat.nat B) B)))))) =>
     sttfa.impl (logic.eq bool.bool (p k) bool.false)
       (logic.eq B
          (y (i:(sttfa.etap (sttfa.p nat.nat)) => p i) nil op
             (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
          (bigops.bigop B k (i:(sttfa.etap (sttfa.p nat.nat)) => p i) nil op
             (i:(sttfa.etap (sttfa.p nat.nat)) => f i))))
    (bigops.sym_eq_bigop_body_S B k
       (y:
        (sttfa.etap
           (sttfa.p
              (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                 (sttfa.arrow B
                    (sttfa.arrow (sttfa.arrow B (sttfa.arrow B B))
                       (sttfa.arrow (sttfa.arrow nat.nat B) B)))))) =>
        sttfa.impl (logic.eq bool.bool (p k) bool.false)
          (logic.eq B
             (y (i:(sttfa.etap (sttfa.p nat.nat)) => p i) nil op
                (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
             (bigops.bigop B k (i:(sttfa.etap (sttfa.p nat.nat)) => p i) nil
                op (i:(sttfa.etap (sttfa.p nat.nat)) => f i))))
       (H:(sttfa.eps (logic.eq bool.bool (p k) bool.false)) =>
        logic.eq_ind_r bool.bool bool.false
          (x:(sttfa.etap (sttfa.p bool.bool)) =>
           logic.eq B
             (bool.match_bool_type B
                (op (f k)
                   (bigops.bigop B k
                      (i:(sttfa.etap (sttfa.p nat.nat)) => p i) nil op
                      (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))
                (bigops.bigop B k (i:(sttfa.etap (sttfa.p nat.nat)) => p i)
                   nil op (i:(sttfa.etap (sttfa.p nat.nat)) => f i)) x)
             (bigops.bigop B k (i:(sttfa.etap (sttfa.p nat.nat)) => p i) nil
                op (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))
          (bool.eq_match_bool_type_false B
             (op (f k)
                (bigops.bigop B k (i:(sttfa.etap (sttfa.p nat.nat)) => p i)
                   nil op (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))
             (bigops.bigop B k (i:(sttfa.etap (sttfa.p nat.nat)) => p i) nil
                op (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
             (y:(sttfa.etap (sttfa.p B)) =>
              logic.eq B
                (bool.match_bool_type B
                   (op (f k)
                      (bigops.bigop B k
                         (i:(sttfa.etap (sttfa.p nat.nat)) => p i) nil op
                         (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))
                   (bigops.bigop B k
                      (i:(sttfa.etap (sttfa.p nat.nat)) => p i) nil op
                      (i:(sttfa.etap (sttfa.p nat.nat)) => f i)) bool.false)
                y)
             (logic.refl B
                (bool.match_bool_type B
                   (op (f k)
                      (bigops.bigop B k
                         (i:(sttfa.etap (sttfa.p nat.nat)) => p i) nil op
                         (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))
                   (bigops.bigop B k
                      (i:(sttfa.etap (sttfa.p nat.nat)) => p i) nil op
                      (i:(sttfa.etap (sttfa.p nat.nat)) => f i)) bool.false)))
          (p k) H)).

def same_bigop :
  sttfa.eps
    (sttfa.forallP
       (B:sttfa.type =>
        sttfa.forall nat.nat
          (k:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall (sttfa.arrow nat.nat bool.bool)
             (p1:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
              sttfa.forall (sttfa.arrow nat.nat bool.bool)
                (p2:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
                 sttfa.forall B
                   (nil:(sttfa.etap (sttfa.p B)) =>
                    sttfa.forall (sttfa.arrow B (sttfa.arrow B B))
                      (op:
                       (sttfa.etap
                          (sttfa.p (sttfa.arrow B (sttfa.arrow B B)))) =>
                       sttfa.forall (sttfa.arrow nat.nat B)
                         (f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat B))) =>
                          sttfa.forall (sttfa.arrow nat.nat B)
                            (g:
                             (sttfa.etap (sttfa.p (sttfa.arrow nat.nat B))) =>
                             sttfa.impl
                               (bigops.sameF_upto bool.bool k p1 p2)
                               (sttfa.impl (bigops.sameF_p B k p1 f g)
                                  (logic.eq B
                                     (bigops.bigop B k
                                        (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                         p1 i) nil op
                                        (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                         f i))
                                     (bigops.bigop B k
                                        (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                         p2 i) nil op
                                        (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                         g i)))))))))))))
  :=
  B:sttfa.type =>
  k:(sttfa.etap (sttfa.p nat.nat)) =>
  p1:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
  p2:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
  nil:(sttfa.etap (sttfa.p B)) =>
  op:(sttfa.etap (sttfa.p (sttfa.arrow B (sttfa.arrow B B)))) =>
  f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat B))) =>
  g:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat B))) =>
  nat.nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.impl (bigops.sameF_upto bool.bool _x_365 p1 p2)
       (sttfa.impl (bigops.sameF_p B _x_365 p1 f g)
          (logic.eq B
             (bigops.bigop B _x_365
                (i:(sttfa.etap (sttfa.p nat.nat)) => p1 i) nil op
                (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
             (bigops.bigop B _x_365
                (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i) nil op
                (i:(sttfa.etap (sttfa.p nat.nat)) => g i)))))
    (bigops.sym_eq_bigop_O B
       (y:
        (sttfa.etap
           (sttfa.p
              (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                 (sttfa.arrow B
                    (sttfa.arrow (sttfa.arrow B (sttfa.arrow B B))
                       (sttfa.arrow (sttfa.arrow nat.nat B) B)))))) =>
        sttfa.impl (bigops.sameF_upto bool.bool nat.O p1 p2)
          (sttfa.impl (bigops.sameF_p B nat.O p1 f g)
             (logic.eq B
                (bigops.bigop B nat.O
                   (i:(sttfa.etap (sttfa.p nat.nat)) => p1 i) nil op
                   (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
                (y (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i) nil op
                   (i:(sttfa.etap (sttfa.p nat.nat)) => g i)))))
       (bigops.sym_eq_bigop_body_O B
          (y:
           (sttfa.etap
              (sttfa.p
                 (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                    (sttfa.arrow B
                       (sttfa.arrow (sttfa.arrow B (sttfa.arrow B B))
                          (sttfa.arrow (sttfa.arrow nat.nat B) B)))))) =>
           sttfa.impl (bigops.sameF_upto bool.bool nat.O p1 p2)
             (sttfa.impl (bigops.sameF_p B nat.O p1 f g)
                (logic.eq B
                   (bigops.bigop B nat.O
                      (i:(sttfa.etap (sttfa.p nat.nat)) => p1 i) nil op
                      (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
                   (y (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i) nil op
                      (i:(sttfa.etap (sttfa.p nat.nat)) => g i)))))
          (bigops.eq_bigop_body_O B
             (y:
              (sttfa.etap
                 (sttfa.p
                    (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                       (sttfa.arrow B
                          (sttfa.arrow (sttfa.arrow B (sttfa.arrow B B))
                             (sttfa.arrow (sttfa.arrow nat.nat B) B)))))) =>
              sttfa.impl (bigops.sameF_upto bool.bool nat.O p1 p2)
                (sttfa.impl (bigops.sameF_p B nat.O p1 f g)
                   (logic.eq B
                      (bigops.bigop B nat.O
                         (i:(sttfa.etap (sttfa.p nat.nat)) => p1 i) nil op
                         (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
                      (y (i:(sttfa.etap (sttfa.p nat.nat)) => p1 i) nil op
                         (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))))
             (bigops.eq_bigop_O B
                (y:
                 (sttfa.etap
                    (sttfa.p
                       (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                          (sttfa.arrow B
                             (sttfa.arrow (sttfa.arrow B (sttfa.arrow B B))
                                (sttfa.arrow (sttfa.arrow nat.nat B) B)))))) =>
                 sttfa.impl (bigops.sameF_upto bool.bool nat.O p1 p2)
                   (sttfa.impl (bigops.sameF_p B nat.O p1 f g)
                      (logic.eq B
                         (bigops.bigop B nat.O
                            (i:(sttfa.etap (sttfa.p nat.nat)) => p1 i) nil
                            op (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
                         (y (i:(sttfa.etap (sttfa.p nat.nat)) => p1 i) nil
                            op (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))))
                (auto:
                 (sttfa.eps (bigops.sameF_upto bool.bool nat.O p1 p2)) =>
                 auto':(sttfa.eps (bigops.sameF_p B nat.O p1 f g)) =>
                 logic.refl B
                   (bigops.bigop B nat.O
                      (i:(sttfa.etap (sttfa.p nat.nat)) => p1 i) nil op
                      (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))))))
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     bigops.sym_eq_bigop_S B n
       (y:
        (sttfa.etap
           (sttfa.p
              (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                 (sttfa.arrow B
                    (sttfa.arrow (sttfa.arrow B (sttfa.arrow B B))
                       (sttfa.arrow (sttfa.arrow nat.nat B) B)))))) =>
        sttfa.impl
          (sttfa.impl (bigops.sameF_upto bool.bool n p1 p2)
             (sttfa.impl (bigops.sameF_p B n p1 f g)
                (logic.eq B
                   (bigops.bigop B n
                      (i:(sttfa.etap (sttfa.p nat.nat)) => p1 i) nil op
                      (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
                   (bigops.bigop B n
                      (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i) nil op
                      (i:(sttfa.etap (sttfa.p nat.nat)) => g i)))))
          (sttfa.impl (bigops.sameF_upto bool.bool (nat.S n) p1 p2)
             (sttfa.impl (bigops.sameF_p B (nat.S n) p1 f g)
                (logic.eq B
                   (bigops.bigop B (nat.S n)
                      (i:(sttfa.etap (sttfa.p nat.nat)) => p1 i) nil op
                      (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
                   (y (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i) nil op
                      (i:(sttfa.etap (sttfa.p nat.nat)) => g i))))))
       (bigops.sym_eq_bigop_S B n
          (y:
           (sttfa.etap
              (sttfa.p
                 (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                    (sttfa.arrow B
                       (sttfa.arrow (sttfa.arrow B (sttfa.arrow B B))
                          (sttfa.arrow (sttfa.arrow nat.nat B) B)))))) =>
           sttfa.impl
             (sttfa.impl (bigops.sameF_upto bool.bool n p1 p2)
                (sttfa.impl (bigops.sameF_p B n p1 f g)
                   (logic.eq B
                      (bigops.bigop B n
                         (i:(sttfa.etap (sttfa.p nat.nat)) => p1 i) nil op
                         (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
                      (bigops.bigop B n
                         (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i) nil op
                         (i:(sttfa.etap (sttfa.p nat.nat)) => g i)))))
             (sttfa.impl (bigops.sameF_upto bool.bool (nat.S n) p1 p2)
                (sttfa.impl (bigops.sameF_p B (nat.S n) p1 f g)
                   (logic.eq B
                      (y (i:(sttfa.etap (sttfa.p nat.nat)) => p1 i) nil op
                         (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
                      (bigops.bigop_body B (nat.S n)
                         (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i) nil op
                         (i:(sttfa.etap (sttfa.p nat.nat)) => g i))))))
          (bigops.sym_eq_bigop_body_S B n
             (y:
              (sttfa.etap
                 (sttfa.p
                    (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                       (sttfa.arrow B
                          (sttfa.arrow (sttfa.arrow B (sttfa.arrow B B))
                             (sttfa.arrow (sttfa.arrow nat.nat B) B)))))) =>
              sttfa.impl
                (sttfa.impl (bigops.sameF_upto bool.bool n p1 p2)
                   (sttfa.impl (bigops.sameF_p B n p1 f g)
                      (logic.eq B
                         (bigops.bigop B n
                            (i:(sttfa.etap (sttfa.p nat.nat)) => p1 i) nil
                            op (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
                         (bigops.bigop B n
                            (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i) nil
                            op (i:(sttfa.etap (sttfa.p nat.nat)) => g i)))))
                (sttfa.impl (bigops.sameF_upto bool.bool (nat.S n) p1 p2)
                   (sttfa.impl (bigops.sameF_p B (nat.S n) p1 f g)
                      (logic.eq B
                         (y (i:(sttfa.etap (sttfa.p nat.nat)) => p1 i) nil
                            op (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
                         (bigops.bigop_body B (nat.S n)
                            (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i) nil
                            op (i:(sttfa.etap (sttfa.p nat.nat)) => g i))))))
             (bigops.sym_eq_bigop_body_S B n
                (y:
                 (sttfa.etap
                    (sttfa.p
                       (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                          (sttfa.arrow B
                             (sttfa.arrow (sttfa.arrow B (sttfa.arrow B B))
                                (sttfa.arrow (sttfa.arrow nat.nat B) B)))))) =>
                 sttfa.impl
                   (sttfa.impl (bigops.sameF_upto bool.bool n p1 p2)
                      (sttfa.impl (bigops.sameF_p B n p1 f g)
                         (logic.eq B
                            (bigops.bigop B n
                               (i:(sttfa.etap (sttfa.p nat.nat)) => p1 i)
                               nil op
                               (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
                            (bigops.bigop B n
                               (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i)
                               nil op
                               (i:(sttfa.etap (sttfa.p nat.nat)) => g i)))))
                   (sttfa.impl (bigops.sameF_upto bool.bool (nat.S n) p1 p2)
                      (sttfa.impl (bigops.sameF_p B (nat.S n) p1 f g)
                         (logic.eq B
                            ((p:
                              (sttfa.etap
                                 (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
                              nil0:(sttfa.etap (sttfa.p B)) =>
                              op0:
                              (sttfa.etap
                                 (sttfa.p (sttfa.arrow B (sttfa.arrow B B)))) =>
                              f0:
                              (sttfa.etap (sttfa.p (sttfa.arrow nat.nat B))) =>
                              bool.match_bool_type B
                                (op0 (f0 n) (bigops.bigop B n p nil0 op0 f0))
                                (bigops.bigop B n p nil0 op0 f0) (p n))
                               (i:(sttfa.etap (sttfa.p nat.nat)) => p1 i)
                               nil op
                               (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
                            (y (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i)
                               nil op
                               (i:(sttfa.etap (sttfa.p nat.nat)) => g i))))))
                (Hind:
                 (sttfa.eps
                    (sttfa.impl (bigops.sameF_upto bool.bool n p1 p2)
                       (sttfa.impl (bigops.sameF_p B n p1 f g)
                          (logic.eq B
                             (bigops.bigop B n
                                (i:(sttfa.etap (sttfa.p nat.nat)) => p1 i)
                                nil op
                                (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
                             (bigops.bigop B n
                                (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i)
                                nil op
                                (i:(sttfa.etap (sttfa.p nat.nat)) => g i)))))) =>
                 samep:
                 (sttfa.eps (bigops.sameF_upto bool.bool (nat.S n) p1 p2)) =>
                 samef:(sttfa.eps (bigops.sameF_p B (nat.S n) p1 f g)) =>
                 logic.eq_ind_r B
                   (bigops.bigop B n
                      (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i) nil op
                      (i:(sttfa.etap (sttfa.p nat.nat)) => g i))
                   (x:(sttfa.etap (sttfa.p B)) =>
                    logic.eq B
                      (bool.match_bool_type B (op (f n) x) x (p1 n))
                      (bool.match_bool_type B
                         (op (g n)
                            (bigops.bigop B n
                               (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i)
                               nil op
                               (i:(sttfa.etap (sttfa.p nat.nat)) => g i)))
                         (bigops.bigop B n
                            (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i) nil
                            op (i:(sttfa.etap (sttfa.p nat.nat)) => g i))
                         (p2 n)))
                   (logic.eq_ind bool.bool (p1 n)
                      (x_1:(sttfa.etap (sttfa.p bool.bool)) =>
                       logic.eq B
                         (bool.match_bool_type B
                            (op (f n)
                               (bigops.bigop B n
                                  (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i)
                                  nil op
                                  (i:(sttfa.etap (sttfa.p nat.nat)) => g i)))
                            (bigops.bigop B n
                               (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i)
                               nil op
                               (i:(sttfa.etap (sttfa.p nat.nat)) => g i))
                            (p1 n))
                         (bool.match_bool_type B
                            (op (g n)
                               (bigops.bigop B n
                                  (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i)
                                  nil op
                                  (i:(sttfa.etap (sttfa.p nat.nat)) => g i)))
                            (bigops.bigop B n
                               (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i)
                               nil op
                               (i:(sttfa.etap (sttfa.p nat.nat)) => g i)) x_1))
                      (connectives.match_Or_prop
                         (logic.eq bool.bool (p1 n) bool.true)
                         (logic.eq bool.bool (p1 n) bool.false)
                         (logic.eq B
                            (bool.match_bool_type B
                               (op (f n)
                                  (bigops.bigop B n
                                     (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                      p2 i) nil op
                                     (i:(sttfa.etap (sttfa.p nat.nat)) => g i)))
                               (bigops.bigop B n
                                  (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i)
                                  nil op
                                  (i:(sttfa.etap (sttfa.p nat.nat)) => g i))
                               (p1 n))
                            (bool.match_bool_type B
                               (op (g n)
                                  (bigops.bigop B n
                                     (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                      p2 i) nil op
                                     (i:(sttfa.etap (sttfa.p nat.nat)) => g i)))
                               (bigops.bigop B n
                                  (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i)
                                  nil op
                                  (i:(sttfa.etap (sttfa.p nat.nat)) => g i))
                               (p1 n)))
                         (H1:
                          (sttfa.eps (logic.eq bool.bool (p1 n) bool.true)) =>
                          logic.eq_ind_r bool.bool bool.true
                            (x:(sttfa.etap (sttfa.p bool.bool)) =>
                             logic.eq B
                               (bool.match_bool_type B
                                  (op (f n)
                                     (bigops.bigop B n
                                        (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                         p2 i) nil op
                                        (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                         g i)))
                                  (bigops.bigop B n
                                     (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                      p2 i) nil op
                                     (i:(sttfa.etap (sttfa.p nat.nat)) => g i))
                                  x)
                               (bool.match_bool_type B
                                  (op (g n)
                                     (bigops.bigop B n
                                        (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                         p2 i) nil op
                                        (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                         g i)))
                                  (bigops.bigop B n
                                     (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                      p2 i) nil op
                                     (i:(sttfa.etap (sttfa.p nat.nat)) => g i))
                                  x))
                            (bool.sym_eq_match_bool_type_true B
                               (op (f n)
                                  (bigops.bigop B n
                                     (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                      p2 i) nil op
                                     (i:(sttfa.etap (sttfa.p nat.nat)) => g i)))
                               (bigops.bigop B n
                                  (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i)
                                  nil op
                                  (i:(sttfa.etap (sttfa.p nat.nat)) => g i))
                               (y:(sttfa.etap (sttfa.p B)) =>
                                logic.eq B y
                                  (bool.match_bool_type B
                                     (op (g n)
                                        (bigops.bigop B n
                                           (i:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            p2 i) nil op
                                           (i:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            g i)))
                                     (bigops.bigop B n
                                        (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                         p2 i) nil op
                                        (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                         g i)) bool.true))
                               (bool.sym_eq_match_bool_type_true B
                                  (op (g n)
                                     (bigops.bigop B n
                                        (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                         p2 i) nil op
                                        (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                         g i)))
                                  (bigops.bigop B n
                                     (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                      p2 i) nil op
                                     (i:(sttfa.etap (sttfa.p nat.nat)) => g i))
                                  (y:(sttfa.etap (sttfa.p B)) =>
                                   logic.eq B
                                     (op (f n)
                                        (bigops.bigop B n
                                           (i:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            p2 i) nil op
                                           (i:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            g i))) y)
                                  (logic.eq_ind B (f n)
                                     (x_1:(sttfa.etap (sttfa.p B)) =>
                                      logic.eq B
                                        (op (f n)
                                           (bigops.bigop B n
                                              (i:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               p2 i) nil op
                                              (i:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               g i)))
                                        (op x_1
                                           (bigops.bigop B n
                                              (i:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               p2 i) nil op
                                              (i:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               g i))))
                                     (logic.refl B
                                        (op (f n)
                                           (bigops.bigop B n
                                              (i:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               p2 i) nil op
                                              (i:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               g i)))) (g n)
                                     (samef n (nat.le_n (nat.S n)) H1))))
                            (p1 n) H1)
                         (H1:
                          (sttfa.eps (logic.eq bool.bool (p1 n) bool.false)) =>
                          logic.eq_ind_r bool.bool bool.false
                            (x:(sttfa.etap (sttfa.p bool.bool)) =>
                             logic.eq B
                               (bool.match_bool_type B
                                  (op (f n)
                                     (bigops.bigop B n
                                        (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                         p2 i) nil op
                                        (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                         g i)))
                                  (bigops.bigop B n
                                     (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                      p2 i) nil op
                                     (i:(sttfa.etap (sttfa.p nat.nat)) => g i))
                                  x)
                               (bool.match_bool_type B
                                  (op (g n)
                                     (bigops.bigop B n
                                        (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                         p2 i) nil op
                                        (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                         g i)))
                                  (bigops.bigop B n
                                     (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                      p2 i) nil op
                                     (i:(sttfa.etap (sttfa.p nat.nat)) => g i))
                                  x))
                            (bool.sym_eq_match_bool_type_false B
                               (op (f n)
                                  (bigops.bigop B n
                                     (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                      p2 i) nil op
                                     (i:(sttfa.etap (sttfa.p nat.nat)) => g i)))
                               (bigops.bigop B n
                                  (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i)
                                  nil op
                                  (i:(sttfa.etap (sttfa.p nat.nat)) => g i))
                               (y:(sttfa.etap (sttfa.p B)) =>
                                logic.eq B y
                                  (bool.match_bool_type B
                                     (op (g n)
                                        (bigops.bigop B n
                                           (i:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            p2 i) nil op
                                           (i:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            g i)))
                                     (bigops.bigop B n
                                        (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                         p2 i) nil op
                                        (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                         g i)) bool.false))
                               (bool.sym_eq_match_bool_type_false B
                                  (op (g n)
                                     (bigops.bigop B n
                                        (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                         p2 i) nil op
                                        (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                         g i)))
                                  (bigops.bigop B n
                                     (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                      p2 i) nil op
                                     (i:(sttfa.etap (sttfa.p nat.nat)) => g i))
                                  (y:(sttfa.etap (sttfa.p B)) =>
                                   logic.eq B
                                     (bigops.bigop B n
                                        (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                         p2 i) nil op
                                        (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                         g i)) y)
                                  (logic.refl B
                                     (bigops.bigop B n
                                        (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                         p2 i) nil op
                                        (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                         g i))))) (p1 n) H1)
                         (bool.true_or_false (p1 n))) (p2 n)
                      (samep n (nat.le_n (nat.S n))))
                   (bigops.bigop B n
                      (i:(sttfa.etap (sttfa.p nat.nat)) => p1 i) nil op
                      (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
                   (Hind
                      (bigops.sameF_upto_le bool.bool p1 p2 n (nat.S n)
                         (logic.eq_coerc
                            (nat.le (nat.pred (nat.S n)) (nat.S n))
                            (nat.le n (nat.S n)) (nat.le_pred_n (nat.S n))
                            (logic.rewrite_l nat.nat n
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq sttfa.bool (nat.le __ (nat.S n))
                                  (nat.le n (nat.S n)))
                               (logic.refl sttfa.bool (nat.le n (nat.S n)))
                               (nat.pred (nat.S n)) (nat.pred_Sn n))) samep)
                      (bigops.sameF_p_le B p1 f g n (nat.S n)
                         (logic.eq_coerc
                            (nat.le (nat.pred (nat.S n)) (nat.S n))
                            (nat.le n (nat.S n)) (nat.le_pred_n (nat.S n))
                            (logic.rewrite_l nat.nat n
                               (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                logic.eq sttfa.bool (nat.le __ (nat.S n))
                                  (nat.le n (nat.S n)))
                               (logic.refl sttfa.bool (nat.le n (nat.S n)))
                               (nat.pred (nat.S n)) (nat.pred_Sn n))) samef)))))))
    k.

def bigop_false :
  sttfa.eps
    (sttfa.forallP
       (B:sttfa.type =>
        sttfa.forall nat.nat
          (n:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall B
             (nil:(sttfa.etap (sttfa.p B)) =>
              sttfa.forall (sttfa.arrow B (sttfa.arrow B B))
                (op:
                 (sttfa.etap (sttfa.p (sttfa.arrow B (sttfa.arrow B B)))) =>
                 sttfa.forall (sttfa.arrow nat.nat B)
                   (f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat B))) =>
                    logic.eq B
                      (bigops.bigop B n
                         (i:(sttfa.etap (sttfa.p nat.nat)) => bool.false)
                         nil op (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
                      nil))))))
  :=
  B:sttfa.type =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nil:(sttfa.etap (sttfa.p B)) =>
  op:(sttfa.etap (sttfa.p (sttfa.arrow B (sttfa.arrow B B)))) =>
  f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat B))) =>
  nat.nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq B
       (bigops.bigop B _x_365
          (i:(sttfa.etap (sttfa.p nat.nat)) => bool.false) nil op
          (i:(sttfa.etap (sttfa.p nat.nat)) => f i)) nil)
    (bigops.eq_bigop_body_O B
       (y:
        (sttfa.etap
           (sttfa.p
              (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                 (sttfa.arrow B
                    (sttfa.arrow (sttfa.arrow B (sttfa.arrow B B))
                       (sttfa.arrow (sttfa.arrow nat.nat B) B)))))) =>
        logic.eq B
          (bigops.bigop B nat.O
             (i:(sttfa.etap (sttfa.p nat.nat)) => bool.false) nil op
             (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
          (y (i:(sttfa.etap (sttfa.p nat.nat)) => bool.false) nil op
             (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))
       (bigops.eq_bigop_O B
          (y:
           (sttfa.etap
              (sttfa.p
                 (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                    (sttfa.arrow B
                       (sttfa.arrow (sttfa.arrow B (sttfa.arrow B B))
                          (sttfa.arrow (sttfa.arrow nat.nat B) B)))))) =>
           logic.eq B
             (bigops.bigop B nat.O
                (i:(sttfa.etap (sttfa.p nat.nat)) => bool.false) nil op
                (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
             (y (i:(sttfa.etap (sttfa.p nat.nat)) => bool.false) nil op
                (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))
          (logic.refl B
             (bigops.bigop B nat.O
                (i:(sttfa.etap (sttfa.p nat.nat)) => bool.false) nil op
                (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))))
    (n1:(sttfa.etap (sttfa.p nat.nat)) =>
     Hind:
     (sttfa.eps
        (logic.eq B
           (bigops.bigop B n1
              (i:(sttfa.etap (sttfa.p nat.nat)) => bool.false) nil op
              (i:(sttfa.etap (sttfa.p nat.nat)) => f i)) nil)) =>
     logic.eq_ind_r B
       (bigops.bigop B n1 (i:(sttfa.etap (sttfa.p nat.nat)) => bool.false)
          nil op (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
       (x:(sttfa.etap (sttfa.p B)) => logic.eq B x nil)
       (logic.rewrite_r B nil
          (__:(sttfa.etap (sttfa.p B)) => logic.eq B __ nil)
          (logic.refl B nil)
          (bigops.bigop B n1
             (i:(sttfa.etap (sttfa.p nat.nat)) => bool.false) nil op
             (i:(sttfa.etap (sttfa.p nat.nat)) => f i)) Hind)
       (bigops.bigop B (nat.S n1)
          (i:(sttfa.etap (sttfa.p nat.nat)) => bool.false) nil op
          (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
       (bigops.bigop_Sfalse B n1
          (__:(sttfa.etap (sttfa.p nat.nat)) => bool.false) nil op f
          (logic.refl bool.bool bool.false))) n.

Aop :
  sttfa.etap
    (sttfa.forallK (A:sttfa.type => sttfa.p (sttfa.arrow A sttfa.bool))).

mk_Aop :
  sttfa.eps
    (sttfa.forallP
       (A:sttfa.type =>
        sttfa.forall A
          (nil:(sttfa.etap (sttfa.p A)) =>
           sttfa.forall (sttfa.arrow A (sttfa.arrow A A))
             (op:(sttfa.etap (sttfa.p (sttfa.arrow A (sttfa.arrow A A)))) =>
              sttfa.impl
                (sttfa.forall A
                   (a:(sttfa.etap (sttfa.p A)) => logic.eq A (op nil a) a))
                (sttfa.impl
                   (sttfa.forall A
                      (a:(sttfa.etap (sttfa.p A)) => logic.eq A (op a nil) a))
                   (sttfa.impl
                      (sttfa.forall A
                         (a:(sttfa.etap (sttfa.p A)) =>
                          sttfa.forall A
                            (b:(sttfa.etap (sttfa.p A)) =>
                             sttfa.forall A
                               (c:(sttfa.etap (sttfa.p A)) =>
                                logic.eq A (op a (op b c)) (op (op a b) c)))))
                      (bigops.Aop A nil))))))).

def assoc :
  sttfa.eps
    (sttfa.forall nat.nat
       (a:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (b:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall nat.nat
             (c:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat (nat.times a (nat.times b c))
                (nat.times (nat.times a b) c)))))
  :=
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  c:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.sym_eq nat.nat (nat.times (nat.times a b) c)
    (nat.times a (nat.times b c)) (nat.associative_times a b c).

def timesA :
  sttfa.eps (bigops.Aop nat.nat (nat.S nat.O))
  :=
  bigops.mk_Aop nat.nat (nat.S nat.O) nat.times
    (a:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_times (nat.S nat.O)
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        logic.eq nat.nat (y a) a)
       (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat)
          nat.times_body nat.O
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           logic.eq nat.nat (y a) a)
          (nat.sym_eq_times_body_S nat.O
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              logic.eq nat.nat (y a) a)
             (nat.sym_eq_times nat.O
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 logic.eq nat.nat (nat.plus a (y a)) a)
                (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat)
                   nat.times_body
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                    logic.eq nat.nat (nat.plus a (y a)) a)
                   (nat.sym_eq_times_body_O
                      (y:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       logic.eq nat.nat (nat.plus a (y a)) a)
                      (logic.sym_eq nat.nat a (nat.plus a nat.O)
                         (nat.plus_n_O a))))))))
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.sym_eq nat.nat n (nat.times n (nat.S nat.O)) (nat.times_n_1 n))
    (a:(sttfa.etap (sttfa.p nat.nat)) =>
     b:(sttfa.etap (sttfa.p nat.nat)) =>
     c:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.sym_eq nat.nat (nat.times (nat.times a b) c)
       (nat.times a (nat.times b c)) (nat.associative_times a b c)).

def bigop_I_gen :
  sttfa.eps
    (sttfa.forall nat.nat
       (a:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (b:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall (sttfa.arrow nat.nat bool.bool)
             (p:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
              sttfa.forall (sttfa.arrow nat.nat nat.nat)
                (f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 sttfa.impl (nat.le a b)
                   (logic.eq nat.nat
                      (bigops.bigop nat.nat (nat.minus b a)
                         (i:(sttfa.etap (sttfa.p nat.nat)) =>
                          p (nat.plus i a)) (nat.S nat.O) nat.times
                         (i:(sttfa.etap (sttfa.p nat.nat)) =>
                          f (nat.plus i a)))
                      (bigops.bigop nat.nat b
                         (i:(sttfa.etap (sttfa.p nat.nat)) =>
                          bool.andb (nat.leb a i) (p i)) (nat.S nat.O)
                         nat.times (i:(sttfa.etap (sttfa.p nat.nat)) => f i))))))))
  :=
  a:(sttfa.etap (sttfa.p nat.nat)) =>
  b:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.forall (sttfa.arrow nat.nat bool.bool)
       (p:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
        sttfa.forall (sttfa.arrow nat.nat nat.nat)
          (f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           sttfa.impl (nat.le a _x_365)
             (logic.eq nat.nat
                (bigops.bigop nat.nat (nat.minus _x_365 a)
                   (i:(sttfa.etap (sttfa.p nat.nat)) => p (nat.plus i a))
                   (nat.S nat.O) nat.times
                   (i:(sttfa.etap (sttfa.p nat.nat)) => f (nat.plus i a)))
                (bigops.bigop nat.nat _x_365
                   (i:(sttfa.etap (sttfa.p nat.nat)) =>
                    bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times
                   (i:(sttfa.etap (sttfa.p nat.nat)) => f i))))))
    (p:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
     f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
     bigops.sym_eq_bigop_O nat.nat
       (y:
        (sttfa.etap
           (sttfa.p
              (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                 (sttfa.arrow nat.nat
                    (sttfa.arrow
                       (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
                       (sttfa.arrow (sttfa.arrow nat.nat nat.nat) nat.nat)))))) =>
        sttfa.impl (nat.le a nat.O)
          (logic.eq nat.nat
             (bigops.bigop nat.nat (nat.minus nat.O a)
                (i:(sttfa.etap (sttfa.p nat.nat)) => p (nat.plus i a))
                (nat.S nat.O) nat.times
                (i:(sttfa.etap (sttfa.p nat.nat)) => f (nat.plus i a)))
             (y
                (i:(sttfa.etap (sttfa.p nat.nat)) =>
                 bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times
                (i:(sttfa.etap (sttfa.p nat.nat)) => f i))))
       (bigops.sym_eq_bigop_body_O nat.nat
          (y:
           (sttfa.etap
              (sttfa.p
                 (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                    (sttfa.arrow nat.nat
                       (sttfa.arrow
                          (sttfa.arrow nat.nat (sttfa.arrow nat.nat nat.nat))
                          (sttfa.arrow (sttfa.arrow nat.nat nat.nat) nat.nat)))))) =>
           sttfa.impl (nat.le a nat.O)
             (logic.eq nat.nat
                (bigops.bigop nat.nat (nat.minus nat.O a)
                   (i:(sttfa.etap (sttfa.p nat.nat)) => p (nat.plus i a))
                   (nat.S nat.O) nat.times
                   (i:(sttfa.etap (sttfa.p nat.nat)) => f (nat.plus i a)))
                (y
                   (i:(sttfa.etap (sttfa.p nat.nat)) =>
                    bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times
                   (i:(sttfa.etap (sttfa.p nat.nat)) => f i))))
          (bigops.eq_bigop_body_O nat.nat
             (y:
              (sttfa.etap
                 (sttfa.p
                    (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                       (sttfa.arrow nat.nat
                          (sttfa.arrow
                             (sttfa.arrow nat.nat
                                (sttfa.arrow nat.nat nat.nat))
                             (sttfa.arrow (sttfa.arrow nat.nat nat.nat)
                                nat.nat)))))) =>
              sttfa.impl (nat.le a nat.O)
                (logic.eq nat.nat
                   (bigops.bigop nat.nat (nat.minus nat.O a)
                      (i:(sttfa.etap (sttfa.p nat.nat)) => p (nat.plus i a))
                      (nat.S nat.O) nat.times
                      (i:(sttfa.etap (sttfa.p nat.nat)) => f (nat.plus i a)))
                   (y (i:(sttfa.etap (sttfa.p nat.nat)) => p (nat.plus i a))
                      (nat.S nat.O) nat.times
                      (i:(sttfa.etap (sttfa.p nat.nat)) => f (nat.plus i a)))))
             (bigops.eq_bigop_O nat.nat
                (y:
                 (sttfa.etap
                    (sttfa.p
                       (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                          (sttfa.arrow nat.nat
                             (sttfa.arrow
                                (sttfa.arrow nat.nat
                                   (sttfa.arrow nat.nat nat.nat))
                                (sttfa.arrow (sttfa.arrow nat.nat nat.nat)
                                   nat.nat)))))) =>
                 sttfa.impl (nat.le a nat.O)
                   (logic.eq nat.nat
                      (bigops.bigop nat.nat (nat.minus nat.O a)
                         (i:(sttfa.etap (sttfa.p nat.nat)) =>
                          p (nat.plus i a)) (nat.S nat.O) nat.times
                         (i:(sttfa.etap (sttfa.p nat.nat)) =>
                          f (nat.plus i a)))
                      (y
                         (i:(sttfa.etap (sttfa.p nat.nat)) =>
                          p (nat.plus i a)) (nat.S nat.O) nat.times
                         (i:(sttfa.etap (sttfa.p nat.nat)) =>
                          f (nat.plus i a)))))
                (nat.eq_minus_body_O
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                    sttfa.impl (nat.le a nat.O)
                      (logic.eq nat.nat
                         (bigops.bigop nat.nat (nat.minus nat.O a)
                            (i:(sttfa.etap (sttfa.p nat.nat)) =>
                             p (nat.plus i a)) (nat.S nat.O) nat.times
                            (i:(sttfa.etap (sttfa.p nat.nat)) =>
                             f (nat.plus i a)))
                         (bigops.bigop nat.nat (y a)
                            (i:(sttfa.etap (sttfa.p nat.nat)) =>
                             p (nat.plus i a)) (nat.S nat.O) nat.times
                            (i:(sttfa.etap (sttfa.p nat.nat)) =>
                             f (nat.plus i a)))))
                   (nat.eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat)
                      nat.minus_body
                      (y:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       sttfa.impl (nat.le a nat.O)
                         (logic.eq nat.nat
                            (bigops.bigop nat.nat (nat.minus nat.O a)
                               (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                p (nat.plus i a)) (nat.S nat.O) nat.times
                               (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                f (nat.plus i a)))
                            (bigops.bigop nat.nat (y a)
                               (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                p (nat.plus i a)) (nat.S nat.O) nat.times
                               (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                f (nat.plus i a)))))
                      (nat.eq_minus nat.O
                         (y:
                          (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                          sttfa.impl (nat.le a nat.O)
                            (logic.eq nat.nat
                               (bigops.bigop nat.nat (nat.minus nat.O a)
                                  (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                   p (nat.plus i a)) (nat.S nat.O) nat.times
                                  (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                   f (nat.plus i a)))
                               (bigops.bigop nat.nat (y a)
                                  (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                   p (nat.plus i a)) (nat.S nat.O) nat.times
                                  (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                   f (nat.plus i a)))))
                         (auto:(sttfa.eps (nat.le a nat.O)) =>
                          logic.refl nat.nat
                            (bigops.bigop nat.nat (nat.minus nat.O a)
                               (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                p (nat.plus i a)) (nat.S nat.O) nat.times
                               (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                f (nat.plus i a)))))))))))
    (b0:(sttfa.etap (sttfa.p nat.nat)) =>
     Hind:
     (sttfa.eps
        (sttfa.forall (sttfa.arrow nat.nat bool.bool)
           (p:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
            sttfa.forall (sttfa.arrow nat.nat nat.nat)
              (f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
               sttfa.impl (nat.le a b0)
                 (logic.eq nat.nat
                    (bigops.bigop nat.nat (nat.minus b0 a)
                       (i:(sttfa.etap (sttfa.p nat.nat)) => p (nat.plus i a))
                       (nat.S nat.O) nat.times
                       (i:(sttfa.etap (sttfa.p nat.nat)) => f (nat.plus i a)))
                    (bigops.bigop nat.nat b0
                       (i:(sttfa.etap (sttfa.p nat.nat)) =>
                        bool.andb (nat.leb a i) (p i)) (nat.S nat.O)
                       nat.times (i:(sttfa.etap (sttfa.p nat.nat)) => f i))))))) =>
     p:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
     f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
     lea:(sttfa.eps (nat.le a (nat.S b0))) =>
     connectives.match_Or_prop (nat.lt a (nat.S b0))
       (logic.eq nat.nat a (nat.S b0))
       (logic.eq nat.nat
          (bigops.bigop nat.nat (nat.minus (nat.S b0) a)
             (i:(sttfa.etap (sttfa.p nat.nat)) => p (nat.plus i a))
             (nat.S nat.O) nat.times
             (i:(sttfa.etap (sttfa.p nat.nat)) => f (nat.plus i a)))
          (bigops.bigop nat.nat (nat.S b0)
             (i:(sttfa.etap (sttfa.p nat.nat)) =>
              bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times
             (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))
       (Ha:(sttfa.eps (nat.lt a (nat.S b0))) =>
        connectives.match_Or_prop (logic.eq bool.bool (p b0) bool.true)
          (logic.eq bool.bool (p b0) bool.false)
          (logic.eq nat.nat
             (bigops.bigop nat.nat (nat.minus (nat.S b0) a)
                (i:(sttfa.etap (sttfa.p nat.nat)) => p (nat.plus i a))
                (nat.S nat.O) nat.times
                (i:(sttfa.etap (sttfa.p nat.nat)) => f (nat.plus i a)))
             (bigops.bigop nat.nat (nat.S b0)
                (i:(sttfa.etap (sttfa.p nat.nat)) =>
                 bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times
                (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))
          (Hcase:(sttfa.eps (logic.eq bool.bool (p b0) bool.true)) =>
           logic.eq_ind_r nat.nat
             (nat.times (f b0)
                (bigops.bigop nat.nat b0
                   (i:(sttfa.etap (sttfa.p nat.nat)) =>
                    bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times
                   (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))
             (x:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat
                (bigops.bigop nat.nat (nat.minus (nat.S b0) a)
                   (i:(sttfa.etap (sttfa.p nat.nat)) => p (nat.plus i a))
                   (nat.S nat.O) nat.times
                   (i:(sttfa.etap (sttfa.p nat.nat)) => f (nat.plus i a))) x)
             (logic.eq_ind_r nat.nat (nat.S (nat.minus b0 a))
                (x:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat
                   (bigops.bigop nat.nat x
                      (i:(sttfa.etap (sttfa.p nat.nat)) => p (nat.plus i a))
                      (nat.S nat.O) nat.times
                      (i:(sttfa.etap (sttfa.p nat.nat)) => f (nat.plus i a)))
                   (nat.times (f b0)
                      (bigops.bigop nat.nat b0
                         (i:(sttfa.etap (sttfa.p nat.nat)) =>
                          bool.andb (nat.leb a i) (p i)) (nat.S nat.O)
                         nat.times (i:(sttfa.etap (sttfa.p nat.nat)) => f i))))
                (logic.eq_ind_r nat.nat
                   (nat.times (f (nat.plus (nat.minus b0 a) a))
                      (bigops.bigop nat.nat (nat.minus b0 a)
                         (i:(sttfa.etap (sttfa.p nat.nat)) =>
                          p (nat.plus i a)) (nat.S nat.O) nat.times
                         (i:(sttfa.etap (sttfa.p nat.nat)) =>
                          f (nat.plus i a))))
                   (x:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat x
                      (nat.times (f b0)
                         (bigops.bigop nat.nat b0
                            (i:(sttfa.etap (sttfa.p nat.nat)) =>
                             bool.andb (nat.leb a i) (p i)) (nat.S nat.O)
                            nat.times
                            (i:(sttfa.etap (sttfa.p nat.nat)) => f i))))
                   (logic.eq_f2 nat.nat nat.nat nat.nat nat.times
                      (f (nat.plus (nat.minus b0 a) a)) (f b0)
                      (bigops.bigop nat.nat (nat.minus b0 a)
                         (i:(sttfa.etap (sttfa.p nat.nat)) =>
                          p (nat.plus i a)) (nat.S nat.O) nat.times
                         (i:(sttfa.etap (sttfa.p nat.nat)) =>
                          f (nat.plus i a)))
                      (bigops.bigop nat.nat b0
                         (i:(sttfa.etap (sttfa.p nat.nat)) =>
                          bool.andb (nat.leb a i) (p i)) (nat.S nat.O)
                         nat.times (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
                      (logic.eq_f nat.nat nat.nat f
                         (nat.plus (nat.minus b0 a) a) b0
                         (logic.eq_ind nat.nat b0
                            (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq nat.nat x_1 b0)
                            (logic.refl nat.nat b0)
                            (nat.plus (nat.minus b0 a) a)
                            (nat.plus_minus_m_m b0 a
                               (nat.le_S_S_to_le a b0 Ha))))
                      (Hind p f (nat.le_S_S_to_le a b0 Ha)))
                   (bigops.bigop nat.nat (nat.S (nat.minus b0 a))
                      (i:(sttfa.etap (sttfa.p nat.nat)) => p (nat.plus i a))
                      (nat.S nat.O) nat.times
                      (i:(sttfa.etap (sttfa.p nat.nat)) => f (nat.plus i a)))
                   (bigops.bigop_Strue nat.nat (nat.minus b0 a)
                      (__:(sttfa.etap (sttfa.p nat.nat)) => p (nat.plus __ a))
                      (nat.S nat.O) nat.times
                      (__:(sttfa.etap (sttfa.p nat.nat)) => f (nat.plus __ a))
                      (logic.eq_ind nat.nat b0
                         (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq bool.bool (p x_1) bool.true)
                         (logic.rewrite_r bool.bool bool.true
                            (__:(sttfa.etap (sttfa.p bool.bool)) =>
                             logic.eq bool.bool __ bool.true)
                            (logic.refl bool.bool bool.true) (p b0) Hcase)
                         (nat.plus (nat.minus b0 a) a)
                         (nat.plus_minus_m_m b0 a (nat.le_S_S_to_le a b0 Ha)))))
                (nat.minus (nat.S b0) a)
                (nat.match_nat_prop
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (nat.le __ b0)
                      (logic.eq nat.nat (nat.minus (nat.S b0) __)
                         (nat.S (nat.minus b0 __))))
                   (auto:(sttfa.eps (nat.le nat.O b0)) =>
                    logic.rewrite_l nat.nat (nat.S b0)
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat __ (nat.S (nat.minus b0 nat.O)))
                      (logic.rewrite_l nat.nat b0
                         (__:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat (nat.S b0) (nat.S __))
                         (logic.refl nat.nat (nat.S b0))
                         (nat.minus b0 nat.O) (nat.minus_n_O b0))
                      (nat.minus (nat.S b0) nat.O) (nat.minus_n_O (nat.S b0)))
                   (nat.sym_eq_minus (nat.S b0)
                      (y:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       sttfa.forall nat.nat
                         (n:(sttfa.etap (sttfa.p nat.nat)) =>
                          sttfa.impl (nat.le (nat.S n) b0)
                            (logic.eq nat.nat (y (nat.S n))
                               (nat.S (nat.minus b0 (nat.S n))))))
                      (nat.sym_eq_filter_nat_type_S
                         (sttfa.arrow nat.nat nat.nat) nat.minus_body b0
                         (y:
                          (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                          sttfa.forall nat.nat
                            (n:(sttfa.etap (sttfa.p nat.nat)) =>
                             sttfa.impl (nat.le (nat.S n) b0)
                               (logic.eq nat.nat (y (nat.S n))
                                  (nat.S (nat.minus b0 (nat.S n))))))
                         (a1:(sttfa.etap (sttfa.p nat.nat)) =>
                          nat.sym_eq_minus_body_S b0
                            (y:
                             (sttfa.etap
                                (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                             sttfa.impl (nat.le (nat.S a1) b0)
                               (logic.eq nat.nat (y (nat.S a1))
                                  (nat.S (nat.minus b0 (nat.S a1)))))
                            (nat.sym_eq_match_nat_type_S nat.nat (nat.S b0)
                               (q:(sttfa.etap (sttfa.p nat.nat)) =>
                                nat.minus b0 q) a1
                               (y:(sttfa.etap (sttfa.p nat.nat)) =>
                                sttfa.impl (nat.le (nat.S a1) b0)
                                  (logic.eq nat.nat y
                                     (nat.S (nat.minus b0 (nat.S a1)))))
                               (lta1:(sttfa.eps (nat.le (nat.S a1) b0)) =>
                                logic.eq_ind_r nat.nat
                                  (nat.pred (nat.minus b0 a1))
                                  (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq nat.nat (nat.minus b0 a1)
                                     (nat.S x))
                                  (logic.eq_ind_r nat.nat (nat.minus b0 a1)
                                     (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq nat.nat (nat.minus b0 a1) x)
                                     (logic.refl nat.nat (nat.minus b0 a1))
                                     (nat.S (nat.pred (nat.minus b0 a1)))
                                     (nat.S_pred (nat.minus b0 a1)
                                        (nat.lt_plus_to_minus_r nat.O a1 b0
                                           (nat.sym_eq_plus nat.O
                                              (y:
                                               (sttfa.etap
                                                  (sttfa.p
                                                     (sttfa.arrow nat.nat
                                                        nat.nat))) =>
                                               nat.le (nat.S (y a1)) b0)
                                              (nat.sym_eq_filter_nat_type_O
                                                 (sttfa.arrow nat.nat nat.nat)
                                                 nat.plus_body
                                                 (y:
                                                  (sttfa.etap
                                                     (sttfa.p
                                                        (sttfa.arrow nat.nat
                                                           nat.nat))) =>
                                                  nat.le (nat.S (y a1)) b0)
                                                 (nat.sym_eq_plus_body_O
                                                    (y:
                                                     (sttfa.etap
                                                        (sttfa.p
                                                           (sttfa.arrow
                                                              nat.nat nat.nat))) =>
                                                     nat.le (nat.S (y a1)) b0)
                                                    lta1))))))
                                  (nat.minus b0 (nat.S a1))
                                  (nat.eq_minus_S_pred b0 a1)))))) a
                   (nat.le_S_S_to_le a b0 Ha)))
             (bigops.bigop nat.nat (nat.S b0)
                (i:(sttfa.etap (sttfa.p nat.nat)) =>
                 bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times
                (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
             (bigops.bigop_Strue nat.nat b0
                (__:(sttfa.etap (sttfa.p nat.nat)) =>
                 bool.andb (nat.leb a __) (p __)) (nat.S nat.O) nat.times f
                (logic.eq_ind_r bool.bool bool.true
                   (x:(sttfa.etap (sttfa.p bool.bool)) =>
                    logic.eq bool.bool (bool.andb (nat.leb a b0) x) bool.true)
                   (logic.eq_ind_r bool.bool bool.true
                      (x:(sttfa.etap (sttfa.p bool.bool)) =>
                       logic.eq bool.bool (bool.andb x bool.true) bool.true)
                      (bool.eq_match_bool_type_true bool.bool bool.true
                         bool.false
                         (y:(sttfa.etap (sttfa.p bool.bool)) =>
                          logic.eq bool.bool
                            (bool.match_bool_type bool.bool bool.true
                               bool.false bool.true) y)
                         (logic.refl bool.bool
                            (bool.andb bool.true bool.true))) (nat.leb a b0)
                      (nat.le_to_leb_true a b0 (nat.le_S_S_to_le a b0 Ha)))
                   (p b0) Hcase)))
          (Hcase:(sttfa.eps (logic.eq bool.bool (p b0) bool.false)) =>
           logic.eq_ind_r nat.nat
             (bigops.bigop nat.nat b0
                (i:(sttfa.etap (sttfa.p nat.nat)) =>
                 bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times
                (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
             (x:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat
                (bigops.bigop nat.nat (nat.minus (nat.S b0) a)
                   (i:(sttfa.etap (sttfa.p nat.nat)) => p (nat.plus i a))
                   (nat.S nat.O) nat.times
                   (i:(sttfa.etap (sttfa.p nat.nat)) => f (nat.plus i a))) x)
             (logic.eq_ind_r nat.nat (nat.S (nat.minus b0 a))
                (x:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat
                   (bigops.bigop nat.nat x
                      (i:(sttfa.etap (sttfa.p nat.nat)) => p (nat.plus i a))
                      (nat.S nat.O) nat.times
                      (i:(sttfa.etap (sttfa.p nat.nat)) => f (nat.plus i a)))
                   (bigops.bigop nat.nat b0
                      (i:(sttfa.etap (sttfa.p nat.nat)) =>
                       bool.andb (nat.leb a i) (p i)) (nat.S nat.O)
                      nat.times (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))
                (logic.eq_ind_r nat.nat
                   (bigops.bigop nat.nat (nat.minus b0 a)
                      (i:(sttfa.etap (sttfa.p nat.nat)) => p (nat.plus i a))
                      (nat.S nat.O) nat.times
                      (i:(sttfa.etap (sttfa.p nat.nat)) => f (nat.plus i a)))
                   (x:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat x
                      (bigops.bigop nat.nat b0
                         (i:(sttfa.etap (sttfa.p nat.nat)) =>
                          bool.andb (nat.leb a i) (p i)) (nat.S nat.O)
                         nat.times (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))
                   (Hind p f (nat.le_S_S_to_le a b0 Ha))
                   (bigops.bigop nat.nat (nat.S (nat.minus b0 a))
                      (i:(sttfa.etap (sttfa.p nat.nat)) => p (nat.plus i a))
                      (nat.S nat.O) nat.times
                      (i:(sttfa.etap (sttfa.p nat.nat)) => f (nat.plus i a)))
                   (bigops.bigop_Sfalse nat.nat (nat.minus b0 a)
                      (__:(sttfa.etap (sttfa.p nat.nat)) => p (nat.plus __ a))
                      (nat.S nat.O) nat.times
                      (__:(sttfa.etap (sttfa.p nat.nat)) => f (nat.plus __ a))
                      (logic.eq_ind nat.nat b0
                         (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq bool.bool (p x_1) bool.false)
                         (logic.rewrite_r bool.bool bool.false
                            (__:(sttfa.etap (sttfa.p bool.bool)) =>
                             logic.eq bool.bool __ bool.false)
                            (logic.refl bool.bool bool.false) (p b0) Hcase)
                         (nat.plus (nat.minus b0 a) a)
                         (nat.plus_minus_m_m b0 a (nat.le_S_S_to_le a b0 Ha)))))
                (nat.minus (nat.S b0) a)
                (nat.match_nat_prop
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.impl (nat.le __ b0)
                      (logic.eq nat.nat (nat.minus (nat.S b0) __)
                         (nat.S (nat.minus b0 __))))
                   (auto:(sttfa.eps (nat.le nat.O b0)) =>
                    logic.rewrite_l nat.nat (nat.S b0)
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat __ (nat.S (nat.minus b0 nat.O)))
                      (logic.rewrite_l nat.nat b0
                         (__:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat (nat.S b0) (nat.S __))
                         (logic.refl nat.nat (nat.S b0))
                         (nat.minus b0 nat.O) (nat.minus_n_O b0))
                      (nat.minus (nat.S b0) nat.O) (nat.minus_n_O (nat.S b0)))
                   (nat.sym_eq_minus (nat.S b0)
                      (y:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       sttfa.forall nat.nat
                         (n:(sttfa.etap (sttfa.p nat.nat)) =>
                          sttfa.impl (nat.le (nat.S n) b0)
                            (logic.eq nat.nat (y (nat.S n))
                               (nat.S (nat.minus b0 (nat.S n))))))
                      (nat.sym_eq_filter_nat_type_S
                         (sttfa.arrow nat.nat nat.nat) nat.minus_body b0
                         (y:
                          (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                          sttfa.forall nat.nat
                            (n:(sttfa.etap (sttfa.p nat.nat)) =>
                             sttfa.impl (nat.le (nat.S n) b0)
                               (logic.eq nat.nat (y (nat.S n))
                                  (nat.S (nat.minus b0 (nat.S n))))))
                         (a1:(sttfa.etap (sttfa.p nat.nat)) =>
                          nat.sym_eq_minus_body_S b0
                            (y:
                             (sttfa.etap
                                (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                             sttfa.impl (nat.le (nat.S a1) b0)
                               (logic.eq nat.nat (y (nat.S a1))
                                  (nat.S (nat.minus b0 (nat.S a1)))))
                            (nat.sym_eq_match_nat_type_S nat.nat (nat.S b0)
                               (q:(sttfa.etap (sttfa.p nat.nat)) =>
                                nat.minus b0 q) a1
                               (y:(sttfa.etap (sttfa.p nat.nat)) =>
                                sttfa.impl (nat.le (nat.S a1) b0)
                                  (logic.eq nat.nat y
                                     (nat.S (nat.minus b0 (nat.S a1)))))
                               (lta1:(sttfa.eps (nat.le (nat.S a1) b0)) =>
                                logic.eq_ind_r nat.nat
                                  (nat.pred (nat.minus b0 a1))
                                  (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq nat.nat (nat.minus b0 a1)
                                     (nat.S x))
                                  (logic.eq_ind_r nat.nat (nat.minus b0 a1)
                                     (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq nat.nat (nat.minus b0 a1) x)
                                     (logic.refl nat.nat (nat.minus b0 a1))
                                     (nat.S (nat.pred (nat.minus b0 a1)))
                                     (nat.S_pred (nat.minus b0 a1)
                                        (nat.lt_plus_to_minus_r nat.O a1 b0
                                           (nat.sym_eq_plus nat.O
                                              (y:
                                               (sttfa.etap
                                                  (sttfa.p
                                                     (sttfa.arrow nat.nat
                                                        nat.nat))) =>
                                               nat.le (nat.S (y a1)) b0)
                                              (nat.sym_eq_filter_nat_type_O
                                                 (sttfa.arrow nat.nat nat.nat)
                                                 nat.plus_body
                                                 (y:
                                                  (sttfa.etap
                                                     (sttfa.p
                                                        (sttfa.arrow nat.nat
                                                           nat.nat))) =>
                                                  nat.le (nat.S (y a1)) b0)
                                                 (nat.sym_eq_plus_body_O
                                                    (y:
                                                     (sttfa.etap
                                                        (sttfa.p
                                                           (sttfa.arrow
                                                              nat.nat nat.nat))) =>
                                                     nat.le (nat.S (y a1)) b0)
                                                    lta1))))))
                                  (nat.minus b0 (nat.S a1))
                                  (nat.eq_minus_S_pred b0 a1)))))) a
                   (nat.le_S_S_to_le a b0 Ha)))
             (bigops.bigop nat.nat (nat.S b0)
                (i:(sttfa.etap (sttfa.p nat.nat)) =>
                 bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times
                (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
             (bigops.bigop_Sfalse nat.nat b0
                (__:(sttfa.etap (sttfa.p nat.nat)) =>
                 bool.andb (nat.leb a __) (p __)) (nat.S nat.O) nat.times f
                (logic.eq_ind_r bool.bool bool.false
                   (x:(sttfa.etap (sttfa.p bool.bool)) =>
                    logic.eq bool.bool (bool.andb (nat.leb a b0) x)
                      bool.false)
                   (bool.match_bool_prop
                      (__:(sttfa.etap (sttfa.p bool.bool)) =>
                       logic.eq bool.bool (bool.andb __ bool.false)
                         bool.false)
                      (bool.eq_match_bool_type_true bool.bool bool.false
                         bool.false
                         (y:(sttfa.etap (sttfa.p bool.bool)) =>
                          logic.eq bool.bool
                            (bool.match_bool_type bool.bool bool.false
                               bool.false bool.true) y)
                         (logic.refl bool.bool
                            (bool.andb bool.true bool.false)))
                      (bool.eq_match_bool_type_false bool.bool bool.false
                         bool.false
                         (y:(sttfa.etap (sttfa.p bool.bool)) =>
                          logic.eq bool.bool
                            (bool.match_bool_type bool.bool bool.false
                               bool.false bool.false) y)
                         (logic.refl bool.bool
                            (bool.andb bool.false bool.false)))
                      (nat.leb a b0)) (p b0) Hcase)))
          (bool.true_or_false (p b0)))
       (Ha:(sttfa.eps (logic.eq nat.nat a (nat.S b0))) =>
        logic.eq_ind nat.nat a
          (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat
             (bigops.bigop nat.nat (nat.minus x_1 a)
                (i:(sttfa.etap (sttfa.p nat.nat)) => p (nat.plus i a))
                (nat.S nat.O) nat.times
                (i:(sttfa.etap (sttfa.p nat.nat)) => f (nat.plus i a)))
             (bigops.bigop nat.nat x_1
                (i:(sttfa.etap (sttfa.p nat.nat)) =>
                 bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times
                (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))
          (logic.eq_ind nat.nat nat.O
             (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat
                (bigops.bigop nat.nat x_1
                   (i:(sttfa.etap (sttfa.p nat.nat)) => p (nat.plus i a))
                   (nat.S nat.O) nat.times
                   (i:(sttfa.etap (sttfa.p nat.nat)) => f (nat.plus i a)))
                (bigops.bigop nat.nat a
                   (i:(sttfa.etap (sttfa.p nat.nat)) =>
                    bool.andb (nat.leb a i) (p i)) (nat.S nat.O) nat.times
                   (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))
             (bigops.sym_eq_bigop_O nat.nat
                (y:
                 (sttfa.etap
                    (sttfa.p
                       (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                          (sttfa.arrow nat.nat
                             (sttfa.arrow
                                (sttfa.arrow nat.nat
                                   (sttfa.arrow nat.nat nat.nat))
                                (sttfa.arrow (sttfa.arrow nat.nat nat.nat)
                                   nat.nat)))))) =>
                 logic.eq nat.nat
                   (y (i:(sttfa.etap (sttfa.p nat.nat)) => p (nat.plus i a))
                      (nat.S nat.O) nat.times
                      (i:(sttfa.etap (sttfa.p nat.nat)) => f (nat.plus i a)))
                   (bigops.bigop nat.nat a
                      (i:(sttfa.etap (sttfa.p nat.nat)) =>
                       bool.andb (nat.leb a i) (p i)) (nat.S nat.O)
                      nat.times (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))
                (bigops.sym_eq_bigop_body_O nat.nat
                   (y:
                    (sttfa.etap
                       (sttfa.p
                          (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                             (sttfa.arrow nat.nat
                                (sttfa.arrow
                                   (sttfa.arrow nat.nat
                                      (sttfa.arrow nat.nat nat.nat))
                                   (sttfa.arrow
                                      (sttfa.arrow nat.nat nat.nat) nat.nat)))))) =>
                    logic.eq nat.nat
                      (y
                         (i:(sttfa.etap (sttfa.p nat.nat)) =>
                          p (nat.plus i a)) (nat.S nat.O) nat.times
                         (i:(sttfa.etap (sttfa.p nat.nat)) =>
                          f (nat.plus i a)))
                      (bigops.bigop nat.nat a
                         (i:(sttfa.etap (sttfa.p nat.nat)) =>
                          bool.andb (nat.leb a i) (p i)) (nat.S nat.O)
                         nat.times (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))
                   (logic.eq_ind nat.nat
                      (bigops.bigop nat.nat a
                         (i:(sttfa.etap (sttfa.p nat.nat)) => bool.false)
                         (nat.S nat.O) nat.times
                         (i:(sttfa.etap (sttfa.p nat.nat)) => f i))
                      (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat x_1
                         (bigops.bigop nat.nat a
                            (i:(sttfa.etap (sttfa.p nat.nat)) =>
                             bool.andb (nat.leb a i) (p i)) (nat.S nat.O)
                            nat.times
                            (i:(sttfa.etap (sttfa.p nat.nat)) => f i)))
                      (bigops.same_bigop nat.nat a
                         (__:(sttfa.etap (sttfa.p nat.nat)) => bool.false)
                         (__:(sttfa.etap (sttfa.p nat.nat)) =>
                          bool.andb (nat.leb a __) (p __)) (nat.S nat.O)
                         nat.times f f
                         (i:(sttfa.etap (sttfa.p nat.nat)) =>
                          ltia:(sttfa.eps (nat.lt i a)) =>
                          logic.eq_ind_r bool.bool bool.false
                            (x:(sttfa.etap (sttfa.p bool.bool)) =>
                             logic.eq bool.bool bool.false
                               (bool.andb x (p i)))
                            (bool.sym_eq_match_bool_type_false bool.bool
                               (p i) bool.false
                               (y:(sttfa.etap (sttfa.p bool.bool)) =>
                                logic.eq bool.bool bool.false y)
                               (logic.refl bool.bool bool.false))
                            (nat.leb a i)
                            (nat.not_le_to_leb_false a i
                               (nat.lt_to_not_le i a ltia)))
                         (i:(sttfa.etap (sttfa.p nat.nat)) =>
                          auto:(sttfa.eps (nat.lt i a)) =>
                          auto':
                          (sttfa.eps
                             (logic.eq bool.bool bool.false bool.true)) =>
                          logic.refl nat.nat (f i))) (nat.S nat.O)
                      (bigops.bigop_false nat.nat a (nat.S nat.O) nat.times f))))
             (nat.minus a a) (nat.minus_n_n a)) (nat.S b0) Ha)
       (nat.le_to_or_lt_eq a (nat.S b0) lea)) b.

ACop :
  sttfa.etap
    (sttfa.forallK (A:sttfa.type => sttfa.p (sttfa.arrow A sttfa.bool))).

mk_ACop :
  sttfa.eps
    (sttfa.forallP
       (A:sttfa.type =>
        sttfa.forall A
          (nil:(sttfa.etap (sttfa.p A)) =>
           sttfa.forall (sttfa.arrow A (sttfa.arrow A A))
             (op:(sttfa.etap (sttfa.p (sttfa.arrow A (sttfa.arrow A A)))) =>
              sttfa.impl
                (sttfa.forall A
                   (a:(sttfa.etap (sttfa.p A)) => logic.eq A (op nil a) a))
                (sttfa.impl
                   (sttfa.forall A
                      (a:(sttfa.etap (sttfa.p A)) => logic.eq A (op a nil) a))
                   (sttfa.impl
                      (sttfa.forall A
                         (a:(sttfa.etap (sttfa.p A)) =>
                          sttfa.forall A
                            (b:(sttfa.etap (sttfa.p A)) =>
                             sttfa.forall A
                               (c:(sttfa.etap (sttfa.p A)) =>
                                logic.eq A (op a (op b c)) (op (op a b) c)))))
                      (sttfa.impl
                         (sttfa.forall A
                            (a:(sttfa.etap (sttfa.p A)) =>
                             sttfa.forall A
                               (b:(sttfa.etap (sttfa.p A)) =>
                                logic.eq A (op a b) (op b a))))
                         (bigops.ACop A nil)))))))).

def timesAC :
  sttfa.eps (bigops.ACop nat.nat (nat.S nat.O))
  :=
  bigops.mk_ACop nat.nat (nat.S nat.O) nat.times
    (a:(sttfa.etap (sttfa.p nat.nat)) =>
     nat.sym_eq_times (nat.S nat.O)
       (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        logic.eq nat.nat (y a) a)
       (nat.sym_eq_filter_nat_type_S (sttfa.arrow nat.nat nat.nat)
          nat.times_body nat.O
          (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           logic.eq nat.nat (y a) a)
          (nat.sym_eq_times_body_S nat.O
             (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              logic.eq nat.nat (y a) a)
             (nat.sym_eq_times nat.O
                (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 logic.eq nat.nat (nat.plus a (y a)) a)
                (nat.sym_eq_filter_nat_type_O (sttfa.arrow nat.nat nat.nat)
                   nat.times_body
                   (y:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                    logic.eq nat.nat (nat.plus a (y a)) a)
                   (nat.sym_eq_times_body_O
                      (y:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       logic.eq nat.nat (nat.plus a (y a)) a)
                      (logic.sym_eq nat.nat a (nat.plus a nat.O)
                         (nat.plus_n_O a))))))))
    (n:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.sym_eq nat.nat n (nat.times n (nat.S nat.O)) (nat.times_n_1 n))
    (a:(sttfa.etap (sttfa.p nat.nat)) =>
     b:(sttfa.etap (sttfa.p nat.nat)) =>
     c:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.sym_eq nat.nat (nat.times (nat.times a b) c)
       (nat.times a (nat.times b c)) (nat.associative_times a b c))
    nat.commutative_times.

def bigop_diff :
  sttfa.eps
    (sttfa.forall (sttfa.arrow nat.nat bool.bool)
       (p:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
        sttfa.forall (sttfa.arrow nat.nat nat.nat)
          (f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           sttfa.forall nat.nat
             (i:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat
                (n:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (nat.lt i n)
                   (sttfa.impl (logic.eq bool.bool (p i) bool.true)
                      (logic.eq nat.nat
                         (bigops.bigop nat.nat n
                            (x:(sttfa.etap (sttfa.p nat.nat)) => p x)
                            (nat.S nat.O) nat.times
                            (x:(sttfa.etap (sttfa.p nat.nat)) => f x))
                         (nat.times (f i)
                            (bigops.bigop nat.nat n
                               (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                bool.andb (bool.notb (nat.eqb i x)) (p x))
                               (nat.S nat.O) nat.times
                               (x:(sttfa.etap (sttfa.p nat.nat)) => f x))))))))))
  :=
  p:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
  f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  i:(sttfa.etap (sttfa.p nat.nat)) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  nat.nat_ind
    (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.impl (nat.lt i _x_365)
       (sttfa.impl (logic.eq bool.bool (p i) bool.true)
          (logic.eq nat.nat
             (bigops.bigop nat.nat _x_365
                (x:(sttfa.etap (sttfa.p nat.nat)) => p x) (nat.S nat.O)
                nat.times (x:(sttfa.etap (sttfa.p nat.nat)) => f x))
             (nat.times (f i)
                (bigops.bigop nat.nat _x_365
                   (x:(sttfa.etap (sttfa.p nat.nat)) =>
                    bool.andb (bool.notb (nat.eqb i x)) (p x)) (nat.S nat.O)
                   nat.times (x:(sttfa.etap (sttfa.p nat.nat)) => f x))))))
    (ltO:(sttfa.eps (nat.lt i nat.O)) =>
     connectives.falsity
       (sttfa.impl (logic.eq bool.bool (p i) bool.true)
          (logic.eq nat.nat
             (bigops.bigop nat.nat nat.O
                (x:(sttfa.etap (sttfa.p nat.nat)) => p x) (nat.S nat.O)
                nat.times (x:(sttfa.etap (sttfa.p nat.nat)) => f x))
             (nat.times (f i)
                (bigops.bigop nat.nat nat.O
                   (x:(sttfa.etap (sttfa.p nat.nat)) =>
                    bool.andb (bool.notb (nat.eqb i x)) (p x)) (nat.S nat.O)
                   nat.times (x:(sttfa.etap (sttfa.p nat.nat)) => f x)))))
       (logic.absurd (nat.le (nat.S i) nat.O) ltO (nat.not_le_Sn_O i)))
    (n0:(sttfa.etap (sttfa.p nat.nat)) =>
     Hind:
     (sttfa.eps
        (sttfa.impl (nat.lt i n0)
           (sttfa.impl (logic.eq bool.bool (p i) bool.true)
              (logic.eq nat.nat
                 (bigops.bigop nat.nat n0
                    (x:(sttfa.etap (sttfa.p nat.nat)) => p x) (nat.S nat.O)
                    nat.times (x:(sttfa.etap (sttfa.p nat.nat)) => f x))
                 (nat.times (f i)
                    (bigops.bigop nat.nat n0
                       (x:(sttfa.etap (sttfa.p nat.nat)) =>
                        bool.andb (bool.notb (nat.eqb i x)) (p x))
                       (nat.S nat.O) nat.times
                       (x:(sttfa.etap (sttfa.p nat.nat)) => f x))))))) =>
     lein:(sttfa.eps (nat.lt i (nat.S n0))) =>
     pi:(sttfa.eps (logic.eq bool.bool (p i) bool.true)) =>
     connectives.match_Or_prop (nat.lt i n0) (logic.eq nat.nat i n0)
       (logic.eq nat.nat
          (bigops.bigop nat.nat (nat.S n0)
             (x:(sttfa.etap (sttfa.p nat.nat)) => p x) (nat.S nat.O)
             nat.times (x:(sttfa.etap (sttfa.p nat.nat)) => f x))
          (nat.times (f i)
             (bigops.bigop nat.nat (nat.S n0)
                (x:(sttfa.etap (sttfa.p nat.nat)) =>
                 bool.andb (bool.notb (nat.eqb i x)) (p x)) (nat.S nat.O)
                nat.times (x:(sttfa.etap (sttfa.p nat.nat)) => f x))))
       (Hi:(sttfa.eps (nat.lt i n0)) =>
        connectives.match_Or_prop (logic.eq bool.bool (p n0) bool.true)
          (logic.eq bool.bool (p n0) bool.false)
          (logic.eq nat.nat
             (bigops.bigop nat.nat (nat.S n0)
                (x:(sttfa.etap (sttfa.p nat.nat)) => p x) (nat.S nat.O)
                nat.times (x:(sttfa.etap (sttfa.p nat.nat)) => f x))
             (nat.times (f i)
                (bigops.bigop nat.nat (nat.S n0)
                   (x:(sttfa.etap (sttfa.p nat.nat)) =>
                    bool.andb (bool.notb (nat.eqb i x)) (p x)) (nat.S nat.O)
                   nat.times (x:(sttfa.etap (sttfa.p nat.nat)) => f x))))
          (pn:(sttfa.eps (logic.eq bool.bool (p n0) bool.true)) =>
           logic.eq_ind_r nat.nat
             (nat.times (f n0)
                (bigops.bigop nat.nat n0
                   (i0:(sttfa.etap (sttfa.p nat.nat)) => p i0) (nat.S nat.O)
                   nat.times (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0)))
             (x:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat x
                (nat.times (f i)
                   (bigops.bigop nat.nat (nat.S n0)
                      (x0:(sttfa.etap (sttfa.p nat.nat)) =>
                       bool.andb (bool.notb (nat.eqb i x0)) (p x0))
                      (nat.S nat.O) nat.times
                      (x0:(sttfa.etap (sttfa.p nat.nat)) => f x0))))
             (logic.eq_ind_r nat.nat
                (nat.times (f n0)
                   (bigops.bigop nat.nat n0
                      (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                       bool.andb (bool.notb (nat.eqb i i0)) (p i0))
                      (nat.S nat.O) nat.times
                      (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0)))
                (x:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat
                   (nat.times (f n0)
                      (bigops.bigop nat.nat n0
                         (i0:(sttfa.etap (sttfa.p nat.nat)) => p i0)
                         (nat.S nat.O) nat.times
                         (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0)))
                   (nat.times (f i) x))
                (logic.eq_ind_r nat.nat
                   (nat.times (nat.times (f i) (f n0))
                      (bigops.bigop nat.nat n0
                         (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                          bool.match_bool_type bool.bool (p i0) bool.false
                            (bool.match_bool_type bool.bool bool.false
                               bool.true (nat.eqb i i0))) (nat.S nat.O)
                         nat.times
                         (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0)))
                   (x:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat
                      (nat.times (f n0)
                         (bigops.bigop nat.nat n0
                            (i0:(sttfa.etap (sttfa.p nat.nat)) => p i0)
                            (nat.S nat.O) nat.times
                            (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0))) x)
                   (logic.eq_ind_r nat.nat (nat.times (f n0) (f i))
                      (x:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat
                         (nat.times (f n0)
                            (bigops.bigop nat.nat n0
                               (i0:(sttfa.etap (sttfa.p nat.nat)) => p i0)
                               (nat.S nat.O) nat.times
                               (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0)))
                         (nat.times x
                            (bigops.bigop nat.nat n0
                               (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                                bool.match_bool_type bool.bool (p i0)
                                  bool.false
                                  (bool.match_bool_type bool.bool bool.false
                                     bool.true (nat.eqb i i0)))
                               (nat.S nat.O) nat.times
                               (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0))))
                      (logic.eq_ind nat.nat
                         (nat.times (f n0)
                            (nat.times (f i)
                               (bigops.bigop nat.nat n0
                                  (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                                   bool.match_bool_type bool.bool (p i0)
                                     bool.false
                                     (bool.match_bool_type bool.bool
                                        bool.false bool.true (nat.eqb i i0)))
                                  (nat.S nat.O) nat.times
                                  (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0))))
                         (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat
                            (nat.times (f n0)
                               (bigops.bigop nat.nat n0
                                  (i0:(sttfa.etap (sttfa.p nat.nat)) => p i0)
                                  (nat.S nat.O) nat.times
                                  (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0)))
                            x_1)
                         (logic.eq_ind_r nat.nat
                            (nat.times (f i)
                               (bigops.bigop nat.nat n0
                                  (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                   bool.andb (bool.notb (nat.eqb i x)) (p x))
                                  (nat.S nat.O) nat.times
                                  (x:(sttfa.etap (sttfa.p nat.nat)) => f x)))
                            (x:(sttfa.etap (sttfa.p nat.nat)) =>
                             logic.eq nat.nat (nat.times (f n0) x)
                               (nat.times (f n0)
                                  (nat.times (f i)
                                     (bigops.bigop nat.nat n0
                                        (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                                         bool.match_bool_type bool.bool
                                           (p i0) bool.false
                                           (bool.match_bool_type bool.bool
                                              bool.false bool.true
                                              (nat.eqb i i0))) (nat.S nat.O)
                                        nat.times
                                        (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                                         f i0)))))
                            (logic.refl nat.nat
                               (nat.times (f n0)
                                  (nat.times (f i)
                                     (bigops.bigop nat.nat n0
                                        (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                         bool.andb (bool.notb (nat.eqb i x))
                                           (p x)) (nat.S nat.O) nat.times
                                        (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                         f x)))))
                            (bigops.bigop nat.nat n0
                               (x:(sttfa.etap (sttfa.p nat.nat)) => p x)
                               (nat.S nat.O) nat.times
                               (x:(sttfa.etap (sttfa.p nat.nat)) => f x))
                            (Hind Hi
                               (logic.rewrite_r bool.bool bool.true
                                  (__:(sttfa.etap (sttfa.p bool.bool)) =>
                                   logic.eq bool.bool __ bool.true)
                                  (logic.refl bool.bool bool.true) (p i) pi)))
                         (nat.times (nat.times (f n0) (f i))
                            (bigops.bigop nat.nat n0
                               (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                                bool.match_bool_type bool.bool (p i0)
                                  bool.false
                                  (bool.match_bool_type bool.bool bool.false
                                     bool.true (nat.eqb i i0)))
                               (nat.S nat.O) nat.times
                               (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0)))
                         (bigops.assoc (f n0) (f i)
                            (bigops.bigop nat.nat n0
                               (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                                bool.match_bool_type bool.bool (p i0)
                                  bool.false
                                  (bool.match_bool_type bool.bool bool.false
                                     bool.true (nat.eqb i i0)))
                               (nat.S nat.O) nat.times
                               (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0))))
                      (nat.times (f i) (f n0))
                      (nat.commutative_times (f i) (f n0)))
                   (nat.times (f i)
                      (nat.times (f n0)
                         (bigops.bigop nat.nat n0
                            (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                             bool.match_bool_type bool.bool (p i0)
                               bool.false
                               (bool.match_bool_type bool.bool bool.false
                                  bool.true (nat.eqb i i0))) (nat.S nat.O)
                            nat.times
                            (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0))))
                   (bigops.assoc (f i) (f n0)
                      (bigops.bigop nat.nat n0
                         (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                          bool.match_bool_type bool.bool (p i0) bool.false
                            (bool.match_bool_type bool.bool bool.false
                               bool.true (nat.eqb i i0))) (nat.S nat.O)
                         nat.times
                         (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0))))
                (bigops.bigop nat.nat (nat.S n0)
                   (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                    bool.andb (bool.notb (nat.eqb i i0)) (p i0))
                   (nat.S nat.O) nat.times
                   (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0))
                (bigops.bigop_Strue nat.nat n0
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    bool.andb (bool.notb (nat.eqb i __)) (p __))
                   (nat.S nat.O) nat.times f
                   (logic.rewrite_r bool.bool bool.true
                      (__:(sttfa.etap (sttfa.p bool.bool)) =>
                       logic.eq bool.bool
                         (bool.andb (bool.notb (nat.eqb i n0)) __) bool.true)
                      (logic.rewrite_r bool.bool bool.true
                         (__:(sttfa.etap (sttfa.p bool.bool)) =>
                          logic.eq bool.bool __ bool.true)
                         (logic.refl bool.bool bool.true)
                         (bool.andb (bool.notb (nat.eqb i n0)) bool.true)
                         (logic.rewrite_l bool.bool (p n0)
                            (__:(sttfa.etap (sttfa.p bool.bool)) =>
                             logic.eq bool.bool
                               (bool.andb (bool.notb (nat.eqb i n0))
                                  bool.true) __)
                            (logic.rewrite_l bool.bool (p n0)
                               (__:(sttfa.etap (sttfa.p bool.bool)) =>
                                logic.eq bool.bool
                                  (bool.andb (bool.notb (nat.eqb i n0)) __)
                                  (p n0))
                               (logic.eq_ind_r bool.bool bool.false
                                  (x:(sttfa.etap (sttfa.p bool.bool)) =>
                                   logic.eq bool.bool
                                     (bool.andb (bool.notb x) (p n0)) (
                                     p n0))
                                  (bool.sym_eq_match_bool_type_false
                                     bool.bool bool.false bool.true
                                     (y:(sttfa.etap (sttfa.p bool.bool)) =>
                                      logic.eq bool.bool
                                        (bool.match_bool_type bool.bool
                                           (p n0) bool.false y) (p n0))
                                     (bool.eq_match_bool_type_true bool.bool
                                        (p n0) bool.false
                                        (y:
                                         (sttfa.etap (sttfa.p bool.bool)) =>
                                         logic.eq bool.bool
                                           (bool.match_bool_type bool.bool
                                              (p n0) bool.false bool.true) y)
                                        (bool.eq_match_bool_type_false
                                           bool.bool bool.false bool.true
                                           (y:
                                            (sttfa.etap (sttfa.p bool.bool)) =>
                                            logic.eq bool.bool
                                              (bool.match_bool_type
                                                 bool.bool (p n0) bool.false
                                                 bool.true)
                                              (bool.match_bool_type
                                                 bool.bool (p n0) bool.false
                                                 y))
                                           (bool.eq_match_bool_type_false
                                              bool.bool bool.false bool.true
                                              (y:
                                               (sttfa.etap
                                                  (sttfa.p bool.bool)) =>
                                               logic.eq bool.bool
                                                 (bool.match_bool_type
                                                    bool.bool (p n0)
                                                    bool.false y)
                                                 (bool.match_bool_type
                                                    bool.bool (p n0)
                                                    bool.false
                                                    (bool.match_bool_type
                                                       bool.bool bool.false
                                                       bool.true bool.false)))
                                              (logic.refl bool.bool
                                                 (bool.andb
                                                    (bool.notb bool.false)
                                                    (p n0)))))))
                                  (nat.eqb i n0)
                                  (nat.not_eq_to_eqb_false i n0
                                     (nat.lt_to_not_eq i n0 Hi))) bool.true
                               pn) bool.true pn)) (p n0) pn)))
             (bigops.bigop nat.nat (nat.S n0)
                (i0:(sttfa.etap (sttfa.p nat.nat)) => p i0) (nat.S nat.O)
                nat.times (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0))
             (bigops.bigop_Strue nat.nat n0 p (nat.S nat.O) nat.times f
                (logic.rewrite_r bool.bool bool.true
                   (__:(sttfa.etap (sttfa.p bool.bool)) =>
                    logic.eq bool.bool __ bool.true)
                   (logic.refl bool.bool bool.true) (p n0) pn)))
          (pn:(sttfa.eps (logic.eq bool.bool (p n0) bool.false)) =>
           logic.eq_ind_r nat.nat
             (bigops.bigop nat.nat n0
                (i0:(sttfa.etap (sttfa.p nat.nat)) => p i0) (nat.S nat.O)
                nat.times (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0))
             (x:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat x
                (nat.times (f i)
                   (bigops.bigop nat.nat (nat.S n0)
                      (x0:(sttfa.etap (sttfa.p nat.nat)) =>
                       bool.andb (bool.notb (nat.eqb i x0)) (p x0))
                      (nat.S nat.O) nat.times
                      (x0:(sttfa.etap (sttfa.p nat.nat)) => f x0))))
             (logic.eq_ind_r nat.nat
                (bigops.bigop nat.nat n0
                   (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                    bool.andb (bool.notb (nat.eqb i i0)) (p i0))
                   (nat.S nat.O) nat.times
                   (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0))
                (x:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq nat.nat
                   (bigops.bigop nat.nat n0
                      (i0:(sttfa.etap (sttfa.p nat.nat)) => p i0)
                      (nat.S nat.O) nat.times
                      (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0))
                   (nat.times (f i) x))
                (logic.eq_ind_r nat.nat
                   (nat.times (f i)
                      (bigops.bigop nat.nat n0
                         (x:(sttfa.etap (sttfa.p nat.nat)) =>
                          bool.andb (bool.notb (nat.eqb i x)) (p x))
                         (nat.S nat.O) nat.times
                         (x:(sttfa.etap (sttfa.p nat.nat)) => f x)))
                   (x:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat x
                      (nat.times (f i)
                         (bigops.bigop nat.nat n0
                            (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                             bool.andb (bool.notb (nat.eqb i i0)) (p i0))
                            (nat.S nat.O) nat.times
                            (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0))))
                   (logic.refl nat.nat
                      (nat.times (f i)
                         (bigops.bigop nat.nat n0
                            (x:(sttfa.etap (sttfa.p nat.nat)) =>
                             bool.andb (bool.notb (nat.eqb i x)) (p x))
                            (nat.S nat.O) nat.times
                            (x:(sttfa.etap (sttfa.p nat.nat)) => f x))))
                   (bigops.bigop nat.nat n0
                      (x:(sttfa.etap (sttfa.p nat.nat)) => p x)
                      (nat.S nat.O) nat.times
                      (x:(sttfa.etap (sttfa.p nat.nat)) => f x))
                   (Hind Hi
                      (logic.rewrite_r bool.bool bool.true
                         (__:(sttfa.etap (sttfa.p bool.bool)) =>
                          logic.eq bool.bool __ bool.true)
                         (logic.refl bool.bool bool.true) (p i) pi)))
                (bigops.bigop nat.nat (nat.S n0)
                   (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                    bool.andb (bool.notb (nat.eqb i i0)) (p i0))
                   (nat.S nat.O) nat.times
                   (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0))
                (bigops.bigop_Sfalse nat.nat n0
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    bool.andb (bool.notb (nat.eqb i __)) (p __))
                   (nat.S nat.O) nat.times f
                   (logic.rewrite_r bool.bool bool.false
                      (__:(sttfa.etap (sttfa.p bool.bool)) =>
                       logic.eq bool.bool
                         (bool.andb (bool.notb (nat.eqb i n0)) __) bool.false)
                      (logic.rewrite_r bool.bool bool.false
                         (__:(sttfa.etap (sttfa.p bool.bool)) =>
                          logic.eq bool.bool __ bool.false)
                         (logic.refl bool.bool bool.false)
                         (bool.andb (bool.notb (nat.eqb i n0)) bool.false)
                         (logic.rewrite_l bool.bool (p n0)
                            (__:(sttfa.etap (sttfa.p bool.bool)) =>
                             logic.eq bool.bool
                               (bool.andb (bool.notb (nat.eqb i n0))
                                  bool.false) __)
                            (logic.rewrite_l bool.bool (p n0)
                               (__:(sttfa.etap (sttfa.p bool.bool)) =>
                                logic.eq bool.bool
                                  (bool.andb (bool.notb (nat.eqb i n0)) __)
                                  (p n0))
                               (logic.eq_ind_r bool.bool bool.false
                                  (x:(sttfa.etap (sttfa.p bool.bool)) =>
                                   logic.eq bool.bool
                                     (bool.andb (bool.notb x) (p n0)) (
                                     p n0))
                                  (bool.sym_eq_match_bool_type_false
                                     bool.bool bool.false bool.true
                                     (y:(sttfa.etap (sttfa.p bool.bool)) =>
                                      logic.eq bool.bool
                                        (bool.match_bool_type bool.bool
                                           (p n0) bool.false y) (p n0))
                                     (bool.eq_match_bool_type_true bool.bool
                                        (p n0) bool.false
                                        (y:
                                         (sttfa.etap (sttfa.p bool.bool)) =>
                                         logic.eq bool.bool
                                           (bool.match_bool_type bool.bool
                                              (p n0) bool.false bool.true) y)
                                        (bool.eq_match_bool_type_false
                                           bool.bool bool.false bool.true
                                           (y:
                                            (sttfa.etap (sttfa.p bool.bool)) =>
                                            logic.eq bool.bool
                                              (bool.match_bool_type
                                                 bool.bool (p n0) bool.false
                                                 bool.true)
                                              (bool.match_bool_type
                                                 bool.bool (p n0) bool.false
                                                 y))
                                           (bool.eq_match_bool_type_false
                                              bool.bool bool.false bool.true
                                              (y:
                                               (sttfa.etap
                                                  (sttfa.p bool.bool)) =>
                                               logic.eq bool.bool
                                                 (bool.match_bool_type
                                                    bool.bool (p n0)
                                                    bool.false y)
                                                 (bool.match_bool_type
                                                    bool.bool (p n0)
                                                    bool.false
                                                    (bool.match_bool_type
                                                       bool.bool bool.false
                                                       bool.true bool.false)))
                                              (logic.refl bool.bool
                                                 (bool.andb
                                                    (bool.notb bool.false)
                                                    (p n0)))))))
                                  (nat.eqb i n0)
                                  (nat.not_eq_to_eqb_false i n0
                                     (nat.lt_to_not_eq i n0 Hi))) bool.false
                               pn) bool.false pn)) (p n0) pn)))
             (bigops.bigop nat.nat (nat.S n0)
                (i0:(sttfa.etap (sttfa.p nat.nat)) => p i0) (nat.S nat.O)
                nat.times (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0))
             (bigops.bigop_Sfalse nat.nat n0 p (nat.S nat.O) nat.times f
                (logic.rewrite_r bool.bool bool.false
                   (__:(sttfa.etap (sttfa.p bool.bool)) =>
                    logic.eq bool.bool __ bool.false)
                   (logic.refl bool.bool bool.false) (p n0) pn)))
          (bool.true_or_false (p n0)))
       (Hi:(sttfa.eps (logic.eq nat.nat i n0)) =>
        logic.eq_ind nat.nat i
          (x_1:(sttfa.etap (sttfa.p nat.nat)) =>
           logic.eq nat.nat
             (bigops.bigop nat.nat (nat.S x_1)
                (x:(sttfa.etap (sttfa.p nat.nat)) => p x) (nat.S nat.O)
                nat.times (x:(sttfa.etap (sttfa.p nat.nat)) => f x))
             (nat.times (f i)
                (bigops.bigop nat.nat (nat.S x_1)
                   (x:(sttfa.etap (sttfa.p nat.nat)) =>
                    bool.andb (bool.notb (nat.eqb i x)) (p x)) (nat.S nat.O)
                   nat.times (x:(sttfa.etap (sttfa.p nat.nat)) => f x))))
          (logic.eq_ind_r nat.nat
             (nat.times (f i)
                (bigops.bigop nat.nat i
                   (i0:(sttfa.etap (sttfa.p nat.nat)) => p i0) (nat.S nat.O)
                   nat.times (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0)))
             (x:(sttfa.etap (sttfa.p nat.nat)) =>
              logic.eq nat.nat x
                (nat.times (f i)
                   (bigops.bigop nat.nat (nat.S i)
                      (x0:(sttfa.etap (sttfa.p nat.nat)) =>
                       bool.andb (bool.notb (nat.eqb i x0)) (p x0))
                      (nat.S nat.O) nat.times
                      (x0:(sttfa.etap (sttfa.p nat.nat)) => f x0))))
             (logic.eq_f nat.nat nat.nat (nat.times (f i))
                (bigops.bigop nat.nat i
                   (i0:(sttfa.etap (sttfa.p nat.nat)) => p i0) (nat.S nat.O)
                   nat.times (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0))
                (bigops.bigop nat.nat (nat.S i)
                   (x:(sttfa.etap (sttfa.p nat.nat)) =>
                    bool.andb (bool.notb (nat.eqb i x)) (p x)) (nat.S nat.O)
                   nat.times (x:(sttfa.etap (sttfa.p nat.nat)) => f x))
                (logic.eq_ind_r nat.nat
                   (bigops.bigop nat.nat i
                      (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                       bool.andb (bool.notb (nat.eqb i i0)) (p i0))
                      (nat.S nat.O) nat.times
                      (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0))
                   (x:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat
                      (bigops.bigop nat.nat i
                         (i0:(sttfa.etap (sttfa.p nat.nat)) => p i0)
                         (nat.S nat.O) nat.times
                         (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0)) x)
                   (bigops.same_bigop nat.nat i p
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       bool.andb (bool.notb (nat.eqb i __)) (p __))
                      (nat.S nat.O) nat.times f f
                      (k:(sttfa.etap (sttfa.p nat.nat)) =>
                       ltki:(sttfa.eps (nat.lt k i)) =>
                       logic.eq_ind_r bool.bool bool.false
                         (x:(sttfa.etap (sttfa.p bool.bool)) =>
                          logic.eq bool.bool (p k)
                            (bool.andb (bool.notb x) (p k)))
                         (bool.sym_eq_match_bool_type_false bool.bool
                            bool.false bool.true
                            (y:(sttfa.etap (sttfa.p bool.bool)) =>
                             logic.eq bool.bool (p k)
                               (bool.match_bool_type bool.bool (p k)
                                  bool.false y))
                            (bool.sym_eq_match_bool_type_true bool.bool
                               (p k) bool.false
                               (y:(sttfa.etap (sttfa.p bool.bool)) =>
                                logic.eq bool.bool (p k) y)
                               (logic.refl bool.bool (p k)))) (nat.eqb i k)
                         (nat.not_eq_to_eqb_false i k
                            (logic.not_to_not (logic.eq nat.nat i k)
                               (nat.le (nat.S i) i)
                               (auto:(sttfa.eps (logic.eq nat.nat i k)) =>
                                logic.eq_coerc (nat.le (nat.S k) i)
                                  (nat.le (nat.S i) i) ltki
                                  (logic.rewrite_l nat.nat i
                                     (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq sttfa.bool
                                        (nat.le (nat.S __) i)
                                        (nat.le (nat.S i) i))
                                     (logic.refl sttfa.bool
                                        (nat.le (nat.S i) i)) k auto))
                               (nat.not_le_Sn_n i))))
                      (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                       auto:(sttfa.eps (nat.lt i0 i)) =>
                       auto':
                       (sttfa.eps (logic.eq bool.bool (p i0) bool.true)) =>
                       logic.refl nat.nat (f i0)))
                   (bigops.bigop nat.nat (nat.S i)
                      (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                       bool.andb (bool.notb (nat.eqb i i0)) (p i0))
                      (nat.S nat.O) nat.times
                      (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0))
                   (bigops.bigop_Sfalse nat.nat i
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       bool.andb (bool.notb (nat.eqb i __)) (p __))
                      (nat.S nat.O) nat.times f
                      (logic.eq_ind_r bool.bool bool.true
                         (x:(sttfa.etap (sttfa.p bool.bool)) =>
                          logic.eq bool.bool (bool.andb (bool.notb x) (p i))
                            bool.false)
                         (bool.eq_match_bool_type_false bool.bool (p i)
                            bool.false
                            (y:(sttfa.etap (sttfa.p bool.bool)) =>
                             logic.eq bool.bool
                               (bool.match_bool_type bool.bool (p i)
                                  bool.false
                                  (bool.match_bool_type bool.bool bool.false
                                     bool.true bool.true)) y)
                            (bool.eq_match_bool_type_true bool.bool
                               bool.false bool.true
                               (y:(sttfa.etap (sttfa.p bool.bool)) =>
                                logic.eq bool.bool
                                  (bool.match_bool_type bool.bool (p i)
                                     bool.false
                                     (bool.match_bool_type bool.bool
                                        bool.false bool.true bool.true))
                                  (bool.match_bool_type bool.bool (p i)
                                     bool.false y))
                               (logic.refl bool.bool
                                  (bool.andb (bool.notb bool.true) (p i)))))
                         (nat.eqb i i)
                         (nat.eq_to_eqb_true i i (logic.refl nat.nat i))))))
             (bigops.bigop nat.nat (nat.S i)
                (i0:(sttfa.etap (sttfa.p nat.nat)) => p i0) (nat.S nat.O)
                nat.times (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0))
             (bigops.bigop_Strue nat.nat i p (nat.S nat.O) nat.times f
                (logic.rewrite_r bool.bool bool.true
                   (__:(sttfa.etap (sttfa.p bool.bool)) =>
                    logic.eq bool.bool __ bool.true)
                   (logic.refl bool.bool bool.true) (p i) pi))) n0 Hi)
       (nat.le_to_or_lt_eq i n0 (nat.le_S_S_to_le i n0 lein))) n.

def sub_hk :
  sttfa.etap
    (sttfa.p
       (sttfa.arrow (sttfa.arrow nat.nat nat.nat)
          (sttfa.arrow (sttfa.arrow nat.nat nat.nat)
             (sttfa.arrow nat.nat
                (sttfa.arrow nat.nat
                   (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                      (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                         (sttfa.arrow (sttfa.arrow nat.nat nat.nat)
                            (sttfa.arrow (sttfa.arrow nat.nat nat.nat)
                               sttfa.bool)))))))))
  :=
  h:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  k:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  n1:(sttfa.etap (sttfa.p nat.nat)) =>
  n2:(sttfa.etap (sttfa.p nat.nat)) =>
  p1:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
  p2:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
  f1:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  f2:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  sttfa.forall nat.nat
    (i:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.impl (nat.lt i n1)
       (sttfa.impl (logic.eq bool.bool (p1 i) bool.true)
          (connectives.And
             (connectives.And (nat.lt (h i) n2)
                (logic.eq bool.bool (p2 (h i)) bool.true))
             (logic.eq nat.nat (k (h i)) i)))).

def iso :
  sttfa.etap
    (sttfa.p
       (sttfa.arrow nat.nat
          (sttfa.arrow nat.nat
             (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                   (sttfa.arrow (sttfa.arrow nat.nat nat.nat)
                      (sttfa.arrow (sttfa.arrow nat.nat nat.nat) sttfa.bool)))))))
  :=
  n1:(sttfa.etap (sttfa.p nat.nat)) =>
  n2:(sttfa.etap (sttfa.p nat.nat)) =>
  p1:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
  p2:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
  f1:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  f2:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  connectives.ex (sttfa.arrow nat.nat nat.nat)
    (h:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
     connectives.ex (sttfa.arrow nat.nat nat.nat)
       (k:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        connectives.And
          (connectives.And
             (sttfa.forall nat.nat
                (i:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (nat.lt i n1)
                   (sttfa.impl (logic.eq bool.bool (p1 i) bool.true)
                      (logic.eq nat.nat (f1 i) (f2 (h i))))))
             (bigops.sub_hk h k n1 n2 p1 p2 f1 f2))
          (bigops.sub_hk k h n2 n1 p2 p1 f2 f1))).

def sub_hkO :
  sttfa.eps
    (sttfa.forall (sttfa.arrow nat.nat nat.nat)
       (h:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        sttfa.forall (sttfa.arrow nat.nat nat.nat)
          (k:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           sttfa.forall nat.nat
             (n1:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat
                (n2:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall (sttfa.arrow nat.nat bool.bool)
                   (p1:
                    (sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
                    sttfa.forall (sttfa.arrow nat.nat bool.bool)
                      (p2:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
                       sttfa.forall (sttfa.arrow nat.nat nat.nat)
                         (f1:
                          (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                          sttfa.forall (sttfa.arrow nat.nat nat.nat)
                            (f2:
                             (sttfa.etap
                                (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                             sttfa.impl (logic.eq nat.nat n1 nat.O)
                               (bigops.sub_hk h k n1 n2 p1 p2 f1 f2))))))))))
  :=
  h:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  k:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  n1:(sttfa.etap (sttfa.p nat.nat)) =>
  n2:(sttfa.etap (sttfa.p nat.nat)) =>
  p1:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
  p2:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
  f1:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  f2:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  up0:(sttfa.eps (logic.eq nat.nat n1 nat.O)) =>
  i:(sttfa.etap (sttfa.p nat.nat)) =>
  lti:(sttfa.eps (nat.lt i n1)) =>
  logic.eq_ind_r nat.nat nat.O
    (x:(sttfa.etap (sttfa.p nat.nat)) =>
     sttfa.impl (logic.eq bool.bool (p1 i) bool.true)
       (connectives.And
          (connectives.And (nat.lt (h i) n2)
             (logic.eq bool.bool (p2 (h i)) bool.true))
          (logic.eq nat.nat (k (h i)) i)))
    (connectives.falsity
       (sttfa.impl (logic.eq bool.bool (p1 i) bool.true)
          (connectives.And
             (connectives.And (nat.lt (h i) n2)
                (logic.eq bool.bool (p2 (h i)) bool.true))
             (logic.eq nat.nat (k (h i)) i)))
       (logic.absurd (nat.le (nat.S i) nat.O)
          (logic.eq_coerc (nat.le (nat.S i) n1) (nat.le (nat.S i) nat.O) lti
             (logic.rewrite_r nat.nat nat.O
                (__:(sttfa.etap (sttfa.p nat.nat)) =>
                 logic.eq sttfa.bool (nat.le (nat.S i) __)
                   (nat.le (nat.S i) nat.O))
                (logic.refl sttfa.bool (nat.le (nat.S i) nat.O)) n1 up0))
          (nat.not_le_Sn_O i))) n1 up0.

def sub0_to_false :
  sttfa.eps
    (sttfa.forall (sttfa.arrow nat.nat nat.nat)
       (h:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        sttfa.forall (sttfa.arrow nat.nat nat.nat)
          (k:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           sttfa.forall nat.nat
             (n1:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat
                (n2:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.forall (sttfa.arrow nat.nat bool.bool)
                   (p1:
                    (sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
                    sttfa.forall (sttfa.arrow nat.nat bool.bool)
                      (p2:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
                       sttfa.forall (sttfa.arrow nat.nat nat.nat)
                         (f1:
                          (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                          sttfa.forall (sttfa.arrow nat.nat nat.nat)
                            (f2:
                             (sttfa.etap
                                (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                             sttfa.impl (logic.eq nat.nat n1 nat.O)
                               (sttfa.impl
                                  (bigops.sub_hk h k n2 n1 p2 p1 f2 f1)
                                  (sttfa.forall nat.nat
                                     (i:(sttfa.etap (sttfa.p nat.nat)) =>
                                      sttfa.impl (nat.lt i n2)
                                        (logic.eq bool.bool (p2 i) bool.false)))))))))))))
  :=
  h:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  k:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  n1:(sttfa.etap (sttfa.p nat.nat)) =>
  n2:(sttfa.etap (sttfa.p nat.nat)) =>
  p1:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
  p2:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
  f1:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  f2:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  up0:(sttfa.eps (logic.eq nat.nat n1 nat.O)) =>
  sub:(sttfa.eps (bigops.sub_hk h k n2 n1 p2 p1 f2 f1)) =>
  i:(sttfa.etap (sttfa.p nat.nat)) =>
  lti:(sttfa.eps (nat.lt i n2)) =>
  connectives.match_Or_prop (logic.eq bool.bool (p2 i) bool.true)
    (logic.eq bool.bool (p2 i) bool.false)
    (logic.eq bool.bool (p2 i) bool.false)
    (ptrue:(sttfa.eps (logic.eq bool.bool (p2 i) bool.true)) =>
     connectives.match_And_prop
       (connectives.And (nat.lt (h i) n1)
          (logic.eq bool.bool (p1 (h i)) bool.true))
       (logic.eq nat.nat (k (h i)) i) (logic.eq bool.bool (p2 i) bool.false)
       (_clearme:
        (sttfa.eps
           (connectives.And (nat.lt (h i) n1)
              (logic.eq bool.bool (p1 (h i)) bool.true))) =>
        connectives.match_And_prop (nat.lt (h i) n1)
          (logic.eq bool.bool (p1 (h i)) bool.true)
          (sttfa.impl (logic.eq nat.nat (k (h i)) i)
             (logic.eq bool.bool (p2 i) bool.false))
          (hi:(sttfa.eps (nat.lt (h i) n1)) =>
           connectives.falsity
             (sttfa.impl (logic.eq bool.bool (p1 (h i)) bool.true)
                (sttfa.impl (logic.eq nat.nat (k (h i)) i)
                   (logic.eq bool.bool (p2 i) bool.false)))
             (logic.absurd (nat.le (nat.S (h i)) nat.O)
                (logic.eq_coerc (nat.le (nat.S (h i)) n1)
                   (nat.le (nat.S (h i)) nat.O) hi
                   (logic.rewrite_r nat.nat nat.O
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq sttfa.bool (nat.le (nat.S (h i)) __)
                         (nat.le (nat.S (h i)) nat.O))
                      (logic.refl sttfa.bool (nat.le (nat.S (h i)) nat.O))
                      n1 up0)) (nat.not_le_Sn_O (h i)))) _clearme)
       (sub i lti ptrue))
    (auto:(sttfa.eps (logic.eq bool.bool (p2 i) bool.false)) =>
     logic.rewrite_r bool.bool bool.false
       (__:(sttfa.etap (sttfa.p bool.bool)) =>
        logic.eq bool.bool __ bool.false) (logic.refl bool.bool bool.false)
       (p2 i) auto) (bool.true_or_false (p2 i)).

def sub_lt :
  sttfa.eps
    (sttfa.forall (sttfa.arrow nat.nat nat.nat)
       (e:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        sttfa.forall (sttfa.arrow nat.nat bool.bool)
          (p:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
           sttfa.forall nat.nat
             (n:(sttfa.etap (sttfa.p nat.nat)) =>
              sttfa.forall nat.nat
                (m:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (nat.le n m)
                   (bigops.sub_hk (x:(sttfa.etap (sttfa.p nat.nat)) => x)
                      (x:(sttfa.etap (sttfa.p nat.nat)) => x) n m p p e e))))))
  :=
  e:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
  n:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  lenm:(sttfa.eps (nat.le n m)) =>
  i:(sttfa.etap (sttfa.p nat.nat)) =>
  lti:(sttfa.eps (nat.lt i n)) =>
  fi:(sttfa.eps (logic.eq bool.bool (f i) bool.true)) =>
  connectives.conj
        (connectives.And (nat.lt i m) (logic.eq bool.bool (f i) bool.true))
        (logic.eq nat.nat i i)
    (connectives.conj (nat.lt i m) (logic.eq bool.bool (f i) bool.true)
     (nat.lt_to_le_to_lt i n m lti lenm)
       (logic.rewrite_r bool.bool bool.true
          (__:(sttfa.etap (sttfa.p bool.bool)) =>
           logic.eq bool.bool __ bool.true) (logic.refl bool.bool bool.true)
          (f i) fi)) (logic.refl nat.nat i).

def transitive_sub :
  sttfa.eps
    (sttfa.forall (sttfa.arrow nat.nat nat.nat)
       (h1:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        sttfa.forall (sttfa.arrow nat.nat nat.nat)
          (k1:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
           sttfa.forall (sttfa.arrow nat.nat nat.nat)
             (h2:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
              sttfa.forall (sttfa.arrow nat.nat nat.nat)
                (k2:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                 sttfa.forall nat.nat
                   (n1:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.forall nat.nat
                      (n2:(sttfa.etap (sttfa.p nat.nat)) =>
                       sttfa.forall nat.nat
                         (n3:(sttfa.etap (sttfa.p nat.nat)) =>
                          sttfa.forall (sttfa.arrow nat.nat bool.bool)
                            (p1:
                             (sttfa.etap
                                (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
                             sttfa.forall (sttfa.arrow nat.nat bool.bool)
                               (p2:
                                (sttfa.etap
                                   (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
                                sttfa.forall (sttfa.arrow nat.nat bool.bool)
                                  (p3:
                                   (sttfa.etap
                                      (sttfa.p
                                         (sttfa.arrow nat.nat bool.bool))) =>
                                   sttfa.forall
                                     (sttfa.arrow nat.nat nat.nat)
                                     (f1:
                                      (sttfa.etap
                                         (sttfa.p
                                            (sttfa.arrow nat.nat nat.nat))) =>
                                      sttfa.forall
                                        (sttfa.arrow nat.nat nat.nat)
                                        (f2:
                                         (sttfa.etap
                                            (sttfa.p
                                               (sttfa.arrow nat.nat nat.nat))) =>
                                         sttfa.forall
                                           (sttfa.arrow nat.nat nat.nat)
                                           (f3:
                                            (sttfa.etap
                                               (sttfa.p
                                                  (sttfa.arrow nat.nat
                                                     nat.nat))) =>
                                            sttfa.impl
                                              (bigops.sub_hk h1 k1 n1 n2 p1
                                                 p2 f1 f2)
                                              (sttfa.impl
                                                 (bigops.sub_hk h2 k2 n2 n3
                                                    p2 p3 f2 f3)
                                                 (bigops.sub_hk
                                                    (x:
                                                     (sttfa.etap
                                                        (sttfa.p nat.nat)) =>
                                                     h2 (h1 x))
                                                    (x:
                                                     (sttfa.etap
                                                        (sttfa.p nat.nat)) =>
                                                     k1 (k2 x)) n1 n3 p1 p3
                                                    f1 f3))))))))))))))))
  :=
  h1:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  k1:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  h2:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  k2:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  n1:(sttfa.etap (sttfa.p nat.nat)) =>
  n2:(sttfa.etap (sttfa.p nat.nat)) =>
  n3:(sttfa.etap (sttfa.p nat.nat)) =>
  p1:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
  p2:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
  p3:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
  f1:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  f2:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  f3:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  sub1:(sttfa.eps (bigops.sub_hk h1 k1 n1 n2 p1 p2 f1 f2)) =>
  sub2:(sttfa.eps (bigops.sub_hk h2 k2 n2 n3 p2 p3 f2 f3)) =>
  i:(sttfa.etap (sttfa.p nat.nat)) =>
  lti:(sttfa.eps (nat.lt i n1)) =>
  fi:(sttfa.eps (logic.eq bool.bool (p1 i) bool.true)) =>
  connectives.match_And_prop
    (connectives.And (nat.lt (h1 i) n2)
       (logic.eq bool.bool (p2 (h1 i)) bool.true))
    (logic.eq nat.nat (k1 (h1 i)) i)
    (connectives.And
       (connectives.And (nat.lt (h2 (h1 i)) n3)
          (logic.eq bool.bool (p3 (h2 (h1 i))) bool.true))
       (logic.eq nat.nat (k1 (k2 (h2 (h1 i)))) i))
    (_clearme:
     (sttfa.eps
        (connectives.And (nat.lt (h1 i) n2)
           (logic.eq bool.bool (p2 (h1 i)) bool.true))) =>
     connectives.match_And_prop (nat.lt (h1 i) n2)
       (logic.eq bool.bool (p2 (h1 i)) bool.true)
       (sttfa.impl (logic.eq nat.nat (k1 (h1 i)) i)
          (connectives.And
             (connectives.And (nat.lt (h2 (h1 i)) n3)
                (logic.eq bool.bool (p3 (h2 (h1 i))) bool.true))
             (logic.eq nat.nat (k1 (k2 (h2 (h1 i)))) i)))
       (lth1i:(sttfa.eps (nat.lt (h1 i) n2)) =>
        fh1i:(sttfa.eps (logic.eq bool.bool (p2 (h1 i)) bool.true)) =>
        ei:(sttfa.eps (logic.eq nat.nat (k1 (h1 i)) i)) =>
        connectives.match_And_prop
          (connectives.And (nat.lt (h2 (h1 i)) n3)
             (logic.eq bool.bool (p3 (h2 (h1 i))) bool.true))
          (logic.eq nat.nat (k2 (h2 (h1 i))) (h1 i))
          (connectives.And
             (connectives.And (nat.lt (h2 (h1 i)) n3)
                (logic.eq bool.bool (p3 (h2 (h1 i))) bool.true))
             (logic.eq nat.nat (k1 (k2 (h2 (h1 i)))) i))
          (_clearme0:
           (sttfa.eps
              (connectives.And (nat.lt (h2 (h1 i)) n3)
                 (logic.eq bool.bool (p3 (h2 (h1 i))) bool.true))) =>
           connectives.match_And_prop (nat.lt (h2 (h1 i)) n3)
             (logic.eq bool.bool (p3 (h2 (h1 i))) bool.true)
             (sttfa.impl (logic.eq nat.nat (k2 (h2 (h1 i))) (h1 i))
                (connectives.And
                   (connectives.And (nat.lt (h2 (h1 i)) n3)
                      (logic.eq bool.bool (p3 (h2 (h1 i))) bool.true))
                   (logic.eq nat.nat (k1 (k2 (h2 (h1 i)))) i)))
             (H1:(sttfa.eps (nat.lt (h2 (h1 i)) n3)) =>
              H2:
              (sttfa.eps (logic.eq bool.bool (p3 (h2 (h1 i))) bool.true)) =>
              H3:(sttfa.eps (logic.eq nat.nat (k2 (h2 (h1 i))) (h1 i))) =>
              connectives.conj
                    (connectives.And (nat.lt (h2 (h1 i)) n3)
                       (logic.eq bool.bool (p3 (h2 (h1 i))) bool.true))
                    (logic.eq nat.nat (k1 (k2 (h2 (h1 i)))) i)
                (connectives.conj (nat.lt (h2 (h1 i)) n3)
                          (logic.eq bool.bool (p3 (h2 (h1 i))) bool.true)
                 H1
                   (logic.rewrite_r bool.bool bool.true
                      (__:(sttfa.etap (sttfa.p bool.bool)) =>
                       logic.eq bool.bool __ bool.true)
                      (logic.refl bool.bool bool.true) (p3 (h2 (h1 i))) H2))
                (logic.rewrite_r nat.nat (h1 i)
                   (__:(sttfa.etap (sttfa.p nat.nat)) =>
                    logic.eq nat.nat (k1 __) i)
                   (logic.rewrite_r nat.nat i
                      (__:(sttfa.etap (sttfa.p nat.nat)) =>
                       logic.eq nat.nat __ i) (logic.refl nat.nat i)
                      (k1 (h1 i)) ei) (k2 (h2 (h1 i))) H3)) _clearme0)
          (sub2 (h1 i) lth1i fh1i)) _clearme) (sub1 i lti fi).

def let_clause_10471 :
  sttfa.eps
    (sttfa.forall nat.nat
       (n1:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (n2:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall (sttfa.arrow nat.nat bool.bool)
             (p1:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
              sttfa.forall (sttfa.arrow nat.nat bool.bool)
                (p2:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
                 sttfa.forall (sttfa.arrow nat.nat nat.nat)
                   (f1:
                    (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                    sttfa.forall (sttfa.arrow nat.nat nat.nat)
                      (f2:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       sttfa.impl (bigops.iso n1 n2 p1 p2 f1 f2)
                         (sttfa.forall (sttfa.arrow nat.nat nat.nat)
                            (h:
                             (sttfa.etap
                                (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                             sttfa.impl
                               (connectives.ex (sttfa.arrow nat.nat nat.nat)
                                  (k:
                                   (sttfa.etap
                                      (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                                   connectives.And
                                     (connectives.And
                                        (sttfa.forall nat.nat
                                           (i:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            sttfa.impl (nat.lt i n1)
                                              (sttfa.impl
                                                 (logic.eq bool.bool (
                                                    p1 i) bool.true)
                                                 (logic.eq nat.nat (f1 i)
                                                    (f2 (h i))))))
                                        (bigops.sub_hk h k n1 n2 p1 p2 f1 f2))
                                     (bigops.sub_hk k h n2 n1 p2 p1 f2 f1)))
                               (sttfa.forall (sttfa.arrow nat.nat nat.nat)
                                  (k:
                                   (sttfa.etap
                                      (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                                   sttfa.impl
                                     (connectives.And
                                        (connectives.And
                                           (sttfa.forall nat.nat
                                              (i:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               sttfa.impl (nat.lt i n1)
                                                 (sttfa.impl
                                                    (logic.eq bool.bool
                                                       (p1 i) bool.true)
                                                    (logic.eq nat.nat (
                                                       f1 i) (f2 (h i))))))
                                           (bigops.sub_hk h k n1 n2 p1 p2 f1
                                              f2))
                                        (bigops.sub_hk k h n2 n1 p2 p1 f2 f1))
                                     (sttfa.impl
                                        (connectives.And
                                           (sttfa.forall nat.nat
                                              (i:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               sttfa.impl (nat.lt i n1)
                                                 (sttfa.impl
                                                    (logic.eq bool.bool
                                                       (p1 i) bool.true)
                                                    (logic.eq nat.nat (
                                                       f1 i) (f2 (h i))))))
                                           (bigops.sub_hk h k n1 n2 p1 p2 f1
                                              f2))
                                        (sttfa.impl
                                           (sttfa.forall nat.nat
                                              (i:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               sttfa.impl (nat.lt i n1)
                                                 (sttfa.impl
                                                    (logic.eq bool.bool
                                                       (p1 i) bool.true)
                                                    (logic.eq nat.nat (
                                                       f1 i) (f2 (h i))))))
                                           (sttfa.forall nat.nat
                                              (i:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               sttfa.forall nat.nat
                                                 (m:
                                                  (sttfa.etap
                                                     (sttfa.p nat.nat)) =>
                                                  sttfa.impl
                                                    (sttfa.forall
                                                       (sttfa.arrow nat.nat
                                                          bool.bool)
                                                       (f:
                                                        (sttfa.etap
                                                           (sttfa.p
                                                              (sttfa.arrow
                                                                 nat.nat
                                                                 bool.bool))) =>
                                                        sttfa.impl
                                                          (nat.le nat.O n1)
                                                          (sttfa.impl
                                                             (bigops.sub_hk
                                                                h k nat.O m
                                                                p1 f f1 f2)
                                                             (sttfa.impl
                                                                (bigops.sub_hk
                                                                   k h m
                                                                   nat.O f
                                                                   p1 f2 f1)
                                                                (logic.eq
                                                                   nat.nat
                                                                   (bigops.bigop
                                                                    nat.nat
                                                                    nat.O
                                                                    (i0:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    p1 i0)
                                                                    (nat.S
                                                                    nat.O)
                                                                    nat.times
                                                                    (i0:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    f1 i0))
                                                                   (bigops.bigop
                                                                    nat.nat
                                                                    m
                                                                    (i0:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    f i0)
                                                                    (nat.S
                                                                    nat.O)
                                                                    nat.times
                                                                    (i0:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    f2 i0)))))))
                                                    (sttfa.forall
                                                       (sttfa.arrow nat.nat
                                                          bool.bool)
                                                       (p20:
                                                        (sttfa.etap
                                                           (sttfa.p
                                                              (sttfa.arrow
                                                                 nat.nat
                                                                 bool.bool))) =>
                                                        sttfa.impl
                                                          (nat.le nat.O n1)
                                                          (sttfa.impl
                                                             (bigops.sub_hk
                                                                h k nat.O
                                                                (nat.S m) p1
                                                                p20 f1 f2)
                                                             (sttfa.impl
                                                                (bigops.sub_hk
                                                                   k h
                                                                   (nat.S m)
                                                                   nat.O p20
                                                                   p1 f2 f1)
                                                                (sttfa.forall
                                                                   nat.nat
                                                                   (x2571:
                                                                    (
                                                                    sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    sttfa.forall
                                                                    nat.nat
                                                                    (x2572:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    x2571
                                                                    (nat.plus
                                                                    (nat.times
                                                                    x2572
                                                                    (div_mod.div
                                                                    x2571
                                                                    x2572))
                                                                    (div_mod.mod
                                                                    x2571
                                                                    x2572)))))))))))))))))))))))))
  :=
  n1:(sttfa.etap (sttfa.p nat.nat)) =>
  n2:(sttfa.etap (sttfa.p nat.nat)) =>
  p1:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
  p2:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
  f1:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  f2:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  _clearme:(sttfa.eps (bigops.iso n1 n2 p1 p2 f1 f2)) =>
  h:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  _clearme0:
  (sttfa.eps
     (connectives.ex (sttfa.arrow nat.nat nat.nat)
        (k:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
         connectives.And
           (connectives.And
              (sttfa.forall nat.nat
                 (i:(sttfa.etap (sttfa.p nat.nat)) =>
                  sttfa.impl (nat.lt i n1)
                    (sttfa.impl (logic.eq bool.bool (p1 i) bool.true)
                       (logic.eq nat.nat (f1 i) (f2 (h i))))))
              (bigops.sub_hk h k n1 n2 p1 p2 f1 f2))
           (bigops.sub_hk k h n2 n1 p2 p1 f2 f1)))) =>
  k:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  _clearme1:
  (sttfa.eps
     (connectives.And
        (connectives.And
           (sttfa.forall nat.nat
              (i:(sttfa.etap (sttfa.p nat.nat)) =>
               sttfa.impl (nat.lt i n1)
                 (sttfa.impl (logic.eq bool.bool (p1 i) bool.true)
                    (logic.eq nat.nat (f1 i) (f2 (h i))))))
           (bigops.sub_hk h k n1 n2 p1 p2 f1 f2))
        (bigops.sub_hk k h n2 n1 p2 p1 f2 f1))) =>
  _clearme2:
  (sttfa.eps
     (connectives.And
        (sttfa.forall nat.nat
           (i:(sttfa.etap (sttfa.p nat.nat)) =>
            sttfa.impl (nat.lt i n1)
              (sttfa.impl (logic.eq bool.bool (p1 i) bool.true)
                 (logic.eq nat.nat (f1 i) (f2 (h i))))))
        (bigops.sub_hk h k n1 n2 p1 p2 f1 f2))) =>
  same:
  (sttfa.eps
     (sttfa.forall nat.nat
        (i:(sttfa.etap (sttfa.p nat.nat)) =>
         sttfa.impl (nat.lt i n1)
           (sttfa.impl (logic.eq bool.bool (p1 i) bool.true)
              (logic.eq nat.nat (f1 i) (f2 (h i))))))) =>
  i:(sttfa.etap (sttfa.p nat.nat)) =>
  m:(sttfa.etap (sttfa.p nat.nat)) =>
  Hind:
  (sttfa.eps
     (sttfa.forall (sttfa.arrow nat.nat bool.bool)
        (f:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
         sttfa.impl (nat.le nat.O n1)
           (sttfa.impl (bigops.sub_hk h k nat.O m p1 f f1 f2)
              (sttfa.impl (bigops.sub_hk k h m nat.O f p1 f2 f1)
                 (logic.eq nat.nat
                    (bigops.bigop nat.nat nat.O
                       (i0:(sttfa.etap (sttfa.p nat.nat)) => p1 i0)
                       (nat.S nat.O) nat.times
                       (i0:(sttfa.etap (sttfa.p nat.nat)) => f1 i0))
                    (bigops.bigop nat.nat m
                       (i0:(sttfa.etap (sttfa.p nat.nat)) => f i0)
                       (nat.S nat.O) nat.times
                       (i0:(sttfa.etap (sttfa.p nat.nat)) => f2 i0)))))))) =>
  p20:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
  __:(sttfa.eps (nat.le nat.O n1)) =>
  sub1:(sttfa.eps (bigops.sub_hk h k nat.O (nat.S m) p1 p20 f1 f2)) =>
  sub2:(sttfa.eps (bigops.sub_hk k h (nat.S m) nat.O p20 p1 f2 f1)) =>
  x2571:(sttfa.etap (sttfa.p nat.nat)) =>
  x2572:(sttfa.etap (sttfa.p nat.nat)) =>
  logic.rewrite_l nat.nat (nat.times (div_mod.div x2571 x2572) x2572)
    (__1:(sttfa.etap (sttfa.p nat.nat)) =>
     logic.eq nat.nat x2571 (nat.plus __1 (div_mod.mod x2571 x2572)))
    (div_mod.div_mod x2571 x2572)
    (nat.times x2572 (div_mod.div x2571 x2572))
    (nat.commutative_times (div_mod.div x2571 x2572) x2572).

def bigop_iso :
  sttfa.eps
    (sttfa.forall nat.nat
       (n1:(sttfa.etap (sttfa.p nat.nat)) =>
        sttfa.forall nat.nat
          (n2:(sttfa.etap (sttfa.p nat.nat)) =>
           sttfa.forall (sttfa.arrow nat.nat bool.bool)
             (p1:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
              sttfa.forall (sttfa.arrow nat.nat bool.bool)
                (p2:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
                 sttfa.forall (sttfa.arrow nat.nat nat.nat)
                   (f1:
                    (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                    sttfa.forall (sttfa.arrow nat.nat nat.nat)
                      (f2:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
                       sttfa.impl (bigops.iso n1 n2 p1 p2 f1 f2)
                         (logic.eq nat.nat
                            (bigops.bigop nat.nat n1
                               (i:(sttfa.etap (sttfa.p nat.nat)) => p1 i)
                               (nat.S nat.O) nat.times
                               (i:(sttfa.etap (sttfa.p nat.nat)) => f1 i))
                            (bigops.bigop nat.nat n2
                               (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i)
                               (nat.S nat.O) nat.times
                               (i:(sttfa.etap (sttfa.p nat.nat)) => f2 i))))))))))
  :=
  n1:(sttfa.etap (sttfa.p nat.nat)) =>
  n2:(sttfa.etap (sttfa.p nat.nat)) =>
  p1:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
  p2:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
  f1:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  f2:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
  _clearme:(sttfa.eps (bigops.iso n1 n2 p1 p2 f1 f2)) =>
  connectives.match_ex_prop (sttfa.arrow nat.nat nat.nat)
    (h:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
     connectives.ex (sttfa.arrow nat.nat nat.nat)
       (k:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        connectives.And
          (connectives.And
             (sttfa.forall nat.nat
                (i:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (nat.lt i n1)
                   (sttfa.impl (logic.eq bool.bool (p1 i) bool.true)
                      (logic.eq nat.nat (f1 i) (f2 (h i))))))
             (bigops.sub_hk h k n1 n2 p1 p2 f1 f2))
          (bigops.sub_hk k h n2 n1 p2 p1 f2 f1)))
    (logic.eq nat.nat
       (bigops.bigop nat.nat n1 (i:(sttfa.etap (sttfa.p nat.nat)) => p1 i)
          (nat.S nat.O) nat.times (i:(sttfa.etap (sttfa.p nat.nat)) => f1 i))
       (bigops.bigop nat.nat n2 (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i)
          (nat.S nat.O) nat.times (i:(sttfa.etap (sttfa.p nat.nat)) => f2 i)))
    (h:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
     _clearme0:
     (sttfa.eps
        (connectives.ex (sttfa.arrow nat.nat nat.nat)
           (k:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
            connectives.And
              (connectives.And
                 (sttfa.forall nat.nat
                    (i:(sttfa.etap (sttfa.p nat.nat)) =>
                     sttfa.impl (nat.lt i n1)
                       (sttfa.impl (logic.eq bool.bool (p1 i) bool.true)
                          (logic.eq nat.nat (f1 i) (f2 (h i))))))
                 (bigops.sub_hk h k n1 n2 p1 p2 f1 f2))
              (bigops.sub_hk k h n2 n1 p2 p1 f2 f1)))) =>
     connectives.match_ex_prop (sttfa.arrow nat.nat nat.nat)
       (k:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        connectives.And
          (connectives.And
             (sttfa.forall nat.nat
                (i:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (nat.lt i n1)
                   (sttfa.impl (logic.eq bool.bool (p1 i) bool.true)
                      (logic.eq nat.nat (f1 i) (f2 (h i))))))
             (bigops.sub_hk h k n1 n2 p1 p2 f1 f2))
          (bigops.sub_hk k h n2 n1 p2 p1 f2 f1))
       (logic.eq nat.nat
          (bigops.bigop nat.nat n1
             (i:(sttfa.etap (sttfa.p nat.nat)) => p1 i) (nat.S nat.O)
             nat.times (i:(sttfa.etap (sttfa.p nat.nat)) => f1 i))
          (bigops.bigop nat.nat n2
             (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i) (nat.S nat.O)
             nat.times (i:(sttfa.etap (sttfa.p nat.nat)) => f2 i)))
       (k:(sttfa.etap (sttfa.p (sttfa.arrow nat.nat nat.nat))) =>
        _clearme1:
        (sttfa.eps
           (connectives.And
              (connectives.And
                 (sttfa.forall nat.nat
                    (i:(sttfa.etap (sttfa.p nat.nat)) =>
                     sttfa.impl (nat.lt i n1)
                       (sttfa.impl (logic.eq bool.bool (p1 i) bool.true)
                          (logic.eq nat.nat (f1 i) (f2 (h i))))))
                 (bigops.sub_hk h k n1 n2 p1 p2 f1 f2))
              (bigops.sub_hk k h n2 n1 p2 p1 f2 f1))) =>
        connectives.match_And_prop
          (connectives.And
             (sttfa.forall nat.nat
                (i:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (nat.lt i n1)
                   (sttfa.impl (logic.eq bool.bool (p1 i) bool.true)
                      (logic.eq nat.nat (f1 i) (f2 (h i))))))
             (bigops.sub_hk h k n1 n2 p1 p2 f1 f2))
          (bigops.sub_hk k h n2 n1 p2 p1 f2 f1)
          (logic.eq nat.nat
             (bigops.bigop nat.nat n1
                (i:(sttfa.etap (sttfa.p nat.nat)) => p1 i) (nat.S nat.O)
                nat.times (i:(sttfa.etap (sttfa.p nat.nat)) => f1 i))
             (bigops.bigop nat.nat n2
                (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i) (nat.S nat.O)
                nat.times (i:(sttfa.etap (sttfa.p nat.nat)) => f2 i)))
          (_clearme2:
           (sttfa.eps
              (connectives.And
                 (sttfa.forall nat.nat
                    (i:(sttfa.etap (sttfa.p nat.nat)) =>
                     sttfa.impl (nat.lt i n1)
                       (sttfa.impl (logic.eq bool.bool (p1 i) bool.true)
                          (logic.eq nat.nat (f1 i) (f2 (h i))))))
                 (bigops.sub_hk h k n1 n2 p1 p2 f1 f2))) =>
           connectives.match_And_prop
             (sttfa.forall nat.nat
                (i:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (nat.lt i n1)
                   (sttfa.impl (logic.eq bool.bool (p1 i) bool.true)
                      (logic.eq nat.nat (f1 i) (f2 (h i))))))
             (bigops.sub_hk h k n1 n2 p1 p2 f1 f2)
             (sttfa.impl (bigops.sub_hk k h n2 n1 p2 p1 f2 f1)
                (logic.eq nat.nat
                   (bigops.bigop nat.nat n1
                      (i:(sttfa.etap (sttfa.p nat.nat)) => p1 i)
                      (nat.S nat.O) nat.times
                      (i:(sttfa.etap (sttfa.p nat.nat)) => f1 i))
                   (bigops.bigop nat.nat n2
                      (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i)
                      (nat.S nat.O) nat.times
                      (i:(sttfa.etap (sttfa.p nat.nat)) => f2 i))))
             (same:
              (sttfa.eps
                 (sttfa.forall nat.nat
                    (i:(sttfa.etap (sttfa.p nat.nat)) =>
                     sttfa.impl (nat.lt i n1)
                       (sttfa.impl (logic.eq bool.bool (p1 i) bool.true)
                          (logic.eq nat.nat (f1 i) (f2 (h i))))))) =>
              nat.le_gen
                (__:(sttfa.etap (sttfa.p nat.nat)) =>
                 sttfa.impl (bigops.sub_hk h k __ n2 p1 p2 f1 f2)
                   (sttfa.impl (bigops.sub_hk k h n2 __ p2 p1 f2 f1)
                      (logic.eq nat.nat
                         (bigops.bigop nat.nat __
                            (i:(sttfa.etap (sttfa.p nat.nat)) => p1 i)
                            (nat.S nat.O) nat.times
                            (i:(sttfa.etap (sttfa.p nat.nat)) => f1 i))
                         (bigops.bigop nat.nat n2
                            (i:(sttfa.etap (sttfa.p nat.nat)) => p2 i)
                            (nat.S nat.O) nat.times
                            (i:(sttfa.etap (sttfa.p nat.nat)) => f2 i)))))
                n1
                (i:(sttfa.etap (sttfa.p nat.nat)) =>
                 nat.nat_ind
                   (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
                    sttfa.forall (sttfa.arrow nat.nat bool.bool)
                      (f:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
                       sttfa.impl (nat.le _x_365 n1)
                         (sttfa.impl
                            (bigops.sub_hk h k _x_365 n2 p1 f f1 f2)
                            (sttfa.impl
                               (bigops.sub_hk k h n2 _x_365 f p1 f2 f1)
                               (logic.eq nat.nat
                                  (bigops.bigop nat.nat _x_365
                                     (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                                      p1 i0) (nat.S nat.O) nat.times
                                     (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                                      f1 i0))
                                  (bigops.bigop nat.nat n2
                                     (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                                      f i0) (nat.S nat.O) nat.times
                                     (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                                      f2 i0)))))))
                   (nat.nat_ind
                      (_x_365:(sttfa.etap (sttfa.p nat.nat)) =>
                       sttfa.forall (sttfa.arrow nat.nat bool.bool)
                         (f:
                          (sttfa.etap
                             (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
                          sttfa.impl (nat.le nat.O n1)
                            (sttfa.impl
                               (bigops.sub_hk h k nat.O _x_365 p1 f f1 f2)
                               (sttfa.impl
                                  (bigops.sub_hk k h _x_365 nat.O f p1 f2 f1)
                                  (logic.eq nat.nat
                                     (bigops.bigop nat.nat nat.O
                                        (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                                         p1 i0) (nat.S nat.O) nat.times
                                        (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                                         f1 i0))
                                     (bigops.bigop nat.nat _x_365
                                        (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                                         f i0) (nat.S nat.O) nat.times
                                        (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                                         f2 i0)))))))
                      (f:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
                       bigops.sym_eq_bigop_O nat.nat
                         (y:
                          (sttfa.etap
                             (sttfa.p
                                (sttfa.arrow (sttfa.arrow nat.nat bool.bool)
                                   (sttfa.arrow nat.nat
                                      (sttfa.arrow
                                         (sttfa.arrow nat.nat
                                            (sttfa.arrow nat.nat nat.nat))
                                         (sttfa.arrow
                                            (sttfa.arrow nat.nat nat.nat)
                                            nat.nat)))))) =>
                          sttfa.impl (nat.le nat.O n1)
                            (sttfa.impl
                               (bigops.sub_hk h k nat.O nat.O p1 f f1 f2)
                               (sttfa.impl
                                  (bigops.sub_hk k h nat.O nat.O f p1 f2 f1)
                                  (logic.eq nat.nat
                                     (bigops.bigop nat.nat nat.O
                                        (iO:(sttfa.etap (sttfa.p nat.nat)) =>
                                         p1 iO) (nat.S nat.O) nat.times
                                        (iO:(sttfa.etap (sttfa.p nat.nat)) =>
                                         f1 iO))
                                     (y
                                        (iO:(sttfa.etap (sttfa.p nat.nat)) =>
                                         f iO) (nat.S nat.O) nat.times
                                        (iO:(sttfa.etap (sttfa.p nat.nat)) =>
                                         f2 iO))))))
                         (bigops.sym_eq_bigop_body_O nat.nat
                            (y:
                             (sttfa.etap
                                (sttfa.p
                                   (sttfa.arrow
                                      (sttfa.arrow nat.nat bool.bool)
                                      (sttfa.arrow nat.nat
                                         (sttfa.arrow
                                            (sttfa.arrow nat.nat
                                               (sttfa.arrow nat.nat nat.nat))
                                            (sttfa.arrow
                                               (sttfa.arrow nat.nat nat.nat)
                                               nat.nat)))))) =>
                             sttfa.impl (nat.le nat.O n1)
                               (sttfa.impl
                                  (bigops.sub_hk h k nat.O nat.O p1 f f1 f2)
                                  (sttfa.impl
                                     (bigops.sub_hk k h nat.O nat.O f p1 f2
                                        f1)
                                     (logic.eq nat.nat
                                        (bigops.bigop nat.nat nat.O
                                           (iO:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            p1 iO) (nat.S nat.O) nat.times
                                           (iO:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            f1 iO))
                                        (y
                                           (iO:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            f iO) (nat.S nat.O) nat.times
                                           (iO:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            f2 iO))))))
                            (bigops.eq_bigop_body_O nat.nat
                               (y:
                                (sttfa.etap
                                   (sttfa.p
                                      (sttfa.arrow
                                         (sttfa.arrow nat.nat bool.bool)
                                         (sttfa.arrow nat.nat
                                            (sttfa.arrow
                                               (sttfa.arrow nat.nat
                                                  (sttfa.arrow nat.nat
                                                     nat.nat))
                                               (sttfa.arrow
                                                  (sttfa.arrow nat.nat
                                                     nat.nat) nat.nat)))))) =>
                                sttfa.impl (nat.le nat.O n1)
                                  (sttfa.impl
                                     (bigops.sub_hk h k nat.O nat.O p1 f f1
                                        f2)
                                     (sttfa.impl
                                        (bigops.sub_hk k h nat.O nat.O f p1
                                           f2 f1)
                                        (logic.eq nat.nat
                                           (bigops.bigop nat.nat nat.O
                                              (iO:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               p1 iO) (nat.S nat.O)
                                              nat.times
                                              (iO:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               f1 iO))
                                           (y
                                              (iO:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               p1 iO) (nat.S nat.O)
                                              nat.times
                                              (iO:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               f1 iO))))))
                               (bigops.eq_bigop_O nat.nat
                                  (y:
                                   (sttfa.etap
                                      (sttfa.p
                                         (sttfa.arrow
                                            (sttfa.arrow nat.nat bool.bool)
                                            (sttfa.arrow nat.nat
                                               (sttfa.arrow
                                                  (sttfa.arrow nat.nat
                                                     (sttfa.arrow nat.nat
                                                        nat.nat))
                                                  (sttfa.arrow
                                                     (sttfa.arrow nat.nat
                                                        nat.nat) nat.nat)))))) =>
                                   sttfa.impl (nat.le nat.O n1)
                                     (sttfa.impl
                                        (bigops.sub_hk h k nat.O nat.O p1 f
                                           f1 f2)
                                        (sttfa.impl
                                           (bigops.sub_hk k h nat.O nat.O f
                                              p1 f2 f1)
                                           (logic.eq nat.nat
                                              (bigops.bigop nat.nat nat.O
                                                 (iO:
                                                  (sttfa.etap
                                                     (sttfa.p nat.nat)) =>
                                                  p1 iO) (nat.S nat.O)
                                                 nat.times
                                                 (iO:
                                                  (sttfa.etap
                                                     (sttfa.p nat.nat)) =>
                                                  f1 iO))
                                              (y
                                                 (iO:
                                                  (sttfa.etap
                                                     (sttfa.p nat.nat)) =>
                                                  p1 iO) (nat.S nat.O)
                                                 nat.times
                                                 (iO:
                                                  (sttfa.etap
                                                     (sttfa.p nat.nat)) =>
                                                  f1 iO))))))
                                  (auto:(sttfa.eps (nat.le nat.O n1)) =>
                                   auto':
                                   (sttfa.eps
                                      (bigops.sub_hk h k nat.O nat.O p1 f f1
                                         f2)) =>
                                   auto'':
                                   (sttfa.eps
                                      (bigops.sub_hk k h nat.O nat.O f p1 f2
                                         f1)) =>
                                   logic.refl nat.nat
                                     (bigops.bigop nat.nat nat.O
                                        (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                                         p1 i0) (nat.S nat.O) nat.times
                                        (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                                         f1 i0)))))))
                      (m:(sttfa.etap (sttfa.p nat.nat)) =>
                       Hind:
                       (sttfa.eps
                          (sttfa.forall (sttfa.arrow nat.nat bool.bool)
                             (f:
                              (sttfa.etap
                                 (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
                              sttfa.impl (nat.le nat.O n1)
                                (sttfa.impl
                                   (bigops.sub_hk h k nat.O m p1 f f1 f2)
                                   (sttfa.impl
                                      (bigops.sub_hk k h m nat.O f p1 f2 f1)
                                      (logic.eq nat.nat
                                         (bigops.bigop nat.nat nat.O
                                            (i0:
                                             (sttfa.etap (sttfa.p nat.nat)) =>
                                             p1 i0) (nat.S nat.O) nat.times
                                            (i0:
                                             (sttfa.etap (sttfa.p nat.nat)) =>
                                             f1 i0))
                                         (bigops.bigop nat.nat m
                                            (i0:
                                             (sttfa.etap (sttfa.p nat.nat)) =>
                                             f i0) (nat.S nat.O) nat.times
                                            (i0:
                                             (sttfa.etap (sttfa.p nat.nat)) =>
                                             f2 i0)))))))) =>
                       p20:
                       (sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
                       __:(sttfa.eps (nat.le nat.O n1)) =>
                       sub1:
                       (sttfa.eps
                          (bigops.sub_hk h k nat.O (nat.S m) p1 p20 f1 f2)) =>
                       sub2:
                       (sttfa.eps
                          (bigops.sub_hk k h (nat.S m) nat.O p20 p1 f2 f1)) =>
                       logic.eq_ind_r nat.nat
                         (bigops.bigop nat.nat m
                            (i0:(sttfa.etap (sttfa.p nat.nat)) => p20 i0)
                            (nat.S nat.O) nat.times
                            (i0:(sttfa.etap (sttfa.p nat.nat)) => f2 i0))
                         (x:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat
                            (bigops.bigop nat.nat nat.O
                               (i0:(sttfa.etap (sttfa.p nat.nat)) => p1 i0)
                               (nat.S nat.O) nat.times
                               (i0:(sttfa.etap (sttfa.p nat.nat)) => f1 i0))
                            x)
                         (Hind p20 (nat.le_O_n n1)
                            (bigops.sub_hkO h k nat.O m p1 p20 f1 f2
                               (logic.refl nat.nat nat.O))
                            (bigops.transitive_sub
                               (x:(sttfa.etap (sttfa.p nat.nat)) => x)
                               (x:(sttfa.etap (sttfa.p nat.nat)) => x) k h m
                               (nat.S m) nat.O p20 p20 p1 f2 f2 f1
                               (bigops.sub_lt f2 p20 m (nat.S m)
                                  (nat.le_n_Sn m)) sub2))
                         (bigops.bigop nat.nat (nat.S m)
                            (i0:(sttfa.etap (sttfa.p nat.nat)) => p20 i0)
                            (nat.S nat.O) nat.times
                            (i0:(sttfa.etap (sttfa.p nat.nat)) => f2 i0))
                         (bigops.bigop_Sfalse nat.nat m p20 (nat.S nat.O)
                            nat.times f2
                            (bigops.sub0_to_false k h nat.O (nat.S m) p1 p20
                               f1 f2 (logic.refl nat.nat nat.O) sub2 m
                               (logic.eq_coerc
                                  (nat.lt (div_mod.mod m nat.O)
                                     (nat.plus
                                        (nat.plus (div_mod.mod m nat.O)
                                           (nat.times nat.O
                                              (div_mod.div m nat.O)))
                                        (nat.S nat.O))) (nat.lt m (nat.S m))
                                  (nat.lt_plus_Sn_r (div_mod.mod m nat.O)
                                     (nat.times nat.O (div_mod.div m nat.O))
                                     nat.O)
                                  (logic.rewrite_l nat.nat m
                                     (__1:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq sttfa.bool
                                        (nat.lt (div_mod.mod m nat.O)
                                           (nat.plus __1 (nat.S nat.O)))
                                        (nat.lt m (nat.S m)))
                                     (logic.rewrite_l nat.nat m
                                        (__1:
                                         (sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq sttfa.bool
                                           (nat.lt __1
                                              (nat.plus m (nat.S nat.O)))
                                           (nat.lt m (nat.S m)))
                                        (logic.rewrite_l nat.nat (nat.S m)
                                           (__1:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq sttfa.bool
                                              (nat.lt m __1)
                                              (nat.lt m (nat.S m)))
                                           (logic.refl sttfa.bool
                                              (nat.lt m (nat.S m)))
                                           (nat.plus m (nat.S nat.O))
                                           (logic.rewrite_r nat.nat
                                              (nat.plus m nat.O)
                                              (__1:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq nat.nat (nat.S __1)
                                                 (nat.plus m (nat.S nat.O)))
                                              (nat.plus_n_Sm m nat.O) m
                                              (nat.plus_n_O m)))
                                        (div_mod.mod m nat.O)
                                        (logic.rewrite_r nat.nat
                                           (nat.plus nat.O
                                              (div_mod.mod m nat.O))
                                           (__1:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            logic.eq nat.nat m __1)
                                           (logic.rewrite_l nat.nat
                                              (nat.plus
                                                 (div_mod.mod m nat.O) nat.O)
                                              (__1:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               logic.eq nat.nat m __1)
                                              (logic.rewrite_r nat.nat
                                                 (nat.times nat.O
                                                    (div_mod.div m nat.O))
                                                 (__1:
                                                  (sttfa.etap
                                                     (sttfa.p nat.nat)) =>
                                                  logic.eq nat.nat m
                                                    (nat.plus
                                                       (div_mod.mod m nat.O)
                                                       __1))
                                                 (logic.rewrite_l nat.nat
                                                    (nat.plus
                                                       (nat.times nat.O
                                                          (div_mod.div m
                                                             nat.O))
                                                       (div_mod.mod m nat.O))
                                                    (__1:
                                                     (sttfa.etap
                                                        (sttfa.p nat.nat)) =>
                                                     logic.eq nat.nat m __1)
                                                    (bigops.let_clause_10471
                                                       n1 n2 p1 p2 f1 f2
                                                       _clearme h _clearme0
                                                       k _clearme1 _clearme2
                                                       same i m Hind p20 __
                                                       sub1 sub2 m nat.O)
                                                    (nat.plus
                                                       (div_mod.mod m nat.O)
                                                       (nat.times nat.O
                                                          (div_mod.div m
                                                             nat.O)))
                                                    (nat.commutative_plus
                                                       (nat.times nat.O
                                                          (div_mod.div m
                                                             nat.O))
                                                       (div_mod.mod m nat.O)))
                                                 nat.O
                                                 (nat.times_O_n
                                                    (div_mod.div m nat.O)))
                                              (nat.plus nat.O
                                                 (div_mod.mod m nat.O))
                                              (nat.commutative_plus
                                                 (div_mod.mod m nat.O) nat.O))
                                           (div_mod.mod m nat.O)
                                           (nat.plus_O_n
                                              (div_mod.mod m nat.O))))
                                     (nat.plus (div_mod.mod m nat.O)
                                        (nat.times nat.O
                                           (div_mod.div m nat.O)))
                                     (logic.rewrite_l nat.nat
                                        (nat.plus
                                           (nat.times nat.O
                                              (div_mod.div m nat.O))
                                           (div_mod.mod m nat.O))
                                        (__1:
                                         (sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq nat.nat m __1)
                                        (bigops.let_clause_10471 n1 n2 p1 p2
                                           f1 f2 _clearme h _clearme0 k
                                           _clearme1 _clearme2 same i m Hind
                                           p20 __ sub1 sub2 m nat.O)
                                        (nat.plus (div_mod.mod m nat.O)
                                           (nat.times nat.O
                                              (div_mod.div m nat.O)))
                                        (nat.commutative_plus
                                           (nat.times nat.O
                                              (div_mod.div m nat.O))
                                           (div_mod.mod m nat.O)))))))) n2)
                   (n:(sttfa.etap (sttfa.p nat.nat)) =>
                    Hind:
                    (sttfa.eps
                       (sttfa.forall (sttfa.arrow nat.nat bool.bool)
                          (f:
                           (sttfa.etap
                              (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
                           sttfa.impl (nat.le n n1)
                             (sttfa.impl (bigops.sub_hk h k n n2 p1 f f1 f2)
                                (sttfa.impl
                                   (bigops.sub_hk k h n2 n f p1 f2 f1)
                                   (logic.eq nat.nat
                                      (bigops.bigop nat.nat n
                                         (i0:
                                          (sttfa.etap (sttfa.p nat.nat)) =>
                                          p1 i0) (nat.S nat.O) nat.times
                                         (i0:
                                          (sttfa.etap (sttfa.p nat.nat)) =>
                                          f1 i0))
                                      (bigops.bigop nat.nat n2
                                         (i0:
                                          (sttfa.etap (sttfa.p nat.nat)) =>
                                          f i0) (nat.S nat.O) nat.times
                                         (i0:
                                          (sttfa.etap (sttfa.p nat.nat)) =>
                                          f2 i0)))))))) =>
                    p20:
                    (sttfa.etap (sttfa.p (sttfa.arrow nat.nat bool.bool))) =>
                    ltn:(sttfa.eps (nat.le (nat.S n) n1)) =>
                    sub1:
                    (sttfa.eps (bigops.sub_hk h k (nat.S n) n2 p1 p20 f1 f2)) =>
                    sub2:
                    (sttfa.eps (bigops.sub_hk k h n2 (nat.S n) p20 p1 f2 f1)) =>
                    connectives.match_Or_prop
                      (logic.eq bool.bool (p1 n) bool.true)
                      (logic.eq bool.bool (p1 n) bool.false)
                      (logic.eq nat.nat
                         (bigops.bigop nat.nat (nat.S n)
                            (i0:(sttfa.etap (sttfa.p nat.nat)) => p1 i0)
                            (nat.S nat.O) nat.times
                            (i0:(sttfa.etap (sttfa.p nat.nat)) => f1 i0))
                         (bigops.bigop nat.nat n2
                            (i0:(sttfa.etap (sttfa.p nat.nat)) => p20 i0)
                            (nat.S nat.O) nat.times
                            (i0:(sttfa.etap (sttfa.p nat.nat)) => f2 i0)))
                      (p1n:
                       (sttfa.eps (logic.eq bool.bool (p1 n) bool.true)) =>
                       logic.eq_ind_r nat.nat
                         (nat.times (f1 n)
                            (bigops.bigop nat.nat n
                               (i0:(sttfa.etap (sttfa.p nat.nat)) => p1 i0)
                               (nat.S nat.O) nat.times
                               (i0:(sttfa.etap (sttfa.p nat.nat)) => f1 i0)))
                         (x:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat x
                            (bigops.bigop nat.nat n2
                               (i0:(sttfa.etap (sttfa.p nat.nat)) => p20 i0)
                               (nat.S nat.O) nat.times
                               (i0:(sttfa.etap (sttfa.p nat.nat)) => f2 i0)))
                         (connectives.match_And_prop
                            (connectives.And (nat.lt (h n) n2)
                               (logic.eq bool.bool (p20 (h n)) bool.true))
                            (logic.eq nat.nat (k (h n)) n)
                            (logic.eq nat.nat
                               (nat.times (f1 n)
                                  (bigops.bigop nat.nat n
                                     (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                                      p1 i0) (nat.S nat.O) nat.times
                                     (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                                      f1 i0)))
                               (bigops.bigop nat.nat n2
                                  (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                                   p20 i0) (nat.S nat.O) nat.times
                                  (i0:(sttfa.etap (sttfa.p nat.nat)) => f2 i0)))
                            (_clearme3:
                             (sttfa.eps
                                (connectives.And (nat.lt (h n) n2)
                                   (logic.eq bool.bool (p20 (h n)) bool.true))) =>
                             connectives.match_And_prop (nat.lt (h n) n2)
                               (logic.eq bool.bool (p20 (h n)) bool.true)
                               (sttfa.impl (logic.eq nat.nat (k (h n)) n)
                                  (logic.eq nat.nat
                                     (nat.times (f1 n)
                                        (bigops.bigop nat.nat n
                                           (i0:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            p1 i0) (nat.S nat.O) nat.times
                                           (i0:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            f1 i0)))
                                     (bigops.bigop nat.nat n2
                                        (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                                         p20 i0) (nat.S nat.O) nat.times
                                        (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                                         f2 i0))))
                               (hn:(sttfa.eps (nat.lt (h n) n2)) =>
                                p2hn:
                                (sttfa.eps
                                   (logic.eq bool.bool (p20 (h n)) bool.true)) =>
                                eqn:
                                (sttfa.eps (logic.eq nat.nat (k (h n)) n)) =>
                                logic.eq_ind_r nat.nat
                                  (nat.times (f2 (h n))
                                     (bigops.bigop nat.nat n2
                                        (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                         bool.andb
                                           (bool.notb (nat.eqb (h n) x))
                                           (p20 x)) (nat.S nat.O) nat.times
                                        (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                         f2 x)))
                                  (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                   logic.eq nat.nat
                                     (nat.times (f1 n)
                                        (bigops.bigop nat.nat n
                                           (i0:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            p1 i0) (nat.S nat.O) nat.times
                                           (i0:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            f1 i0))) x)
                                  (logic.eq_ind_r nat.nat (f2 (h n))
                                     (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                      logic.eq nat.nat
                                        (nat.times x
                                           (bigops.bigop nat.nat n
                                              (i0:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               p1 i0) (nat.S nat.O)
                                              nat.times
                                              (i0:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               f1 i0)))
                                        (nat.times (f2 (h n))
                                           (bigops.bigop nat.nat n2
                                              (x0:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               bool.andb
                                                 (bool.notb
                                                    (nat.eqb (h n) x0))
                                                 (p20 x0)) (nat.S nat.O)
                                              nat.times
                                              (x0:
                                               (sttfa.etap (sttfa.p nat.nat)) =>
                                               f2 x0))))
                                     (logic.eq_f nat.nat nat.nat
                                        (nat.times (f2 (h n)))
                                        (bigops.bigop nat.nat n
                                           (i0:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            p1 i0) (nat.S nat.O) nat.times
                                           (i0:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            f1 i0))
                                        (bigops.bigop nat.nat n2
                                           (x:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            bool.andb
                                              (bool.notb (nat.eqb (h n) x))
                                              (p20 x)) (nat.S nat.O)
                                           nat.times
                                           (x:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            f2 x))
                                        (Hind
                                           (__:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            bool.andb
                                              (bool.notb (nat.eqb (h n) __))
                                              (p20 __))
                                           (nat.lt_to_le n n1 ltn)
                                           (i0:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            ltin:(sttfa.eps (nat.lt i0 n)) =>
                                            p1i:
                                            (sttfa.eps
                                               (logic.eq bool.bool (p1 i0)
                                                  bool.true)) =>
                                            connectives.match_And_prop
                                              (connectives.And
                                                 (nat.lt (h i0) n2)
                                                 (logic.eq bool.bool
                                                    (p20 (h i0)) bool.true))
                                              (logic.eq nat.nat (k (h i0)) i0)
                                              (connectives.And
                                                 (connectives.And
                                                    (nat.lt (h i0) n2)
                                                    (logic.eq bool.bool
                                                       (bool.andb
                                                          (bool.notb
                                                             (nat.eqb (
                                                                h n) (
                                                                h i0)))
                                                          (p20 (h i0)))
                                                       bool.true))
                                                 (logic.eq nat.nat
                                                    (k (h i0)) i0))
                                              (_clearme4:
                                               (sttfa.eps
                                                  (connectives.And
                                                     (nat.lt (h i0) n2)
                                                     (logic.eq bool.bool
                                                        (p20 (h i0))
                                                        bool.true))) =>
                                               connectives.match_And_prop
                                                 (nat.lt (h i0) n2)
                                                 (logic.eq bool.bool
                                                    (p20 (h i0)) bool.true)
                                                 (sttfa.impl
                                                    (logic.eq nat.nat
                                                       (k (h i0)) i0)
                                                    (connectives.And
                                                       (connectives.And
                                                          (nat.lt (h i0) n2)
                                                          (logic.eq
                                                             bool.bool
                                                             (bool.andb
                                                                (bool.notb
                                                                   (nat.eqb
                                                                    (h n)
                                                                    (h i0)))
                                                                (p20 (h i0)))
                                                             bool.true))
                                                       (logic.eq nat.nat
                                                          (k (h i0)) i0)))
                                                 (h1i:
                                                  (sttfa.eps
                                                     (nat.lt (h i0) n2)) =>
                                                  p2h1i:
                                                  (sttfa.eps
                                                     (logic.eq bool.bool
                                                        (p20 (h i0))
                                                        bool.true)) =>
                                                  eqi:
                                                  (sttfa.eps
                                                     (logic.eq nat.nat
                                                        (k (h i0)) i0)) =>
                                                  connectives.conj
                                                        (connectives.And
                                                           (nat.lt (h i0) n2)
                                                           (logic.eq
                                                              bool.bool
                                                              (bool.andb
                                                                 (bool.notb
                                                                    (
                                                                    nat.eqb
                                                                    (h n)
                                                                    (h i0)))
                                                                 (p20 (h i0)))
                                                              bool.true))
                                                           (logic.eq nat.nat
                                                              (k (h i0)) i0)
                                                    (connectives.conj
                                                           (nat.lt (h i0) n2)
                                                              (logic.eq
                                                                 bool.bool
                                                                 (bool.andb
                                                                    (
                                                                    bool.notb
                                                                    (nat.eqb
                                                                    (h n)
                                                                    (h i0)))
                                                                    (
                                                                    p20
                                                                    (h i0)))
                                                                 bool.true)
                                                     h1i
                                                       (logic.eq_ind_r
                                                          bool.bool
                                                          bool.false
                                                          (x:
                                                           (sttfa.etap
                                                              (sttfa.p
                                                                 bool.bool)) =>
                                                           logic.eq
                                                             bool.bool
                                                             (bool.andb
                                                                (bool.notb x)
                                                                (p20 (h i0)))
                                                             bool.true)
                                                          (bool.sym_eq_match_bool_type_false
                                                             bool.bool
                                                             bool.false
                                                             bool.true
                                                             (y:
                                                              (sttfa.etap
                                                                 (sttfa.p
                                                                    bool.bool)) =>
                                                              logic.eq
                                                                bool.bool
                                                                (bool.match_bool_type
                                                                   bool.bool
                                                                   (p20
                                                                    (h i0))
                                                                   bool.false
                                                                   y)
                                                                bool.true)
                                                             (bool.sym_eq_match_bool_type_true
                                                                bool.bool
                                                                (p20 (h i0))
                                                                bool.false
                                                                (y:
                                                                 (sttfa.etap
                                                                    (
                                                                    sttfa.p
                                                                    bool.bool)) =>
                                                                 logic.eq
                                                                   bool.bool
                                                                   y
                                                                   bool.true)
                                                                (logic.rewrite_r
                                                                   bool.bool
                                                                   bool.true
                                                                   (__:
                                                                    (
                                                                    sttfa.etap
                                                                    (sttfa.p
                                                                    bool.bool)) =>
                                                                    logic.eq
                                                                    bool.bool
                                                                    __
                                                                    bool.true)
                                                                   (logic.refl
                                                                    bool.bool
                                                                    bool.true)
                                                                   (p20
                                                                    (h i0))
                                                                   p2h1i)))
                                                          (nat.eqb (h n)
                                                             (h i0))
                                                          (nat.not_eq_to_eqb_false
                                                             (h n) (h i0)
                                                             (logic.not_to_not
                                                                (logic.eq
                                                                   nat.nat
                                                                   (h n)
                                                                   (h i0))
                                                                (logic.eq
                                                                   nat.nat
                                                                   i0 n)
                                                                (auto:
                                                                 (sttfa.eps
                                                                    (
                                                                    logic.eq
                                                                    nat.nat
                                                                    (h n)
                                                                    (h i0))) =>
                                                                 logic.rewrite_r
                                                                   nat.nat n
                                                                   (__:
                                                                    (
                                                                    sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    __ n)
                                                                   (logic.refl
                                                                    nat.nat n)
                                                                   i0
                                                                   (logic.rewrite_l
                                                                    nat.nat
                                                                    (k (h n))
                                                                    (__:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    __ n)
                                                                    eqn i0
                                                                    (logic.rewrite_r
                                                                    nat.nat
                                                                    (h i0)
                                                                    (__:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (k __) i0)
                                                                    eqi
                                                                    (h n)
                                                                    auto)))
                                                                (nat.lt_to_not_eq
                                                                   i0 n ltin)))))
                                                    (logic.rewrite_r nat.nat
                                                       i0
                                                       (__:
                                                        (sttfa.etap
                                                           (sttfa.p nat.nat)) =>
                                                        logic.eq nat.nat __
                                                          i0)
                                                       (logic.refl nat.nat i0)
                                                       (k (h i0)) eqi))
                                                 _clearme4)
                                              (sub1 i0
                                                 (nat.le_S (nat.S i0) n ltin)
                                                 p1i))
                                           (j:
                                            (sttfa.etap (sttfa.p nat.nat)) =>
                                            ltj:(sttfa.eps (nat.lt j n2)) =>
                                            p2j:
                                            (sttfa.eps
                                               (logic.eq bool.bool
                                                  (bool.andb
                                                     (bool.notb
                                                        (nat.eqb (h n) j))
                                                     (p20 j)) bool.true)) =>
                                            connectives.match_And_prop
                                              (connectives.And
                                                 (nat.lt (k j) (nat.S n))
                                                 (logic.eq bool.bool
                                                    (p1 (k j)) bool.true))
                                              (logic.eq nat.nat (h (k j)) j)
                                              (connectives.And
                                                 (connectives.And
                                                    (nat.lt (k j) n)
                                                    (logic.eq bool.bool
                                                       (p1 (k j)) bool.true))
                                                 (logic.eq nat.nat (h (k j))
                                                    j))
                                              (_clearme4:
                                               (sttfa.eps
                                                  (connectives.And
                                                     (nat.lt (k j) (nat.S n))
                                                     (logic.eq bool.bool
                                                        (p1 (k j)) bool.true))) =>
                                               connectives.match_And_prop
                                                 (nat.lt (k j) (nat.S n))
                                                 (logic.eq bool.bool
                                                    (p1 (k j)) bool.true)
                                                 (sttfa.impl
                                                    (logic.eq nat.nat
                                                       (h (k j)) j)
                                                    (connectives.And
                                                       (connectives.And
                                                          (nat.lt (k j) n)
                                                          (logic.eq
                                                             bool.bool
                                                             (p1 (k j))
                                                             bool.true))
                                                       (logic.eq nat.nat
                                                          (h (k j)) j)))
                                                 (ltkj:
                                                  (sttfa.eps
                                                     (nat.lt (k j) (nat.S n))) =>
                                                  p1kj:
                                                  (sttfa.eps
                                                     (logic.eq bool.bool
                                                        (p1 (k j)) bool.true)) =>
                                                  eqj:
                                                  (sttfa.eps
                                                     (logic.eq nat.nat
                                                        (h (k j)) j)) =>
                                                        connectives.conj
                                                        (connectives.And
                                                           (nat.lt (k j) n)
                                                           (logic.eq
                                                              bool.bool
                                                              (p1 (k j))
                                                              bool.true))
                                                           (logic.eq nat.nat
                                                              (h (k j)) j)
                                                    (connectives.conj
                                                           (nat.lt (k j) n)
                                                              (logic.eq
                                                                 bool.bool
                                                                 (p1 (k j))
                                                                 bool.true)
                                                       (connectives.match_Or_prop
                                                          (nat.lt (k j) n)
                                                          (logic.eq nat.nat
                                                             (k j) n)
                                                          (nat.lt (k j) n)
                                                          (auto:
                                                           (sttfa.eps
                                                              (nat.lt (k j) n)) =>
                                                           auto)
                                                          (eqkj:
                                                           (sttfa.eps
                                                              (logic.eq
                                                                 nat.nat
                                                                 (k j) n)) =>
                                                           connectives.falsity
                                                             (nat.lt (k j) n)
                                                             (nat.eqb_elim
                                                                (h n) j
                                                                (__:
                                                                 (sttfa.etap
                                                                    (
                                                                    sttfa.p
                                                                    bool.bool)) =>
                                                                 sttfa.impl
                                                                   (logic.eq
                                                                    bool.bool
                                                                    (bool.andb
                                                                    (bool.notb
                                                                    __)
                                                                    (p20 j))
                                                                    bool.true)
                                                                   connectives.False)
                                                                (bool.sym_eq_match_bool_type_true
                                                                   bool.bool
                                                                   bool.false
                                                                   bool.true
                                                                   (y:
                                                                    (
                                                                    sttfa.etap
                                                                    (sttfa.p
                                                                    bool.bool)) =>
                                                                    sttfa.impl
                                                                    (logic.eq
                                                                    nat.nat
                                                                    (h n) j)
                                                                    (sttfa.impl
                                                                    (logic.eq
                                                                    bool.bool
                                                                    (bool.match_bool_type
                                                                    bool.bool
                                                                    (p20 j)
                                                                    bool.false
                                                                    y)
                                                                    bool.true)
                                                                    connectives.False))
                                                                   (bool.sym_eq_match_bool_type_false
                                                                    bool.bool
                                                                    (p20 j)
                                                                    bool.false
                                                                    (y:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    bool.bool)) =>
                                                                    sttfa.impl
                                                                    (logic.eq
                                                                    nat.nat
                                                                    (h n) j)
                                                                    (sttfa.impl
                                                                    (logic.eq
                                                                    bool.bool
                                                                    y
                                                                    bool.true)
                                                                    connectives.False))
                                                                    (auto:
                                                                    (sttfa.eps
                                                                    (logic.eq
                                                                    nat.nat
                                                                    (h n) j)) =>
                                                                    auto':
                                                                    (
                                                                    sttfa.eps
                                                                    (logic.eq
                                                                    bool.bool
                                                                    bool.false
                                                                    bool.true)) =>
                                                                    logic.absurd
                                                                    (logic.eq
                                                                    bool.bool
                                                                    bool.true
                                                                    bool.false)
                                                                    (logic.rewrite_r
                                                                    bool.bool
                                                                    bool.true
                                                                    (__:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    bool.bool)) =>
                                                                    logic.eq
                                                                    bool.bool
                                                                    bool.true
                                                                    __)
                                                                    (logic.refl
                                                                    bool.bool
                                                                    bool.true)
                                                                    bool.false
                                                                    auto')
                                                                    bool.not_eq_true_false)))
                                                                (bool.sym_eq_match_bool_type_false
                                                                   bool.bool
                                                                   bool.false
                                                                   bool.true
                                                                   (y:
                                                                    (
                                                                    sttfa.etap
                                                                    (sttfa.p
                                                                    bool.bool)) =>
                                                                    sttfa.impl
                                                                    (connectives.Not
                                                                    (logic.eq
                                                                    nat.nat
                                                                    (h n) j))
                                                                    (sttfa.impl
                                                                    (logic.eq
                                                                    bool.bool
                                                                    (bool.match_bool_type
                                                                    bool.bool
                                                                    (p20 j)
                                                                    bool.false
                                                                    y)
                                                                    bool.true)
                                                                    connectives.False))
                                                                   (bool.sym_eq_match_bool_type_true
                                                                    bool.bool
                                                                    (p20 j)
                                                                    bool.false
                                                                    (y:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    bool.bool)) =>
                                                                    sttfa.impl
                                                                    (connectives.Not
                                                                    (logic.eq
                                                                    nat.nat
                                                                    (h n) j))
                                                                    (sttfa.impl
                                                                    (logic.eq
                                                                    bool.bool
                                                                    y
                                                                    bool.true)
                                                                    connectives.False))
                                                                    (auto:
                                                                    (sttfa.eps
                                                                    (connectives.Not
                                                                    (logic.eq
                                                                    nat.nat
                                                                    (h n) j))) =>
                                                                    auto':
                                                                    (
                                                                    sttfa.eps
                                                                    (logic.eq
                                                                    bool.bool
                                                                    (p20 j)
                                                                    bool.true)) =>
                                                                    logic.absurd
                                                                    (logic.eq
                                                                    nat.nat
                                                                    (h n) j)
                                                                    (logic.rewrite_r
                                                                    nat.nat
                                                                    j
                                                                    (__:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    __ j)
                                                                    (logic.refl
                                                                    nat.nat j)
                                                                    (h n)
                                                                    (logic.rewrite_l
                                                                    nat.nat
                                                                    (k j)
                                                                    (__:
                                                                    (sttfa.etap
                                                                    (sttfa.p
                                                                    nat.nat)) =>
                                                                    logic.eq
                                                                    nat.nat
                                                                    (h __) j)
                                                                    eqj n
                                                                    eqkj))
                                                                    auto)))
                                                                p2j))
                                                          (nat.le_to_or_lt_eq
                                                             (k j) n
                                                             (nat.le_S_S_to_le
                                                                (k j) n ltkj)))
                                                       (logic.rewrite_r
                                                          bool.bool
                                                          bool.true
                                                          (__:
                                                           (sttfa.etap
                                                              (sttfa.p
                                                                 bool.bool)) =>
                                                           logic.eq
                                                             bool.bool __
                                                             bool.true)
                                                          (logic.refl
                                                             bool.bool
                                                             bool.true)
                                                          (p1 (k j)) p1kj))
                                                    (logic.rewrite_r nat.nat
                                                       j
                                                       (__:
                                                        (sttfa.etap
                                                           (sttfa.p nat.nat)) =>
                                                        logic.eq nat.nat __ j)
                                                       (logic.refl nat.nat j)
                                                       (h (k j)) eqj))
                                                 _clearme4)
                                              (sub2 j ltj
                                                 (bool.andb_true_r
                                                    (bool.notb
                                                       (nat.eqb (h n) j))
                                                    (p20 j) p2j))))) (
                                     f1 n)
                                     (same n ltn
                                        (logic.rewrite_r bool.bool bool.true
                                           (__:
                                            (sttfa.etap (sttfa.p bool.bool)) =>
                                            logic.eq bool.bool __ bool.true)
                                           (logic.refl bool.bool bool.true)
                                           (p1 n) p1n)))
                                  (bigops.bigop nat.nat n2
                                     (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                      p20 x) (nat.S nat.O) nat.times
                                     (x:(sttfa.etap (sttfa.p nat.nat)) =>
                                      f2 x))
                                  (bigops.bigop_diff p20 f2 (h n) n2 hn
                                     (logic.rewrite_r bool.bool bool.true
                                        (__:
                                         (sttfa.etap (sttfa.p bool.bool)) =>
                                         logic.eq bool.bool __ bool.true)
                                        (logic.refl bool.bool bool.true)
                                        (p20 (h n)) p2hn))) _clearme3)
                            (sub1 n (nat.le_n (nat.S n)) p1n))
                         (bigops.bigop nat.nat (nat.S n)
                            (i0:(sttfa.etap (sttfa.p nat.nat)) => p1 i0)
                            (nat.S nat.O) nat.times
                            (i0:(sttfa.etap (sttfa.p nat.nat)) => f1 i0))
                         (bigops.bigop_Strue nat.nat n p1 (nat.S nat.O)
                            nat.times f1
                            (logic.rewrite_r bool.bool bool.true
                               (__:(sttfa.etap (sttfa.p bool.bool)) =>
                                logic.eq bool.bool __ bool.true)
                               (logic.refl bool.bool bool.true) (p1 n) p1n)))
                      (p1n:
                       (sttfa.eps (logic.eq bool.bool (p1 n) bool.false)) =>
                       logic.eq_ind_r nat.nat
                         (bigops.bigop nat.nat n
                            (i0:(sttfa.etap (sttfa.p nat.nat)) => p1 i0)
                            (nat.S nat.O) nat.times
                            (i0:(sttfa.etap (sttfa.p nat.nat)) => f1 i0))
                         (x:(sttfa.etap (sttfa.p nat.nat)) =>
                          logic.eq nat.nat x
                            (bigops.bigop nat.nat n2
                               (i0:(sttfa.etap (sttfa.p nat.nat)) => p20 i0)
                               (nat.S nat.O) nat.times
                               (i0:(sttfa.etap (sttfa.p nat.nat)) => f2 i0)))
                         (Hind p20 (nat.lt_to_le n n1 ltn)
                            (bigops.transitive_sub
                               (x:(sttfa.etap (sttfa.p nat.nat)) => x)
                               (x:(sttfa.etap (sttfa.p nat.nat)) => x) h k n
                               (nat.S n) n2 p1 p1 p20 f1 f1 f2
                               (bigops.sub_lt f1 p1 n (nat.S n)
                                  (nat.le_n_Sn n)) sub1)
                            (i0:(sttfa.etap (sttfa.p nat.nat)) =>
                             lti:(sttfa.eps (nat.lt i0 n2)) =>
                             p2i:
                             (sttfa.eps
                                (logic.eq bool.bool (p20 i0) bool.true)) =>
                             connectives.match_And_prop
                               (connectives.And (nat.lt (k i0) (nat.S n))
                                  (logic.eq bool.bool (p1 (k i0)) bool.true))
                               (logic.eq nat.nat (h (k i0)) i0)
                               (connectives.And
                                  (connectives.And (nat.lt (k i0) n)
                                     (logic.eq bool.bool (p1 (k i0))
                                        bool.true))
                                  (logic.eq nat.nat (h (k i0)) i0))
                               (_clearme3:
                                (sttfa.eps
                                   (connectives.And
                                      (nat.lt (k i0) (nat.S n))
                                      (logic.eq bool.bool (p1 (k i0))
                                         bool.true))) =>
                                connectives.match_And_prop
                                  (nat.lt (k i0) (nat.S n))
                                  (logic.eq bool.bool (p1 (k i0)) bool.true)
                                  (sttfa.impl
                                     (logic.eq nat.nat (h (k i0)) i0)
                                     (connectives.And
                                        (connectives.And (nat.lt (k i0) n)
                                           (logic.eq bool.bool (p1 (k i0))
                                              bool.true))
                                        (logic.eq nat.nat (h (k i0)) i0)))
                                  (ltki:
                                   (sttfa.eps (nat.lt (k i0) (nat.S n))) =>
                                   p1ki:
                                   (sttfa.eps
                                      (logic.eq bool.bool (p1 (k i0))
                                         bool.true)) =>
                                   eqi:
                                   (sttfa.eps
                                      (logic.eq nat.nat (h (k i0)) i0)) =>
                                      connectives.conj
                                         (connectives.And (nat.lt (k i0) n)
                                            (logic.eq bool.bool (p1 (k i0))
                                               bool.true))
                                            (logic.eq nat.nat (h (k i0)) i0)
                                     (connectives.conj
                                      (nat.lt (k i0) n)
                                               (logic.eq bool.bool
                                                  (p1 (k i0)) bool.true)
                                        (connectives.match_Or_prop
                                           (nat.lt (k i0) n)
                                           (logic.eq nat.nat (k i0) n)
                                           (nat.lt (k i0) n)
                                           (auto:
                                            (sttfa.eps (nat.lt (k i0) n)) =>
                                            auto)
                                           (eqki:
                                            (sttfa.eps
                                               (logic.eq nat.nat (k i0) n)) =>
                                            connectives.falsity (nat.lt (k i0) n)
                                              (logic.absurd
                                                 (logic.eq bool.bool
                                                    bool.true bool.false)
                                                 (logic.rewrite_l bool.bool
                                                    bool.true
                                                    (__:
                                                     (sttfa.etap
                                                        (sttfa.p bool.bool)) =>
                                                     logic.eq bool.bool
                                                       bool.true __)
                                                    (logic.refl bool.bool
                                                       bool.true) bool.false
                                                    (logic.rewrite_l
                                                       bool.bool (p1 n)
                                                       (__:
                                                        (sttfa.etap
                                                           (sttfa.p bool.bool)) =>
                                                        logic.eq bool.bool
                                                          __ bool.false) p1n
                                                       bool.true
                                                       (logic.rewrite_l
                                                          nat.nat (k i0)
                                                          (__:
                                                           (sttfa.etap
                                                              (sttfa.p
                                                                 nat.nat)) =>
                                                           logic.eq
                                                             bool.bool
                                                             (p1 __)
                                                             bool.true) p1ki
                                                          n eqki)))
                                                 bool.not_eq_true_false))
                                           (nat.le_to_or_lt_eq (k i0) n
                                              (nat.le_S_S_to_le (k i0) n ltki)))
                                        (logic.rewrite_r bool.bool bool.true
                                           (__:
                                            (sttfa.etap (sttfa.p bool.bool)) =>
                                            logic.eq bool.bool __ bool.true)
                                           (logic.refl bool.bool bool.true)
                                           (p1 (k i0)) p1ki))
                                     (logic.rewrite_r nat.nat i0
                                        (__:(sttfa.etap (sttfa.p nat.nat)) =>
                                         logic.eq nat.nat __ i0)
                                        (logic.refl nat.nat i0) (h (k i0))
                                        eqi)) _clearme3) (sub2 i0 lti p2i)))
                         (bigops.bigop nat.nat (nat.S n)
                            (i0:(sttfa.etap (sttfa.p nat.nat)) => p1 i0)
                            (nat.S nat.O) nat.times
                            (i0:(sttfa.etap (sttfa.p nat.nat)) => f1 i0))
                         (bigops.bigop_Sfalse nat.nat n p1 (nat.S nat.O)
                            nat.times f1
                            (logic.rewrite_r bool.bool bool.false
                               (__:(sttfa.etap (sttfa.p bool.bool)) =>
                                logic.eq bool.bool __ bool.false)
                               (logic.refl bool.bool bool.false) (p1 n) p1n)))
                      (bool.true_or_false (p1 n))) i p2)) _clearme2)
          _clearme1) _clearme0) _clearme.
