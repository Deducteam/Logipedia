#NAME bool.

bool : sttfa.type.

true : sttfa.etap (sttfa.p bool.bool).

false : sttfa.etap (sttfa.p bool.bool).

match_bool_prop :
  sttfa.eps 
    (sttfa.forall (sttfa.arrow bool.bool sttfa.bool) 
       (return:(sttfa.etap (sttfa.p (sttfa.arrow bool.bool sttfa.bool))) =>
        sttfa.impl (return bool.true) 
          (sttfa.impl (return bool.false) 
             (sttfa.forall bool.bool 
                (z:(sttfa.etap (sttfa.p bool.bool)) => return z))))).

match_bool_type :
  sttfa.etap 
    (sttfa.forallK 
       (return:sttfa.type =>
        sttfa.p 
          (sttfa.arrow return 
             (sttfa.arrow return (sttfa.arrow bool.bool return))))).

eq_match_bool_type_true :
  sttfa.eps 
    (sttfa.forallP 
       (return:sttfa.type =>
        sttfa.forall return 
          (case_true:(sttfa.etap (sttfa.p return)) =>
           sttfa.forall return 
             (case_false:(sttfa.etap (sttfa.p return)) =>
              sttfa.leibniz return 
                (bool.match_bool_type return case_true case_false bool.true) 
                case_true)))).

eq_match_bool_type_false :
  sttfa.eps 
    (sttfa.forallP 
       (return:sttfa.type =>
        sttfa.forall return 
          (case_true:(sttfa.etap (sttfa.p return)) =>
           sttfa.forall return 
             (case_false:(sttfa.etap (sttfa.p return)) =>
              sttfa.leibniz return 
                (bool.match_bool_type return case_true case_false bool.false) 
                case_false)))).

def sym_eq_match_bool_type_true :
  sttfa.eps 
    (sttfa.forallP 
       (return:sttfa.type =>
        sttfa.forall return 
          (case_true:(sttfa.etap (sttfa.p return)) =>
           sttfa.forall return 
             (case_false:(sttfa.etap (sttfa.p return)) =>
              sttfa.leibniz return case_true 
                (bool.match_bool_type return case_true case_false bool.true)))))
  :=
  return_type:sttfa.type =>
  case_true:(sttfa.etap (sttfa.p return_type)) =>
  case_false:(sttfa.etap (sttfa.p return_type)) =>
  sttfa.sym_leibniz return_type 
    (bool.match_bool_type return_type case_true case_false bool.true) 
    case_true (bool.eq_match_bool_type_true return_type case_true case_false).

def sym_eq_match_bool_type_false :
  sttfa.eps 
    (sttfa.forallP 
       (return:sttfa.type =>
        sttfa.forall return 
          (case_true:(sttfa.etap (sttfa.p return)) =>
           sttfa.forall return 
             (case_false:(sttfa.etap (sttfa.p return)) =>
              sttfa.leibniz return case_false 
                (bool.match_bool_type return case_true case_false bool.false)))))
  :=
  return_type:sttfa.type =>
  case_true:(sttfa.etap (sttfa.p return_type)) =>
  case_false:(sttfa.etap (sttfa.p return_type)) =>
  sttfa.sym_leibniz return_type 
    (bool.match_bool_type return_type case_true case_false bool.false) 
    case_false 
    (bool.eq_match_bool_type_false return_type case_true case_false).

def bool_discr :
  sttfa.eps 
    (sttfa.forall bool.bool 
       (x:(sttfa.etap (sttfa.p bool.bool)) =>
        sttfa.forall bool.bool 
          (y:(sttfa.etap (sttfa.p bool.bool)) =>
           sttfa.impl (logic.eq bool.bool x y) 
             (bool.match_bool_type sttfa.bool 
                (bool.match_bool_type sttfa.bool 
                   (sttfa.forall sttfa.bool 
                      (P:(sttfa.etap (sttfa.p sttfa.bool)) => sttfa.impl P P)) 
                   (sttfa.forall sttfa.bool 
                      (P:(sttfa.etap (sttfa.p sttfa.bool)) => P)) y) 
                (bool.match_bool_type sttfa.bool 
                   (sttfa.forall sttfa.bool 
                      (P:(sttfa.etap (sttfa.p sttfa.bool)) => P)) 
                   (sttfa.forall sttfa.bool 
                      (P:(sttfa.etap (sttfa.p sttfa.bool)) => sttfa.impl P P)) 
                   y) x))))
  :=
  x:(sttfa.etap (sttfa.p bool.bool)) =>
  y:(sttfa.etap (sttfa.p bool.bool)) =>
  Deq:(sttfa.eps (logic.eq bool.bool x y)) =>
  logic.eq_ind bool.bool x 
    (x_13:(sttfa.etap (sttfa.p bool.bool)) =>
     bool.match_bool_type sttfa.bool 
       (bool.match_bool_type sttfa.bool 
          (sttfa.forall sttfa.bool 
             (P:(sttfa.etap (sttfa.p sttfa.bool)) => sttfa.impl P P)) 
          (sttfa.forall sttfa.bool (P:(sttfa.etap (sttfa.p sttfa.bool)) => P)) 
          x_13) 
       (bool.match_bool_type sttfa.bool 
          (sttfa.forall sttfa.bool (P:(sttfa.etap (sttfa.p sttfa.bool)) => P)) 
          (sttfa.forall sttfa.bool 
             (P:(sttfa.etap (sttfa.p sttfa.bool)) => sttfa.impl P P)) x_13) x) 
    (bool.match_bool_prop 
       (__:(sttfa.etap (sttfa.p bool.bool)) =>
        bool.match_bool_type sttfa.bool 
          (bool.match_bool_type sttfa.bool 
             (sttfa.forall sttfa.bool 
                (P:(sttfa.etap (sttfa.p sttfa.bool)) => sttfa.impl P P)) 
             (sttfa.forall sttfa.bool 
                (P:(sttfa.etap (sttfa.p sttfa.bool)) => P)) __) 
          (bool.match_bool_type sttfa.bool 
             (sttfa.forall sttfa.bool 
                (P:(sttfa.etap (sttfa.p sttfa.bool)) => P)) 
             (sttfa.forall sttfa.bool 
                (P:(sttfa.etap (sttfa.p sttfa.bool)) => sttfa.impl P P)) __) 
          __) 
       (bool.sym_eq_match_bool_type_true sttfa.bool 
          (bool.match_bool_type sttfa.bool 
             (sttfa.forall sttfa.bool 
                (P:(sttfa.etap (sttfa.p sttfa.bool)) => sttfa.impl P P)) 
             (sttfa.forall sttfa.bool 
                (P:(sttfa.etap (sttfa.p sttfa.bool)) => P)) bool.true) 
          (bool.match_bool_type sttfa.bool 
             (sttfa.forall sttfa.bool 
                (P:(sttfa.etap (sttfa.p sttfa.bool)) => P)) 
             (sttfa.forall sttfa.bool 
                (P:(sttfa.etap (sttfa.p sttfa.bool)) => sttfa.impl P P)) 
             bool.true) (x0:(sttfa.etap (sttfa.p sttfa.bool)) => x0) 
          (bool.sym_eq_match_bool_type_true sttfa.bool 
             (sttfa.forall sttfa.bool 
                (P:(sttfa.etap (sttfa.p sttfa.bool)) => sttfa.impl P P)) 
             (sttfa.forall sttfa.bool 
                (P:(sttfa.etap (sttfa.p sttfa.bool)) => P)) 
             (x0:(sttfa.etap (sttfa.p sttfa.bool)) => x0) 
             (P:(sttfa.etap (sttfa.p sttfa.bool)) => DH:(sttfa.eps P) => DH))) 
       (bool.sym_eq_match_bool_type_false sttfa.bool 
          (bool.match_bool_type sttfa.bool 
             (sttfa.forall sttfa.bool 
                (P:(sttfa.etap (sttfa.p sttfa.bool)) => sttfa.impl P P)) 
             (sttfa.forall sttfa.bool 
                (P:(sttfa.etap (sttfa.p sttfa.bool)) => P)) bool.false) 
          (bool.match_bool_type sttfa.bool 
             (sttfa.forall sttfa.bool 
                (P:(sttfa.etap (sttfa.p sttfa.bool)) => P)) 
             (sttfa.forall sttfa.bool 
                (P:(sttfa.etap (sttfa.p sttfa.bool)) => sttfa.impl P P)) 
             bool.false) (x0:(sttfa.etap (sttfa.p sttfa.bool)) => x0) 
          (bool.sym_eq_match_bool_type_false sttfa.bool 
             (sttfa.forall sttfa.bool 
                (P:(sttfa.etap (sttfa.p sttfa.bool)) => P)) 
             (sttfa.forall sttfa.bool 
                (P:(sttfa.etap (sttfa.p sttfa.bool)) => sttfa.impl P P)) 
             (x0:(sttfa.etap (sttfa.p sttfa.bool)) => x0) 
             (P:(sttfa.etap (sttfa.p sttfa.bool)) => DH:(sttfa.eps P) => DH))) 
       x) y Deq.

def not_eq_true_false :
  sttfa.eps (connectives.Not (logic.eq bool.bool bool.true bool.false))
  :=
  Heq:(sttfa.eps (logic.eq bool.bool bool.true bool.false)) =>
  bool.eq_match_bool_type_false sttfa.bool 
    (sttfa.forall sttfa.bool 
       (P:(sttfa.etap (sttfa.p sttfa.bool)) => sttfa.impl P P)) 
    (sttfa.forall sttfa.bool (P:(sttfa.etap (sttfa.p sttfa.bool)) => P)) 
    (x:(sttfa.etap (sttfa.p sttfa.bool)) => x) 
    (bool.eq_match_bool_type_true sttfa.bool 
       (bool.match_bool_type sttfa.bool 
          (sttfa.forall sttfa.bool 
             (P:(sttfa.etap (sttfa.p sttfa.bool)) => sttfa.impl P P)) 
          (sttfa.forall sttfa.bool (P:(sttfa.etap (sttfa.p sttfa.bool)) => P)) 
          bool.false) 
       (bool.match_bool_type sttfa.bool 
          (sttfa.forall sttfa.bool (P:(sttfa.etap (sttfa.p sttfa.bool)) => P)) 
          (sttfa.forall sttfa.bool 
             (P:(sttfa.etap (sttfa.p sttfa.bool)) => sttfa.impl P P)) 
          bool.false) (x:(sttfa.etap (sttfa.p sttfa.bool)) => x) 
       (bool.bool_discr bool.true bool.false Heq)) connectives.False.

def notb :
  sttfa.etap (sttfa.p (sttfa.arrow bool.bool bool.bool))
  :=
  b:(sttfa.etap (sttfa.p bool.bool)) =>
  bool.match_bool_type bool.bool bool.false bool.true b.

def andb :
  sttfa.etap 
    (sttfa.p (sttfa.arrow bool.bool (sttfa.arrow bool.bool bool.bool)))
  :=
  b1:(sttfa.etap (sttfa.p bool.bool)) =>
  b2:(sttfa.etap (sttfa.p bool.bool)) =>
  bool.match_bool_type bool.bool b2 bool.false b1.

def andb_true_l :
  sttfa.eps 
    (sttfa.forall bool.bool 
       (b1:(sttfa.etap (sttfa.p bool.bool)) =>
        sttfa.forall bool.bool 
          (b2:(sttfa.etap (sttfa.p bool.bool)) =>
           sttfa.impl (logic.eq bool.bool (bool.andb b1 b2) bool.true) 
             (logic.eq bool.bool b1 bool.true))))
  :=
  b1:(sttfa.etap (sttfa.p bool.bool)) =>
  bool.match_bool_prop 
    (__:(sttfa.etap (sttfa.p bool.bool)) =>
     sttfa.forall bool.bool 
       (b2:(sttfa.etap (sttfa.p bool.bool)) =>
        sttfa.impl (logic.eq bool.bool (bool.andb __ b2) bool.true) 
          (logic.eq bool.bool __ bool.true))) 
    (b2:(sttfa.etap (sttfa.p bool.bool)) =>
     bool.sym_eq_match_bool_type_true bool.bool b2 bool.false 
       (x:(sttfa.etap (sttfa.p bool.bool)) =>
        sttfa.impl (logic.eq bool.bool x bool.true) 
          (logic.eq bool.bool bool.true bool.true)) 
       (auto:(sttfa.eps (logic.eq bool.bool b2 bool.true)) =>
        logic.rewrite_l bool.bool b2 
          (__:(sttfa.etap (sttfa.p bool.bool)) =>
           logic.eq bool.bool __ bool.true) 
          (logic.rewrite_l bool.bool b2 
             (__:(sttfa.etap (sttfa.p bool.bool)) => logic.eq bool.bool b2 __) 
             (logic.refl bool.bool b2) bool.true auto) bool.true auto)) 
    (_b2:(sttfa.etap (sttfa.p bool.bool)) =>
     bool.sym_eq_match_bool_type_false bool.bool _b2 bool.false 
       (x:(sttfa.etap (sttfa.p bool.bool)) =>
        sttfa.impl (logic.eq bool.bool x bool.true) 
          (logic.eq bool.bool bool.false bool.true)) 
       (auto:(sttfa.eps (logic.eq bool.bool bool.false bool.true)) =>
        logic.rewrite_r bool.bool bool.true 
          (__:(sttfa.etap (sttfa.p bool.bool)) =>
           logic.eq bool.bool __ bool.true) (logic.refl bool.bool bool.true) 
          bool.false auto)) b1.

def andb_true_r :
  sttfa.eps 
    (sttfa.forall bool.bool 
       (b1:(sttfa.etap (sttfa.p bool.bool)) =>
        sttfa.forall bool.bool 
          (b2:(sttfa.etap (sttfa.p bool.bool)) =>
           sttfa.impl (logic.eq bool.bool (bool.andb b1 b2) bool.true) 
             (logic.eq bool.bool b2 bool.true))))
  :=
  b1:(sttfa.etap (sttfa.p bool.bool)) =>
  b2:(sttfa.etap (sttfa.p bool.bool)) =>
  bool.match_bool_prop 
    (__:(sttfa.etap (sttfa.p bool.bool)) =>
     sttfa.impl (logic.eq bool.bool (bool.andb __ b2) bool.true) 
       (logic.eq bool.bool b2 bool.true)) 
    (bool.sym_eq_match_bool_type_true bool.bool b2 bool.false 
       (x:(sttfa.etap (sttfa.p bool.bool)) =>
        sttfa.impl (logic.eq bool.bool x bool.true) 
          (logic.eq bool.bool b2 bool.true)) 
       (auto:(sttfa.eps (logic.eq bool.bool b2 bool.true)) =>
        logic.rewrite_l bool.bool b2 
          (__:(sttfa.etap (sttfa.p bool.bool)) => logic.eq bool.bool b2 __) 
          (logic.refl bool.bool b2) bool.true auto)) 
    (bool.sym_eq_match_bool_type_false bool.bool b2 bool.false 
       (x:(sttfa.etap (sttfa.p bool.bool)) =>
        sttfa.impl (logic.eq bool.bool x bool.true) 
          (logic.eq bool.bool b2 bool.true)) 
       (bool.match_bool_prop 
          (__:(sttfa.etap (sttfa.p bool.bool)) =>
           sttfa.impl (logic.eq bool.bool bool.false bool.true) 
             (logic.eq bool.bool __ bool.true)) 
          (auto:(sttfa.eps (logic.eq bool.bool bool.false bool.true)) =>
           logic.refl bool.bool bool.true) 
          (auto:(sttfa.eps (logic.eq bool.bool bool.false bool.true)) =>
           logic.rewrite_r bool.bool bool.true 
             (__:(sttfa.etap (sttfa.p bool.bool)) =>
              logic.eq bool.bool __ bool.true) 
             (logic.refl bool.bool bool.true) bool.false auto) b2)) b1.

def true_or_false :
  sttfa.eps 
    (sttfa.forall bool.bool 
       (b:(sttfa.etap (sttfa.p bool.bool)) =>
        connectives.Or (logic.eq bool.bool b bool.true) 
          (logic.eq bool.bool b bool.false)))
  :=
  b:(sttfa.etap (sttfa.p bool.bool)) =>
  bool.match_bool_prop 
    (__:(sttfa.etap (sttfa.p bool.bool)) =>
     connectives.Or (logic.eq bool.bool __ bool.true) 
       (logic.eq bool.bool __ bool.false)) 
    (z:(sttfa.etap (sttfa.p sttfa.bool)) =>
     l:(sttfa.eps (sttfa.impl (logic.eq bool.bool bool.true bool.true) z)) =>
     r:
     (sttfa.eps (sttfa.impl (logic.eq bool.bool bool.true bool.false) z)) =>
     l (logic.refl bool.bool bool.true)) 
    (relations.RC_reflexive bool.bool 
       (__:(sttfa.etap (sttfa.p bool.bool)) =>
        _0:(sttfa.etap (sttfa.p bool.bool)) =>
        logic.eq bool.bool bool.false bool.true) bool.false) b.

