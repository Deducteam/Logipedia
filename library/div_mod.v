Require Import bool.
Require Import connectives.
Require Import leibniz.
Require Import logic.
Require Import nat.
Parameter mod_aux : ((nat.nat) ) -> ((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) .
Parameter mod_aux_body : ((nat.nat) ) -> ((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) .
Axiom axiom_mod_aux : forall (p:(nat.nat) ), (((connectives.equal) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((mod_aux) ) (p))) ((((nat.filter_nat_type) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((mod_aux_body) )) (p)).
Definition eq_mod_aux : forall (p:(nat.nat) ), (((leibniz.leibniz) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((mod_aux) ) (p))) ((((nat.filter_nat_type) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((mod_aux_body) )) (p)) := fun (p:(nat.nat) ) => ((((connectives.equal_leibniz) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((mod_aux) ) (p))) ((((nat.filter_nat_type) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((mod_aux_body) )) (p))) ((axiom_mod_aux) (p)).
Definition sym_eq_mod_aux : forall (p:(nat.nat) ), (((leibniz.leibniz) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((((nat.filter_nat_type) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((mod_aux_body) )) (p))) (((mod_aux) ) (p)) := fun (p:(nat.nat) ) => ((((leibniz.sym_leibniz) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((mod_aux) ) (p))) ((((nat.filter_nat_type) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((mod_aux_body) )) (p))) ((eq_mod_aux) (p)).
Axiom axiom_mod_aux_body_O : (((connectives.equal) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((mod_aux_body) ) ((nat.O) ))) (fun (m:(nat.nat) ) => fun (n:(nat.nat) ) => m).
Definition eq_mod_aux_body_O : (((leibniz.leibniz) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((mod_aux_body) ) ((nat.O) ))) (fun (m:(nat.nat) ) => fun (n:(nat.nat) ) => m) := ((((connectives.equal_leibniz) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((mod_aux_body) ) ((nat.O) ))) (fun (m:(nat.nat) ) => fun (n:(nat.nat) ) => m)) (axiom_mod_aux_body_O).
Definition sym_eq_mod_aux_body_O : (((leibniz.leibniz) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (fun (m:(nat.nat) ) => fun (n:(nat.nat) ) => m)) (((mod_aux_body) ) ((nat.O) )) := ((((leibniz.sym_leibniz) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((mod_aux_body) ) ((nat.O) ))) (fun (m:(nat.nat) ) => fun (n:(nat.nat) ) => m)) (eq_mod_aux_body_O).
Axiom axiom_mod_aux_body_S : forall (p:(nat.nat) ), (((connectives.equal) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((mod_aux_body) ) (((nat.S) ) (p)))) (fun (m:(nat.nat) ) => fun (n:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) (m)) (((((mod_aux) ) (p)) ((((nat.minus) ) (m)) (((nat.S) ) (n)))) (n))) ((((nat.leb) ) (m)) (n))).
Definition eq_mod_aux_body_S : forall (p:(nat.nat) ), (((leibniz.leibniz) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((mod_aux_body) ) (((nat.S) ) (p)))) (fun (m:(nat.nat) ) => fun (n:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) (m)) (((((mod_aux) ) (p)) ((((nat.minus) ) (m)) (((nat.S) ) (n)))) (n))) ((((nat.leb) ) (m)) (n))) := fun (p:(nat.nat) ) => ((((connectives.equal_leibniz) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((mod_aux_body) ) (((nat.S) ) (p)))) (fun (m:(nat.nat) ) => fun (n:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) (m)) (((((mod_aux) ) (p)) ((((nat.minus) ) (m)) (((nat.S) ) (n)))) (n))) ((((nat.leb) ) (m)) (n)))) ((axiom_mod_aux_body_S) (p)).
Definition sym_eq_mod_aux_body_S : forall (p:(nat.nat) ), (((leibniz.leibniz) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (fun (m:(nat.nat) ) => fun (n:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) (m)) (((((mod_aux) ) (p)) ((((nat.minus) ) (m)) (((nat.S) ) (n)))) (n))) ((((nat.leb) ) (m)) (n)))) (((mod_aux_body) ) (((nat.S) ) (p))) := fun (p:(nat.nat) ) => ((((leibniz.sym_leibniz) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((mod_aux_body) ) (((nat.S) ) (p)))) (fun (m:(nat.nat) ) => fun (n:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) (m)) (((((mod_aux) ) (p)) ((((nat.minus) ) (m)) (((nat.S) ) (n)))) (n))) ((((nat.leb) ) (m)) (n)))) ((eq_mod_aux_body_S) (p)).
Definition mod : ((nat.nat) ) -> ((nat.nat) ) -> (nat.nat)  := fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => ((((nat.match_nat_type) ((nat.nat) )) (n)) (fun (p:(nat.nat) ) => ((((mod_aux) ) (n)) (n)) (p))) (m).
Parameter div_aux : ((nat.nat) ) -> ((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) .
Parameter div_aux_body : ((nat.nat) ) -> ((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) .
Axiom axiom_div_aux : forall (p:(nat.nat) ), (((connectives.equal) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((div_aux) ) (p))) ((((nat.filter_nat_type) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((div_aux_body) )) (p)).
Definition eq_div_aux : forall (p:(nat.nat) ), (((leibniz.leibniz) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((div_aux) ) (p))) ((((nat.filter_nat_type) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((div_aux_body) )) (p)) := fun (p:(nat.nat) ) => ((((connectives.equal_leibniz) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((div_aux) ) (p))) ((((nat.filter_nat_type) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((div_aux_body) )) (p))) ((axiom_div_aux) (p)).
Definition sym_eq_div_aux : forall (p:(nat.nat) ), (((leibniz.leibniz) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((((nat.filter_nat_type) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((div_aux_body) )) (p))) (((div_aux) ) (p)) := fun (p:(nat.nat) ) => ((((leibniz.sym_leibniz) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((div_aux) ) (p))) ((((nat.filter_nat_type) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((div_aux_body) )) (p))) ((eq_div_aux) (p)).
Axiom axiom_div_aux_body_O : (((connectives.equal) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((div_aux_body) ) ((nat.O) ))) (fun (m:(nat.nat) ) => fun (n:(nat.nat) ) => (nat.O) ).
Definition eq_div_aux_body_O : (((leibniz.leibniz) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((div_aux_body) ) ((nat.O) ))) (fun (m:(nat.nat) ) => fun (n:(nat.nat) ) => (nat.O) ) := ((((connectives.equal_leibniz) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((div_aux_body) ) ((nat.O) ))) (fun (m:(nat.nat) ) => fun (n:(nat.nat) ) => (nat.O) )) (axiom_div_aux_body_O).
Definition sym_eq_div_aux_body_O : (((leibniz.leibniz) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (fun (m:(nat.nat) ) => fun (n:(nat.nat) ) => (nat.O) )) (((div_aux_body) ) ((nat.O) )) := ((((leibniz.sym_leibniz) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((div_aux_body) ) ((nat.O) ))) (fun (m:(nat.nat) ) => fun (n:(nat.nat) ) => (nat.O) )) (eq_div_aux_body_O).
Axiom axiom_div_aux_body_S : forall (p:(nat.nat) ), (((connectives.equal) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((div_aux_body) ) (((nat.S) ) (p)))) (fun (m:(nat.nat) ) => fun (n:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) (((nat.S) ) (((((div_aux) ) (p)) ((((nat.minus) ) (m)) (((nat.S) ) (n)))) (n)))) ((((nat.leb) ) (m)) (n))).
Definition eq_div_aux_body_S : forall (p:(nat.nat) ), (((leibniz.leibniz) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((div_aux_body) ) (((nat.S) ) (p)))) (fun (m:(nat.nat) ) => fun (n:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) (((nat.S) ) (((((div_aux) ) (p)) ((((nat.minus) ) (m)) (((nat.S) ) (n)))) (n)))) ((((nat.leb) ) (m)) (n))) := fun (p:(nat.nat) ) => ((((connectives.equal_leibniz) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((div_aux_body) ) (((nat.S) ) (p)))) (fun (m:(nat.nat) ) => fun (n:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) (((nat.S) ) (((((div_aux) ) (p)) ((((nat.minus) ) (m)) (((nat.S) ) (n)))) (n)))) ((((nat.leb) ) (m)) (n)))) ((axiom_div_aux_body_S) (p)).
Definition sym_eq_div_aux_body_S : forall (p:(nat.nat) ), (((leibniz.leibniz) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (fun (m:(nat.nat) ) => fun (n:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) (((nat.S) ) (((((div_aux) ) (p)) ((((nat.minus) ) (m)) (((nat.S) ) (n)))) (n)))) ((((nat.leb) ) (m)) (n)))) (((div_aux_body) ) (((nat.S) ) (p))) := fun (p:(nat.nat) ) => ((((leibniz.sym_leibniz) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) (((div_aux_body) ) (((nat.S) ) (p)))) (fun (m:(nat.nat) ) => fun (n:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) (((nat.S) ) (((((div_aux) ) (p)) ((((nat.minus) ) (m)) (((nat.S) ) (n)))) (n)))) ((((nat.leb) ) (m)) (n)))) ((eq_div_aux_body_S) (p)).
Definition div : ((nat.nat) ) -> ((nat.nat) ) -> (nat.nat)  := fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => ((((nat.match_nat_type) ((nat.nat) )) (((nat.S) ) (n))) (fun (p:(nat.nat) ) => ((((div_aux) ) (n)) (n)) (p))) (m).
Definition le_mod_aux_m_m : forall (p:(nat.nat) ), forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((((nat.le) ) (n)) (p)) -> (((nat.le) ) (((((mod_aux) ) (p)) (n)) (m))) (m) := fun (p:(nat.nat) ) => ((((nat.nat_ind) (fun (_x_365:(nat.nat) ) => forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((((nat.le) ) (n)) (_x_365)) -> (((nat.le) ) (((((mod_aux) ) (_x_365)) (n)) (m))) (m))) (fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => (((sym_eq_mod_aux) ((nat.O) )) (fun (y:((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) (n)) ((nat.O) )) -> (((nat.le) ) (((y) (n)) (m))) (m))) (((((nat.sym_eq_filter_nat_type_O) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((mod_aux_body) )) (fun (y:((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) (n)) ((nat.O) )) -> (((nat.le) ) (((y) (n)) (m))) (m))) (((sym_eq_mod_aux_body_O) (fun (y:((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) (n)) ((nat.O) )) -> (((nat.le) ) (((y) (n)) (m))) (m))) (fun (lenO:(((nat.le) ) (n)) ((nat.O) )) => (((((nat.le_n_O_elim) (n)) (lenO)) (fun (__:(nat.nat) ) => (((nat.le) ) (__)) (m))) ((nat.le_O_n) (m)))))))) (fun (q:(nat.nat) ) => (((sym_eq_mod_aux) (((nat.S) ) (q))) (fun (y:((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => (forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((((nat.le) ) (n)) (q)) -> (((nat.le) ) (((((mod_aux) ) (q)) (n)) (m))) (m)) -> forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((((nat.le) ) (n)) (((nat.S) ) (q))) -> (((nat.le) ) (((y) (n)) (m))) (m))) ((((((nat.sym_eq_filter_nat_type_S) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((mod_aux_body) )) (q)) (fun (y:((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => (forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((((nat.le) ) (n)) (q)) -> (((nat.le) ) (((((mod_aux) ) (q)) (n)) (m))) (m)) -> forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((((nat.le) ) (n)) (((nat.S) ) (q))) -> (((nat.le) ) (((y) (n)) (m))) (m))) ((((sym_eq_mod_aux_body_S) (q)) (fun (y:((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => (forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((((nat.le) ) (n)) (q)) -> (((nat.le) ) (((((mod_aux) ) (q)) (n)) (m))) (m)) -> forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((((nat.le) ) (n)) (((nat.S) ) (q))) -> (((nat.le) ) (((y) (n)) (m))) (m))) (fun (Hind:forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((((nat.le) ) (n)) (q)) -> (((nat.le) ) (((((mod_aux) ) (q)) (n)) (m))) (m)) => (fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => fun (len:(((nat.le) ) (n)) (((nat.S) ) (q))) => ((((((nat.leb_elim) (n)) (m)) (fun (__:(bool.bool) ) => (((nat.le) ) (((((bool.match_bool_type) ((nat.nat) )) (n)) (((((mod_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))) (__))) (m))) ((((((bool.sym_eq_match_bool_type_true) ((nat.nat) )) (n)) (((((mod_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))) (fun (y:(nat.nat) ) => ((((nat.le) ) (n)) (m)) -> (((nat.le) ) (y)) (m))) (fun (auto:(((nat.le) ) (n)) (m)) => (auto)))) ((((((bool.sym_eq_match_bool_type_false) ((nat.nat) )) (n)) (((((mod_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))) (fun (y:(nat.nat) ) => (((connectives.Not) ) ((((nat.le) ) (n)) (m))) -> (((nat.le) ) (y)) (m))) (fun (notlenm:((connectives.Not) ) ((((nat.le) ) (n)) (m))) => ((((Hind) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m)) (((((nat.le_plus_to_minus) (n)) (((nat.S) ) (m))) (q)) ((((((nat.transitive_le) (n)) (((nat.S) ) (q))) ((((nat.plus) ) (q)) (((nat.S) ) (m)))) (len)) (((((logic.eq_coerc) ((((nat.le) ) (((nat.S) ) (q))) ((((nat.plus) ) (((nat.S) ) (q))) (m)))) ((((nat.le) ) (((nat.S) ) (q))) ((((nat.plus) ) (q)) (((nat.S) ) (m))))) (((nat.le_plus_n_r) (m)) (((nat.S) ) (q)))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.plus) ) (m)) (((nat.S) ) (q)))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) (((nat.S) ) (q))) (__))) ((((nat.le) ) (((nat.S) ) (q))) ((((nat.plus) ) (q)) (((nat.S) ) (m)))))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.plus) ) (q)) (((nat.S) ) (m)))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) (((nat.S) ) (q))) (__))) ((((nat.le) ) (((nat.S) ) (q))) ((((nat.plus) ) (q)) (((nat.S) ) (m)))))) (((logic.refl) (Prop)) ((((nat.le) ) (((nat.S) ) (q))) ((((nat.plus) ) (q)) (((nat.S) ) (m)))))) ((((nat.plus) ) (m)) (((nat.S) ) (q)))) (((((((logic.rewrite_l) ((nat.nat) )) (((nat.S) ) ((((nat.plus) ) (m)) (q)))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__)) ((((nat.plus) ) (q)) (((nat.S) ) (m))))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.plus) ) (q)) (m))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((nat.S) ) (__))) ((((nat.plus) ) (q)) (((nat.S) ) (m))))) (((nat.plus_n_Sm) (q)) (m))) ((((nat.plus) ) (m)) (q))) (((nat.commutative_plus) (q)) (m)))) ((((nat.plus) ) (m)) (((nat.S) ) (q)))) (((nat.plus_n_Sm) (m)) (q))))) ((((nat.plus) ) (((nat.S) ) (q))) (m))) (((nat.commutative_plus) (m)) (((nat.S) ) (q))))))))))))))))) (p).
Definition lt_mod_m_m : forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((((nat.lt) ) ((nat.O) )) (m)) -> (((nat.lt) ) ((((mod) ) (n)) (m))) (m) := fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => ((((nat.match_nat_prop) (fun (__:(nat.nat) ) => ((((nat.lt) ) ((nat.O) )) (__)) -> (((nat.lt) ) ((((mod) ) (n)) (__))) (__))) (fun (abs:(((nat.lt) ) ((nat.O) )) ((nat.O) )) => (((connectives.falsity) ((((nat.lt) ) ((((mod) ) (n)) ((nat.O) ))) ((nat.O) ))) ((((logic.absurd) ((((nat.le) ) (((nat.S) ) ((nat.O) ))) ((nat.O) ))) (abs)) ((nat.not_le_Sn_O) ((nat.O) )))))) (fun (p:(nat.nat) ) => ((((((nat.sym_eq_match_nat_type_S) ((nat.nat) )) (n)) (fun (q:(nat.nat) ) => ((((mod_aux) ) (n)) (n)) (q))) (p)) (fun (y:(nat.nat) ) => ((((nat.lt) ) ((nat.O) )) (((nat.S) ) (p))) -> (((nat.lt) ) (y)) (((nat.S) ) (p)))) (fun (__:(((nat.lt) ) ((nat.O) )) (((nat.S) ) (p))) => ((((nat.le_S_S) (((((mod_aux) ) (n)) (n)) (p))) (p)) (((((le_mod_aux_m_m) (n)) (n)) (p)) ((nat.le_n) (n))))))) (m).
Definition div_aux_mod_aux : forall (p:(nat.nat) ), forall (n:(nat.nat) ), forall (m:(nat.nat) ), (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (((((div_aux) ) (p)) (n)) (m))) (((nat.S) ) (m)))) (((((mod_aux) ) (p)) (n)) (m))) := fun (p:(nat.nat) ) => ((((nat.nat_ind) (fun (_x_365:(nat.nat) ) => forall (n:(nat.nat) ), forall (m:(nat.nat) ), (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (((((div_aux) ) (_x_365)) (n)) (m))) (((nat.S) ) (m)))) (((((mod_aux) ) (_x_365)) (n)) (m))))) (fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => (((sym_eq_div_aux) ((nat.O) )) (fun (y:((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (((y) (n)) (m))) (((nat.S) ) (m)))) (((((mod_aux) ) ((nat.O) )) (n)) (m))))) (((((nat.sym_eq_filter_nat_type_O) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((div_aux_body) )) (fun (y:((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (((y) (n)) (m))) (((nat.S) ) (m)))) (((((mod_aux) ) ((nat.O) )) (n)) (m))))) (((sym_eq_div_aux_body_O) (fun (y:((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (((y) (n)) (m))) (((nat.S) ) (m)))) (((((mod_aux) ) ((nat.O) )) (n)) (m))))) ((((((nat.eq_match_nat_type_O) ((nat.nat) )) ((nat.O) )) (fun (q:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) (((nat.S) ) (((((div_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m)))) ((((nat.leb) ) (n)) (m)))) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (y)) (((nat.S) ) (m)))) (((((mod_aux) ) ((nat.O) )) (n)) (m))))) ((((sym_eq_mod_aux) ((nat.O) )) (fun (y:((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (((fun (m0:(nat.nat) ) => fun (n0:(nat.nat) ) => ((((nat.match_nat_type) ((nat.nat) )) ((nat.O) )) (fun (q:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) (((nat.S) ) (((((div_aux) ) (q)) ((((nat.minus) ) (m0)) (((nat.S) ) (n0)))) (n0)))) ((((nat.leb) ) (m0)) (n0)))) ((nat.O) )) (n)) (m))) (((nat.S) ) (m)))) (((y) (n)) (m))))) (((((nat.sym_eq_filter_nat_type_O) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((mod_aux_body) )) (fun (y:((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (((fun (m0:(nat.nat) ) => fun (n0:(nat.nat) ) => ((((nat.match_nat_type) ((nat.nat) )) ((nat.O) )) (fun (q:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) (((nat.S) ) (((((div_aux) ) (q)) ((((nat.minus) ) (m0)) (((nat.S) ) (n0)))) (n0)))) ((((nat.leb) ) (m0)) (n0)))) ((nat.O) )) (n)) (m))) (((nat.S) ) (m)))) (((y) (n)) (m))))) (((sym_eq_mod_aux_body_O) (fun (y:((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (((fun (m0:(nat.nat) ) => fun (n0:(nat.nat) ) => ((((nat.match_nat_type) ((nat.nat) )) ((nat.O) )) (fun (q:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) (((nat.S) ) (((((div_aux) ) (q)) ((((nat.minus) ) (m0)) (((nat.S) ) (n0)))) (n0)))) ((((nat.leb) ) (m0)) (n0)))) ((nat.O) )) (n)) (m))) (((nat.S) ) (m)))) (((y) (n)) (m))))) ((((((nat.sym_eq_match_nat_type_O) ((nat.nat) )) ((nat.O) )) (fun (q:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) (((nat.S) ) (((((div_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m)))) ((((nat.leb) ) (n)) (m)))) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (((fun (m0:(nat.nat) ) => fun (n0:(nat.nat) ) => y) (n)) (m))) (((nat.S) ) (m)))) (n)))) ((((nat.sym_eq_times) ((nat.O) )) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((y) (((nat.S) ) (m)))) (n)))) (((((nat.sym_eq_filter_nat_type_O) (((nat.nat) ) -> (nat.nat) )) ((nat.times_body) )) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((y) (((nat.S) ) (m)))) (n)))) (((nat.sym_eq_times_body_O) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((y) (((nat.S) ) (m)))) (n)))) ((((nat.sym_eq_plus) ((nat.O) )) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((y) (n)))) (((((nat.sym_eq_filter_nat_type_O) (((nat.nat) ) -> (nat.nat) )) ((nat.plus_body) )) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((y) (n)))) (((nat.sym_eq_plus_body_O) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((y) (n)))) (((logic.refl) ((nat.nat) )) (n))))))))))))))))) (fun (q:(nat.nat) ) => (((sym_eq_div_aux) (((nat.S) ) (q))) (fun (y:((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => (forall (n:(nat.nat) ), forall (m:(nat.nat) ), (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (((((div_aux) ) (q)) (n)) (m))) (((nat.S) ) (m)))) (((((mod_aux) ) (q)) (n)) (m)))) -> forall (n:(nat.nat) ), forall (m:(nat.nat) ), (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (((y) (n)) (m))) (((nat.S) ) (m)))) (((((mod_aux) ) (((nat.S) ) (q))) (n)) (m))))) ((((((nat.sym_eq_filter_nat_type_S) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((div_aux_body) )) (q)) (fun (y:((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => (forall (n:(nat.nat) ), forall (m:(nat.nat) ), (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (((((div_aux) ) (q)) (n)) (m))) (((nat.S) ) (m)))) (((((mod_aux) ) (q)) (n)) (m)))) -> forall (n:(nat.nat) ), forall (m:(nat.nat) ), (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (((y) (n)) (m))) (((nat.S) ) (m)))) (((((mod_aux) ) (((nat.S) ) (q))) (n)) (m))))) ((((sym_eq_div_aux_body_S) (q)) (fun (y:((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => (forall (n:(nat.nat) ), forall (m:(nat.nat) ), (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (((((div_aux) ) (q)) (n)) (m))) (((nat.S) ) (m)))) (((((mod_aux) ) (q)) (n)) (m)))) -> forall (n:(nat.nat) ), forall (m:(nat.nat) ), (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (((y) (n)) (m))) (((nat.S) ) (m)))) (((((mod_aux) ) (((nat.S) ) (q))) (n)) (m))))) (fun (Hind:forall (n:(nat.nat) ), forall (m:(nat.nat) ), (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (((((div_aux) ) (q)) (n)) (m))) (((nat.S) ) (m)))) (((((mod_aux) ) (q)) (n)) (m)))) => (fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => ((((((nat.eq_match_nat_type_S) ((nat.nat) )) ((nat.O) )) (fun (q0:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) (((nat.S) ) (((((div_aux) ) (q0)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m)))) ((((nat.leb) ) (n)) (m)))) (q)) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (y)) (((nat.S) ) (m)))) (((((mod_aux) ) (((nat.S) ) (q))) (n)) (m))))) ((((sym_eq_mod_aux) (((nat.S) ) (q))) (fun (y:((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (((fun (m0:(nat.nat) ) => fun (n0:(nat.nat) ) => ((((nat.match_nat_type) ((nat.nat) )) ((nat.O) )) (fun (q0:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) (((nat.S) ) (((((div_aux) ) (q0)) ((((nat.minus) ) (m0)) (((nat.S) ) (n0)))) (n0)))) ((((nat.leb) ) (m0)) (n0)))) (((nat.S) ) (q))) (n)) (m))) (((nat.S) ) (m)))) (((y) (n)) (m))))) ((((((nat.sym_eq_filter_nat_type_S) (((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) )) ((mod_aux_body) )) (q)) (fun (y:((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (((fun (m0:(nat.nat) ) => fun (n0:(nat.nat) ) => ((((nat.match_nat_type) ((nat.nat) )) ((nat.O) )) (fun (q0:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) (((nat.S) ) (((((div_aux) ) (q0)) ((((nat.minus) ) (m0)) (((nat.S) ) (n0)))) (n0)))) ((((nat.leb) ) (m0)) (n0)))) (((nat.S) ) (q))) (n)) (m))) (((nat.S) ) (m)))) (((y) (n)) (m))))) ((((sym_eq_mod_aux_body_S) (q)) (fun (y:((nat.nat) ) -> ((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (((fun (m0:(nat.nat) ) => fun (n0:(nat.nat) ) => ((((nat.match_nat_type) ((nat.nat) )) ((nat.O) )) (fun (q0:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) (((nat.S) ) (((((div_aux) ) (q0)) ((((nat.minus) ) (m0)) (((nat.S) ) (n0)))) (n0)))) ((((nat.leb) ) (m0)) (n0)))) (((nat.S) ) (q))) (n)) (m))) (((nat.S) ) (m)))) (((y) (n)) (m))))) (((((((nat.sym_eq_match_nat_type_S) ((nat.nat) )) ((nat.O) )) (fun (z:(nat.nat) ) => ((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) (((nat.S) ) (((((div_aux) ) (z)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m)))) ((((nat.leb) ) (n)) (m)))) (q)) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (y)) (((nat.S) ) (m)))) (((((bool.match_bool_type) ((nat.nat) )) (n)) (((((mod_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))) ((((nat.leb) ) (n)) (m)))))) ((((((nat.leb_elim) (n)) (m)) (fun (__:(bool.bool) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) (((nat.S) ) (((((div_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m)))) (__))) (((nat.S) ) (m)))) (((((bool.match_bool_type) ((nat.nat) )) (n)) (((((mod_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))) (__))))) ((((((bool.sym_eq_match_bool_type_true) ((nat.nat) )) ((nat.O) )) (((nat.S) ) (((((div_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m)))) (fun (x:(nat.nat) ) => ((((nat.le) ) (n)) (m)) -> (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (x)) (((nat.S) ) (m)))) (((((bool.match_bool_type) ((nat.nat) )) (n)) (((((mod_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))) ((bool.true) ))))) ((((nat.sym_eq_times) ((nat.O) )) (fun (y:((nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) (n)) (m)) -> (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((y) (((nat.S) ) (m)))) (((((bool.match_bool_type) ((nat.nat) )) (n)) (((((mod_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))) ((bool.true) ))))) (((((nat.sym_eq_filter_nat_type_O) (((nat.nat) ) -> (nat.nat) )) ((nat.times_body) )) (fun (y:((nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) (n)) (m)) -> (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((y) (((nat.S) ) (m)))) (((((bool.match_bool_type) ((nat.nat) )) (n)) (((((mod_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))) ((bool.true) ))))) (((nat.sym_eq_times_body_O) (fun (y:((nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) (n)) (m)) -> (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((y) (((nat.S) ) (m)))) (((((bool.match_bool_type) ((nat.nat) )) (n)) (((((mod_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))) ((bool.true) ))))) ((((((bool.sym_eq_match_bool_type_true) ((nat.nat) )) (n)) (((((mod_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))) (fun (y:(nat.nat) ) => ((((nat.le) ) (n)) (m)) -> (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((nat.O) )) (y)))) ((((nat.sym_eq_plus) ((nat.O) )) (fun (y:((nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) (n)) (m)) -> (((logic.eq) ((nat.nat) )) (n)) ((y) (n)))) (((((nat.sym_eq_filter_nat_type_O) (((nat.nat) ) -> (nat.nat) )) ((nat.plus_body) )) (fun (y:((nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) (n)) (m)) -> (((logic.eq) ((nat.nat) )) (n)) ((y) (n)))) (((nat.sym_eq_plus_body_O) (fun (y:((nat.nat) ) -> (nat.nat) ) => ((((nat.le) ) (n)) (m)) -> (((logic.eq) ((nat.nat) )) (n)) ((y) (n)))) (fun (lenm:(((nat.le) ) (n)) (m)) => (((logic.refl) ((nat.nat) )) (n)))))))))))) ((((((bool.sym_eq_match_bool_type_false) ((nat.nat) )) (n)) (((((mod_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))) (fun (x:(nat.nat) ) => (((connectives.Not) ) ((((nat.le) ) (n)) (m))) -> (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (((((bool.match_bool_type) ((nat.nat) )) ((nat.O) )) (((nat.S) ) (((((div_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m)))) ((bool.false) ))) (((nat.S) ) (m)))) (x)))) ((((((bool.sym_eq_match_bool_type_false) ((nat.nat) )) ((nat.O) )) (((nat.S) ) (((((div_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m)))) (fun (y:(nat.nat) ) => (((connectives.Not) ) ((((nat.le) ) (n)) (m))) -> (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (y)) (((nat.S) ) (m)))) (((((mod_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))))) ((((nat.sym_eq_times) (((nat.S) ) (((((div_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m)))) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((connectives.Not) ) ((((nat.le) ) (n)) (m))) -> (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((y) (((nat.S) ) (m)))) (((((mod_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))))) ((((((nat.sym_eq_filter_nat_type_S) (((nat.nat) ) -> (nat.nat) )) ((nat.times_body) )) (((((div_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((connectives.Not) ) ((((nat.le) ) (n)) (m))) -> (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((y) (((nat.S) ) (m)))) (((((mod_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))))) ((((nat.sym_eq_times_body_S) (((((div_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((connectives.Not) ) ((((nat.le) ) (n)) (m))) -> (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((y) (((nat.S) ) (m)))) (((((mod_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))))) ((((nat.sym_eq_plus) (((nat.S) ) (m))) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((connectives.Not) ) ((((nat.le) ) (n)) (m))) -> (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((y) ((((nat.times) ) (((((div_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))) (((nat.S) ) (m))))) (((((mod_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))))) ((((((nat.sym_eq_filter_nat_type_S) (((nat.nat) ) -> (nat.nat) )) ((nat.plus_body) )) (m)) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((connectives.Not) ) ((((nat.le) ) (n)) (m))) -> (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((y) ((((nat.times) ) (((((div_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))) (((nat.S) ) (m))))) (((((mod_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))))) ((((nat.sym_eq_plus_body_S) (m)) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((connectives.Not) ) ((((nat.le) ) (n)) (m))) -> (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((y) ((((nat.times) ) (((((div_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))) (((nat.S) ) (m))))) (((((mod_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))))) ((((nat.sym_eq_plus) (((nat.S) ) ((((nat.plus) ) (m)) ((((nat.times) ) (((((div_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))) (((nat.S) ) (m)))))) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((connectives.Not) ) ((((nat.le) ) (n)) (m))) -> (((logic.eq) ((nat.nat) )) (n)) ((y) (((((mod_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))))) ((((((nat.sym_eq_filter_nat_type_S) (((nat.nat) ) -> (nat.nat) )) ((nat.plus_body) )) ((((nat.plus) ) (m)) ((((nat.times) ) (((((div_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))) (((nat.S) ) (m))))) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((connectives.Not) ) ((((nat.le) ) (n)) (m))) -> (((logic.eq) ((nat.nat) )) (n)) ((y) (((((mod_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))))) ((((nat.sym_eq_plus_body_S) ((((nat.plus) ) (m)) ((((nat.times) ) (((((div_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))) (((nat.S) ) (m))))) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((connectives.Not) ) ((((nat.le) ) (n)) (m))) -> (((logic.eq) ((nat.nat) )) (n)) ((y) (((((mod_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))))) (fun (lenm:((connectives.Not) ) ((((nat.le) ) (n)) (m))) => (((((((logic.eq_ind_r) ((nat.nat) )) ((((nat.plus) ) (m)) ((((nat.plus) ) ((((nat.times) ) (((((div_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))) (((nat.S) ) (m)))) (((((mod_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))))) (fun (x:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) (((nat.S) ) (x)))) (((((((logic.eq_ind) ((nat.nat) )) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (fun (x_1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) (((nat.S) ) ((((nat.plus) ) (m)) (x_1))))) (((((logic.eq_coerc) ((((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (((nat.S) ) (m))))) ((((logic.eq) ((nat.nat) )) (n)) (((nat.S) ) ((((nat.plus) ) (m)) ((((nat.minus) ) (n)) (((nat.S) ) (m))))))) ((((nat.plus_minus_m_m) (n)) (((nat.S) ) (m))) ((((nat.not_le_to_lt) (n)) (m)) (lenm)))) (((((((logic.rewrite_r) ((nat.nat) )) (((nat.pred) ) ((((nat.minus) ) (n)) (m)))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) (__)) (((nat.S) ) (m))))) ((((logic.eq) ((nat.nat) )) (n)) (((nat.S) ) ((((nat.plus) ) (m)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))))))) (((((((logic.rewrite_r) ((nat.nat) )) (((nat.pred) ) ((((nat.minus) ) (n)) (m)))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) (((nat.pred) ) ((((nat.minus) ) (n)) (m)))) (((nat.S) ) (m))))) ((((logic.eq) ((nat.nat) )) (n)) (((nat.S) ) ((((nat.plus) ) (m)) (__)))))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.plus) ) (m)) (((nat.S) ) (((nat.pred) ) ((((nat.minus) ) (n)) (m)))))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) (((nat.pred) ) ((((nat.minus) ) (n)) (m)))) (((nat.S) ) (m))))) ((((logic.eq) ((nat.nat) )) (n)) (__)))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.plus) ) (m)) (((nat.S) ) (((nat.pred) ) ((((nat.minus) ) (n)) (m)))))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((logic.eq) ((nat.nat) )) (n)) (__))) ((((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) (m)) (((nat.S) ) (((nat.pred) ) ((((nat.minus) ) (n)) (m)))))))) (((logic.refl) (Prop)) ((((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) (m)) (((nat.S) ) (((nat.pred) ) ((((nat.minus) ) (n)) (m)))))))) ((((nat.plus) ) (((nat.pred) ) ((((nat.minus) ) (n)) (m)))) (((nat.S) ) (m)))) (((((((logic.rewrite_l) ((nat.nat) )) (((nat.S) ) ((((nat.plus) ) (((nat.pred) ) ((((nat.minus) ) (n)) (m)))) (m)))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__)) ((((nat.plus) ) (m)) (((nat.S) ) (((nat.pred) ) ((((nat.minus) ) (n)) (m))))))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.plus) ) (m)) (((nat.pred) ) ((((nat.minus) ) (n)) (m))))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (((nat.S) ) (__))) ((((nat.plus) ) (m)) (((nat.S) ) (((nat.pred) ) ((((nat.minus) ) (n)) (m))))))) (((nat.plus_n_Sm) (m)) (((nat.pred) ) ((((nat.minus) ) (n)) (m))))) ((((nat.plus) ) (((nat.pred) ) ((((nat.minus) ) (n)) (m)))) (m))) (((nat.commutative_plus) (m)) (((nat.pred) ) ((((nat.minus) ) (n)) (m)))))) ((((nat.plus) ) (((nat.pred) ) ((((nat.minus) ) (n)) (m)))) (((nat.S) ) (m)))) (((nat.plus_n_Sm) (((nat.pred) ) ((((nat.minus) ) (n)) (m)))) (m))))) (((nat.S) ) ((((nat.plus) ) (m)) (((nat.pred) ) ((((nat.minus) ) (n)) (m)))))) (((nat.plus_n_Sm) (m)) (((nat.pred) ) ((((nat.minus) ) (n)) (m)))))) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (((nat.eq_minus_S_pred) (n)) (m)))) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (((nat.eq_minus_S_pred) (n)) (m))))) ((((nat.plus) ) ((((nat.times) ) (((((div_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))) (((nat.S) ) (m)))) (((((mod_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m)))) (((Hind) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m)))) ((((nat.plus) ) ((((nat.plus) ) (m)) ((((nat.times) ) (((((div_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))) (((nat.S) ) (m))))) (((((mod_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m)))) ((((nat.associative_plus) (m)) ((((nat.times) ) (((((div_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))) (((nat.S) ) (m)))) (((((mod_aux) ) (q)) ((((nat.minus) ) (n)) (((nat.S) ) (m)))) (m))))))))))))))))))))))))))) (p).
Definition div_mod : forall (n:(nat.nat) ), forall (m:(nat.nat) ), (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) ((((div) ) (n)) (m))) (m))) ((((mod) ) (n)) (m))) := fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => ((((nat.match_nat_prop) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) ((((div) ) (n)) (__))) (__))) ((((mod) ) (n)) (__))))) ((((nat.sym_eq_times) ((((div) ) (n)) ((nat.O) ))) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((y) ((nat.O) ))) ((((mod) ) (n)) ((nat.O) ))))) ((((((nat.sym_eq_match_nat_type_O) ((nat.nat) )) (((nat.S) ) (n))) (fun (p:(nat.nat) ) => ((((div_aux) ) (n)) (n)) (p))) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) (((((nat.filter_nat_type) (((nat.nat) ) -> (nat.nat) )) ((nat.times_body) )) (y)) ((nat.O) ))) (((((nat.match_nat_type) ((nat.nat) )) (n)) (fun (p:(nat.nat) ) => ((((mod_aux) ) (n)) (n)) (p))) ((nat.O) ))))) ((((((nat.sym_eq_filter_nat_type_S) (((nat.nat) ) -> (nat.nat) )) ((nat.times_body) )) (n)) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((y) ((nat.O) ))) ((((mod) ) (n)) ((nat.O) ))))) ((((nat.sym_eq_times_body_S) (n)) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((y) ((nat.O) ))) ((((mod) ) (n)) ((nat.O) ))))) ((((((nat.sym_eq_match_nat_type_O) ((nat.nat) )) (n)) (fun (p:(nat.nat) ) => ((((mod_aux) ) (n)) (n)) (p))) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.plus) ) ((nat.O) )) ((((nat.times) ) (n)) ((nat.O) )))) (y)))) ((((nat.sym_eq_plus) ((nat.O) )) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((y) ((((nat.times) ) (n)) ((nat.O) )))) (n)))) (((((nat.sym_eq_filter_nat_type_O) (((nat.nat) ) -> (nat.nat) )) ((nat.plus_body) )) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((y) ((((nat.times) ) (n)) ((nat.O) )))) (n)))) (((nat.sym_eq_plus_body_O) (fun (y:((nat.nat) ) -> (nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((y) ((((nat.times) ) (n)) ((nat.O) )))) (n)))) (((((((logic.rewrite_l) ((nat.nat) )) ((nat.O) )) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) (__)) (n)))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.plus) ) (n)) ((nat.O) ))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) (__))) (((((((logic.rewrite_l) ((nat.nat) )) (n)) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) (__))) (((logic.refl) ((nat.nat) )) (n))) ((((nat.plus) ) (n)) ((nat.O) ))) ((nat.plus_n_O) (n)))) ((((nat.plus) ) ((nat.O) )) (n))) (((nat.commutative_plus) ((nat.O) )) (n)))) ((((nat.times) ) (n)) ((nat.O) ))) ((nat.times_n_O) (n)))))))))))) (fun (auto:(nat.nat) ) => ((((((nat.sym_eq_match_nat_type_S) ((nat.nat) )) (((nat.S) ) (n))) (fun (p:(nat.nat) ) => ((((div_aux) ) (n)) (n)) (p))) (auto)) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (y)) (((nat.S) ) (auto)))) (((((nat.match_nat_type) ((nat.nat) )) (n)) (fun (p:(nat.nat) ) => ((((mod_aux) ) (n)) (n)) (p))) (((nat.S) ) (auto)))))) (((((((nat.sym_eq_match_nat_type_S) ((nat.nat) )) (n)) (fun (p:(nat.nat) ) => ((((mod_aux) ) (n)) (n)) (p))) (auto)) (fun (y:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (((((div_aux) ) (n)) (n)) (auto))) (((nat.S) ) (auto)))) (y)))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.plus) ) ((((nat.times) ) (((((div_aux) ) (n)) (n)) (auto))) (((nat.S) ) (auto)))) (((((mod_aux) ) (n)) (n)) (auto)))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__)) ((((nat.plus) ) ((((nat.times) ) (((((div_aux) ) (n)) (n)) (auto))) (((nat.S) ) (auto)))) (((((mod_aux) ) (n)) (n)) (auto))))) (((logic.refl) ((nat.nat) )) ((((nat.plus) ) ((((nat.times) ) (((((div_aux) ) (n)) (n)) (auto))) (((nat.S) ) (auto)))) (((((mod_aux) ) (n)) (n)) (auto))))) (n)) ((((div_aux_mod_aux) (n)) (n)) (auto)))))) (m).
Definition eq_times_div_minus_mod : forall (a:(nat.nat) ), forall (b:(nat.nat) ), (((logic.eq) ((nat.nat) )) ((((nat.times) ) ((((div) ) (a)) (b))) (b))) ((((nat.minus) ) (a)) ((((mod) ) (a)) (b))) := fun (a:(nat.nat) ) => fun (b:(nat.nat) ) => ((((logic.eq_coerc) ((((logic.eq) ((nat.nat) )) ((((nat.times) ) (b)) ((((div) ) (a)) (b)))) ((((nat.minus) ) ((((nat.plus) ) ((((nat.times) ) (b)) ((((div) ) (a)) (b)))) ((((mod) ) (a)) (b)))) ((((mod) ) (a)) (b))))) ((((logic.eq) ((nat.nat) )) ((((nat.times) ) ((((div) ) (a)) (b))) (b))) ((((nat.minus) ) (a)) ((((mod) ) (a)) (b))))) (((nat.minus_plus_m_m) ((((nat.times) ) (b)) ((((div) ) (a)) (b)))) ((((mod) ) (a)) (b)))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.plus) ) ((((mod) ) (a)) (b))) ((((nat.times) ) (b)) ((((div) ) (a)) (b))))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((logic.eq) ((nat.nat) )) ((((nat.times) ) (b)) ((((div) ) (a)) (b)))) ((((nat.minus) ) (__)) ((((mod) ) (a)) (b))))) ((((logic.eq) ((nat.nat) )) ((((nat.times) ) ((((div) ) (a)) (b))) (b))) ((((nat.minus) ) (a)) ((((mod) ) (a)) (b)))))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (b)) ((((div) ) (a)) (b)))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((logic.eq) ((nat.nat) )) ((((nat.times) ) (b)) ((((div) ) (a)) (b)))) ((((nat.minus) ) ((((nat.plus) ) ((((mod) ) (a)) (b))) ((((nat.times) ) (b)) ((((div) ) (a)) (b))))) ((((mod) ) (a)) (b))))) ((((logic.eq) ((nat.nat) )) (__)) ((((nat.minus) ) (a)) ((((mod) ) (a)) (b)))))) (((((((logic.rewrite_l) ((nat.nat) )) (a)) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((logic.eq) ((nat.nat) )) ((((nat.times) ) (b)) ((((div) ) (a)) (b)))) ((((nat.minus) ) (__)) ((((mod) ) (a)) (b))))) ((((logic.eq) ((nat.nat) )) ((((nat.times) ) (b)) ((((div) ) (a)) (b)))) ((((nat.minus) ) (a)) ((((mod) ) (a)) (b)))))) (((logic.refl) (Prop)) ((((logic.eq) ((nat.nat) )) ((((nat.times) ) (b)) ((((div) ) (a)) (b)))) ((((nat.minus) ) (a)) ((((mod) ) (a)) (b)))))) ((((nat.plus) ) ((((mod) ) (a)) (b))) ((((nat.times) ) (b)) ((((div) ) (a)) (b))))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.plus) ) ((((nat.times) ) (b)) ((((div) ) (a)) (b)))) ((((mod) ) (a)) (b)))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (a)) (__))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.times) ) ((((div) ) (a)) (b))) (b))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (a)) ((((nat.plus) ) (__)) ((((mod) ) (a)) (b))))) (((div_mod) (a)) (b))) ((((nat.times) ) (b)) ((((div) ) (a)) (b)))) (((nat.commutative_times) ((((div) ) (a)) (b))) (b)))) ((((nat.plus) ) ((((mod) ) (a)) (b))) ((((nat.times) ) (b)) ((((div) ) (a)) (b))))) (((nat.commutative_plus) ((((nat.times) ) (b)) ((((div) ) (a)) (b)))) ((((mod) ) (a)) (b)))))) ((((nat.times) ) ((((div) ) (a)) (b))) (b))) (((nat.commutative_times) ((((div) ) (a)) (b))) (b)))) ((((nat.plus) ) ((((nat.times) ) (b)) ((((div) ) (a)) (b)))) ((((mod) ) (a)) (b)))) (((nat.commutative_plus) ((((nat.times) ) (b)) ((((div) ) (a)) (b)))) ((((mod) ) (a)) (b)))).
Parameter div_mod_spec : ((nat.nat) ) -> ((nat.nat) ) -> ((nat.nat) ) -> ((nat.nat) ) -> Prop.
Axiom div_mod_spec_intro : forall (n:(nat.nat) ), forall (m:(nat.nat) ), forall (q:(nat.nat) ), forall (r:(nat.nat) ), ((((nat.lt) ) (r)) (m)) -> ((((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (q)) (m))) (r))) -> (((((div_mod_spec) ) (n)) (m)) (q)) (r).
Axiom match_div_mod_spec_prop : forall (n:(nat.nat) ), forall (m:(nat.nat) ), forall (q:(nat.nat) ), forall (r:(nat.nat) ), forall (return_:Prop), (((((nat.lt) ) (r)) (m)) -> ((((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) ((((nat.times) ) (q)) (m))) (r))) -> return_) -> ((((((div_mod_spec) ) (n)) (m)) (q)) (r)) -> return_.
Definition div_mod_spec_div_mod : forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((((nat.lt) ) ((nat.O) )) (m)) -> (((((div_mod_spec) ) (n)) (m)) ((((div) ) (n)) (m))) ((((mod) ) (n)) (m)) := fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => fun (posm:(((nat.lt) ) ((nat.O) )) (m)) => (((((((div_mod_spec_intro) (n)) (m)) ((((div) ) (n)) (m))) ((((mod) ) (n)) (m))) ((((lt_mod_m_m) (n)) (m)) (posm))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (m)) ((((div) ) (n)) (m)))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) (__)) ((((mod) ) (n)) (m))))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.plus) ) ((((mod) ) (n)) (m))) ((((nat.times) ) (m)) ((((div) ) (n)) (m))))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) (__))) (((((((logic.rewrite_l) ((nat.nat) )) (n)) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) (__))) (((logic.refl) ((nat.nat) )) (n))) ((((nat.plus) ) ((((mod) ) (n)) (m))) ((((nat.times) ) (m)) ((((div) ) (n)) (m))))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.plus) ) ((((nat.times) ) (m)) ((((div) ) (n)) (m)))) ((((mod) ) (n)) (m)))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) (__))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.times) ) ((((div) ) (n)) (m))) (m))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) (__)) ((((mod) ) (n)) (m))))) (((div_mod) (n)) (m))) ((((nat.times) ) (m)) ((((div) ) (n)) (m)))) (((nat.commutative_times) ((((div) ) (n)) (m))) (m)))) ((((nat.plus) ) ((((mod) ) (n)) (m))) ((((nat.times) ) (m)) ((((div) ) (n)) (m))))) (((nat.commutative_plus) ((((nat.times) ) (m)) ((((div) ) (n)) (m)))) ((((mod) ) (n)) (m)))))) ((((nat.plus) ) ((((nat.times) ) (m)) ((((div) ) (n)) (m)))) ((((mod) ) (n)) (m)))) (((nat.commutative_plus) ((((nat.times) ) (m)) ((((div) ) (n)) (m)))) ((((mod) ) (n)) (m))))) ((((nat.times) ) ((((div) ) (n)) (m))) (m))) (((nat.commutative_times) ((((div) ) (n)) (m))) (m)))).
Definition let_clause_1078 : forall (a:(nat.nat) ), forall (b:(nat.nat) ), forall (q:(nat.nat) ), forall (r:(nat.nat) ), forall (q1:(nat.nat) ), forall (r1:(nat.nat) ), ((((((div_mod_spec) ) (a)) (b)) (q)) (r)) -> ((((nat.lt) ) (r)) (b)) -> ((((logic.eq) ((nat.nat) )) (a)) ((((nat.plus) ) ((((nat.times) ) (q)) (b))) (r))) -> ((((((div_mod_spec) ) (a)) (b)) (q1)) (r1)) -> ((((nat.lt) ) (r1)) (b)) -> ((((logic.eq) ((nat.nat) )) (a)) ((((nat.plus) ) ((((nat.times) ) (q1)) (b))) (r1))) -> ((((nat.le) ) (q)) (q1)) -> ((((nat.lt) ) (q)) (q1)) -> (((logic.eq) ((nat.nat) )) (a)) ((((nat.plus) ) (r)) ((((nat.times) ) (b)) (q))) := fun (a:(nat.nat) ) => fun (b:(nat.nat) ) => fun (q:(nat.nat) ) => fun (r:(nat.nat) ) => fun (q1:(nat.nat) ) => fun (r1:(nat.nat) ) => fun (_clearme:(((((div_mod_spec) ) (a)) (b)) (q)) (r)) => (fun (ltrb:(((nat.lt) ) (r)) (b)) => (fun (spec:(((logic.eq) ((nat.nat) )) (a)) ((((nat.plus) ) ((((nat.times) ) (q)) (b))) (r))) => (fun (_clearme0:(((((div_mod_spec) ) (a)) (b)) (q1)) (r1)) => (fun (ltr1b:(((nat.lt) ) (r1)) (b)) => (fun (spec1:(((logic.eq) ((nat.nat) )) (a)) ((((nat.plus) ) ((((nat.times) ) (q1)) (b))) (r1))) => (fun (leqq1:(((nat.le) ) (q)) (q1)) => (fun (ltqq1:(((nat.lt) ) (q)) (q1)) => (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.plus) ) ((((nat.times) ) (b)) (q))) (r))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (a)) (__))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.times) ) (q)) (b))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (a)) ((((nat.plus) ) (__)) (r)))) (spec)) ((((nat.times) ) (b)) (q))) (((nat.commutative_times) (q)) (b)))) ((((nat.plus) ) (r)) ((((nat.times) ) (b)) (q)))) (((nat.commutative_plus) ((((nat.times) ) (b)) (q))) (r)))))))))).
Definition let_clause_1062 : forall (a:(nat.nat) ), forall (b:(nat.nat) ), forall (q:(nat.nat) ), forall (r:(nat.nat) ), forall (q1:(nat.nat) ), forall (r1:(nat.nat) ), ((((((div_mod_spec) ) (a)) (b)) (q)) (r)) -> ((((nat.lt) ) (r)) (b)) -> ((((logic.eq) ((nat.nat) )) (a)) ((((nat.plus) ) ((((nat.times) ) (q)) (b))) (r))) -> ((((((div_mod_spec) ) (a)) (b)) (q1)) (r1)) -> ((((nat.lt) ) (r1)) (b)) -> ((((logic.eq) ((nat.nat) )) (a)) ((((nat.plus) ) ((((nat.times) ) (q1)) (b))) (r1))) -> (((connectives.Not) ) ((((nat.le) ) (q)) (q1))) -> (((logic.eq) ((nat.nat) )) (a)) ((((nat.plus) ) (r1)) ((((nat.times) ) (b)) (q1))) := fun (a:(nat.nat) ) => fun (b:(nat.nat) ) => fun (q:(nat.nat) ) => fun (r:(nat.nat) ) => fun (q1:(nat.nat) ) => fun (r1:(nat.nat) ) => fun (_clearme:(((((div_mod_spec) ) (a)) (b)) (q)) (r)) => (fun (ltrb:(((nat.lt) ) (r)) (b)) => (fun (spec:(((logic.eq) ((nat.nat) )) (a)) ((((nat.plus) ) ((((nat.times) ) (q)) (b))) (r))) => (fun (_clearme0:(((((div_mod_spec) ) (a)) (b)) (q1)) (r1)) => (fun (ltr1b:(((nat.lt) ) (r1)) (b)) => (fun (spec1:(((logic.eq) ((nat.nat) )) (a)) ((((nat.plus) ) ((((nat.times) ) (q1)) (b))) (r1))) => (fun (leqq1:((connectives.Not) ) ((((nat.le) ) (q)) (q1))) => (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.plus) ) ((((nat.times) ) (b)) (q1))) (r1))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (a)) (__))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.times) ) (q1)) (b))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (a)) ((((nat.plus) ) (__)) (r1)))) (spec1)) ((((nat.times) ) (b)) (q1))) (((nat.commutative_times) (q1)) (b)))) ((((nat.plus) ) (r1)) ((((nat.times) ) (b)) (q1)))) (((nat.commutative_plus) ((((nat.times) ) (b)) (q1))) (r1))))))))).
Definition div_mod_spec_to_eq : forall (a:(nat.nat) ), forall (b:(nat.nat) ), forall (q:(nat.nat) ), forall (r:(nat.nat) ), forall (q1:(nat.nat) ), forall (r1:(nat.nat) ), ((((((div_mod_spec) ) (a)) (b)) (q)) (r)) -> ((((((div_mod_spec) ) (a)) (b)) (q1)) (r1)) -> (((logic.eq) ((nat.nat) )) (q)) (q1) := fun (a:(nat.nat) ) => fun (b:(nat.nat) ) => fun (q:(nat.nat) ) => fun (r:(nat.nat) ) => fun (q1:(nat.nat) ) => fun (r1:(nat.nat) ) => fun (_clearme:(((((div_mod_spec) ) (a)) (b)) (q)) (r)) => ((((((((match_div_mod_spec_prop) (a)) (b)) (q)) (r)) (((((((div_mod_spec) ) (a)) (b)) (q1)) (r1)) -> (((logic.eq) ((nat.nat) )) (q)) (q1))) (fun (ltrb:(((nat.lt) ) (r)) (b)) => (fun (spec:(((logic.eq) ((nat.nat) )) (a)) ((((nat.plus) ) ((((nat.times) ) (q)) (b))) (r))) => (fun (_clearme0:(((((div_mod_spec) ) (a)) (b)) (q1)) (r1)) => ((((((((match_div_mod_spec_prop) (a)) (b)) (q1)) (r1)) ((((logic.eq) ((nat.nat) )) (q)) (q1))) (fun (ltr1b:(((nat.lt) ) (r1)) (b)) => (fun (spec1:(((logic.eq) ((nat.nat) )) (a)) ((((nat.plus) ) ((((nat.times) ) (q1)) (b))) (r1))) => ((((((nat.leb_elim) (q)) (q1)) (fun (__:(bool.bool) ) => (((logic.eq) ((nat.nat) )) (q)) (q1))) (fun (leqq1:(((nat.le) ) (q)) (q1)) => (((((((connectives.match_Or_prop) ((((nat.lt) ) (q)) (q1))) ((((logic.eq) ((nat.nat) )) (q)) (q1))) ((((logic.eq) ((nat.nat) )) (q)) (q1))) (fun (ltqq1:(((nat.lt) ) (q)) (q1)) => (((connectives.falsity) ((((logic.eq) ((nat.nat) )) (q)) (q1))) ((((logic.absurd) ((((nat.le) ) (((nat.S) ) (a))) (a))) ((((((nat.lt_to_le_to_lt) (a)) ((((nat.times) ) (((nat.S) ) (q))) (b))) (a)) (((((((logic.eq_ind_r) ((nat.nat) )) ((((nat.plus) ) ((((nat.times) ) (q)) (b))) (r))) (fun (x:(nat.nat) ) => (((nat.lt) ) (x)) ((((nat.times) ) (((nat.S) ) (q))) (b)))) (((((logic.eq_coerc) ((((nat.lt) ) ((((nat.plus) ) ((((nat.times) ) (q)) (b))) (r))) ((((nat.plus) ) ((((nat.times) ) (q)) (b))) (b)))) ((((nat.lt) ) ((((nat.plus) ) ((((nat.times) ) (q)) (b))) (r))) ((((nat.times) ) (((nat.S) ) (q))) (b)))) (((((nat.monotonic_lt_plus_r) ((((nat.times) ) (q)) (b))) (r)) (b)) (ltrb))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (b)) (q))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.lt) ) ((((nat.plus) ) (__)) (r))) ((((nat.plus) ) (__)) (b)))) ((((nat.lt) ) ((((nat.plus) ) (__)) (r))) ((((nat.times) ) (((nat.S) ) (q))) (b))))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.plus) ) (r)) ((((nat.times) ) (b)) (q)))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.lt) ) ((((nat.plus) ) ((((nat.times) ) (b)) (q))) (r))) ((((nat.plus) ) ((((nat.times) ) (b)) (q))) (b)))) ((((nat.lt) ) (__)) ((((nat.times) ) (((nat.S) ) (q))) (b))))) (((((((logic.rewrite_l) ((nat.nat) )) (a)) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.lt) ) ((((nat.plus) ) ((((nat.times) ) (b)) (q))) (r))) ((((nat.plus) ) ((((nat.times) ) (b)) (q))) (b)))) ((((nat.lt) ) (__)) ((((nat.times) ) (((nat.S) ) (q))) (b))))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (b)) (((nat.S) ) (q)))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.lt) ) ((((nat.plus) ) ((((nat.times) ) (b)) (q))) (r))) ((((nat.plus) ) ((((nat.times) ) (b)) (q))) (b)))) ((((nat.lt) ) (a)) (__)))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.plus) ) (b)) ((((nat.times) ) (b)) (q)))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.lt) ) ((((nat.plus) ) ((((nat.times) ) (b)) (q))) (r))) ((((nat.plus) ) ((((nat.times) ) (b)) (q))) (b)))) ((((nat.lt) ) (a)) (__)))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.plus) ) (r)) ((((nat.times) ) (b)) (q)))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.lt) ) (__)) ((((nat.plus) ) ((((nat.times) ) (b)) (q))) (b)))) ((((nat.lt) ) (a)) ((((nat.plus) ) (b)) ((((nat.times) ) (b)) (q)))))) (((((((logic.rewrite_l) ((nat.nat) )) (a)) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.lt) ) (__)) ((((nat.plus) ) ((((nat.times) ) (b)) (q))) (b)))) ((((nat.lt) ) (a)) ((((nat.plus) ) (b)) ((((nat.times) ) (b)) (q)))))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.plus) ) (b)) ((((nat.times) ) (b)) (q)))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.lt) ) (a)) (__))) ((((nat.lt) ) (a)) ((((nat.plus) ) (b)) ((((nat.times) ) (b)) (q)))))) (((logic.refl) (Prop)) ((((nat.lt) ) (a)) ((((nat.plus) ) (b)) ((((nat.times) ) (b)) (q)))))) ((((nat.plus) ) ((((nat.times) ) (b)) (q))) (b))) (((nat.commutative_plus) ((((nat.times) ) (b)) (q))) (b)))) ((((nat.plus) ) (r)) ((((nat.times) ) (b)) (q)))) (((((((((((((((let_clause_1078) (a)) (b)) (q)) (r)) (q1)) (r1)) (_clearme)) (ltrb)) (spec)) (_clearme0)) (ltr1b)) (spec1)) (leqq1)) (ltqq1)))) ((((nat.plus) ) ((((nat.times) ) (b)) (q))) (r))) (((nat.commutative_plus) ((((nat.times) ) (b)) (q))) (r)))) ((((nat.times) ) (b)) (((nat.S) ) (q)))) (((nat.times_n_Sm) (b)) (q)))) ((((nat.times) ) (((nat.S) ) (q))) (b))) (((nat.commutative_times) (((nat.S) ) (q))) (b)))) ((((nat.plus) ) (r)) ((((nat.times) ) (b)) (q)))) (((((((((((((((let_clause_1078) (a)) (b)) (q)) (r)) (q1)) (r1)) (_clearme)) (ltrb)) (spec)) (_clearme0)) (ltr1b)) (spec1)) (leqq1)) (ltqq1)))) ((((nat.plus) ) ((((nat.times) ) (b)) (q))) (r))) (((nat.commutative_plus) ((((nat.times) ) (b)) (q))) (r)))) ((((nat.times) ) (q)) (b))) (((nat.commutative_times) (q)) (b))))) (a)) (spec))) ((((((nat.transitive_le) ((((nat.times) ) (((nat.S) ) (q))) (b))) ((((nat.times) ) (q1)) (b))) (a)) (((((logic.eq_coerc) ((((nat.le) ) ((((nat.times) ) (b)) (((nat.S) ) (q)))) ((((nat.times) ) (b)) (q1)))) ((((nat.le) ) ((((nat.times) ) (((nat.S) ) (q))) (b))) ((((nat.times) ) (q1)) (b)))) (((((nat.monotonic_le_times_r) (b)) (((nat.S) ) (q))) (q1)) (ltqq1))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (b)) (((nat.S) ) (q)))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) ((((nat.times) ) (b)) (((nat.S) ) (q)))) ((((nat.times) ) (b)) (q1)))) ((((nat.le) ) (__)) ((((nat.times) ) (q1)) (b))))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.plus) ) (b)) ((((nat.times) ) (b)) (q)))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) ((((nat.times) ) (b)) (((nat.S) ) (q)))) ((((nat.times) ) (b)) (q1)))) ((((nat.le) ) (__)) ((((nat.times) ) (q1)) (b))))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (b)) (q1))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) ((((nat.times) ) (b)) (((nat.S) ) (q)))) ((((nat.times) ) (b)) (q1)))) ((((nat.le) ) ((((nat.plus) ) (b)) ((((nat.times) ) (b)) (q)))) (__)))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.plus) ) (b)) ((((nat.times) ) (b)) (q)))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) (__)) ((((nat.times) ) (b)) (q1)))) ((((nat.le) ) ((((nat.plus) ) (b)) ((((nat.times) ) (b)) (q)))) ((((nat.times) ) (b)) (q1))))) (((logic.refl) (Prop)) ((((nat.le) ) ((((nat.plus) ) (b)) ((((nat.times) ) (b)) (q)))) ((((nat.times) ) (b)) (q1))))) ((((nat.times) ) (b)) (((nat.S) ) (q)))) (((nat.times_n_Sm) (b)) (q)))) ((((nat.times) ) (q1)) (b))) (((nat.commutative_times) (q1)) (b)))) ((((nat.times) ) (b)) (((nat.S) ) (q)))) (((nat.times_n_Sm) (b)) (q)))) ((((nat.times) ) (((nat.S) ) (q))) (b))) (((nat.commutative_times) (((nat.S) ) (q))) (b))))) (((((logic.eq_coerc) ((((nat.le) ) ((((nat.times) ) (q1)) (b))) ((((nat.plus) ) ((((nat.times) ) (q1)) (b))) (r1)))) ((((nat.le) ) ((((nat.times) ) (q1)) (b))) (a))) (((nat.le_plus_n_r) (r1)) ((((nat.times) ) (q1)) (b)))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (b)) (q1))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) (__)) ((((nat.plus) ) (__)) (r1)))) ((((nat.le) ) (__)) (a)))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.plus) ) (r1)) ((((nat.times) ) (b)) (q1)))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) ((((nat.times) ) (b)) (q1))) (__))) ((((nat.le) ) ((((nat.times) ) (b)) (q1))) (a)))) (((((((logic.rewrite_l) ((nat.nat) )) (a)) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) ((((nat.times) ) (b)) (q1))) (__))) ((((nat.le) ) ((((nat.times) ) (b)) (q1))) (a)))) (((logic.refl) (Prop)) ((((nat.le) ) ((((nat.times) ) (b)) (q1))) (a)))) ((((nat.plus) ) (r1)) ((((nat.times) ) (b)) (q1)))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.plus) ) ((((nat.times) ) (b)) (q1))) (r1))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (a)) (__))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.times) ) (q1)) (b))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (a)) ((((nat.plus) ) (__)) (r1)))) (spec1)) ((((nat.times) ) (b)) (q1))) (((nat.commutative_times) (q1)) (b)))) ((((nat.plus) ) (r1)) ((((nat.times) ) (b)) (q1)))) (((nat.commutative_plus) ((((nat.times) ) (b)) (q1))) (r1))))) ((((nat.plus) ) ((((nat.times) ) (b)) (q1))) (r1))) (((nat.commutative_plus) ((((nat.times) ) (b)) (q1))) (r1)))) ((((nat.times) ) (q1)) (b))) (((nat.commutative_times) (q1)) (b))))))) ((nat.not_le_Sn_n) (a)))))) (fun (_x_172:(((logic.eq) ((nat.nat) )) (q)) (q1)) => (((((((logic.rewrite_l) ((nat.nat) )) (q)) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (q)) (__))) (((logic.refl) ((nat.nat) )) (q))) (q1)) (_x_172)))) ((((nat.le_to_or_lt_eq) (q)) (q1)) (leqq1))))) (fun (leqq1:((connectives.Not) ) ((((nat.le) ) (q)) (q1))) => (((connectives.falsity) ((((logic.eq) ((nat.nat) )) (q)) (q1))) ((((logic.absurd) ((((nat.le) ) (((nat.S) ) (a))) (a))) ((((((nat.lt_to_le_to_lt) (a)) ((((nat.times) ) (((nat.S) ) (q1))) (b))) (a)) (((((((logic.eq_ind_r) ((nat.nat) )) ((((nat.plus) ) ((((nat.times) ) (q1)) (b))) (r1))) (fun (x:(nat.nat) ) => (((nat.lt) ) (x)) ((((nat.times) ) (((nat.S) ) (q1))) (b)))) (((((logic.eq_coerc) ((((nat.lt) ) ((((nat.plus) ) ((((nat.times) ) (q1)) (b))) (r1))) ((((nat.plus) ) ((((nat.times) ) (q1)) (b))) (b)))) ((((nat.lt) ) ((((nat.plus) ) ((((nat.times) ) (q1)) (b))) (r1))) ((((nat.times) ) (((nat.S) ) (q1))) (b)))) (((((nat.monotonic_lt_plus_r) ((((nat.times) ) (q1)) (b))) (r1)) (b)) (ltr1b))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (b)) (q1))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.lt) ) ((((nat.plus) ) (__)) (r1))) ((((nat.plus) ) (__)) (b)))) ((((nat.lt) ) ((((nat.plus) ) (__)) (r1))) ((((nat.times) ) (((nat.S) ) (q1))) (b))))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.plus) ) (r1)) ((((nat.times) ) (b)) (q1)))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.lt) ) ((((nat.plus) ) ((((nat.times) ) (b)) (q1))) (r1))) ((((nat.plus) ) ((((nat.times) ) (b)) (q1))) (b)))) ((((nat.lt) ) (__)) ((((nat.times) ) (((nat.S) ) (q1))) (b))))) (((((((logic.rewrite_l) ((nat.nat) )) (a)) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.lt) ) ((((nat.plus) ) ((((nat.times) ) (b)) (q1))) (r1))) ((((nat.plus) ) ((((nat.times) ) (b)) (q1))) (b)))) ((((nat.lt) ) (__)) ((((nat.times) ) (((nat.S) ) (q1))) (b))))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (b)) (((nat.S) ) (q1)))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.lt) ) ((((nat.plus) ) ((((nat.times) ) (b)) (q1))) (r1))) ((((nat.plus) ) ((((nat.times) ) (b)) (q1))) (b)))) ((((nat.lt) ) (a)) (__)))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.plus) ) (b)) ((((nat.times) ) (b)) (q1)))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.lt) ) ((((nat.plus) ) ((((nat.times) ) (b)) (q1))) (r1))) ((((nat.plus) ) ((((nat.times) ) (b)) (q1))) (b)))) ((((nat.lt) ) (a)) (__)))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.plus) ) (r1)) ((((nat.times) ) (b)) (q1)))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.lt) ) (__)) ((((nat.plus) ) ((((nat.times) ) (b)) (q1))) (b)))) ((((nat.lt) ) (a)) ((((nat.plus) ) (b)) ((((nat.times) ) (b)) (q1)))))) (((((((logic.rewrite_l) ((nat.nat) )) (a)) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.lt) ) (__)) ((((nat.plus) ) ((((nat.times) ) (b)) (q1))) (b)))) ((((nat.lt) ) (a)) ((((nat.plus) ) (b)) ((((nat.times) ) (b)) (q1)))))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.plus) ) (b)) ((((nat.times) ) (b)) (q1)))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.lt) ) (a)) (__))) ((((nat.lt) ) (a)) ((((nat.plus) ) (b)) ((((nat.times) ) (b)) (q1)))))) (((logic.refl) (Prop)) ((((nat.lt) ) (a)) ((((nat.plus) ) (b)) ((((nat.times) ) (b)) (q1)))))) ((((nat.plus) ) ((((nat.times) ) (b)) (q1))) (b))) (((nat.commutative_plus) ((((nat.times) ) (b)) (q1))) (b)))) ((((nat.plus) ) (r1)) ((((nat.times) ) (b)) (q1)))) ((((((((((((((let_clause_1062) (a)) (b)) (q)) (r)) (q1)) (r1)) (_clearme)) (ltrb)) (spec)) (_clearme0)) (ltr1b)) (spec1)) (leqq1)))) ((((nat.plus) ) ((((nat.times) ) (b)) (q1))) (r1))) (((nat.commutative_plus) ((((nat.times) ) (b)) (q1))) (r1)))) ((((nat.times) ) (b)) (((nat.S) ) (q1)))) (((nat.times_n_Sm) (b)) (q1)))) ((((nat.times) ) (((nat.S) ) (q1))) (b))) (((nat.commutative_times) (((nat.S) ) (q1))) (b)))) ((((nat.plus) ) (r1)) ((((nat.times) ) (b)) (q1)))) ((((((((((((((let_clause_1062) (a)) (b)) (q)) (r)) (q1)) (r1)) (_clearme)) (ltrb)) (spec)) (_clearme0)) (ltr1b)) (spec1)) (leqq1)))) ((((nat.plus) ) ((((nat.times) ) (b)) (q1))) (r1))) (((nat.commutative_plus) ((((nat.times) ) (b)) (q1))) (r1)))) ((((nat.times) ) (q1)) (b))) (((nat.commutative_times) (q1)) (b))))) (a)) (spec1))) ((((((nat.transitive_le) ((((nat.times) ) (((nat.S) ) (q1))) (b))) ((((nat.times) ) (q)) (b))) (a)) (((((logic.eq_coerc) ((((nat.le) ) ((((nat.times) ) (b)) (((nat.S) ) (q1)))) ((((nat.times) ) (b)) (q)))) ((((nat.le) ) ((((nat.times) ) (((nat.S) ) (q1))) (b))) ((((nat.times) ) (q)) (b)))) (((((nat.monotonic_le_times_r) (b)) (((nat.S) ) (q1))) (q)) ((((nat.not_le_to_lt) (q)) (q1)) (leqq1)))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (b)) (((nat.S) ) (q1)))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) ((((nat.times) ) (b)) (((nat.S) ) (q1)))) ((((nat.times) ) (b)) (q)))) ((((nat.le) ) (__)) ((((nat.times) ) (q)) (b))))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.plus) ) (b)) ((((nat.times) ) (b)) (q1)))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) ((((nat.times) ) (b)) (((nat.S) ) (q1)))) ((((nat.times) ) (b)) (q)))) ((((nat.le) ) (__)) ((((nat.times) ) (q)) (b))))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (b)) (q))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) ((((nat.times) ) (b)) (((nat.S) ) (q1)))) ((((nat.times) ) (b)) (q)))) ((((nat.le) ) ((((nat.plus) ) (b)) ((((nat.times) ) (b)) (q1)))) (__)))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.plus) ) (b)) ((((nat.times) ) (b)) (q1)))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) (__)) ((((nat.times) ) (b)) (q)))) ((((nat.le) ) ((((nat.plus) ) (b)) ((((nat.times) ) (b)) (q1)))) ((((nat.times) ) (b)) (q))))) (((logic.refl) (Prop)) ((((nat.le) ) ((((nat.plus) ) (b)) ((((nat.times) ) (b)) (q1)))) ((((nat.times) ) (b)) (q))))) ((((nat.times) ) (b)) (((nat.S) ) (q1)))) (((nat.times_n_Sm) (b)) (q1)))) ((((nat.times) ) (q)) (b))) (((nat.commutative_times) (q)) (b)))) ((((nat.times) ) (b)) (((nat.S) ) (q1)))) (((nat.times_n_Sm) (b)) (q1)))) ((((nat.times) ) (((nat.S) ) (q1))) (b))) (((nat.commutative_times) (((nat.S) ) (q1))) (b))))) (((((logic.eq_coerc) ((((nat.le) ) ((((nat.times) ) (q)) (b))) ((((nat.plus) ) ((((nat.times) ) (q)) (b))) (r)))) ((((nat.le) ) ((((nat.times) ) (q)) (b))) (a))) (((nat.le_plus_n_r) (r)) ((((nat.times) ) (q)) (b)))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (b)) (q))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) (__)) ((((nat.plus) ) (__)) (r)))) ((((nat.le) ) (__)) (a)))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.plus) ) (r)) ((((nat.times) ) (b)) (q)))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) ((((nat.times) ) (b)) (q))) (__))) ((((nat.le) ) ((((nat.times) ) (b)) (q))) (a)))) (((((((logic.rewrite_l) ((nat.nat) )) (a)) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) ((((nat.times) ) (b)) (q))) (__))) ((((nat.le) ) ((((nat.times) ) (b)) (q))) (a)))) (((logic.refl) (Prop)) ((((nat.le) ) ((((nat.times) ) (b)) (q))) (a)))) ((((nat.plus) ) (r)) ((((nat.times) ) (b)) (q)))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.plus) ) ((((nat.times) ) (b)) (q))) (r))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (a)) (__))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.times) ) (q)) (b))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (a)) ((((nat.plus) ) (__)) (r)))) (spec)) ((((nat.times) ) (b)) (q))) (((nat.commutative_times) (q)) (b)))) ((((nat.plus) ) (r)) ((((nat.times) ) (b)) (q)))) (((nat.commutative_plus) ((((nat.times) ) (b)) (q))) (r))))) ((((nat.plus) ) ((((nat.times) ) (b)) (q))) (r))) (((nat.commutative_plus) ((((nat.times) ) (b)) (q))) (r)))) ((((nat.times) ) (q)) (b))) (((nat.commutative_times) (q)) (b))))))) ((nat.not_le_Sn_n) (a))))))))) (_clearme0)))))) (_clearme)).
Definition div_mod_spec_to_eq2 : forall (a:(nat.nat) ), forall (b:(nat.nat) ), forall (q:(nat.nat) ), forall (r:(nat.nat) ), forall (q1:(nat.nat) ), forall (r1:(nat.nat) ), ((((((div_mod_spec) ) (a)) (b)) (q)) (r)) -> ((((((div_mod_spec) ) (a)) (b)) (q1)) (r1)) -> (((logic.eq) ((nat.nat) )) (r)) (r1) := fun (a:(nat.nat) ) => fun (b:(nat.nat) ) => fun (q:(nat.nat) ) => fun (r:(nat.nat) ) => fun (q1:(nat.nat) ) => fun (r1:(nat.nat) ) => fun (spec:(((((div_mod_spec) ) (a)) (b)) (q)) (r)) => (fun (spec1:(((((div_mod_spec) ) (a)) (b)) (q1)) (r1)) => ((((((((match_div_mod_spec_prop) (a)) (b)) (q)) (r)) ((((logic.eq) ((nat.nat) )) (r)) (r1))) (fun (__:(((nat.lt) ) (r)) (b)) => (fun (eqa:(((logic.eq) ((nat.nat) )) (a)) ((((nat.plus) ) ((((nat.times) ) (q)) (b))) (r))) => ((((((((match_div_mod_spec_prop) (a)) (b)) (q1)) (r1)) ((((logic.eq) ((nat.nat) )) (r)) (r1))) (fun (_0:(((nat.lt) ) (r1)) (b)) => (fun (eqa1:(((logic.eq) ((nat.nat) )) (a)) ((((nat.plus) ) ((((nat.times) ) (q1)) (b))) (r1))) => (((((nat.injective_plus_r) ((((nat.times) ) (q)) (b))) (r)) (r1)) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (b)) (q))) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.plus) ) (__1)) (r))) ((((nat.plus) ) ((((nat.times) ) (q)) (b))) (r1)))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.plus) ) (r)) ((((nat.times) ) (b)) (q)))) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__1)) ((((nat.plus) ) ((((nat.times) ) (q)) (b))) (r1)))) (((((((logic.rewrite_l) ((nat.nat) )) (a)) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (__1)) ((((nat.plus) ) ((((nat.times) ) (q)) (b))) (r1)))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (b)) (q))) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (a)) ((((nat.plus) ) (__1)) (r1)))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.plus) ) (r1)) ((((nat.times) ) (b)) (q)))) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (a)) (__1))) (((((((logic.rewrite_l) ((nat.nat) )) (a)) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (a)) (__1))) (((logic.refl) ((nat.nat) )) (a))) ((((nat.plus) ) (r1)) ((((nat.times) ) (b)) (q)))) (((((((logic.rewrite_r) ((nat.nat) )) (q1)) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (a)) ((((nat.plus) ) (r1)) ((((nat.times) ) (b)) (__1))))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.plus) ) ((((nat.times) ) (b)) (q1))) (r1))) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (a)) (__1))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.times) ) (q1)) (b))) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (a)) ((((nat.plus) ) (__1)) (r1)))) (eqa1)) ((((nat.times) ) (b)) (q1))) (((nat.commutative_times) (q1)) (b)))) ((((nat.plus) ) (r1)) ((((nat.times) ) (b)) (q1)))) (((nat.commutative_plus) ((((nat.times) ) (b)) (q1))) (r1)))) (q)) (((((((((div_mod_spec_to_eq) (a)) (b)) (q)) (r)) (q1)) (r1)) (spec)) (spec1))))) ((((nat.plus) ) ((((nat.times) ) (b)) (q))) (r1))) (((nat.commutative_plus) ((((nat.times) ) (b)) (q))) (r1)))) ((((nat.times) ) (q)) (b))) (((nat.commutative_times) (q)) (b)))) ((((nat.plus) ) (r)) ((((nat.times) ) (b)) (q)))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.plus) ) ((((nat.times) ) (b)) (q))) (r))) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (a)) (__1))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.times) ) (q)) (b))) (fun (__1:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (a)) ((((nat.plus) ) (__1)) (r)))) (eqa)) ((((nat.times) ) (b)) (q))) (((nat.commutative_times) (q)) (b)))) ((((nat.plus) ) (r)) ((((nat.times) ) (b)) (q)))) (((nat.commutative_plus) ((((nat.times) ) (b)) (q))) (r))))) ((((nat.plus) ) ((((nat.times) ) (b)) (q))) (r))) (((nat.commutative_plus) ((((nat.times) ) (b)) (q))) (r)))) ((((nat.times) ) (q)) (b))) (((nat.commutative_times) (q)) (b))))))) (spec1))))) (spec))).
Definition div_times : forall (a:(nat.nat) ), forall (b:(nat.nat) ), ((((nat.lt) ) ((nat.O) )) (b)) -> (((logic.eq) ((nat.nat) )) ((((div) ) ((((nat.times) ) (a)) (b))) (b))) (a) := fun (a:(nat.nat) ) => fun (b:(nat.nat) ) => fun (posb:(((nat.lt) ) ((nat.O) )) (b)) => (((((((((div_mod_spec_to_eq) ((((nat.times) ) (a)) (b))) (b)) ((((div) ) ((((nat.times) ) (a)) (b))) (b))) ((((mod) ) ((((nat.times) ) (a)) (b))) (b))) (a)) ((nat.O) )) ((((div_mod_spec_div_mod) ((((nat.times) ) (a)) (b))) (b)) (posb))) (((((((div_mod_spec_intro) ((((nat.times) ) (a)) (b))) (b)) (a)) ((nat.O) )) (posb)) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.plus) ) ((nat.O) )) ((((nat.times) ) (a)) (b)))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.times) ) (a)) (b))) (__))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.times) ) (a)) (b))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((((nat.times) ) (a)) (b))) (__))) (((logic.refl) ((nat.nat) )) ((((nat.times) ) (a)) (b)))) ((((nat.plus) ) ((nat.O) )) ((((nat.times) ) (a)) (b)))) ((nat.plus_O_n) ((((nat.times) ) (a)) (b))))) ((((nat.plus) ) ((((nat.times) ) (a)) (b))) ((nat.O) ))) (((nat.commutative_plus) ((((nat.times) ) (a)) (b))) ((nat.O) ))))).
Definition eq_div_O : forall (n:(nat.nat) ), forall (m:(nat.nat) ), ((((nat.lt) ) (n)) (m)) -> (((logic.eq) ((nat.nat) )) ((((div) ) (n)) (m))) ((nat.O) ) := fun (n:(nat.nat) ) => fun (m:(nat.nat) ) => fun (ltnm:(((nat.lt) ) (n)) (m)) => (((((((((div_mod_spec_to_eq) (n)) (m)) ((((div) ) (n)) (m))) ((((mod) ) (n)) (m))) ((nat.O) )) (n)) ((((div_mod_spec_div_mod) (n)) (m)) ((((nat.ltn_to_ltO) (n)) (m)) (ltnm)))) (((((((div_mod_spec_intro) (n)) (m)) ((nat.O) )) (n)) (ltnm)) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.times) ) (m)) ((nat.O) ))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) (__)) (n)))) (((((((logic.rewrite_l) ((nat.nat) )) ((nat.O) )) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) ((((nat.plus) ) (__)) (n)))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.plus) ) (n)) ((nat.O) ))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) (__))) (((((((logic.rewrite_l) ((nat.nat) )) (n)) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) (n)) (__))) (((logic.refl) ((nat.nat) )) (n))) ((((nat.plus) ) (n)) ((nat.O) ))) ((nat.plus_n_O) (n)))) ((((nat.plus) ) ((nat.O) )) (n))) (((nat.commutative_plus) ((nat.O) )) (n)))) ((((nat.times) ) (m)) ((nat.O) ))) ((nat.times_n_O) (m)))) ((((nat.times) ) ((nat.O) )) (m))) (((nat.commutative_times) ((nat.O) )) (m))))).
Definition mod_O_n : forall (n:(nat.nat) ), (((logic.eq) ((nat.nat) )) ((((mod) ) ((nat.O) )) (n))) ((nat.O) ) := fun (n:(nat.nat) ) => ((((logic.sym_eq) ((nat.nat) )) ((nat.O) )) ((((mod) ) ((nat.O) )) (n))) (((((logic.eq_coerc) ((((logic.eq) ((nat.nat) )) ((nat.O) )) ((((mod) ) ((nat.O) )) (n)))) ((((logic.eq) ((nat.nat) )) ((nat.O) )) ((((mod) ) ((nat.O) )) (n)))) (((nat.le_n_O_to_eq) ((((mod) ) ((nat.O) )) (n))) (((((logic.eq_coerc) ((((nat.le) ) ((((nat.minus) ) ((((nat.plus) ) ((((mod) ) ((nat.O) )) (n))) ((((nat.times) ) (n)) ((((div) ) ((nat.O) )) (n))))) ((((nat.plus) ) ((nat.O) )) ((((nat.times) ) (n)) ((((div) ) ((nat.O) )) (n)))))) ((((nat.plus) ) ((((mod) ) ((nat.O) )) (n))) ((((nat.times) ) (n)) ((((div) ) ((nat.O) )) (n)))))) ((((nat.le) ) ((((mod) ) ((nat.O) )) (n))) ((nat.O) ))) (((nat.minus_le) ((((nat.plus) ) ((((mod) ) ((nat.O) )) (n))) ((((nat.times) ) (n)) ((((div) ) ((nat.O) )) (n))))) ((((nat.plus) ) ((nat.O) )) ((((nat.times) ) (n)) ((((div) ) ((nat.O) )) (n)))))) (((((((logic.rewrite_r) ((nat.nat) )) ((((nat.minus) ) ((((mod) ) ((nat.O) )) (n))) ((nat.O) ))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) (__)) ((((nat.plus) ) ((((mod) ) ((nat.O) )) (n))) ((((nat.times) ) (n)) ((((div) ) ((nat.O) )) (n)))))) ((((nat.le) ) ((((mod) ) ((nat.O) )) (n))) ((nat.O) )))) (((((((logic.rewrite_l) ((nat.nat) )) ((((mod) ) ((nat.O) )) (n))) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) (__)) ((((nat.plus) ) ((((mod) ) ((nat.O) )) (n))) ((((nat.times) ) (n)) ((((div) ) ((nat.O) )) (n)))))) ((((nat.le) ) ((((mod) ) ((nat.O) )) (n))) ((nat.O) )))) (((((((logic.rewrite_l) ((nat.nat) )) ((nat.O) )) (fun (__:(nat.nat) ) => (((logic.eq) (Prop)) ((((nat.le) ) ((((mod) ) ((nat.O) )) (n))) (__))) ((((nat.le) ) ((((mod) ) ((nat.O) )) (n))) ((nat.O) )))) (((logic.refl) (Prop)) ((((nat.le) ) ((((mod) ) ((nat.O) )) (n))) ((nat.O) )))) ((((nat.plus) ) ((((mod) ) ((nat.O) )) (n))) ((((nat.times) ) (n)) ((((div) ) ((nat.O) )) (n))))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.plus) ) ((((nat.times) ) (n)) ((((div) ) ((nat.O) )) (n)))) ((((mod) ) ((nat.O) )) (n)))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((nat.O) )) (__))) (((((((logic.rewrite_l) ((nat.nat) )) ((((nat.times) ) ((((div) ) ((nat.O) )) (n))) (n))) (fun (__:(nat.nat) ) => (((logic.eq) ((nat.nat) )) ((nat.O) )) ((((nat.plus) ) (__)) ((((mod) ) ((nat.O) )) (n))))) (((div_mod) ((nat.O) )) (n))) ((((nat.times) ) (n)) ((((div) ) ((nat.O) )) (n)))) (((nat.commutative_times) ((((div) ) ((nat.O) )) (n))) (n)))) ((((nat.plus) ) ((((mod) ) ((nat.O) )) (n))) ((((nat.times) ) (n)) ((((div) ) ((nat.O) )) (n))))) (((nat.commutative_plus) ((((nat.times) ) (n)) ((((div) ) ((nat.O) )) (n)))) ((((mod) ) ((nat.O) )) (n)))))) ((((nat.minus) ) ((((mod) ) ((nat.O) )) (n))) ((nat.O) ))) ((nat.minus_n_O) ((((mod) ) ((nat.O) )) (n))))) ((((nat.minus) ) ((((nat.plus) ) ((((mod) ) ((nat.O) )) (n))) ((((nat.times) ) (n)) ((((div) ) ((nat.O) )) (n))))) ((((nat.plus) ) ((nat.O) )) ((((nat.times) ) (n)) ((((div) ) ((nat.O) )) (n)))))) ((((nat.minus_plus_plus_l) ((((mod) ) ((nat.O) )) (n))) ((nat.O) )) ((((nat.times) ) (n)) ((((div) ) ((nat.O) )) (n)))))))) (((logic.refl) (Prop)) ((((logic.eq) ((nat.nat) )) ((nat.O) )) ((((mod) ) ((nat.O) )) (n))))).
