Require Import connectives.
Require Import leibniz.
Require Import logic.
Require Import relations.
Parameter bool : Type.
Parameter true : (bool) .
Parameter false : (bool) .
Axiom match_bool_prop : forall (return_:((bool) ) -> Prop), ((return_) ((true) )) -> ((return_) ((false) )) -> forall (z:(bool) ), (return_) (z).
Parameter match_bool_type : forall (return_:Type), (return_) -> (return_) -> ((bool) ) -> return_.
Axiom axiom_match_bool_type_true : forall return_, forall (case_true:return_), forall (case_false:return_), (((connectives.equal) (return_)) (((((match_bool_type) (return_)) (case_true)) (case_false)) ((true) ))) (case_true).
Definition eq_match_bool_type_true : forall return_, forall (case_true:return_), forall (case_false:return_), (((leibniz.leibniz) (return_)) (((((match_bool_type) (return_)) (case_true)) (case_false)) ((true) ))) (case_true) := fun (return_:Type) => fun (case_true:return_) => fun (case_false:return_) => ((((connectives.equal_leibniz) (return_)) (((((match_bool_type) (return_)) (case_true)) (case_false)) ((true) ))) (case_true)) ((((axiom_match_bool_type_true) (return_)) (case_true)) (case_false)).
Axiom axiom_match_bool_type_false : forall return_, forall (case_true:return_), forall (case_false:return_), (((connectives.equal) (return_)) (((((match_bool_type) (return_)) (case_true)) (case_false)) ((false) ))) (case_false).
Definition eq_match_bool_type_false : forall return_, forall (case_true:return_), forall (case_false:return_), (((leibniz.leibniz) (return_)) (((((match_bool_type) (return_)) (case_true)) (case_false)) ((false) ))) (case_false) := fun (return_:Type) => fun (case_true:return_) => fun (case_false:return_) => ((((connectives.equal_leibniz) (return_)) (((((match_bool_type) (return_)) (case_true)) (case_false)) ((false) ))) (case_false)) ((((axiom_match_bool_type_false) (return_)) (case_true)) (case_false)).
Definition sym_eq_match_bool_type_true : forall return_, forall (case_true:return_), forall (case_false:return_), (((leibniz.leibniz) (return_)) (case_true)) (((((match_bool_type) (return_)) (case_true)) (case_false)) ((true) )) := fun (return_:Type) => fun (case_true:return_) => fun (case_false:return_) => ((((leibniz.sym_leibniz) (return_)) (((((match_bool_type) (return_)) (case_true)) (case_false)) ((true) ))) (case_true)) ((((eq_match_bool_type_true) (return_)) (case_true)) (case_false)).
Definition sym_eq_match_bool_type_false : forall return_, forall (case_true:return_), forall (case_false:return_), (((leibniz.leibniz) (return_)) (case_false)) (((((match_bool_type) (return_)) (case_true)) (case_false)) ((false) )) := fun (return_:Type) => fun (case_true:return_) => fun (case_false:return_) => ((((leibniz.sym_leibniz) (return_)) (((((match_bool_type) (return_)) (case_true)) (case_false)) ((false) ))) (case_false)) ((((eq_match_bool_type_false) (return_)) (case_true)) (case_false)).
Definition bool_discr : forall (x:(bool) ), forall (y:(bool) ), ((((logic.eq) ((bool) )) (x)) (y)) -> ((((match_bool_type) (Prop)) (((((match_bool_type) (Prop)) (forall (P:Prop), (P) -> P)) (forall (P:Prop), P)) (y))) (((((match_bool_type) (Prop)) (forall (P:Prop), P)) (forall (P:Prop), (P) -> P)) (y))) (x) := fun (x:(bool) ) => fun (y:(bool) ) => fun (Deq:(((logic.eq) ((bool) )) (x)) (y)) => (((((((logic.eq_ind) ((bool) )) (x)) (fun (x_13:(bool) ) => ((((match_bool_type) (Prop)) (((((match_bool_type) (Prop)) (forall (P:Prop), (P) -> P)) (forall (P:Prop), P)) (x_13))) (((((match_bool_type) (Prop)) (forall (P:Prop), P)) (forall (P:Prop), (P) -> P)) (x_13))) (x))) (((((match_bool_prop) (fun (__:(bool) ) => ((((match_bool_type) (Prop)) (((((match_bool_type) (Prop)) (forall (P:Prop), (P) -> P)) (forall (P:Prop), P)) (__))) (((((match_bool_type) (Prop)) (forall (P:Prop), P)) (forall (P:Prop), (P) -> P)) (__))) (__))) ((((((sym_eq_match_bool_type_true) (Prop)) (((((match_bool_type) (Prop)) (forall (P:Prop), (P) -> P)) (forall (P:Prop), P)) ((true) ))) (((((match_bool_type) (Prop)) (forall (P:Prop), P)) (forall (P:Prop), (P) -> P)) ((true) ))) (fun (x0:Prop) => x0)) ((((((sym_eq_match_bool_type_true) (Prop)) (forall (P:Prop), (P) -> P)) (forall (P:Prop), P)) (fun (x0:Prop) => x0)) (fun (P:Prop) => fun (DH:P) => (DH))))) ((((((sym_eq_match_bool_type_false) (Prop)) (((((match_bool_type) (Prop)) (forall (P:Prop), (P) -> P)) (forall (P:Prop), P)) ((false) ))) (((((match_bool_type) (Prop)) (forall (P:Prop), P)) (forall (P:Prop), (P) -> P)) ((false) ))) (fun (x0:Prop) => x0)) ((((((sym_eq_match_bool_type_false) (Prop)) (forall (P:Prop), P)) (forall (P:Prop), (P) -> P)) (fun (x0:Prop) => x0)) (fun (P:Prop) => fun (DH:P) => (DH))))) (x))) (y)) (Deq)).
Definition not_eq_true_false : ((connectives.Not) ) ((((logic.eq) ((bool) )) ((true) )) ((false) )) := ((connectives.nmk) ((((logic.eq) ((bool) )) ((true) )) ((false) ))) (fun (Heq:(((logic.eq) ((bool) )) ((true) )) ((false) )) => (((((((eq_match_bool_type_false) (Prop)) (forall (P:Prop), (P) -> P)) (forall (P:Prop), P)) (fun (x:Prop) => x)) ((((((eq_match_bool_type_true) (Prop)) (((((match_bool_type) (Prop)) (forall (P:Prop), (P) -> P)) (forall (P:Prop), P)) ((false) ))) (((((match_bool_type) (Prop)) (forall (P:Prop), P)) (forall (P:Prop), (P) -> P)) ((false) ))) (fun (x:Prop) => x)) ((((bool_discr) ((true) )) ((false) )) (Heq)))) ((connectives.False) ))).
Definition notb : ((bool) ) -> (bool)  := fun (b:(bool) ) => ((((match_bool_type) ((bool) )) ((false) )) ((true) )) (b).
Definition andb : ((bool) ) -> ((bool) ) -> (bool)  := fun (b1:(bool) ) => fun (b2:(bool) ) => ((((match_bool_type) ((bool) )) (b2)) ((false) )) (b1).
Definition andb_true_l : forall (b1:(bool) ), forall (b2:(bool) ), ((((logic.eq) ((bool) )) ((((andb) ) (b1)) (b2))) ((true) )) -> (((logic.eq) ((bool) )) (b1)) ((true) ) := fun (b1:(bool) ) => ((((match_bool_prop) (fun (__:(bool) ) => forall (b2:(bool) ), ((((logic.eq) ((bool) )) ((((andb) ) (__)) (b2))) ((true) )) -> (((logic.eq) ((bool) )) (__)) ((true) ))) (fun (b2:(bool) ) => (((((sym_eq_match_bool_type_true) ((bool) )) (b2)) ((false) )) (fun (x:(bool) ) => ((((logic.eq) ((bool) )) (x)) ((true) )) -> (((logic.eq) ((bool) )) ((true) )) ((true) ))) (fun (auto:(((logic.eq) ((bool) )) (b2)) ((true) )) => (((((((logic.rewrite_l) ((bool) )) (b2)) (fun (__:(bool) ) => (((logic.eq) ((bool) )) (__)) ((true) ))) (((((((logic.rewrite_l) ((bool) )) (b2)) (fun (__:(bool) ) => (((logic.eq) ((bool) )) (b2)) (__))) (((logic.refl) ((bool) )) (b2))) ((true) )) (auto))) ((true) )) (auto))))) (fun (_b2:(bool) ) => (((((sym_eq_match_bool_type_false) ((bool) )) (_b2)) ((false) )) (fun (x:(bool) ) => ((((logic.eq) ((bool) )) (x)) ((true) )) -> (((logic.eq) ((bool) )) ((false) )) ((true) ))) (fun (auto:(((logic.eq) ((bool) )) ((false) )) ((true) )) => (((((((logic.rewrite_r) ((bool) )) ((true) )) (fun (__:(bool) ) => (((logic.eq) ((bool) )) (__)) ((true) ))) (((logic.refl) ((bool) )) ((true) ))) ((false) )) (auto))))) (b1).
Definition andb_true_r : forall (b1:(bool) ), forall (b2:(bool) ), ((((logic.eq) ((bool) )) ((((andb) ) (b1)) (b2))) ((true) )) -> (((logic.eq) ((bool) )) (b2)) ((true) ) := fun (b1:(bool) ) => fun (b2:(bool) ) => ((((match_bool_prop) (fun (__:(bool) ) => ((((logic.eq) ((bool) )) ((((andb) ) (__)) (b2))) ((true) )) -> (((logic.eq) ((bool) )) (b2)) ((true) ))) ((((((sym_eq_match_bool_type_true) ((bool) )) (b2)) ((false) )) (fun (x:(bool) ) => ((((logic.eq) ((bool) )) (x)) ((true) )) -> (((logic.eq) ((bool) )) (b2)) ((true) ))) (fun (auto:(((logic.eq) ((bool) )) (b2)) ((true) )) => (((((((logic.rewrite_l) ((bool) )) (b2)) (fun (__:(bool) ) => (((logic.eq) ((bool) )) (b2)) (__))) (((logic.refl) ((bool) )) (b2))) ((true) )) (auto))))) ((((((sym_eq_match_bool_type_false) ((bool) )) (b2)) ((false) )) (fun (x:(bool) ) => ((((logic.eq) ((bool) )) (x)) ((true) )) -> (((logic.eq) ((bool) )) (b2)) ((true) ))) (((((match_bool_prop) (fun (__:(bool) ) => ((((logic.eq) ((bool) )) ((false) )) ((true) )) -> (((logic.eq) ((bool) )) (__)) ((true) ))) (fun (auto:(((logic.eq) ((bool) )) ((false) )) ((true) )) => (((logic.refl) ((bool) )) ((true) )))) (fun (auto:(((logic.eq) ((bool) )) ((false) )) ((true) )) => (((((((logic.rewrite_r) ((bool) )) ((true) )) (fun (__:(bool) ) => (((logic.eq) ((bool) )) (__)) ((true) ))) (((logic.refl) ((bool) )) ((true) ))) ((false) )) (auto)))) (b2)))) (b1).
Definition true_or_false : forall (b:(bool) ), (((connectives.Or) ) ((((logic.eq) ((bool) )) (b)) ((true) ))) ((((logic.eq) ((bool) )) (b)) ((false) )) := fun (b:(bool) ) => ((((match_bool_prop) (fun (__:(bool) ) => (((connectives.Or) ) ((((logic.eq) ((bool) )) (__)) ((true) ))) ((((logic.eq) ((bool) )) (__)) ((false) )))) ((((connectives.or_introl) ((((logic.eq) ((bool) )) ((true) )) ((true) ))) ((((logic.eq) ((bool) )) ((true) )) ((false) ))) (((logic.refl) ((bool) )) ((true) )))) ((((relations.RC_reflexive) ((bool) )) (fun (__:(bool) ) => fun (_0:(bool) ) => (((logic.eq) ((bool) )) ((false) )) ((true) ))) ((false) ))) (b).
